{"bug_id": "Math_99", "version": "fixed", "focal_method_signature": "int org.apache.commons.math.util.MathUtils#gcd(int#p,int#q)", "test_case_signature": "MathUtilsTest::testGcdMixedSigns", "test_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_99/fixed/src/test/MathUtilsTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_99/fixed/src/java/org/apache/commons/math/util/MathUtils.java", "focal_method": "public static int gcd(final int p, final int q) {\n        int u = p;\n        int v = q;\n        if ((u == 0) || (v == 0)) {\n            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n                throw MathRuntimeException.createArithmeticException(\n                        \"overflow: gcd({0}, {1}) is 2^31\",\n                        new Object[] { p, q });\n            }\n            return (Math.abs(u) + Math.abs(v));\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        /* assert u!=0 && v!=0; */\n        if (u > 0) {\n            u = -u;\n        } // make u negative\n        if (v > 0) {\n            v = -v;\n        } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n                                                            // both even...\n            u /= 2;\n            v /= 2;\n            k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw MathRuntimeException.createArithmeticException(\n                    \"overflow: gcd({0}, {1}) is 2^31\",\n                    new Object[] { p, q });\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        // one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }", "return_type": "int", "test_case": "@Test\n    public void testGcdMixedSigns() {\n        assertEquals(1, MathUtils.gcd(-5, 10));\n        assertEquals(5, MathUtils.gcd(10, -5));\n    }", "parent_test_case": "@Test\n    public void testGcdMixedSigns() {\n        assertEquals(1, MathUtils.gcd(-5, 10));\n        assertEquals(5, MathUtils.gcd(10, -5));\n    }", "test_case_invocations": ["assertEquals", "gcd", "assertEquals", "assertEquals", "gcd", "gcd", "fail", "gcd", "assertEquals", "assertEquals", "assertEquals", "assertEquals", "gcd", "assertEquals", "assertEquals", "gcd", "gcd", "gcd", "gcd", "assertEquals", "gcd", "assertEquals", "gcd", "gcd", "assertEquals", "fail", "gcd", "gcd", "assertEquals", "assertEquals", "assertEquals", "assertEquals", "gcd", "assertEquals", "gcd", "fail", "gcd", "gcd", "gcd", "gcd"], "test_class": {"path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_99/fixed/src/test/org/apache/commons/math/util/MathUtilsTest.java", "imports": ["import java.math.BigDecimal;", "import java.util.ArrayList;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;", "import junit.framework.Test;", "import junit.framework.TestCase;", "import junit.framework.TestSuite;", "import org.apache.commons.math.random.RandomDataImpl;", "import org.apache.commons.math.TestUtils;"], "fields": ["private static List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>()"], "methods": ["Test org.apache.commons.math.util.MathUtilsTest#suite()", "long org.apache.commons.math.util.MathUtilsTest#binomialCoefficient(int#n,int#k)", "long org.apache.commons.math.util.MathUtilsTest#factorial(int#n)", "void org.apache.commons.math.util.MathUtilsTest#test0Choose0()", "void org.apache.commons.math.util.MathUtilsTest#testAddAndCheck()", "void org.apache.commons.math.util.MathUtilsTest#testAddAndCheckLong()", "void org.apache.commons.math.util.MathUtilsTest#testAddAndCheckLongFailure(long#a,long#b)", "void org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficient()", "void org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientLarge()", "void org.apache.commons.math.util.MathUtilsTest#testBinomialCoefficientFail()", "void org.apache.commons.math.util.MathUtilsTest#testCosh()", "void org.apache.commons.math.util.MathUtilsTest#testCoshNaN()", "void org.apache.commons.math.util.MathUtilsTest#testEquals()", "void org.apache.commons.math.util.MathUtilsTest#testEqualsWithAllowedDelta()", "void org.apache.commons.math.util.MathUtilsTest#testArrayEquals()", "void org.apache.commons.math.util.MathUtilsTest#testFactorial()", "void org.apache.commons.math.util.MathUtilsTest#testFactorialFail()", "void org.apache.commons.math.util.MathUtilsTest#testHash()", "void org.apache.commons.math.util.MathUtilsTest#testArrayHash()", "void org.apache.commons.math.util.MathUtilsTest#testPermutedArrayHash()", "void org.apache.commons.math.util.MathUtilsTest#testIndicatorByte()", "void org.apache.commons.math.util.MathUtilsTest#testIndicatorDouble()", "void org.apache.commons.math.util.MathUtilsTest#testIndicatorFloat()", "void org.apache.commons.math.util.MathUtilsTest#testIndicatorInt()", "void org.apache.commons.math.util.MathUtilsTest#testIndicatorLong()", "void org.apache.commons.math.util.MathUtilsTest#testIndicatorShort()", "void org.apache.commons.math.util.MathUtilsTest#testLcm()", "void org.apache.commons.math.util.MathUtilsTest#testLog()", "void org.apache.commons.math.util.MathUtilsTest#testMulAndCheck()", "void org.apache.commons.math.util.MathUtilsTest#testMulAndCheckLong()", "void org.apache.commons.math.util.MathUtilsTest#testMulAndCheckLongFailure(long#a,long#b)", "void org.apache.commons.math.util.MathUtilsTest#testNextAfter()", "void org.apache.commons.math.util.MathUtilsTest#testNextAfterSpecialCases()", "void org.apache.commons.math.util.MathUtilsTest#testScalb()", "void org.apache.commons.math.util.MathUtilsTest#testNormalizeAngle()", "void org.apache.commons.math.util.MathUtilsTest#testRoundDouble()", "void org.apache.commons.math.util.MathUtilsTest#testRoundFloat()", "void org.apache.commons.math.util.MathUtilsTest#testSignByte()", "void org.apache.commons.math.util.MathUtilsTest#testSignDouble()", "void org.apache.commons.math.util.MathUtilsTest#testSignFloat()", "void org.apache.commons.math.util.MathUtilsTest#testSignInt()", "void org.apache.commons.math.util.MathUtilsTest#testSignLong()", "void org.apache.commons.math.util.MathUtilsTest#testSignShort()", "void org.apache.commons.math.util.MathUtilsTest#testSinh()", "void org.apache.commons.math.util.MathUtilsTest#testSinhNaN()", "void org.apache.commons.math.util.MathUtilsTest#testSubAndCheck()", "void org.apache.commons.math.util.MathUtilsTest#testSubAndCheckErrorMessage()", "void org.apache.commons.math.util.MathUtilsTest#testSubAndCheckLong()", "void org.apache.commons.math.util.MathUtilsTest#testSubAndCheckLongFailure(long#a,long#b)"], "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n * or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\npackage org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\n\nimport org.apache.commons.math.random.RandomDataImpl;\nimport org.apache.commons.math.TestUtils;\n\n/**\n * Test cases for the MathUtils class.\n * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n *          2007) $\n */\npublic final class MathUtilsTest extends TestCase {\n\n    public MathUtilsTest(String name) {\n        super(name);\n    }\n\n    public static Test suite() {\n        TestSuite suite = new TestSuite(MathUtilsTest.class);\n        suite.setName(\"MathUtils Tests\");\n        return suite;\n    }\n\n    /** cached binomial coefficients */\n    private static List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>();\n\n    /**\n     * Exact (caching) recursive implementation to test against\n     */\n    private long binomialCoefficient(int n, int k) throws ArithmeticException {\n        if (binomialCache.size() > n) {\n            Long cachedResult = binomialCache.get(n).get(new Integer(k));\n            if (cachedResult != null) {\n                return cachedResult.longValue();\n            }\n        }\n        long result = -1;\n        if ((n == k) || (k == 0)) {\n            result = 1;\n        } else if ((k == 1) || (k == n - 1)) {\n            result = n;\n        } else {\n            // Reduce stack depth for larger values of n\n            if (k < n - 100) {\n                binomialCoefficient(n - 100, k);\n            }\n            if (k > 100) {\n                binomialCoefficient(n - 100, k - 100);\n            }\n            result = MathUtils.addAndCheck(binomialCoefficient(n - 1, k - 1),\n                binomialCoefficient(n - 1, k));\n        }\n        if (result == -1) {\n            throw new ArithmeticException(\n                \"error computing binomial coefficient\");\n        }\n        for (int i = binomialCache.size(); i < n + 1; i++) {\n            binomialCache.add(new HashMap<Integer, Long>());\n        }\n        binomialCache.get(n).put(new Integer(k), new Long(result));\n        return result;\n    }\n\n    /**\n     * Exact direct multiplication implementation to test against\n     */\n    private long factorial(int n) {\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    /** Verify that b(0,0) = 1 */\n    public void test0Choose0() {\n        assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0);\n        assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0);\n        assertEquals(MathUtils.binomialCoefficient(0, 0), 1);\n    }\n\n    public void testAddAndCheck() {\n        int big = Integer.MAX_VALUE;\n        int bigNeg = Integer.MIN_VALUE;\n        assertEquals(big, MathUtils.addAndCheck(big, 0));\n        try {\n            MathUtils.addAndCheck(big, 1);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n        }\n        try {\n            MathUtils.addAndCheck(bigNeg, -1);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n        }\n    }\n\n    public void testAddAndCheckLong() {\n        long max = Long.MAX_VALUE;\n        long min = Long.MIN_VALUE;\n        assertEquals(max, MathUtils.addAndCheck(max, 0L));\n        assertEquals(min, MathUtils.addAndCheck(min, 0L));\n        assertEquals(max, MathUtils.addAndCheck(0L, max));\n        assertEquals(min, MathUtils.addAndCheck(0L, min));\n        assertEquals(1, MathUtils.addAndCheck(-1L, 2L));\n        assertEquals(1, MathUtils.addAndCheck(2L, -1L));\n        assertEquals(-3, MathUtils.addAndCheck(-2L, -1L));\n        assertEquals(min, MathUtils.addAndCheck(min + 1, -1L));\n        testAddAndCheckLongFailure(max, 1L);\n        testAddAndCheckLongFailure(min, -1L);\n        testAddAndCheckLongFailure(1L, max);\n        testAddAndCheckLongFailure(-1L, min);\n    }\n\n    private void testAddAndCheckLongFailure(long a, long b) {\n        try {\n            MathUtils.addAndCheck(a, b);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // success\n        }\n    }\n\n    public void testBinomialCoefficient() {\n        long[] bcoef5 = {\n            1,\n            5,\n            10,\n            10,\n            5,\n            1 };\n        long[] bcoef6 = {\n            1,\n            6,\n            15,\n            20,\n            15,\n            6,\n            1 };\n        for (int i = 0; i < 6; i++) {\n            assertEquals(\"5 choose \" + i, bcoef5[i], MathUtils.binomialCoefficient(5, i));\n        }\n        for (int i = 0; i < 7; i++) {\n            assertEquals(\"6 choose \" + i, bcoef6[i], MathUtils.binomialCoefficient(6, i));\n        }\n\n        for (int n = 1; n < 10; n++) {\n            for (int k = 0; k <= n; k++) {\n                assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), MathUtils.binomialCoefficient(n, k));\n                assertEquals(n + \" choose \" + k, (double)binomialCoefficient(n, k), MathUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE);\n                assertEquals(n + \" choose \" + k, Math.log((double)binomialCoefficient(n, k)), MathUtils.binomialCoefficientLog(n, k), 10E-12);\n            }\n        }\n\n        int[] n = { 34, 66, 100, 1500, 1500 };\n        int[] k = { 17, 33, 10, 1500 - 4, 4 };\n        for (int i = 0; i < n.length; i++) {\n            long expected = binomialCoefficient(n[i], k[i]);\n            assertEquals(n[i] + \" choose \" + k[i], expected,\n                MathUtils.binomialCoefficient(n[i], k[i]));\n            assertEquals(n[i] + \" choose \" + k[i], (double) expected,\n                MathUtils.binomialCoefficientDouble(n[i], k[i]), 0.0);\n            assertEquals(\"log(\" + n[i] + \" choose \" + k[i] + \")\", Math.log(expected),\n                MathUtils.binomialCoefficientLog(n[i], k[i]), 0.0);\n        }\n    }\n\n    /**\n     * Tests correctness for large n and sharpness of upper bound in API doc\n     * JIRA: MATH-241\n     */\n    public void testBinomialCoefficientLarge() throws Exception {\n        // This tests all legal and illegal values for n <= 200.\n        for (int n = 0; n <= 200; n++) {\n            for (int k = 0; k <= n; k++) {\n                long ourResult = -1;\n                long exactResult = -1;\n                boolean shouldThrow = false;\n                boolean didThrow = false;\n                try {\n                    ourResult = MathUtils.binomialCoefficient(n, k);\n                } catch (ArithmeticException ex) {\n                    didThrow = true;\n                }\n                try {\n                    exactResult = binomialCoefficient(n, k);\n                } catch (ArithmeticException ex) {\n                    shouldThrow = true;\n                }\n                assertEquals(n + \" choose \" + k, exactResult, ourResult);\n                assertEquals(n + \" choose \" + k, shouldThrow, didThrow);\n                assertTrue(n + \" choose \" + k, (n > 66 || !didThrow));\n\n                if (!shouldThrow && exactResult > 1) {\n                    assertEquals(n + \" choose \" + k, 1.,\n                        MathUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10);\n                    assertEquals(n + \" choose \" + k, 1,\n                        MathUtils.binomialCoefficientLog(n, k) / Math.log(exactResult), 1e-10);\n                }\n            }\n        }\n\n        long ourResult = MathUtils.binomialCoefficient(300, 3);\n        long exactResult = binomialCoefficient(300, 3);\n        assertEquals(exactResult, ourResult);\n\n        ourResult = MathUtils.binomialCoefficient(700, 697);\n        exactResult = binomialCoefficient(700, 697);\n        assertEquals(exactResult, ourResult);\n\n        // This one should throw\n        try {\n            MathUtils.binomialCoefficient(700, 300);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // Expected\n        }\n\n        int n = 10000;\n        ourResult = MathUtils.binomialCoefficient(n, 3);\n        exactResult = binomialCoefficient(n, 3);\n        assertEquals(exactResult, ourResult);\n        assertEquals(1, MathUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10);\n        assertEquals(1, MathUtils.binomialCoefficientLog(n, 3) / Math.log(exactResult), 1e-10);\n\n    }\n\n    public void testBinomialCoefficientFail() {\n        try {\n            MathUtils.binomialCoefficient(4, 5);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n\n        try {\n            MathUtils.binomialCoefficientDouble(4, 5);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n\n        try {\n            MathUtils.binomialCoefficientLog(4, 5);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n\n        try {\n            MathUtils.binomialCoefficient(-1, -2);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            MathUtils.binomialCoefficientDouble(-1, -2);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            MathUtils.binomialCoefficientLog(-1, -2);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n\n        try {\n            MathUtils.binomialCoefficient(67, 30);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            ;\n        }\n        try {\n            MathUtils.binomialCoefficient(67, 34);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            ;\n        }\n        double x = MathUtils.binomialCoefficientDouble(1030, 515);\n        assertTrue(\"expecting infinite binomial coefficient\", Double\n            .isInfinite(x));\n    }\n\n    public void testCosh() {\n        double x = 3.0;\n        double expected = 10.06766;\n        assertEquals(expected, MathUtils.cosh(x), 1.0e-5);\n    }\n\n    public void testCoshNaN() {\n        assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN)));\n    \n    public void testEquals() {\n        double[] testArray = {\n            Double.NaN,\n            Double.POSITIVE_INFINITY,\n            Double.NEGATIVE_INFINITY,\n            1d,\n            0d };\n        for (int i = 0; i < testArray.length; i++) {\n            for (int j = 0; j < testArray.length; j++) {\n                if (i == j) {\n                    assertTrue(MathUtils.equals(testArray[i], testArray[j]));\n                    assertTrue(MathUtils.equals(testArray[j], testArray[i]));\n                } else {\n                    assertTrue(!MathUtils.equals(testArray[i], testArray[j]));\n                    assertTrue(!MathUtils.equals(testArray[j], testArray[i]));\n                }\n            }\n        }\n    }\n\n    public void testEqualsWithAllowedDelta() {\n        assertTrue(MathUtils.equals(153.0000, 153.0000, .0001));\n        assertTrue(MathUtils.equals(153.0000, 153.0001, .0001));\n        assertTrue(MathUtils.equals(152.9999, 153.0000, .0001));\n        assertFalse(MathUtils.equals(153.0000, 153.0001, .00001));\n        assertFalse(MathUtils.equals(152.9998, 153.0000, .0001));\n    }\n    \n    public void testArrayEquals() {\n        assertFalse(MathUtils.equals(new double[] { 1d }, null));\n        assertFalse(MathUtils.equals(null, new double[] { 1d }));\n        assertTrue(MathUtils.equals((double[]) null, (double[]) null));\n\n        assertFalse(MathUtils.equals(new double[] { 1d }, new double[0]));\n        assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d }));\n        assertTrue(MathUtils.equals(new double[] {\n                                      Double.NaN, Double.POSITIVE_INFINITY,\n                                      Double.NEGATIVE_INFINITY, 1d, 0d\n                                    }, new double[] {\n                                      Double.NaN, Double.POSITIVE_INFINITY,\n                                      Double.NEGATIVE_INFINITY, 1d, 0d\n                                    }));\n        assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY },\n                                     new double[] { Double.NEGATIVE_INFINITY }));\n        assertFalse(MathUtils.equals(new double[] { 1d },\n                                     new double[] { MathUtils.nextAfter(1d, 2d) }));\n\n    }\n\n    public void testFactorial() {\n        for (int i = 1; i < 21; i++) {\n            assertEquals(i + \"! \", factorial(i), MathUtils.factorial(i));\n            assertEquals(i + \"! \", (double)factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);\n            assertEquals(i + \"! \", Math.log((double)factorial(i)), MathUtils.factorialLog(i), 10E-12);\n        }\n        \n        assertEquals(\"0\", 1, MathUtils.factorial(0));\n        assertEquals(\"0\", 1.0d, MathUtils.factorialDouble(0), 1E-14);\n        assertEquals(\"0\", 0.0d, MathUtils.factorialLog(0), 1E-14);\n    }\n\n    public void testFactorialFail() {\n        try {\n            MathUtils.factorial(-1);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            MathUtils.factorialDouble(-1);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            MathUtils.factorialLog(-1);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            MathUtils.factorial(21);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            ;\n        }\n        assertTrue(\"expecting infinite factorial value\", Double.isInfinite(MathUtils.factorialDouble(171)));\n    }\n\n    public void testGcd() {\n        int a = 30;\n        int b = 50;\n        int c = 77;\n\n        assertEquals(0, MathUtils.gcd(0, 0));\n\n        assertEquals(b, MathUtils.gcd(0, b));\n        assertEquals(a, MathUtils.gcd(a, 0));\n        assertEquals(b, MathUtils.gcd(0, -b));\n        assertEquals(a, MathUtils.gcd(-a, 0));\n\n        assertEquals(10, MathUtils.gcd(a, b));\n        assertEquals(10, MathUtils.gcd(-a, b));\n        assertEquals(10, MathUtils.gcd(a, -b));\n        assertEquals(10, MathUtils.gcd(-a, -b));\n\n        assertEquals(1, MathUtils.gcd(a, c));\n        assertEquals(1, MathUtils.gcd(-a, c));\n        assertEquals(1, MathUtils.gcd(a, -c));\n        assertEquals(1, MathUtils.gcd(-a, -c));\n\n        assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));\n\n        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(Integer.MAX_VALUE, 0));\n        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(-Integer.MAX_VALUE, 0));\n        assertEquals(1<<30, MathUtils.gcd(1<<30, -Integer.MIN_VALUE));\n        try {\n            // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE\n            MathUtils.gcd(Integer.MIN_VALUE, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException expected) {\n            // expected\n        }\n        try {\n            // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE\n            MathUtils.gcd(0, Integer.MIN_VALUE);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException expected) {\n            // expected\n        }\n        try {\n            // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE\n            MathUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException expected) {\n            // expected\n        }\n    }\n\n    public void testHash() {\n        double[] testArray = {\n            Double.NaN,\n            Double.POSITIVE_INFINITY,\n            Double.NEGATIVE_INFINITY,\n            1d,\n            0d,\n            1E-14,\n            (1 + 1E-14),\n            Double.MIN_VALUE,\n            Double.MAX_VALUE };\n        for (int i = 0; i < testArray.length; i++) {\n            for (int j = 0; j < testArray.length; j++) {\n                if (i == j) {\n                    assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j]));\n                    assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i]));\n                } else {\n                    assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j]));\n                    assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i]));\n                }\n            }\n        }\n    }\n\n    public void testArrayHash() {\n        assertEquals(0, MathUtils.hash((double[]) null));\n        assertEquals(MathUtils.hash(new double[] {\n                                      Double.NaN, Double.POSITIVE_INFINITY,\n                                      Double.NEGATIVE_INFINITY, 1d, 0d\n                                    }),\n                     MathUtils.hash(new double[] {\n                                      Double.NaN, Double.POSITIVE_INFINITY,\n                                      Double.NEGATIVE_INFINITY, 1d, 0d\n                                    }));\n        assertFalse(MathUtils.hash(new double[] { 1d }) ==\n                    MathUtils.hash(new double[] { MathUtils.nextAfter(1d, 2d) }));\n        assertFalse(MathUtils.hash(new double[] { 1d }) ==\n                    MathUtils.hash(new double[] { 1d, 1d }));\n    }\n    \n    /**\n     * Make sure that permuted arrays do not hash to the same value.\n     */\n    public void testPermutedArrayHash() {\n        double[] original = new double[10];\n        double[] permuted = new double[10];\n        RandomDataImpl random = new RandomDataImpl();\n        \n        // Generate 10 distinct random values\n        for (int i = 0; i < 10; i++) {\n            original[i] = random.nextUniform((double)i + 0.5, (double)i + 0.75);\n        }\n        \n        // Generate a random permutation, making sure it is not the identity\n        boolean isIdentity = true;\n        do {\n            int[] permutation = random.nextPermutation(10, 10);\n            for (int i = 0; i < 10; i++) {\n                if (i != permutation[i]) {\n                    isIdentity = false;\n                }\n                permuted[i] = original[permutation[i]];\n            }\n        } while (isIdentity);\n        \n        // Verify that permuted array has different hash\n        assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted));\n    }\n\n    public void testIndicatorByte() {\n        assertEquals((byte)1, MathUtils.indicator((byte)2));\n        assertEquals((byte)1, MathUtils.indicator((byte)0));\n        assertEquals((byte)(-1), MathUtils.indicator((byte)(-2)));\n    }\n\n    public void testIndicatorDouble() {\n        double delta = 0.0;\n        assertEquals(1.0, MathUtils.indicator(2.0), delta);\n        assertEquals(1.0, MathUtils.indicator(0.0), delta);\n        assertEquals(-1.0, MathUtils.indicator(-2.0), delta);\n        assertEquals(Double.NaN, MathUtils.indicator(Double.NaN));\n    }\n\n    public void testIndicatorFloat() {\n        float delta = 0.0F;\n        assertEquals(1.0F, MathUtils.indicator(2.0F), delta);\n        assertEquals(1.0F, MathUtils.indicator(0.0F), delta);\n        assertEquals(-1.0F, MathUtils.indicator(-2.0F), delta);\n    }\n\n    public void testIndicatorInt() {\n        assertEquals((int)1, MathUtils.indicator((int)(2)));\n        assertEquals((int)1, MathUtils.indicator((int)(0)));\n        assertEquals((int)(-1), MathUtils.indicator((int)(-2)));\n    }\n\n    public void testIndicatorLong() {\n        assertEquals(1L, MathUtils.indicator(2L));\n        assertEquals(1L, MathUtils.indicator(0L));\n        assertEquals(-1L, MathUtils.indicator(-2L));\n    }\n\n    public void testIndicatorShort() {\n        assertEquals((short)1, MathUtils.indicator((short)2));\n        assertEquals((short)1, MathUtils.indicator((short)0));\n        assertEquals((short)(-1), MathUtils.indicator((short)(-2)));\n    }\n\n    public void testLcm() {\n        int a = 30;\n        int b = 50;\n        int c = 77;\n\n        assertEquals(0, MathUtils.lcm(0, b));\n        assertEquals(0, MathUtils.lcm(a, 0));\n        assertEquals(b, MathUtils.lcm(1, b));\n        assertEquals(a, MathUtils.lcm(a, 1));\n        assertEquals(150, MathUtils.lcm(a, b));\n        assertEquals(150, MathUtils.lcm(-a, b));\n        assertEquals(150, MathUtils.lcm(a, -b));\n        assertEquals(150, MathUtils.lcm(-a, -b));\n        assertEquals(2310, MathUtils.lcm(a, c));\n\n        // Assert that no intermediate value overflows:\n        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n        assertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));\n\n        // Special case\n        assertEquals(0, MathUtils.lcm(0, 0));\n\n        try {\n            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n            MathUtils.lcm(Integer.MIN_VALUE, 1);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected\n        }\n        \n        try {\n            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n            MathUtils.lcm(Integer.MIN_VALUE, 1<<20);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected\n        }\n\n        try {\n            MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // expected\n        }\n    }\n\n    public void testLog() {\n        assertEquals(2.0, MathUtils.log(2, 4), 0);\n        assertEquals(3.0, MathUtils.log(2, 8), 0);\n        assertTrue(Double.isNaN(MathUtils.log(-1, 1)));\n        assertTrue(Double.isNaN(MathUtils.log(1, -1)));\n        assertTrue(Double.isNaN(MathUtils.log(0, 0)));\n        assertEquals(0, MathUtils.log(0, 10), 0);\n        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.log(10, 0), 0);\n    }\n\n    public void testMulAndCheck() {\n        int big = Integer.MAX_VALUE;\n        int bigNeg = Integer.MIN_VALUE;\n        assertEquals(big, MathUtils.mulAndCheck(big, 1));\n        try {\n            MathUtils.mulAndCheck(big, 2);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n        }\n        try {\n            MathUtils.mulAndCheck(bigNeg, 2);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n        }\n    }\n\n    public void testMulAndCheckLong() {\n        long max = Long.MAX_VALUE;\n        long min = Long.MIN_VALUE;\n        assertEquals(max, MathUtils.mulAndCheck(max, 1L));\n        assertEquals(min, MathUtils.mulAndCheck(min, 1L));\n        assertEquals(0L, MathUtils.mulAndCheck(max, 0L));\n        assertEquals(0L, MathUtils.mulAndCheck(min, 0L));\n        assertEquals(max, MathUtils.mulAndCheck(1L, max));\n        assertEquals(min, MathUtils.mulAndCheck(1L, min));\n        assertEquals(0L, MathUtils.mulAndCheck(0L, max));\n        assertEquals(0L, MathUtils.mulAndCheck(0L, min));\n        assertEquals(1L, MathUtils.mulAndCheck(-1L, -1L));\n        assertEquals(min, MathUtils.mulAndCheck(min / 2, 2));\n        testMulAndCheckLongFailure(max, 2L);\n        testMulAndCheckLongFailure(2L, max);\n        testMulAndCheckLongFailure(min, 2L);\n        testMulAndCheckLongFailure(2L, min);\n        testMulAndCheckLongFailure(min, -1L);\n        testMulAndCheckLongFailure(-1L, min);\n    }\n\n    private void testMulAndCheckLongFailure(long a, long b) {\n        try {\n            MathUtils.mulAndCheck(a, b);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // success\n        }\n    }\n\n    public void testNextAfter() {\n        // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000\n        assertEquals(16.0, MathUtils.nextAfter(15.999999999999998, 34.27555555555555), 0.0);\n\n        // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe\n        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);\n\n        // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe\n        assertEquals(15.999999999999996, MathUtils.nextAfter(15.999999999999998, 2.142222222222222), 0.0);\n\n        // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe\n        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);\n\n        // 0x4020000000000000 0x404123456789abcd -> 4020000000000001\n        assertEquals(8.000000000000002, MathUtils.nextAfter(8.0, 34.27555555555555), 0.0);\n\n        // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff\n        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 34.27555555555555), 0.0);\n\n        // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff\n        assertEquals(7.999999999999999, MathUtils.nextAfter(8.0, 2.142222222222222), 0.0);\n\n        // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff\n        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 2.142222222222222), 0.0);\n\n        // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224\n        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n\n        // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a224\n        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n\n        // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222\n        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n\n        // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222\n        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n\n        // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222\n        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n\n        // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222\n        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n\n        // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222\n        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);\n\n        // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222\n        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);\n\n        // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222\n        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);\n\n        // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224\n        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);\n\n        // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a224\n        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);\n\n        // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222\n        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);\n\n    }\n\n    public void testNextAfterSpecialCases() {\n        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.NEGATIVE_INFINITY, 0)));\n        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.POSITIVE_INFINITY, 0)));\n        assertTrue(Double.isNaN(MathUtils.nextAfter(Double.NaN, 0)));\n        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY)));\n        assertTrue(Double.isInfinite(MathUtils.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY)));\n        assertEquals(Double.MIN_VALUE, MathUtils.nextAfter(0, 1), 0);\n        assertEquals(-Double.MIN_VALUE, MathUtils.nextAfter(0, -1), 0);\n        assertEquals(0, MathUtils.nextAfter(Double.MIN_VALUE, -1), 0);\n        assertEquals(0, MathUtils.nextAfter(-Double.MIN_VALUE, 1), 0);\n    }\n\n    public void testScalb() {\n        assertEquals( 0.0, MathUtils.scalb(0.0, 5), 1.0e-15);\n        assertEquals(32.0, MathUtils.scalb(1.0, 5), 1.0e-15);\n        assertEquals(1.0 / 32.0, MathUtils.scalb(1.0,  -5), 1.0e-15);\n        assertEquals(Math.PI, MathUtils.scalb(Math.PI, 0), 1.0e-15);\n        assertTrue(Double.isInfinite(MathUtils.scalb(Double.POSITIVE_INFINITY, 1)));\n        assertTrue(Double.isInfinite(MathUtils.scalb(Double.NEGATIVE_INFINITY, 1)));\n        assertTrue(Double.isNaN(MathUtils.scalb(Double.NaN, 1)));\n    }\n\n    public void testNormalizeAngle() {\n        for (double a = -15.0; a <= 15.0; a += 0.1) {\n            for (double b = -15.0; b <= 15.0; b += 0.2) {\n                double c = MathUtils.normalizeAngle(a, b);\n                assertTrue((b - Math.PI) <= c);\n                assertTrue(c <= (b + Math.PI));\n                double twoK = Math.rint((a - c) / Math.PI);\n                assertEquals(c, a - twoK * Math.PI, 1.0e-14);\n            }\n        }\n    }\n\n    public void testRoundDouble() {\n        double x = 1.234567890;\n        assertEquals(1.23, MathUtils.round(x, 2), 0.0);\n        assertEquals(1.235, MathUtils.round(x, 3), 0.0);\n        assertEquals(1.2346, MathUtils.round(x, 4), 0.0);\n\n        // JIRA MATH-151\n        assertEquals(39.25, MathUtils.round(39.245, 2), 0.0);\n        assertEquals(39.24, MathUtils.round(39.245, 2, BigDecimal.ROUND_DOWN), 0.0);\n        double xx = 39.0;\n        xx = xx + 245d / 1000d;\n        assertEquals(39.25, MathUtils.round(xx, 2), 0.0);\n\n        // BZ 35904\n        assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);\n        assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);\n        assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);\n        assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);\n        assertEquals(50.09d, MathUtils.round(50.085d, 2), 0.0d);\n        assertEquals(50.19d, MathUtils.round(50.185d, 2), 0.0d);\n        assertEquals(50.01d, MathUtils.round(50.005d, 2), 0.0d);\n        assertEquals(30.01d, MathUtils.round(30.005d, 2), 0.0d);\n        assertEquals(30.65d, MathUtils.round(30.645d, 2), 0.0d);\n\n        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n\n        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n\n        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n\n        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n\n        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n\n        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n\n        assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n        assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n\n        try {\n            MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);\n            fail();\n        } catch (ArithmeticException ex) {\n            // success\n        }\n\n        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n\n        try {\n            MathUtils.round(1.234, 2, 1923);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            // success\n        }\n\n        // MATH-151\n        assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n\n        // special values\n        TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);\n        assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);\n        assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0);\n        assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0);\n    }\n\n    public void testRoundFloat() {\n        float x = 1.234567890f;\n        assertEquals(1.23f, MathUtils.round(x, 2), 0.0);\n        assertEquals(1.235f, MathUtils.round(x, 3), 0.0);\n        assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);\n\n        // BZ 35904\n        assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);\n        assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f);\n        assertEquals(50.09f, MathUtils.round(50.085f, 2), 0.0f);\n        assertEquals(50.19f, MathUtils.round(50.185f, 2), 0.0f);\n        assertEquals(50.01f, MathUtils.round(50.005f, 2), 0.0f);\n        assertEquals(30.01f, MathUtils.round(30.005f, 2), 0.0f);\n        assertEquals(30.65f, MathUtils.round(30.645f, 2), 0.0f);\n\n        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n\n        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n\n        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n\n        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n\n        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n        assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n\n        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n        assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n\n        assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n        assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n\n        try {\n            MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);\n            fail();\n        } catch (ArithmeticException ex) {\n            // success\n        }\n\n        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n\n        try {\n            MathUtils.round(1.234f, 2, 1923);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            // success\n        }\n\n        // special values\n        TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f);\n        assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f);\n        assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f);\n        assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);\n    }\n\n    public void testSignByte() {\n        assertEquals((byte) 1, MathUtils.sign((byte) 2));\n        assertEquals((byte) 0, MathUtils.sign((byte) 0));\n        assertEquals((byte) (-1), MathUtils.sign((byte) (-2)));\n    }\n\n    public void testSignDouble() {\n        double delta = 0.0;\n        assertEquals(1.0, MathUtils.sign(2.0), delta);\n        assertEquals(0.0, MathUtils.sign(0.0), delta);\n        assertEquals(-1.0, MathUtils.sign(-2.0), delta);\n        TestUtils.assertSame(-0. / 0., MathUtils.sign(Double.NaN));\n    }\n\n    public void testSignFloat() {\n        float delta = 0.0F;\n        assertEquals(1.0F, MathUtils.sign(2.0F), delta);\n        assertEquals(0.0F, MathUtils.sign(0.0F), delta);\n        assertEquals(-1.0F, MathUtils.sign(-2.0F), delta);\n        TestUtils.assertSame(Float.NaN, MathUtils.sign(Float.NaN));\n    }\n\n    public void testSignInt() {\n        assertEquals((int) 1, MathUtils.sign((int) 2));\n        assertEquals((int) 0, MathUtils.sign((int) 0));\n        assertEquals((int) (-1), MathUtils.sign((int) (-2)));\n    }\n\n    public void testSignLong() {\n        assertEquals(1L, MathUtils.sign(2L));\n        assertEquals(0L, MathUtils.sign(0L));\n        assertEquals(-1L, MathUtils.sign(-2L));\n    }\n\n    public void testSignShort() {\n        assertEquals((short) 1, MathUtils.sign((short) 2));\n        assertEquals((short) 0, MathUtils.sign((short) 0));\n        assertEquals((short) (-1), MathUtils.sign((short) (-2)));\n    }\n\n    public void testSinh() {\n        double x = 3.0;\n        double expected = 10.01787;\n        assertEquals(expected, MathUtils.sinh(x), 1.0e-5);\n    }\n\n    public void testSinhNaN() {\n        assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN)));\n    }\n\n    public void testSubAndCheck() {\n        int big = Integer.MAX_VALUE;\n        int bigNeg = Integer.MIN_VALUE;\n        assertEquals(big, MathUtils.subAndCheck(big, 0));\n        assertEquals(bigNeg + 1, MathUtils.subAndCheck(bigNeg, -1));\n        assertEquals(-1, MathUtils.subAndCheck(bigNeg, -big));\n        try {\n            MathUtils.subAndCheck(big, -1);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n        }\n        try {\n            MathUtils.subAndCheck(bigNeg, 1);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n        }\n    }\n\n    public void testSubAndCheckErrorMessage() {\n        int big = Integer.MAX_VALUE;\n        try {\n            MathUtils.subAndCheck(big, -1);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            assertEquals(\"overflow: subtract\", ex.getMessage());\n        }\n    }\n\n    public void testSubAndCheckLong() {\n        long max = Long.MAX_VALUE;\n        long min = Long.MIN_VALUE;\n        assertEquals(max, MathUtils.subAndCheck(max, 0));\n        assertEquals(min, MathUtils.subAndCheck(min, 0));\n        assertEquals(-max, MathUtils.subAndCheck(0, max));\n        assertEquals(min + 1, MathUtils.subAndCheck(min, -1));\n        // min == -1-max\n        assertEquals(-1, MathUtils.subAndCheck(-max - 1, -max));\n        assertEquals(max, MathUtils.subAndCheck(-1, -1 - max));\n        testSubAndCheckLongFailure(0L, min);\n        testSubAndCheckLongFailure(max, -1L);\n        testSubAndCheckLongFailure(min, 1L);\n    }\n\n    private void testSubAndCheckLongFailure(long a, long b) {\n        try {\n            MathUtils.subAndCheck(a, b);\n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {\n            // success\n        }\n\n    }\n}"}, "focal_class": {"name": "MathUtils", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_99/fixed/src/java/org/apache/commons/math/util/MathUtils.java", "superclass": "", "interface": "", "imports": ["import java.math.BigDecimal;", "import java.util.Arrays;", "import org.apache.commons.math.MathException;", "import org.apache.commons.math.MathRuntimeException;"], "fields": ["public static final double EPSILON = 0x1.0p-53", "public static final double SAFE_MIN = 0x1.0p-1022", "private static final byte NB = (byte)-1", "private static final short NS = (short)-1", "private static final byte PB = (byte)1", "private static final short PS = (short)1", "private static final byte ZB = (byte)0", "private static final short ZS = (short)0", "private static final double TWO_PI = 2 * Math.PI", "private static final long[] factorials = new long[] \n       {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800,\n        479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l,\n        355687428096000l, 6402373705728000l, 121645100408832000l,\n        2432902008176640000l}"], "methods": ["int org.apache.commons.math.util.MathUtils#addAndCheck(int#x,int#y)", "long org.apache.commons.math.util.MathUtils#addAndCheck(long#a,long#b)", "long org.apache.commons.math.util.MathUtils#addAndCheck(long#a,long#b,String#msg)", "long org.apache.commons.math.util.MathUtils#binomialCoefficient(int#n,int#k)", "double org.apache.commons.math.util.MathUtils#binomialCoefficientDouble(int#n,int#k)", "double org.apache.commons.math.util.MathUtils#binomialCoefficientLog(int#n,int#k)", "double org.apache.commons.math.util.MathUtils#cosh(double#x)", "boolean org.apache.commons.math.util.MathUtils#equals(double#x,double#y)", "boolean org.apache.commons.math.util.MathUtils#equals(double#x,double#y,double#eps)", "boolean org.apache.commons.math.util.MathUtils#equals(double[]#x,double[]#y)", "long org.apache.commons.math.util.MathUtils#factorial(int#n)", "double org.apache.commons.math.util.MathUtils#factorialDouble(int#n)", "double org.apache.commons.math.util.MathUtils#factorialLog(int#n)", "int org.apache.commons.math.util.MathUtils#hash(double#value)", "int org.apache.commons.math.util.MathUtils#hash(double[]#value)", "byte org.apache.commons.math.util.MathUtils#indicator(byte#x)", "double org.apache.commons.math.util.MathUtils#indicator(double#x)", "float org.apache.commons.math.util.MathUtils#indicator(float#x)", "int org.apache.commons.math.util.MathUtils#indicator(int#x)", "long org.apache.commons.math.util.MathUtils#indicator(long#x)", "short org.apache.commons.math.util.MathUtils#indicator(short#x)", "int org.apache.commons.math.util.MathUtils#lcm(int#a,int#b)", "double org.apache.commons.math.util.MathUtils#log(double#base,double#x)", "int org.apache.commons.math.util.MathUtils#mulAndCheck(int#x,int#y)", "long org.apache.commons.math.util.MathUtils#mulAndCheck(long#a,long#b)", "double org.apache.commons.math.util.MathUtils#nextAfter(double#d,double#direction)", "double org.apache.commons.math.util.MathUtils#scalb(double#d,int#scaleFactor)", "double org.apache.commons.math.util.MathUtils#normalizeAngle(double#a,double#center)", "double org.apache.commons.math.util.MathUtils#round(double#x,int#scale)", "double org.apache.commons.math.util.MathUtils#round(double#x,int#scale,int#roundingMethod)", "float org.apache.commons.math.util.MathUtils#round(float#x,int#scale)", "float org.apache.commons.math.util.MathUtils#round(float#x,int#scale,int#roundingMethod)", "double org.apache.commons.math.util.MathUtils#roundUnscaled(double#unscaled,double#sign,int#roundingMethod)", "byte org.apache.commons.math.util.MathUtils#sign(byte#x)", "double org.apache.commons.math.util.MathUtils#sign(double#x)", "float org.apache.commons.math.util.MathUtils#sign(float#x)", "int org.apache.commons.math.util.MathUtils#sign(int#x)", "long org.apache.commons.math.util.MathUtils#sign(long#x)", "short org.apache.commons.math.util.MathUtils#sign(short#x)", "double org.apache.commons.math.util.MathUtils#sinh(double#x)", "int org.apache.commons.math.util.MathUtils#subAndCheck(int#x,int#y)", "long org.apache.commons.math.util.MathUtils#subAndCheck(long#a,long#b)"], "other_methods": ["public static int addAndCheck(int x,int y);", "public static long addAndCheck(long a,long b);", "public static long binomialCoefficient(int n,int k);", "public static double binomialCoefficientDouble(int n,int k);", "public static double binomialCoefficientLog(int n,int k);", "public static double cosh(double x);", "public static boolean equals(double x,double y);", "public static boolean equals(double x,double y,double eps);", "public static boolean equals(double[] x,double[] y);", "public static long factorial(int n);", "public static double factorialDouble(int n);", "public static double factorialLog(int n);", "public static int hash(double value);", "public static int hash(double[] value);", "public static byte indicator(byte x);", "public static double indicator(double x);", "public static float indicator(float x);", "public static int indicator(int x);", "public static long indicator(long x);", "public static short indicator(short x);", "public static int lcm(int a,int b);", "public static double log(double base,double x);", "public static int mulAndCheck(int x,int y);", "public static long mulAndCheck(long a,long b);", "public static double nextAfter(double d,double direction);", "public static double scalb(double d,int scaleFactor);", "public static double normalizeAngle(double a,double center);", "public static double round(double x,int scale);", "public static double round(double x,int scale,int roundingMethod);", "public static float round(float x,int scale);", "public static float round(float x,int scale,int roundingMethod);", "public static byte sign(byte x);", "public static double sign(double x);", "public static float sign(float x);", "public static int sign(int x);", "public static long sign(long x);", "public static short sign(short x);", "public static double sinh(double x);", "public static int subAndCheck(int x,int y);", "public static long subAndCheck(long a,long b);"], "fields_dict": {"double#EPSILON": "public static final double EPSILON = 0x1.0p-53", "double#SAFE_MIN": "public static final double SAFE_MIN = 0x1.0p-1022", "byte#NB": "private static final byte NB = (byte)-1", "short#NS": "private static final short NS = (short)-1", "byte#PB": "private static final byte PB = (byte)1", "short#PS": "private static final short PS = (short)1", "byte#ZB": "private static final byte ZB = (byte)0", "short#ZS": "private static final short ZS = (short)0", "double#TWO_PI": "private static final double TWO_PI = 2 * Math.PI", "long[]#factorials": "private static final long[] factorials = new long[] \n       {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800,\n        479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l,\n        355687428096000l, 6402373705728000l, 121645100408832000l,\n        2432902008176640000l}"}, "text": "package org.apache.commons.math.util;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\n\nimport org.apache.commons.math.MathException;\nimport org.apache.commons.math.MathRuntimeException;\n"}, "retrieved_test_case": "@Test\n    public void testGcdPositiveNumbers() {\n        assertEquals(4, MathUtils.gcd(8, 12));\n        assertEquals(6, MathUtils.gcd(48, 18));\n        assertEquals(1, MathUtils.gcd(7, 5));\n        assertEquals(7, MathUtils.gcd(21, 14));\n        assertEquals(1, MathUtils.gcd(1, 1));\n    }"}
