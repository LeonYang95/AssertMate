{"content:callee_code": ["public static String htmlEscape(String input) {\r\n    if (input == null) {\r\n        throw new IllegalArgumentException(\"Null 'input' argument.\");\r\n    }\r\n    StringBuffer result = new StringBuffer();\r\n    int length = input.length();\r\n    for (int i = 0; i < length; i++) {\r\n        char c = input.charAt(i);\r\n        if (c == '&') {\r\n            result.append(\"&amp;\");\r\n        } else if (c == '\\\"') {\r\n            result.append(\"&quot;\");\r\n        } else if (c == '<') {\r\n            result.append(\"&lt;\");\r\n        } else if (c == '>') {\r\n            result.append(\"&gt;\");\r\n        } else if (c == '\\'') {\r\n            result.append(\"&#39;\");\r\n        } else if (c == '\\\\') {\r\n            result.append(\"&#092;\");\r\n        } else {\r\n            result.append(c);\r\n        }\r\n    }\r\n    return result.toString();\r\n}"], "content:callee_signature": ["org.jfree.chart.imagemap#ImageMapUtilities#htmlEscape(java.lang#String)"], "content:parameter_class_code": [], "content:parameter_class_constructors": [], "content:parameter_class_signature": [], "content:parameter_list": ["String toolTipText"], "content:source_class_code_format": "public class StandardToolTipTagFragmentGenerator implements ToolTipTagFragmentGenerator {\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     */\r\n    public StandardToolTipTagFragmentGenerator() {\r\n        super();\r\n    }\r\n\r\n    /**\r\n     * Generates a tooltip string to go in an HTML image map.\r\n     *\r\n     * @param toolTipText  the tooltip.\r\n     *\r\n     * @return The formatted HTML area tag attribute(s).\r\n     */\r\n    public String generateToolTipFragment(String toolTipText) {\r\n        return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) + \"\\\" alt=\\\"\\\"\";\r\n    }\r\n}", "content:source_class_code_imports": [], "content:source_class_code_path": "D:\\try\\ut4\\d4j_fixed_projects\\Chart_10_fixed\\source\\org\\jfree\\chart\\imagemap\\StandardToolTipTagFragmentGenerator.java", "content:source_class_code_signature": "org.jfree.chart.imagemap#StandardToolTipTagFragmentGenerator | generateToolTipFragment(String) | StandardToolTipTagFragmentGenerator()", "content:source_class_constructors": ["public StandardToolTipTagFragmentGenerator();"], "content:source_class_define": "public class StandardToolTipTagFragmentGenerator implements ToolTipTagFragmentGenerator;", "content:source_class_name": "StandardToolTipTagFragmentGenerator", "errorList": [], "extra:language": "Java", "extra:project_name": "Chart_10_fixed", "rowKey": "7834e2bbc31d59e507e8cbbf3ffe4980", "source:source_method_code_format": "public String generateToolTipFragment(String toolTipText) {\r\n    return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) + \"\\\" alt=\\\"\\\"\";\r\n}", "source:source_method_comment": "/**\r\n * Generates a tooltip string to go in an HTML image map.\r\n *\r\n * @param toolTipText  the tooltip.\r\n *\r\n * @return The formatted HTML area tag attribute(s).\r\n */\r\n <innerComment> ", "source:source_method_name": "generateToolTipFragment", "source:source_method_return_type_class_constructors": [], "source:source_method_signature": "org.jfree.chart.imagemap#StandardToolTipTagFragmentGenerator#generateToolTipFragment(java.lang#String)", "source:source_other_method_signature": ["public StandardToolTipTagFragmentGenerator();"], "sourceMethodExistNonEn": "false", "testMethodCodeFormat": [], "testMethodExistNonEn": [], "testMethodSignature": [], "bytecode_signature": "org.jfree.chart.imagemap.StandardToolTipTagFragmentGenerator.generateToolTipFragment(Ljava/lang/String;)Ljava/lang/String;"}
{"content:callee_code": [], "content:callee_signature": [], "content:parameter_class_code": [], "content:parameter_class_constructors": [], "content:parameter_class_signature": [], "content:parameter_list": ["Ellipse2D e1", "Ellipse2D e2"], "content:source_class_code_format": "public class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            } catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        } else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, double transX, double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(), anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle, float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y) {\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n    }\n\n    /**\n     * A useful constant used internally.\n     */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        } else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y, Rectangle2D area) {\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n        return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double width = rect2.getWidth();\n        double y = rect2.getY();\n        double height = rect2.getHeight();\n        return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());\n    }\n}", "content:source_class_code_imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "content:source_class_code_path": "D:\\try\\ut4\\d4j_fixed_projects\\Chart_11_fixed\\source\\org\\jfree\\chart\\util\\ShapeUtilities.java", "content:source_class_code_signature": "org.jfree.chart.util#ShapeUtilities | equal(Shape, Shape) | createLineRegion(Line2D, float) | equal(Polygon, Polygon) | createTranslatedShape(Shape, RectangleAnchor, double, double) | createDiamond(float) | createRegularCross(float, float) | createDownTriangle(float) | createTranslatedShape(Shape, double, double) | intersects(Rectangle2D, Rectangle2D) | drawRotatedShape(Graphics2D, Shape, double, float, float) | equal(Ellipse2D, Ellipse2D) | contains(Rectangle2D, Rectangle2D) | clone(Shape) | equal(Line2D, Line2D) | equal(GeneralPath, GeneralPath) | getPointInRectangle(double, double, Rectangle2D) | equal(Arc2D, Arc2D) | createDiagonalCross(float, float) | createUpTriangle(float) | rotateShape(Shape, double, float, float)", "content:source_class_constructors": ["private ShapeUtilities();"], "content:source_class_define": "public class ShapeUtilities;", "content:source_class_name": "ShapeUtilities", "errorList": [], "extra:language": "Java", "extra:project_name": "Chart_11_fixed", "rowKey": "e00f7ddbfabe123eae9adeb7858678ac", "source:source_method_code_format": "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "source:source_method_comment": "/**\r\n * Compares two ellipses and returns <code>true</code> if they are equal or\r\n * both <code>null</code>.\r\n *\r\n * @param e1  the first ellipse (<code>null</code> permitted).\r\n * @param e2  the second ellipse (<code>null</code> permitted).\r\n *\r\n * @return A boolean.\r\n */\r\n <innerComment> ", "source:source_method_name": "equal", "source:source_method_return_type_class_constructors": [], "source:source_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "source:source_other_method_signature": ["public static boolean equal(Shape s1, Shape s2);", "public static Shape createLineRegion(Line2D line, float width);", "public static boolean equal(Polygon p1, Polygon p2);", "public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY);", "public static Shape createDiamond(float s);", "public static Shape createRegularCross(float l, float t);", "public static Shape createDownTriangle(float s);", "public static Shape createTranslatedShape(Shape shape, double transX, double transY);", "public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2);", "public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y);", "private ShapeUtilities();", "public static boolean contains(Rectangle2D rect1, Rectangle2D rect2);", "public static Shape clone(Shape shape);", "public static boolean equal(Line2D l1, Line2D l2);", "public static boolean equal(GeneralPath p1, GeneralPath p2);", "public static Point2D getPointInRectangle(double x, double y, Rectangle2D area);", "public static boolean equal(Arc2D a1, Arc2D a2);", "public static Shape createDiagonalCross(float l, float t);", "public static Shape createUpTriangle(float s);", "public static Shape rotateShape(Shape base, double angle, float x, float y);"], "sourceMethodExistNonEn": "false", "testMethodCodeFormat": [], "testMethodExistNonEn": [], "testMethodSignature": [], "bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Ellipse2D;Ljava/awt/geom/Ellipse2D;)Z"}
{"content:callee_code": [], "content:callee_signature": [], "content:parameter_class_code": [], "content:parameter_class_constructors": [], "content:parameter_class_signature": [], "content:parameter_list": ["Polygon p1", "Polygon p2"], "content:source_class_code_format": "public class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            } catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        } else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, double transX, double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(), anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle, float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y) {\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n    }\n\n    /**\n     * A useful constant used internally.\n     */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        } else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y, Rectangle2D area) {\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n        return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double width = rect2.getWidth();\n        double y = rect2.getY();\n        double height = rect2.getHeight();\n        return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());\n    }\n}", "content:source_class_code_imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "content:source_class_code_path": "D:\\try\\ut4\\d4j_fixed_projects\\Chart_11_fixed\\source\\org\\jfree\\chart\\util\\ShapeUtilities.java", "content:source_class_code_signature": "org.jfree.chart.util#ShapeUtilities | equal(Shape, Shape) | createLineRegion(Line2D, float) | equal(Polygon, Polygon) | createTranslatedShape(Shape, RectangleAnchor, double, double) | createDiamond(float) | createRegularCross(float, float) | createDownTriangle(float) | createTranslatedShape(Shape, double, double) | intersects(Rectangle2D, Rectangle2D) | drawRotatedShape(Graphics2D, Shape, double, float, float) | equal(Ellipse2D, Ellipse2D) | contains(Rectangle2D, Rectangle2D) | clone(Shape) | equal(Line2D, Line2D) | equal(GeneralPath, GeneralPath) | getPointInRectangle(double, double, Rectangle2D) | equal(Arc2D, Arc2D) | createDiagonalCross(float, float) | createUpTriangle(float) | rotateShape(Shape, double, float, float)", "content:source_class_constructors": ["private ShapeUtilities();"], "content:source_class_define": "public class ShapeUtilities;", "content:source_class_name": "ShapeUtilities", "errorList": [], "extra:language": "Java", "extra:project_name": "Chart_11_fixed", "rowKey": "76413267221830cc9af7f4452667c8d5", "source:source_method_code_format": "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "source:source_method_comment": "/**\r\n * Tests two polygons for equality.  If both are <code>null</code> this\r\n * method returns <code>true</code>.\r\n *\r\n * @param p1  polygon 1 (<code>null</code> permitted).\r\n * @param p2  polygon 2 (<code>null</code> permitted).\r\n *\r\n * @return A boolean.\r\n */\r\n <innerComment> ", "source:source_method_name": "equal", "source:source_method_return_type_class_constructors": [], "source:source_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "source:source_other_method_signature": ["public static boolean equal(Shape s1, Shape s2);", "public static Shape createLineRegion(Line2D line, float width);", "public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY);", "public static Shape createDiamond(float s);", "public static Shape createRegularCross(float l, float t);", "public static Shape createDownTriangle(float s);", "public static Shape createTranslatedShape(Shape shape, double transX, double transY);", "public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2);", "public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y);", "private ShapeUtilities();", "public static boolean equal(Ellipse2D e1, Ellipse2D e2);", "public static boolean contains(Rectangle2D rect1, Rectangle2D rect2);", "public static Shape clone(Shape shape);", "public static boolean equal(Line2D l1, Line2D l2);", "public static boolean equal(GeneralPath p1, GeneralPath p2);", "public static Point2D getPointInRectangle(double x, double y, Rectangle2D area);", "public static boolean equal(Arc2D a1, Arc2D a2);", "public static Shape createDiagonalCross(float l, float t);", "public static Shape createUpTriangle(float s);", "public static Shape rotateShape(Shape base, double angle, float x, float y);"], "sourceMethodExistNonEn": "false", "testMethodCodeFormat": [], "testMethodExistNonEn": [], "testMethodSignature": [], "bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Polygon;Ljava/awt/Polygon;)Z"}
{"content:callee_code": [], "content:callee_signature": [], "content:parameter_class_code": [], "content:parameter_class_constructors": [], "content:parameter_class_signature": [], "content:parameter_list": ["Arc2D a1", "Arc2D a2"], "content:source_class_code_format": "public class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            } catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        } else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, double transX, double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(), anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle, float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y) {\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n    }\n\n    /**\n     * A useful constant used internally.\n     */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        } else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y, Rectangle2D area) {\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n        return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double width = rect2.getWidth();\n        double y = rect2.getY();\n        double height = rect2.getHeight();\n        return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());\n    }\n}", "content:source_class_code_imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "content:source_class_code_path": "D:\\try\\ut4\\d4j_fixed_projects\\Chart_11_fixed\\source\\org\\jfree\\chart\\util\\ShapeUtilities.java", "content:source_class_code_signature": "org.jfree.chart.util#ShapeUtilities | equal(Shape, Shape) | createLineRegion(Line2D, float) | equal(Polygon, Polygon) | createTranslatedShape(Shape, RectangleAnchor, double, double) | createDiamond(float) | createRegularCross(float, float) | createDownTriangle(float) | createTranslatedShape(Shape, double, double) | intersects(Rectangle2D, Rectangle2D) | drawRotatedShape(Graphics2D, Shape, double, float, float) | equal(Ellipse2D, Ellipse2D) | contains(Rectangle2D, Rectangle2D) | clone(Shape) | equal(Line2D, Line2D) | equal(GeneralPath, GeneralPath) | getPointInRectangle(double, double, Rectangle2D) | equal(Arc2D, Arc2D) | createDiagonalCross(float, float) | createUpTriangle(float) | rotateShape(Shape, double, float, float)", "content:source_class_constructors": ["private ShapeUtilities();"], "content:source_class_define": "public class ShapeUtilities;", "content:source_class_name": "ShapeUtilities", "errorList": [], "extra:language": "Java", "extra:project_name": "Chart_11_fixed", "rowKey": "7296193eeb06bb02486955f377492273", "source:source_method_code_format": "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "source:source_method_comment": "/**\r\n * Compares two arcs and returns <code>true</code> if they are equal or\r\n * both <code>null</code>.\r\n *\r\n * @param a1  the first arc (<code>null</code> permitted).\r\n * @param a2  the second arc (<code>null</code> permitted).\r\n *\r\n * @return A boolean.\r\n */\r\n <innerComment> ", "source:source_method_name": "equal", "source:source_method_return_type_class_constructors": [], "source:source_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "source:source_other_method_signature": ["public static boolean equal(Shape s1, Shape s2);", "public static Shape createLineRegion(Line2D line, float width);", "public static boolean equal(Polygon p1, Polygon p2);", "public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY);", "public static Shape createDiamond(float s);", "public static Shape createRegularCross(float l, float t);", "public static Shape createDownTriangle(float s);", "public static Shape createTranslatedShape(Shape shape, double transX, double transY);", "public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2);", "public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y);", "private ShapeUtilities();", "public static boolean equal(Ellipse2D e1, Ellipse2D e2);", "public static boolean contains(Rectangle2D rect1, Rectangle2D rect2);", "public static Shape clone(Shape shape);", "public static boolean equal(Line2D l1, Line2D l2);", "public static boolean equal(GeneralPath p1, GeneralPath p2);", "public static Point2D getPointInRectangle(double x, double y, Rectangle2D area);", "public static Shape createDiagonalCross(float l, float t);", "public static Shape createUpTriangle(float s);", "public static Shape rotateShape(Shape base, double angle, float x, float y);"], "sourceMethodExistNonEn": "false", "testMethodCodeFormat": [], "testMethodExistNonEn": [], "testMethodSignature": [], "bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Arc2D;Ljava/awt/geom/Arc2D;)Z"}
{"content:callee_code": [], "content:callee_signature": [], "content:parameter_class_code": [], "content:parameter_class_constructors": [], "content:parameter_class_signature": [], "content:parameter_list": ["Line2D l1", "Line2D l2"], "content:source_class_code_format": "public class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            } catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        } else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, double transX, double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(), anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle, float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y) {\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n    }\n\n    /**\n     * A useful constant used internally.\n     */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        } else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y, Rectangle2D area) {\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n        return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double width = rect2.getWidth();\n        double y = rect2.getY();\n        double height = rect2.getHeight();\n        return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());\n    }\n}", "content:source_class_code_imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "content:source_class_code_path": "D:\\try\\ut4\\d4j_fixed_projects\\Chart_11_fixed\\source\\org\\jfree\\chart\\util\\ShapeUtilities.java", "content:source_class_code_signature": "org.jfree.chart.util#ShapeUtilities | equal(Shape, Shape) | createLineRegion(Line2D, float) | equal(Polygon, Polygon) | createTranslatedShape(Shape, RectangleAnchor, double, double) | createDiamond(float) | createRegularCross(float, float) | createDownTriangle(float) | createTranslatedShape(Shape, double, double) | intersects(Rectangle2D, Rectangle2D) | drawRotatedShape(Graphics2D, Shape, double, float, float) | equal(Ellipse2D, Ellipse2D) | contains(Rectangle2D, Rectangle2D) | clone(Shape) | equal(Line2D, Line2D) | equal(GeneralPath, GeneralPath) | getPointInRectangle(double, double, Rectangle2D) | equal(Arc2D, Arc2D) | createDiagonalCross(float, float) | createUpTriangle(float) | rotateShape(Shape, double, float, float)", "content:source_class_constructors": ["private ShapeUtilities();"], "content:source_class_define": "public class ShapeUtilities;", "content:source_class_name": "ShapeUtilities", "errorList": [], "extra:language": "Java", "extra:project_name": "Chart_11_fixed", "rowKey": "a517165d880b0b863c47b7e247bf3651", "source:source_method_code_format": "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}", "source:source_method_comment": "/**\r\n * Compares two lines are returns <code>true</code> if they are equal or\r\n * both <code>null</code>.\r\n *\r\n * @param l1  the first line (<code>null</code> permitted).\r\n * @param l2  the second line (<code>null</code> permitted).\r\n *\r\n * @return A boolean.\r\n */\r\n <innerComment> ", "source:source_method_name": "equal", "source:source_method_return_type_class_constructors": [], "source:source_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)", "source:source_other_method_signature": ["public static boolean equal(Shape s1, Shape s2);", "public static Shape createLineRegion(Line2D line, float width);", "public static boolean equal(Polygon p1, Polygon p2);", "public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY);", "public static Shape createDiamond(float s);", "public static Shape createRegularCross(float l, float t);", "public static Shape createDownTriangle(float s);", "public static Shape createTranslatedShape(Shape shape, double transX, double transY);", "public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2);", "public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y);", "private ShapeUtilities();", "public static boolean equal(Ellipse2D e1, Ellipse2D e2);", "public static boolean contains(Rectangle2D rect1, Rectangle2D rect2);", "public static Shape clone(Shape shape);", "public static boolean equal(GeneralPath p1, GeneralPath p2);", "public static Point2D getPointInRectangle(double x, double y, Rectangle2D area);", "public static boolean equal(Arc2D a1, Arc2D a2);", "public static Shape createDiagonalCross(float l, float t);", "public static Shape createUpTriangle(float s);", "public static Shape rotateShape(Shape base, double angle, float x, float y);"], "sourceMethodExistNonEn": "false", "testMethodCodeFormat": [], "testMethodExistNonEn": [], "testMethodSignature": [], "bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Line2D;Ljava/awt/geom/Line2D;)Z"}
{"content:callee_code": [], "content:callee_signature": [], "content:parameter_class_code": [], "content:parameter_class_constructors": [], "content:parameter_class_signature": [], "content:parameter_list": ["GeneralPath p1", "GeneralPath p2"], "content:source_class_code_format": "public class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            } catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        } else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, double transX, double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(), anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle, float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y) {\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n    }\n\n    /**\n     * A useful constant used internally.\n     */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        } else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y, Rectangle2D area) {\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n        return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double width = rect2.getWidth();\n        double y = rect2.getY();\n        double height = rect2.getHeight();\n        return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());\n    }\n}", "content:source_class_code_imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "content:source_class_code_path": "D:\\try\\ut4\\d4j_fixed_projects\\Chart_11_fixed\\source\\org\\jfree\\chart\\util\\ShapeUtilities.java", "content:source_class_code_signature": "org.jfree.chart.util#ShapeUtilities | equal(Shape, Shape) | createLineRegion(Line2D, float) | equal(Polygon, Polygon) | createTranslatedShape(Shape, RectangleAnchor, double, double) | createDiamond(float) | createRegularCross(float, float) | createDownTriangle(float) | createTranslatedShape(Shape, double, double) | intersects(Rectangle2D, Rectangle2D) | drawRotatedShape(Graphics2D, Shape, double, float, float) | equal(Ellipse2D, Ellipse2D) | contains(Rectangle2D, Rectangle2D) | clone(Shape) | equal(Line2D, Line2D) | equal(GeneralPath, GeneralPath) | getPointInRectangle(double, double, Rectangle2D) | equal(Arc2D, Arc2D) | createDiagonalCross(float, float) | createUpTriangle(float) | rotateShape(Shape, double, float, float)", "content:source_class_constructors": ["private ShapeUtilities();"], "content:source_class_define": "public class ShapeUtilities;", "content:source_class_name": "ShapeUtilities", "errorList": [], "extra:language": "Java", "extra:project_name": "Chart_11_fixed", "rowKey": "f5ecace986545df70a90efd61ce21b38", "source:source_method_code_format": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "source:source_method_comment": "/**\r\n * Tests two polygons for equality.  If both are <code>null</code> this\r\n * method returns <code>true</code>.\r\n *\r\n * @param p1  path 1 (<code>null</code> permitted).\r\n * @param p2  path 2 (<code>null</code> permitted).\r\n *\r\n * @return A boolean.\r\n */\r\n <innerComment> ", "source:source_method_name": "equal", "source:source_method_return_type_class_constructors": [], "source:source_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "source:source_other_method_signature": ["public static boolean equal(Shape s1, Shape s2);", "public static Shape createLineRegion(Line2D line, float width);", "public static boolean equal(Polygon p1, Polygon p2);", "public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY);", "public static Shape createDiamond(float s);", "public static Shape createRegularCross(float l, float t);", "public static Shape createDownTriangle(float s);", "public static Shape createTranslatedShape(Shape shape, double transX, double transY);", "public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2);", "public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y);", "private ShapeUtilities();", "public static boolean equal(Ellipse2D e1, Ellipse2D e2);", "public static boolean contains(Rectangle2D rect1, Rectangle2D rect2);", "public static Shape clone(Shape shape);", "public static boolean equal(Line2D l1, Line2D l2);", "public static Point2D getPointInRectangle(double x, double y, Rectangle2D area);", "public static boolean equal(Arc2D a1, Arc2D a2);", "public static Shape createDiagonalCross(float l, float t);", "public static Shape createUpTriangle(float s);", "public static Shape rotateShape(Shape base, double angle, float x, float y);"], "sourceMethodExistNonEn": "false", "testMethodCodeFormat": [], "testMethodExistNonEn": [], "testMethodSignature": [], "bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/GeneralPath;Ljava/awt/geom/GeneralPath;)Z"}
{"content:callee_code": ["public static boolean equal(final Object o1, final Object o2) {\n    if (o1 == o2) {\n        return true;\n    }\n    if (o1 != null) {\n        return o1.equals(o2);\n    } else {\n        return false;\n    }\n}", "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}"], "content:callee_signature": ["org.jfree.chart.util#ObjectUtilities#equal(java.lang#Object, java.lang#Object)", "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)"], "content:parameter_class_code": [], "content:parameter_class_constructors": [], "content:parameter_class_signature": [], "content:parameter_list": ["Shape s1", "Shape s2"], "content:source_class_code_format": "public class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            } catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        } else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, double transX, double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(), anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle, float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y) {\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n    }\n\n    /**\n     * A useful constant used internally.\n     */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        } else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y, Rectangle2D area) {\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n        return ((x >= x0) && (y >= y0) && ((x + w) <= (x0 + rect1.getWidth())) && ((y + h) <= (y0 + rect1.getHeight())));\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double width = rect2.getWidth();\n        double y = rect2.getY();\n        double height = rect2.getHeight();\n        return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth() && y <= y0 + rect1.getHeight());\n    }\n}", "content:source_class_code_imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "content:source_class_code_path": "D:\\try\\ut4\\d4j_fixed_projects\\Chart_11_fixed\\source\\org\\jfree\\chart\\util\\ShapeUtilities.java", "content:source_class_code_signature": "org.jfree.chart.util#ShapeUtilities | equal(Shape, Shape) | createLineRegion(Line2D, float) | equal(Polygon, Polygon) | createTranslatedShape(Shape, RectangleAnchor, double, double) | createDiamond(float) | createRegularCross(float, float) | createDownTriangle(float) | createTranslatedShape(Shape, double, double) | intersects(Rectangle2D, Rectangle2D) | drawRotatedShape(Graphics2D, Shape, double, float, float) | equal(Ellipse2D, Ellipse2D) | contains(Rectangle2D, Rectangle2D) | clone(Shape) | equal(Line2D, Line2D) | equal(GeneralPath, GeneralPath) | getPointInRectangle(double, double, Rectangle2D) | equal(Arc2D, Arc2D) | createDiagonalCross(float, float) | createUpTriangle(float) | rotateShape(Shape, double, float, float)", "content:source_class_constructors": ["private ShapeUtilities();"], "content:source_class_define": "public class ShapeUtilities;", "content:source_class_name": "ShapeUtilities", "errorList": [], "extra:language": "Java", "extra:project_name": "Chart_11_fixed", "rowKey": "f99e927edb62e3815008cd0600fa1fa9", "source:source_method_code_format": "public static boolean equal(Shape s1, Shape s2) {\n    if (s1 instanceof Line2D && s2 instanceof Line2D) {\n        return equal((Line2D) s1, (Line2D) s2);\n    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n        return equal((Ellipse2D) s1, (Ellipse2D) s2);\n    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n        return equal((Arc2D) s1, (Arc2D) s2);\n    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n        return equal((Polygon) s1, (Polygon) s2);\n    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n        return equal((GeneralPath) s1, (GeneralPath) s2);\n    } else {\n        // this will handle Rectangle2D...\n        return ObjectUtilities.equal(s1, s2);\n    }\n}", "source:source_method_comment": "/**\r\n * Tests two shapes for equality.  If both shapes are <code>null</code>,\r\n * this method will return <code>true</code>.\r\n * <p>\r\n * In the current implementation, the following shapes are supported:\r\n * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\r\n * (implicit).\r\n *\r\n * @param s1  the first shape (<code>null</code> permitted).\r\n * @param s2  the second shape (<code>null</code> permitted).\r\n *\r\n * @return A boolean.\r\n */\r\n <innerComment> // this will handle Rectangle2D...\r\n", "source:source_method_name": "equal", "source:source_method_return_type_class_constructors": [], "source:source_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Shape, java.awt#Shape)", "source:source_other_method_signature": ["public static Shape createLineRegion(Line2D line, float width);", "public static boolean equal(Polygon p1, Polygon p2);", "public static Shape createTranslatedShape(Shape shape, RectangleAnchor anchor, double locationX, double locationY);", "public static Shape createDiamond(float s);", "public static Shape createRegularCross(float l, float t);", "public static Shape createDownTriangle(float s);", "public static Shape createTranslatedShape(Shape shape, double transX, double transY);", "public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2);", "public static void drawRotatedShape(Graphics2D g2, Shape shape, double angle, float x, float y);", "private ShapeUtilities();", "public static boolean equal(Ellipse2D e1, Ellipse2D e2);", "public static boolean contains(Rectangle2D rect1, Rectangle2D rect2);", "public static Shape clone(Shape shape);", "public static boolean equal(Line2D l1, Line2D l2);", "public static boolean equal(GeneralPath p1, GeneralPath p2);", "public static Point2D getPointInRectangle(double x, double y, Rectangle2D area);", "public static boolean equal(Arc2D a1, Arc2D a2);", "public static Shape createDiagonalCross(float l, float t);", "public static Shape createUpTriangle(float s);", "public static Shape rotateShape(Shape base, double angle, float x, float y);"], "sourceMethodExistNonEn": "false", "testMethodCodeFormat": [], "testMethodExistNonEn": [], "testMethodSignature": [], "bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Shape;Ljava/awt/Shape;)Z"}
{"content:callee_code": ["public double getWidth() {\r\n    return this.width;\r\n}", "public double getHeight() {\r\n    return this.height;\r\n}", "public Size2D arrange(Graphics2D g2, RectangleConstraint constraint);", "public void setBounds(Rectangle2D bounds);"], "content:callee_signature": ["org.jfree.chart.block#RectangleConstraint#getWidth()", "org.jfree.chart.block#RectangleConstraint#getHeight()", "org.jfree.chart.block#Block#arrange(java.awt#Graphics2D, org.jfree.chart.block#RectangleConstraint)", "org.jfree.chart.block#Block#setBounds(java.awt.geom#Rectangle2D)"], "content:parameter_class_code": ["public class BlockContainer extends AbstractBlock implements Block, Cloneable, PublicCloneable, Serializable {\r\n\r\n    /**\r\n     * For serialization.\r\n     */\r\n    private static final long serialVersionUID = 8199508075695195293L;\r\n\r\n    /**\r\n     * The blocks within the container.\r\n     */\r\n    private List blocks;\r\n\r\n    /**\r\n     * The object responsible for laying out the blocks.\r\n     */\r\n    private Arrangement arrangement;\r\n\r\n    /**\r\n     * Creates a new instance with default settings.\r\n     */\r\n    public BlockContainer() {\r\n        this(new BorderArrangement());\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance with the specified arrangement.\r\n     *\r\n     * @param arrangement  the arrangement manager (<code>null</code> not\r\n     *                     permitted).\r\n     */\r\n    public BlockContainer(Arrangement arrangement) {\r\n        if (arrangement == null) {\r\n            throw new IllegalArgumentException(\"Null 'arrangement' argument.\");\r\n        }\r\n        this.arrangement = arrangement;\r\n        this.blocks = new ArrayList();\r\n    }\r\n\r\n    /**\r\n     * Returns the arrangement (layout) manager for the container.\r\n     *\r\n     * @return The arrangement manager (never <code>null</code>).\r\n     */\r\n    public Arrangement getArrangement() {\r\n        return this.arrangement;\r\n    }\r\n\r\n    /**\r\n     * Sets the arrangement (layout) manager.\r\n     *\r\n     * @param arrangement  the arrangement (<code>null</code> not permitted).\r\n     */\r\n    public void setArrangement(Arrangement arrangement) {\r\n        if (arrangement == null) {\r\n            throw new IllegalArgumentException(\"Null 'arrangement' argument.\");\r\n        }\r\n        this.arrangement = arrangement;\r\n    }\r\n\r\n    /**\r\n     * Returns <code>true</code> if there are no blocks in the container, and\r\n     * <code>false</code> otherwise.\r\n     *\r\n     * @return A boolean.\r\n     */\r\n    public boolean isEmpty() {\r\n        return this.blocks.isEmpty();\r\n    }\r\n\r\n    /**\r\n     * Returns an unmodifiable list of the {@link Block} objects managed by\r\n     * this arrangement.\r\n     *\r\n     * @return A list of blocks.\r\n     */\r\n    public List getBlocks() {\r\n        return Collections.unmodifiableList(this.blocks);\r\n    }\r\n\r\n    /**\r\n     * Adds a block to the container.\r\n     *\r\n     * @param block  the block (<code>null</code> permitted).\r\n     */\r\n    public void add(Block block) {\r\n        add(block, null);\r\n    }\r\n\r\n    /**\r\n     * Adds a block to the container.\r\n     *\r\n     * @param block  the block (<code>null</code> permitted).\r\n     * @param key  the key (<code>null</code> permitted).\r\n     */\r\n    public void add(Block block, Object key) {\r\n        this.blocks.add(block);\r\n        this.arrangement.add(block, key);\r\n    }\r\n\r\n    /**\r\n     * Clears all the blocks from the container.\r\n     */\r\n    public void clear() {\r\n        this.blocks.clear();\r\n        this.arrangement.clear();\r\n    }\r\n\r\n    /**\r\n     * Arranges the contents of the block, within the given constraints, and\r\n     * returns the block size.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param constraint  the constraint (<code>null</code> not permitted).\r\n     *\r\n     * @return The block size (in Java2D units, never <code>null</code>).\r\n     */\r\n    public Size2D arrange(Graphics2D g2, RectangleConstraint constraint) {\r\n        return this.arrangement.arrange(this, g2, constraint);\r\n    }\r\n\r\n    /**\r\n     * Draws the container and all the blocks within it.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area.\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D area) {\r\n        draw(g2, area, null);\r\n    }\r\n\r\n    /**\r\n     * Draws the block within the specified area.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area.\r\n     * @param params  passed on to blocks within the container\r\n     *                (<code>null</code> permitted).\r\n     *\r\n     * @return An instance of {@link EntityBlockResult}, or <code>null</code>.\r\n     */\r\n    public Object draw(Graphics2D g2, Rectangle2D area, Object params) {\r\n        // check if we need to collect chart entities from the container\r\n        EntityBlockParams ebp = null;\r\n        StandardEntityCollection sec = null;\r\n        if (params instanceof EntityBlockParams) {\r\n            ebp = (EntityBlockParams) params;\r\n            if (ebp.getGenerateEntities()) {\r\n                sec = new StandardEntityCollection();\r\n            }\r\n        }\r\n        Rectangle2D contentArea = (Rectangle2D) area.clone();\r\n        contentArea = trimMargin(contentArea);\r\n        drawBorder(g2, contentArea);\r\n        contentArea = trimBorder(contentArea);\r\n        contentArea = trimPadding(contentArea);\r\n        Iterator iterator = this.blocks.iterator();\r\n        while (iterator.hasNext()) {\r\n            Block block = (Block) iterator.next();\r\n            Rectangle2D bounds = block.getBounds();\r\n            Rectangle2D drawArea = new Rectangle2D.Double(bounds.getX() + area.getX(), bounds.getY() + area.getY(), bounds.getWidth(), bounds.getHeight());\r\n            Object r = block.draw(g2, drawArea, params);\r\n            if (sec != null) {\r\n                if (r instanceof EntityBlockResult) {\r\n                    EntityBlockResult ebr = (EntityBlockResult) r;\r\n                    EntityCollection ec = ebr.getEntityCollection();\r\n                    sec.addAll(ec);\r\n                }\r\n            }\r\n        }\r\n        BlockResult result = null;\r\n        if (sec != null) {\r\n            result = new BlockResult();\r\n            result.setEntityCollection(sec);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Tests this container for equality with an arbitrary object.\r\n     *\r\n     * @param obj  the object (<code>null</code> permitted).\r\n     *\r\n     * @return A boolean.\r\n     */\r\n    public boolean equals(Object obj) {\r\n        if (obj == this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof BlockContainer)) {\r\n            return false;\r\n        }\r\n        if (!super.equals(obj)) {\r\n            return false;\r\n        }\r\n        BlockContainer that = (BlockContainer) obj;\r\n        if (!this.arrangement.equals(that.arrangement)) {\r\n            return false;\r\n        }\r\n        if (!this.blocks.equals(that.blocks)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns a clone of the container.\r\n     *\r\n     * @return A clone.\r\n     *\r\n     * @throws CloneNotSupportedException if there is a problem cloning.\r\n     */\r\n    public Object clone() throws CloneNotSupportedException {\r\n        BlockContainer clone = (BlockContainer) super.clone();\r\n        // TODO : complete this\r\n        return clone;\r\n    }\r\n}\n\n", "public class RectangleConstraint {\r\n\r\n    /**\r\n     * An instance representing no constraint.\r\n     */\r\n    public static final RectangleConstraint NONE = new RectangleConstraint(0.0, null, LengthConstraintType.NONE, 0.0, null, LengthConstraintType.NONE);\r\n\r\n    /**\r\n     * The width.\r\n     */\r\n    private double width;\r\n\r\n    /**\r\n     * The width range.\r\n     */\r\n    private Range widthRange;\r\n\r\n    /**\r\n     * The width constraint type.\r\n     */\r\n    private LengthConstraintType widthConstraintType;\r\n\r\n    /**\r\n     * The fixed or maximum height.\r\n     */\r\n    private double height;\r\n\r\n    private Range heightRange;\r\n\r\n    /**\r\n     * The constraint type.\r\n     */\r\n    private LengthConstraintType heightConstraintType;\r\n\r\n    /**\r\n     * Creates a new \"fixed width and height\" instance.\r\n     *\r\n     * @param w  the fixed width.\r\n     * @param h  the fixed height.\r\n     */\r\n    public RectangleConstraint(double w, double h) {\r\n        this(w, null, LengthConstraintType.FIXED, h, null, LengthConstraintType.FIXED);\r\n    }\r\n\r\n    /**\r\n     * Creates a new \"range width and height\" instance.\r\n     *\r\n     * @param w  the width range.\r\n     * @param h  the height range.\r\n     */\r\n    public RectangleConstraint(Range w, Range h) {\r\n        this(0.0, w, LengthConstraintType.RANGE, 0.0, h, LengthConstraintType.RANGE);\r\n    }\r\n\r\n    /**\r\n     * Creates a new constraint with a range for the width and a\r\n     * fixed height.\r\n     *\r\n     * @param w  the width range.\r\n     * @param h  the fixed height.\r\n     */\r\n    public RectangleConstraint(Range w, double h) {\r\n        this(0.0, w, LengthConstraintType.RANGE, h, null, LengthConstraintType.FIXED);\r\n    }\r\n\r\n    /**\r\n     * Creates a new constraint with a fixed width and a range for\r\n     * the height.\r\n     *\r\n     * @param w  the fixed width.\r\n     * @param h  the height range.\r\n     */\r\n    public RectangleConstraint(double w, Range h) {\r\n        this(w, null, LengthConstraintType.FIXED, 0.0, h, LengthConstraintType.RANGE);\r\n    }\r\n\r\n    /**\r\n     * Creates a new constraint.\r\n     *\r\n     * @param w  the fixed or maximum width.\r\n     * @param widthRange  the width range.\r\n     * @param widthConstraintType  the width type.\r\n     * @param h  the fixed or maximum height.\r\n     * @param heightRange  the height range.\r\n     * @param heightConstraintType  the height type.\r\n     */\r\n    public RectangleConstraint(double w, Range widthRange, LengthConstraintType widthConstraintType, double h, Range heightRange, LengthConstraintType heightConstraintType) {\r\n        if (widthConstraintType == null) {\r\n            throw new IllegalArgumentException(\"Null 'widthType' argument.\");\r\n        }\r\n        if (heightConstraintType == null) {\r\n            throw new IllegalArgumentException(\"Null 'heightType' argument.\");\r\n        }\r\n        this.width = w;\r\n        this.widthRange = widthRange;\r\n        this.widthConstraintType = widthConstraintType;\r\n        this.height = h;\r\n        this.heightRange = heightRange;\r\n        this.heightConstraintType = heightConstraintType;\r\n    }\r\n\r\n    /**\r\n     * Returns the fixed width.\r\n     *\r\n     * @return The width.\r\n     */\r\n    public double getWidth() {\r\n        return this.width;\r\n    }\r\n\r\n    /**\r\n     * Returns the width range.\r\n     *\r\n     * @return The range (possibly <code>null</code>).\r\n     */\r\n    public Range getWidthRange() {\r\n        return this.widthRange;\r\n    }\r\n\r\n    /**\r\n     * Returns the constraint type.\r\n     *\r\n     * @return The constraint type (never <code>null</code>).\r\n     */\r\n    public LengthConstraintType getWidthConstraintType() {\r\n        return this.widthConstraintType;\r\n    }\r\n\r\n    /**\r\n     * Returns the fixed height.\r\n     *\r\n     * @return The height.\r\n     */\r\n    public double getHeight() {\r\n        return this.height;\r\n    }\r\n\r\n    /**\r\n     * Returns the width range.\r\n     *\r\n     * @return The range (possibly <code>null</code>).\r\n     */\r\n    public Range getHeightRange() {\r\n        return this.heightRange;\r\n    }\r\n\r\n    /**\r\n     * Returns the constraint type.\r\n     *\r\n     * @return The constraint type (never <code>null</code>).\r\n     */\r\n    public LengthConstraintType getHeightConstraintType() {\r\n        return this.heightConstraintType;\r\n    }\r\n\r\n    /**\r\n     * Returns a constraint that matches this one on the height attributes,\r\n     * but has no width constraint.\r\n     *\r\n     * @return A new constraint.\r\n     */\r\n    public RectangleConstraint toUnconstrainedWidth() {\r\n        if (this.widthConstraintType == LengthConstraintType.NONE) {\r\n            return this;\r\n        } else {\r\n            return new RectangleConstraint(this.width, this.widthRange, LengthConstraintType.NONE, this.height, this.heightRange, this.heightConstraintType);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a constraint that matches this one on the width attributes,\r\n     * but has no height constraint.\r\n     *\r\n     * @return A new constraint.\r\n     */\r\n    public RectangleConstraint toUnconstrainedHeight() {\r\n        if (this.heightConstraintType == LengthConstraintType.NONE) {\r\n            return this;\r\n        } else {\r\n            return new RectangleConstraint(this.width, this.widthRange, this.widthConstraintType, 0.0, this.heightRange, LengthConstraintType.NONE);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a constraint that matches this one on the height attributes,\r\n     * but has a fixed width constraint.\r\n     *\r\n     * @param width  the fixed width.\r\n     *\r\n     * @return A new constraint.\r\n     */\r\n    public RectangleConstraint toFixedWidth(double width) {\r\n        return new RectangleConstraint(width, this.widthRange, LengthConstraintType.FIXED, this.height, this.heightRange, this.heightConstraintType);\r\n    }\r\n\r\n    /**\r\n     * Returns a constraint that matches this one on the width attributes,\r\n     * but has a fixed height constraint.\r\n     *\r\n     * @param height  the fixed height.\r\n     *\r\n     * @return A new constraint.\r\n     */\r\n    public RectangleConstraint toFixedHeight(double height) {\r\n        return new RectangleConstraint(this.width, this.widthRange, this.widthConstraintType, height, this.heightRange, LengthConstraintType.FIXED);\r\n    }\r\n\r\n    /**\r\n     * Returns a constraint that matches this one on the height attributes,\r\n     * but has a range width constraint.\r\n     *\r\n     * @param range  the width range (<code>null</code> not permitted).\r\n     *\r\n     * @return A new constraint.\r\n     */\r\n    public RectangleConstraint toRangeWidth(Range range) {\r\n        if (range == null) {\r\n            throw new IllegalArgumentException(\"Null 'range' argument.\");\r\n        }\r\n        return new RectangleConstraint(range.getUpperBound(), range, LengthConstraintType.RANGE, this.height, this.heightRange, this.heightConstraintType);\r\n    }\r\n\r\n    /**\r\n     * Returns a constraint that matches this one on the width attributes,\r\n     * but has a range height constraint.\r\n     *\r\n     * @param range  the height range (<code>null</code> not permitted).\r\n     *\r\n     * @return A new constraint.\r\n     */\r\n    public RectangleConstraint toRangeHeight(Range range) {\r\n        if (range == null) {\r\n            throw new IllegalArgumentException(\"Null 'range' argument.\");\r\n        }\r\n        return new RectangleConstraint(this.width, this.widthRange, this.widthConstraintType, range.getUpperBound(), range, LengthConstraintType.RANGE);\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of this instance, mostly used for\r\n     * debugging purposes.\r\n     *\r\n     * @return A string.\r\n     */\r\n    public String toString() {\r\n        return \"RectangleConstraint[\" + this.widthConstraintType.toString() + \": width=\" + this.width + \", height=\" + this.height + \"]\";\r\n    }\r\n\r\n    /**\r\n     * Returns the new size that reflects the constraints defined by this\r\n     * instance.\r\n     *\r\n     * @param base  the base size.\r\n     *\r\n     * @return The constrained size.\r\n     */\r\n    public Size2D calculateConstrainedSize(Size2D base) {\r\n        Size2D result = new Size2D();\r\n        if (this.widthConstraintType == LengthConstraintType.NONE) {\r\n            result.width = base.width;\r\n            if (this.heightConstraintType == LengthConstraintType.NONE) {\r\n                result.height = base.height;\r\n            } else if (this.heightConstraintType == LengthConstraintType.RANGE) {\r\n                result.height = this.heightRange.constrain(base.height);\r\n            } else if (this.heightConstraintType == LengthConstraintType.FIXED) {\r\n                result.height = this.height;\r\n            }\r\n        } else if (this.widthConstraintType == LengthConstraintType.RANGE) {\r\n            result.width = this.widthRange.constrain(base.width);\r\n            if (this.heightConstraintType == LengthConstraintType.NONE) {\r\n                result.height = base.height;\r\n            } else if (this.heightConstraintType == LengthConstraintType.RANGE) {\r\n                result.height = this.heightRange.constrain(base.height);\r\n            } else if (this.heightConstraintType == LengthConstraintType.FIXED) {\r\n                result.height = this.height;\r\n            }\r\n        } else if (this.widthConstraintType == LengthConstraintType.FIXED) {\r\n            result.width = this.width;\r\n            if (this.heightConstraintType == LengthConstraintType.NONE) {\r\n                result.height = base.height;\r\n            } else if (this.heightConstraintType == LengthConstraintType.RANGE) {\r\n                result.height = this.heightRange.constrain(base.height);\r\n            } else if (this.heightConstraintType == LengthConstraintType.FIXED) {\r\n                result.height = this.height;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\n\n"], "content:parameter_class_constructors": ["public BlockContainer();", "public BlockContainer(Arrangement arrangement);", "public RectangleConstraint(Range w, Range h);", "public RectangleConstraint(double w, double h);", "public RectangleConstraint(double w, Range widthRange, LengthConstraintType widthConstraintType, double h, Range heightRange, LengthConstraintType heightConstraintType);", "public RectangleConstraint(Range w, double h);", "public RectangleConstraint(double w, Range h);"], "content:parameter_class_signature": ["org.jfree.chart.block#BlockContainer | add(Block) | setArrangement(Arrangement) | isEmpty() | draw(Graphics2D, Rectangle2D, Object) | BlockContainer() | BlockContainer(Arrangement) | clone() | clear() | getBlocks() | add(Block, Object) | arrange(Graphics2D, RectangleConstraint) | getArrangement() | draw(Graphics2D, Rectangle2D) | equals(Object)\n\n", "org.jfree.chart.block#RectangleConstraint | getHeightConstraintType() | calculateConstrainedSize(Size2D) | toFixedHeight(double) | getWidth() | toString() | RectangleConstraint(Range, Range) | getHeight() | toUnconstrainedHeight() | RectangleConstraint(double, double) | toFixedWidth(double) | getWidthRange() | toRangeWidth(Range) | getWidthConstraintType() | RectangleConstraint(double, Range, LengthConstraintType, double, Range, LengthConstraintType) | RectangleConstraint(Range, double) | getHeightRange() | toRangeHeight(Range) | RectangleConstraint(double, Range) | toUnconstrainedWidth()\n\n"], "content:parameter_list": ["BlockContainer container", "Graphics2D g2", "RectangleConstraint constraint"], "content:source_class_code_format": "public class BorderArrangement implements Arrangement, Serializable {\r\n\r\n    /**\r\n     * For serialization.\r\n     */\r\n    private static final long serialVersionUID = 506071142274883745L;\r\n\r\n    /**\r\n     * The block (if any) at the center of the layout.\r\n     */\r\n    private Block centerBlock;\r\n\r\n    /**\r\n     * The block (if any) at the top of the layout.\r\n     */\r\n    private Block topBlock;\r\n\r\n    /**\r\n     * The block (if any) at the bottom of the layout.\r\n     */\r\n    private Block bottomBlock;\r\n\r\n    /**\r\n     * The block (if any) at the left of the layout.\r\n     */\r\n    private Block leftBlock;\r\n\r\n    /**\r\n     * The block (if any) at the right of the layout.\r\n     */\r\n    private Block rightBlock;\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     */\r\n    public BorderArrangement() {\r\n    }\r\n\r\n    /**\r\n     * Adds a block to the arrangement manager at the specified edge.\r\n     *\r\n     * @param block  the block (<code>null</code> permitted).\r\n     * @param key  the edge (an instance of {@link RectangleEdge}) or\r\n     *             <code>null</code> for the center block.\r\n     */\r\n    public void add(Block block, Object key) {\r\n        if (key == null) {\r\n            this.centerBlock = block;\r\n        } else {\r\n            RectangleEdge edge = (RectangleEdge) key;\r\n            if (edge == RectangleEdge.TOP) {\r\n                this.topBlock = block;\r\n            } else if (edge == RectangleEdge.BOTTOM) {\r\n                this.bottomBlock = block;\r\n            } else if (edge == RectangleEdge.LEFT) {\r\n                this.leftBlock = block;\r\n            } else if (edge == RectangleEdge.RIGHT) {\r\n                this.rightBlock = block;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Arranges the items in the specified container, subject to the given\r\n     * constraint.\r\n     *\r\n     * @param container  the container.\r\n     * @param g2  the graphics device.\r\n     * @param constraint  the constraint.\r\n     *\r\n     * @return The block size.\r\n     */\r\n    public Size2D arrange(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) {\r\n        RectangleConstraint contentConstraint = container.toContentConstraint(constraint);\r\n        Size2D contentSize = null;\r\n        LengthConstraintType w = contentConstraint.getWidthConstraintType();\r\n        LengthConstraintType h = contentConstraint.getHeightConstraintType();\r\n        if (w == LengthConstraintType.NONE) {\r\n            if (h == LengthConstraintType.NONE) {\r\n                contentSize = arrangeNN(container, g2);\r\n            } else if (h == LengthConstraintType.FIXED) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            } else if (h == LengthConstraintType.RANGE) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            }\r\n        } else if (w == LengthConstraintType.FIXED) {\r\n            if (h == LengthConstraintType.NONE) {\r\n                contentSize = arrangeFN(container, g2, constraint.getWidth());\r\n            } else if (h == LengthConstraintType.FIXED) {\r\n                contentSize = arrangeFF(container, g2, constraint);\r\n            } else if (h == LengthConstraintType.RANGE) {\r\n                contentSize = arrangeFR(container, g2, constraint);\r\n            }\r\n        } else if (w == LengthConstraintType.RANGE) {\r\n            if (h == LengthConstraintType.NONE) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            } else if (h == LengthConstraintType.FIXED) {\r\n                throw new RuntimeException(\"Not implemented.\");\r\n            } else if (h == LengthConstraintType.RANGE) {\r\n                contentSize = arrangeRR(container, constraint.getWidthRange(), constraint.getHeightRange(), g2);\r\n            }\r\n        }\r\n        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()), container.calculateTotalHeight(contentSize.getHeight()));\r\n    }\r\n\r\n    /**\r\n     * Performs an arrangement without constraints.\r\n     *\r\n     * @param container  the container.\r\n     * @param g2  the graphics device.\r\n     *\r\n     * @return The container size after the arrangement.\r\n     */\r\n    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        if (this.topBlock != null) {\r\n            Size2D size = this.topBlock.arrange(g2, RectangleConstraint.NONE);\r\n            w[0] = size.width;\r\n            h[0] = size.height;\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            Size2D size = this.bottomBlock.arrange(g2, RectangleConstraint.NONE);\r\n            w[1] = size.width;\r\n            h[1] = size.height;\r\n        }\r\n        if (this.leftBlock != null) {\r\n            Size2D size = this.leftBlock.arrange(g2, RectangleConstraint.NONE);\r\n            w[2] = size.width;\r\n            h[2] = size.height;\r\n        }\r\n        if (this.rightBlock != null) {\r\n            Size2D size = this.rightBlock.arrange(g2, RectangleConstraint.NONE);\r\n            w[3] = size.width;\r\n            h[3] = size.height;\r\n        }\r\n        h[2] = Math.max(h[2], h[3]);\r\n        h[3] = h[2];\r\n        if (this.centerBlock != null) {\r\n            Size2D size = this.centerBlock.arrange(g2, RectangleConstraint.NONE);\r\n            w[4] = size.width;\r\n            h[4] = size.height;\r\n        }\r\n        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\r\n        double centerHeight = Math.max(h[2], Math.max(h[3], h[4]));\r\n        double height = h[0] + h[1] + centerHeight;\r\n        if (this.topBlock != null) {\r\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width, h[0]));\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, height - h[1], width, h[1]));\r\n        }\r\n        if (this.leftBlock != null) {\r\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], centerHeight));\r\n        }\r\n        if (this.rightBlock != null) {\r\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3], h[0], w[3], centerHeight));\r\n        }\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], width - w[2] - w[3], centerHeight));\r\n        }\r\n        return new Size2D(width, height);\r\n    }\r\n\r\n    /**\r\n     * Performs an arrangement with a fixed width and a range for the height.\r\n     *\r\n     * @param container  the container.\r\n     * @param g2  the graphics device.\r\n     * @param constraint  the constraint.\r\n     *\r\n     * @return The container size after the arrangement.\r\n     */\r\n    protected Size2D arrangeFR(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) {\r\n        Size2D size1 = arrangeFN(container, g2, constraint.getWidth());\r\n        if (constraint.getHeightRange().contains(size1.getHeight())) {\r\n            return size1;\r\n        } else {\r\n            double h = constraint.getHeightRange().constrain(size1.getHeight());\r\n            RectangleConstraint c2 = constraint.toFixedHeight(h);\r\n            return arrange(container, g2, c2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Arranges the container width a fixed width and no constraint on the\r\n     * height.\r\n     *\r\n     * @param container  the container.\r\n     * @param g2  the graphics device.\r\n     * @param width  the fixed width.\r\n     *\r\n     * @return The container size after arranging the contents.\r\n     */\r\n    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2, double width) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        RectangleConstraint c1 = new RectangleConstraint(width, null, LengthConstraintType.FIXED, 0.0, null, LengthConstraintType.NONE);\r\n        if (this.topBlock != null) {\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            w[0] = size.width;\r\n            h[0] = size.height;\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            Size2D size = this.bottomBlock.arrange(g2, c1);\r\n            w[1] = size.width;\r\n            h[1] = size.height;\r\n        }\r\n        RectangleConstraint c2 = new RectangleConstraint(0.0, new Range(0.0, width), LengthConstraintType.RANGE, 0.0, null, LengthConstraintType.NONE);\r\n        if (this.leftBlock != null) {\r\n            Size2D size = this.leftBlock.arrange(g2, c2);\r\n            w[2] = size.width;\r\n            h[2] = size.height;\r\n        }\r\n        if (this.rightBlock != null) {\r\n            double maxW = Math.max(width - w[2], 0.0);\r\n            RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(Math.min(w[2], maxW), maxW), LengthConstraintType.RANGE, 0.0, null, LengthConstraintType.NONE);\r\n            Size2D size = this.rightBlock.arrange(g2, c3);\r\n            w[3] = size.width;\r\n            h[3] = size.height;\r\n        }\r\n        h[2] = Math.max(h[2], h[3]);\r\n        h[3] = h[2];\r\n        if (this.centerBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(width - w[2] - w[3], null, LengthConstraintType.FIXED, 0.0, null, LengthConstraintType.NONE);\r\n            Size2D size = this.centerBlock.arrange(g2, c4);\r\n            w[4] = size.width;\r\n            h[4] = size.height;\r\n        }\r\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\r\n        return arrange(container, g2, new RectangleConstraint(width, height));\r\n    }\r\n\r\n    /**\r\n     * Performs an arrangement with range constraints on both the vertical\r\n     * and horizontal sides.\r\n     *\r\n     * @param container  the container.\r\n     * @param widthRange  the allowable range for the container width.\r\n     * @param heightRange  the allowable range for the container height.\r\n     * @param g2  the graphics device.\r\n     *\r\n     * @return The container size.\r\n     */\r\n    protected Size2D arrangeRR(BlockContainer container, Range widthRange, Range heightRange, Graphics2D g2) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        if (this.topBlock != null) {\r\n            RectangleConstraint c1 = new RectangleConstraint(widthRange, heightRange);\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            w[0] = size.width;\r\n            h[0] = size.height;\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            Range heightRange2 = Range.shift(heightRange, -h[0], false);\r\n            RectangleConstraint c2 = new RectangleConstraint(widthRange, heightRange2);\r\n            Size2D size = this.bottomBlock.arrange(g2, c2);\r\n            w[1] = size.width;\r\n            h[1] = size.height;\r\n        }\r\n        Range heightRange3 = Range.shift(heightRange, -(h[0] + h[1]));\r\n        if (this.leftBlock != null) {\r\n            RectangleConstraint c3 = new RectangleConstraint(widthRange, heightRange3);\r\n            Size2D size = this.leftBlock.arrange(g2, c3);\r\n            w[2] = size.width;\r\n            h[2] = size.height;\r\n        }\r\n        Range widthRange2 = Range.shift(widthRange, -w[2], false);\r\n        if (this.rightBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(widthRange2, heightRange3);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\r\n            h[3] = size.height;\r\n        }\r\n        h[2] = Math.max(h[2], h[3]);\r\n        h[3] = h[2];\r\n        Range widthRange3 = Range.shift(widthRange, -(w[2] + w[3]), false);\r\n        if (this.centerBlock != null) {\r\n            RectangleConstraint c5 = new RectangleConstraint(widthRange3, heightRange3);\r\n            // TODO:  the width and height ranges should be reduced by the\r\n            // height required for the top and bottom, and the width required\r\n            // by the left and right\r\n            Size2D size = this.centerBlock.arrange(g2, c5);\r\n            w[4] = size.width;\r\n            h[4] = size.height;\r\n        }\r\n        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\r\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\r\n        if (this.topBlock != null) {\r\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width, h[0]));\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, height - h[1], width, h[1]));\r\n        }\r\n        if (this.leftBlock != null) {\r\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2]));\r\n        }\r\n        if (this.rightBlock != null) {\r\n            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3], h[0], w[3], h[3]));\r\n        }\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], width - w[2] - w[3], height - h[0] - h[1]));\r\n        }\r\n        return new Size2D(width, height);\r\n    }\r\n\r\n    /**\r\n     * Arranges the items within a container.\r\n     *\r\n     * @param container  the container.\r\n     * @param constraint  the constraint.\r\n     * @param g2  the graphics device.\r\n     *\r\n     * @return The container size after the arrangement.\r\n     */\r\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) {\r\n        double[] w = new double[5];\r\n        double[] h = new double[5];\r\n        w[0] = constraint.getWidth();\r\n        if (this.topBlock != null) {\r\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE);\r\n            Size2D size = this.topBlock.arrange(g2, c1);\r\n            h[0] = size.height;\r\n        }\r\n        w[1] = w[0];\r\n        if (this.bottomBlock != null) {\r\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\r\n            Size2D size = this.bottomBlock.arrange(g2, c2);\r\n            h[1] = size.height;\r\n        }\r\n        h[2] = constraint.getHeight() - h[1] - h[0];\r\n        if (this.leftBlock != null) {\r\n            RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED);\r\n            Size2D size = this.leftBlock.arrange(g2, c3);\r\n            w[2] = size.width;\r\n        }\r\n        h[3] = h[2];\r\n        if (this.rightBlock != null) {\r\n            RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED);\r\n            Size2D size = this.rightBlock.arrange(g2, c4);\r\n            w[3] = size.width;\r\n        }\r\n        h[4] = h[2];\r\n        w[4] = constraint.getWidth() - w[3] - w[2];\r\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.arrange(g2, c5);\r\n        }\r\n        if (this.topBlock != null) {\r\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0]));\r\n        }\r\n        if (this.bottomBlock != null) {\r\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1]));\r\n        }\r\n        if (this.leftBlock != null) {\r\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2]));\r\n        }\r\n        if (this.rightBlock != null) {\r\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3]));\r\n        }\r\n        if (this.centerBlock != null) {\r\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4]));\r\n        }\r\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\r\n    }\r\n\r\n    /**\r\n     * Clears the layout.\r\n     */\r\n    public void clear() {\r\n        this.centerBlock = null;\r\n        this.topBlock = null;\r\n        this.bottomBlock = null;\r\n        this.leftBlock = null;\r\n        this.rightBlock = null;\r\n    }\r\n\r\n    /**\r\n     * Tests this arrangement for equality with an arbitrary object.\r\n     *\r\n     * @param obj  the object (<code>null</code> permitted).\r\n     *\r\n     * @return A boolean.\r\n     */\r\n    public boolean equals(Object obj) {\r\n        if (obj == this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof BorderArrangement)) {\r\n            return false;\r\n        }\r\n        BorderArrangement that = (BorderArrangement) obj;\r\n        if (!ObjectUtilities.equal(this.topBlock, that.topBlock)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.bottomBlock, that.bottomBlock)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.leftBlock, that.leftBlock)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.rightBlock, that.rightBlock)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.centerBlock, that.centerBlock)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}", "content:source_class_code_imports": ["import java.awt.Graphics2D;", "import java.awt.geom.Rectangle2D;", "import java.io.Serializable;", "import org.jfree.chart.util.ObjectUtilities;", "import org.jfree.chart.util.RectangleEdge;", "import org.jfree.chart.util.Size2D;", "import org.jfree.data.Range;"], "content:source_class_code_path": "D:\\try\\ut4\\d4j_fixed_projects\\Chart_13_fixed\\source\\org\\jfree\\chart\\block\\BorderArrangement.java", "content:source_class_code_signature": "org.jfree.chart.block#BorderArrangement | BorderArrangement() | add(Block, Object) | clear() | equals(Object) | arrange(BlockContainer, Graphics2D, RectangleConstraint)", "content:source_class_constructors": ["public BorderArrangement();"], "content:source_class_define": "public class BorderArrangement implements Arrangement, Serializable;", "content:source_class_name": "BorderArrangement", "errorList": [], "extra:language": "Java", "extra:project_name": "Chart_13_fixed", "rowKey": "d00ebca5753683275a7442cdba6ab664", "source:source_method_code_format": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) {\r\n    double[] w = new double[5];\r\n    double[] h = new double[5];\r\n    w[0] = constraint.getWidth();\r\n    if (this.topBlock != null) {\r\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE);\r\n        Size2D size = this.topBlock.arrange(g2, c1);\r\n        h[0] = size.height;\r\n    }\r\n    w[1] = w[0];\r\n    if (this.bottomBlock != null) {\r\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\r\n        Size2D size = this.bottomBlock.arrange(g2, c2);\r\n        h[1] = size.height;\r\n    }\r\n    h[2] = constraint.getHeight() - h[1] - h[0];\r\n    if (this.leftBlock != null) {\r\n        RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED);\r\n        Size2D size = this.leftBlock.arrange(g2, c3);\r\n        w[2] = size.width;\r\n    }\r\n    h[3] = h[2];\r\n    if (this.rightBlock != null) {\r\n        RectangleConstraint c4 = new RectangleConstraint(0.0, new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED);\r\n        Size2D size = this.rightBlock.arrange(g2, c4);\r\n        w[3] = size.width;\r\n    }\r\n    h[4] = h[2];\r\n    w[4] = constraint.getWidth() - w[3] - w[2];\r\n    RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\r\n    if (this.centerBlock != null) {\r\n        this.centerBlock.arrange(g2, c5);\r\n    }\r\n    if (this.topBlock != null) {\r\n        this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0]));\r\n    }\r\n    if (this.bottomBlock != null) {\r\n        this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1]));\r\n    }\r\n    if (this.leftBlock != null) {\r\n        this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2]));\r\n    }\r\n    if (this.rightBlock != null) {\r\n        this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3]));\r\n    }\r\n    if (this.centerBlock != null) {\r\n        this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4]));\r\n    }\r\n    return new Size2D(constraint.getWidth(), constraint.getHeight());\r\n}", "source:source_method_comment": "/**\r\n * Arranges the items within a container.\r\n *\r\n * @param container  the container.\r\n * @param constraint  the constraint.\r\n * @param g2  the graphics device.\r\n *\r\n * @return The container size after the arrangement.\r\n */\r\n <innerComment> ", "source:source_method_name": "arrangeFF", "source:source_method_return_type_class_constructors": ["public Size2D();", "public Size2D(double width, double height);"], "source:source_method_signature": "org.jfree.chart.block#BorderArrangement#arrangeFF(org.jfree.chart.block#BlockContainer, java.awt#Graphics2D, org.jfree.chart.block#RectangleConstraint)", "source:source_other_method_signature": ["protected Size2D arrangeRR(BlockContainer container, Range widthRange, Range heightRange, Graphics2D g2);", "public BorderArrangement();", "protected Size2D arrangeFR(BlockContainer container, Graphics2D g2, RectangleConstraint constraint);", "public void add(Block block, Object key);", "protected Size2D arrangeNN(BlockContainer container, Graphics2D g2);", "public void clear();", "public boolean equals(Object obj);", "public Size2D arrange(BlockContainer container, Graphics2D g2, RectangleConstraint constraint);", "protected Size2D arrangeFN(BlockContainer container, Graphics2D g2, double width);"], "sourceMethodExistNonEn": "false", "testMethodCodeFormat": [], "testMethodExistNonEn": [], "testMethodSignature": [], "bytecode_signature": "org.jfree.chart.block.BorderArrangement.arrangeFF(Lorg/jfree/chart/block/BlockContainer;Ljava/awt/Graphics2D;Lorg/jfree/chart/block/RectangleConstraint;)Lorg/jfree/chart/util/Size2D;"}
{"content:callee_code": ["public boolean removeRangeMarker(Marker marker, Layer layer) {\r\n    return removeRangeMarker(0, marker, layer);\r\n}"], "content:callee_signature": ["org.jfree.chart.plot#XYPlot#removeRangeMarker(org.jfree.chart.plot#Marker, org.jfree.chart.util#Layer)"], "content:parameter_class_code": ["public abstract class Marker implements Cloneable, Serializable {\r\n\r\n    /**\r\n     * For serialization.\r\n     */\r\n    private static final long serialVersionUID = -734389651405327166L;\r\n\r\n    /**\r\n     * The paint.\r\n     */\r\n    private transient Paint paint;\r\n\r\n    /**\r\n     * The stroke.\r\n     */\r\n    private transient Stroke stroke;\r\n\r\n    /**\r\n     * The outline paint.\r\n     */\r\n    private transient Paint outlinePaint;\r\n\r\n    /**\r\n     * The outline stroke.\r\n     */\r\n    private transient Stroke outlineStroke;\r\n\r\n    /**\r\n     * The alpha transparency.\r\n     */\r\n    private float alpha;\r\n\r\n    /**\r\n     * The label.\r\n     */\r\n    private String label = null;\r\n\r\n    /**\r\n     * The label font.\r\n     */\r\n    private Font labelFont;\r\n\r\n    /**\r\n     * The label paint.\r\n     */\r\n    private transient Paint labelPaint;\r\n\r\n    /**\r\n     * The label position.\r\n     */\r\n    private RectangleAnchor labelAnchor;\r\n\r\n    /**\r\n     * The text anchor for the label.\r\n     */\r\n    private TextAnchor labelTextAnchor;\r\n\r\n    /**\r\n     * The label offset from the marker rectangle.\r\n     */\r\n    private RectangleInsets labelOffset;\r\n\r\n    /**\r\n     * The offset type for the domain or range axis (never <code>null</code>).\r\n     */\r\n    private LengthAdjustmentType labelOffsetType;\r\n\r\n    /**\r\n     * Storage for registered change listeners.\r\n     */\r\n    private transient EventListenerList listenerList;\r\n\r\n    /**\r\n     * Creates a new marker with default attributes.\r\n     */\r\n    protected Marker() {\r\n        this(Color.gray);\r\n    }\r\n\r\n    /**\r\n     * Constructs a new marker.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     */\r\n    protected Marker(Paint paint) {\r\n        this(paint, new BasicStroke(0.5f), Color.gray, new BasicStroke(0.5f), 0.80f);\r\n    }\r\n\r\n    /**\r\n     * Constructs a new marker.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     * @param stroke  the stroke (<code>null</code> not permitted).\r\n     * @param outlinePaint  the outline paint (<code>null</code> permitted).\r\n     * @param outlineStroke  the outline stroke (<code>null</code> permitted).\r\n     * @param alpha  the alpha transparency (must be in the range 0.0f to\r\n     *     1.0f).\r\n     *\r\n     * @throws IllegalArgumentException if <code>paint</code> or\r\n     *     <code>stroke</code> is <code>null</code>, or <code>alpha</code> is\r\n     *     not in the specified range.\r\n     */\r\n    protected Marker(Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        if (alpha < 0.0f || alpha > 1.0f)\r\n            throw new IllegalArgumentException(\"The 'alpha' value must be in the range 0.0f to 1.0f\");\r\n        this.paint = paint;\r\n        this.stroke = stroke;\r\n        this.outlinePaint = outlinePaint;\r\n        this.outlineStroke = outlineStroke;\r\n        this.alpha = alpha;\r\n        this.labelFont = new Font(\"SansSerif\", Font.PLAIN, 9);\r\n        this.labelPaint = Color.black;\r\n        this.labelAnchor = RectangleAnchor.TOP_LEFT;\r\n        this.labelOffset = new RectangleInsets(3.0, 3.0, 3.0, 3.0);\r\n        this.labelOffsetType = LengthAdjustmentType.CONTRACT;\r\n        this.labelTextAnchor = TextAnchor.CENTER;\r\n        this.listenerList = new EventListenerList();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint.\r\n     *\r\n     * @return The paint (never <code>null</code>).\r\n     *\r\n     * @see #setPaint(Paint)\r\n     */\r\n    public Paint getPaint() {\r\n        return this.paint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint and sends a {@link MarkerChangeEvent} to all registered\r\n     * listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     *\r\n     * @see #getPaint()\r\n     */\r\n    public void setPaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.paint = paint;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the stroke.\r\n     *\r\n     * @return The stroke (never <code>null</code>).\r\n     *\r\n     * @see #setStroke(Stroke)\r\n     */\r\n    public Stroke getStroke() {\r\n        return this.stroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the stroke and sends a {@link MarkerChangeEvent} to all registered\r\n     * listeners.\r\n     *\r\n     * @param stroke  the stroke (<code>null</code> not permitted).\r\n     *\r\n     * @see #getStroke()\r\n     */\r\n    public void setStroke(Stroke stroke) {\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        this.stroke = stroke;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the outline paint.\r\n     *\r\n     * @return The outline paint (possibly <code>null</code>).\r\n     *\r\n     * @see #setOutlinePaint(Paint)\r\n     */\r\n    public Paint getOutlinePaint() {\r\n        return this.outlinePaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the outline paint and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> permitted).\r\n     *\r\n     * @see #getOutlinePaint()\r\n     */\r\n    public void setOutlinePaint(Paint paint) {\r\n        this.outlinePaint = paint;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the outline stroke.\r\n     *\r\n     * @return The outline stroke (possibly <code>null</code>).\r\n     *\r\n     * @see #setOutlineStroke(Stroke)\r\n     */\r\n    public Stroke getOutlineStroke() {\r\n        return this.outlineStroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the outline stroke and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param stroke  the stroke (<code>null</code> permitted).\r\n     *\r\n     * @see #getOutlineStroke()\r\n     */\r\n    public void setOutlineStroke(Stroke stroke) {\r\n        this.outlineStroke = stroke;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the alpha transparency.\r\n     *\r\n     * @return The alpha transparency.\r\n     *\r\n     * @see #setAlpha(float)\r\n     */\r\n    public float getAlpha() {\r\n        return this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Sets the alpha transparency that should be used when drawing the\r\n     * marker, and sends a {@link MarkerChangeEvent} to all registered\r\n     * listeners.  The alpha transparency is a value in the range 0.0f\r\n     * (completely transparent) to 1.0f (completely opaque).\r\n     *\r\n     * @param alpha  the alpha transparency (must be in the range 0.0f to\r\n     *     1.0f).\r\n     *\r\n     * @throws IllegalArgumentException if <code>alpha</code> is not in the\r\n     *     specified range.\r\n     *\r\n     * @see #getAlpha()\r\n     */\r\n    public void setAlpha(float alpha) {\r\n        if (alpha < 0.0f || alpha > 1.0f)\r\n            throw new IllegalArgumentException(\"The 'alpha' value must be in the range 0.0f to 1.0f\");\r\n        this.alpha = alpha;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label (if <code>null</code> no label is displayed).\r\n     *\r\n     * @return The label (possibly <code>null</code>).\r\n     *\r\n     * @see #setLabel(String)\r\n     */\r\n    public String getLabel() {\r\n        return this.label;\r\n    }\r\n\r\n    /**\r\n     * Sets the label (if <code>null</code> no label is displayed) and sends a\r\n     * {@link MarkerChangeEvent} to all registered listeners.\r\n     *\r\n     * @param label  the label (<code>null</code> permitted).\r\n     *\r\n     * @see #getLabel()\r\n     */\r\n    public void setLabel(String label) {\r\n        this.label = label;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label font.\r\n     *\r\n     * @return The label font (never <code>null</code>).\r\n     *\r\n     * @see #setLabelFont(Font)\r\n     */\r\n    public Font getLabelFont() {\r\n        return this.labelFont;\r\n    }\r\n\r\n    /**\r\n     * Sets the label font and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param font  the font (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelFont()\r\n     */\r\n    public void setLabelFont(Font font) {\r\n        if (font == null) {\r\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\r\n        }\r\n        this.labelFont = font;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label paint.\r\n     *\r\n     * @return The label paint (never </code>null</code>).\r\n     *\r\n     * @see #setLabelPaint(Paint)\r\n     */\r\n    public Paint getLabelPaint() {\r\n        return this.labelPaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the label paint and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelPaint()\r\n     */\r\n    public void setLabelPaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.labelPaint = paint;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label anchor.  This defines the position of the label\r\n     * anchor, relative to the bounds of the marker.\r\n     *\r\n     * @return The label anchor (never <code>null</code>).\r\n     *\r\n     * @see #setLabelAnchor(RectangleAnchor)\r\n     */\r\n    public RectangleAnchor getLabelAnchor() {\r\n        return this.labelAnchor;\r\n    }\r\n\r\n    /**\r\n     * Sets the label anchor and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.  The anchor defines the position of the label\r\n     * anchor, relative to the bounds of the marker.\r\n     *\r\n     * @param anchor  the anchor (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelAnchor()\r\n     */\r\n    public void setLabelAnchor(RectangleAnchor anchor) {\r\n        if (anchor == null) {\r\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\r\n        }\r\n        this.labelAnchor = anchor;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label offset.\r\n     *\r\n     * @return The label offset (never <code>null</code>).\r\n     *\r\n     * @see #setLabelOffset(RectangleInsets)\r\n     */\r\n    public RectangleInsets getLabelOffset() {\r\n        return this.labelOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the label offset and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param offset  the label offset (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelOffset()\r\n     */\r\n    public void setLabelOffset(RectangleInsets offset) {\r\n        if (offset == null) {\r\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\r\n        }\r\n        this.labelOffset = offset;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label offset type.\r\n     *\r\n     * @return The type (never <code>null</code>).\r\n     *\r\n     * @see #setLabelOffsetType(LengthAdjustmentType)\r\n     */\r\n    public LengthAdjustmentType getLabelOffsetType() {\r\n        return this.labelOffsetType;\r\n    }\r\n\r\n    /**\r\n     * Sets the label offset type and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param adj  the type (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelOffsetType()\r\n     */\r\n    public void setLabelOffsetType(LengthAdjustmentType adj) {\r\n        if (adj == null) {\r\n            throw new IllegalArgumentException(\"Null 'adj' argument.\");\r\n        }\r\n        this.labelOffsetType = adj;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label text anchor.\r\n     *\r\n     * @return The label text anchor (never <code>null</code>).\r\n     *\r\n     * @see #setLabelTextAnchor(TextAnchor)\r\n     */\r\n    public TextAnchor getLabelTextAnchor() {\r\n        return this.labelTextAnchor;\r\n    }\r\n\r\n    /**\r\n     * Sets the label text anchor and sends a {@link MarkerChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param anchor  the label text anchor (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelTextAnchor()\r\n     */\r\n    public void setLabelTextAnchor(TextAnchor anchor) {\r\n        if (anchor == null) {\r\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\r\n        }\r\n        this.labelTextAnchor = anchor;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Registers an object for notification of changes to the marker.\r\n     *\r\n     * @param listener  the object to be registered.\r\n     *\r\n     * @see #removeChangeListener(MarkerChangeListener)\r\n     *\r\n     * @since 1.0.3\r\n     */\r\n    public void addChangeListener(MarkerChangeListener listener) {\r\n        this.listenerList.add(MarkerChangeListener.class, listener);\r\n    }\r\n\r\n    /**\r\n     * Unregisters an object for notification of changes to the marker.\r\n     *\r\n     * @param listener  the object to be unregistered.\r\n     *\r\n     * @see #addChangeListener(MarkerChangeListener)\r\n     *\r\n     * @since 1.0.3\r\n     */\r\n    public void removeChangeListener(MarkerChangeListener listener) {\r\n        this.listenerList.remove(MarkerChangeListener.class, listener);\r\n    }\r\n\r\n    /**\r\n     * Notifies all registered listeners that the marker has been modified.\r\n     *\r\n     * @param event  information about the change event.\r\n     *\r\n     * @since 1.0.3\r\n     */\r\n    public void notifyListeners(MarkerChangeEvent event) {\r\n        Object[] listeners = this.listenerList.getListenerList();\r\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\r\n            if (listeners[i] == MarkerChangeListener.class) {\r\n                ((MarkerChangeListener) listeners[i + 1]).markerChanged(event);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing all the listeners of the specified type.\r\n     *\r\n     * @param listenerType  the listener type.\r\n     *\r\n     * @return The array of listeners.\r\n     *\r\n     * @since 1.0.3\r\n     */\r\n    public EventListener[] getListeners(Class listenerType) {\r\n        return this.listenerList.getListeners(listenerType);\r\n    }\r\n\r\n    /**\r\n     * Tests the marker for equality with an arbitrary object.\r\n     *\r\n     * @param obj  the object (<code>null</code> permitted).\r\n     *\r\n     * @return A boolean.\r\n     */\r\n    public boolean equals(Object obj) {\r\n        if (obj == this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof Marker)) {\r\n            return false;\r\n        }\r\n        Marker that = (Marker) obj;\r\n        if (!PaintUtilities.equal(this.paint, that.paint)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.stroke, that.stroke)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.outlinePaint, that.outlinePaint)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.outlineStroke, that.outlineStroke)) {\r\n            return false;\r\n        }\r\n        if (this.alpha != that.alpha) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.label, that.label)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {\r\n            return false;\r\n        }\r\n        if (this.labelAnchor != that.labelAnchor) {\r\n            return false;\r\n        }\r\n        if (this.labelTextAnchor != that.labelTextAnchor) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.labelOffset, that.labelOffset)) {\r\n            return false;\r\n        }\r\n        if (!this.labelOffsetType.equals(that.labelOffsetType)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the marker.\r\n     *\r\n     * @return A clone.\r\n     *\r\n     * @throws CloneNotSupportedException never.\r\n     */\r\n    public Object clone() throws CloneNotSupportedException {\r\n        return super.clone();\r\n    }\r\n\r\n    /**\r\n     * Provides serialization support.\r\n     *\r\n     * @param stream  the output stream.\r\n     *\r\n     * @throws IOException  if there is an I/O error.\r\n     */\r\n    private void writeObject(ObjectOutputStream stream) throws IOException {\r\n        stream.defaultWriteObject();\r\n        SerialUtilities.writePaint(this.paint, stream);\r\n        SerialUtilities.writeStroke(this.stroke, stream);\r\n        SerialUtilities.writePaint(this.outlinePaint, stream);\r\n        SerialUtilities.writeStroke(this.outlineStroke, stream);\r\n        SerialUtilities.writePaint(this.labelPaint, stream);\r\n    }\r\n\r\n    /**\r\n     * Provides serialization support.\r\n     *\r\n     * @param stream  the input stream.\r\n     *\r\n     * @throws IOException  if there is an I/O error.\r\n     * @throws ClassNotFoundException  if there is a classpath problem.\r\n     */\r\n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\r\n        stream.defaultReadObject();\r\n        this.paint = SerialUtilities.readPaint(stream);\r\n        this.stroke = SerialUtilities.readStroke(stream);\r\n        this.outlinePaint = SerialUtilities.readPaint(stream);\r\n        this.outlineStroke = SerialUtilities.readStroke(stream);\r\n        this.labelPaint = SerialUtilities.readPaint(stream);\r\n        this.listenerList = new EventListenerList();\r\n    }\r\n}\n\n"], "content:parameter_class_constructors": ["public ValueMarker(double value); | public ValueMarker(double value, Paint paint, Stroke stroke); | public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha); | public IntervalMarker(double start, double end); | public IntervalMarker(double start, double end, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha); | public CategoryMarker(Comparable key, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha); | public CategoryMarker(Comparable key, Paint paint, Stroke stroke); | public CategoryMarker(Comparable key);"], "content:parameter_class_signature": ["org.jfree.chart.plot#Marker | getStroke() | setLabelAnchor(RectangleAnchor) | getLabel() | setLabel(String) | clone() | getLabelFont() | getPaint() | setLabelFont(Font) | setLabelTextAnchor(TextAnchor) | addChangeListener(MarkerChangeListener) | setOutlineStroke(Stroke) | getLabelTextAnchor() | getOutlineStroke() | notifyListeners(MarkerChangeEvent) | setOutlinePaint(Paint) | setLabelPaint(Paint) | getLabelPaint() | getLabelOffset() | equals(Object) | setStroke(Stroke) | setLabelOffset(RectangleInsets) | setLabelOffsetType(LengthAdjustmentType) | getLabelOffsetType() | setPaint(Paint) | getAlpha() | getLabelAnchor() | removeChangeListener(MarkerChangeListener) | getListeners(Class) | getOutlinePaint() | setAlpha(float)\n\n:public class ValueMarker extends Marker;#org.jfree.chart.plot#ValueMarker | ValueMarker(double) | setValue(double) | ValueMarker(double, Paint, Stroke) | ValueMarker(double, Paint, Stroke, Paint, Stroke, float) | equals(Object) | getValue()\n\npublic class IntervalMarker extends Marker implements Cloneable, Serializable;#org.jfree.chart.plot#IntervalMarker | getGradientPaintTransformer() | getStartValue() | getEndValue() | equals(Object) | IntervalMarker(double, double) | setStartValue(double) | setGradientPaintTransformer(GradientPaintTransformer) | setEndValue(double) | IntervalMarker(double, double, Paint, Stroke, Paint, Stroke, float) | clone()\n\npublic class CategoryMarker extends Marker implements Cloneable, Serializable;#org.jfree.chart.plot#CategoryMarker | getKey() | CategoryMarker(Comparable, Paint, Stroke, Paint, Stroke, float) | getDrawAsLine() | setDrawAsLine(boolean) | CategoryMarker(Comparable, Paint, Stroke) | equals(Object) | setKey(Comparable) | CategoryMarker(Comparable)\n\n"], "content:parameter_list": ["Marker marker"], "content:source_class_code_format": "public class XYPlot extends Plot implements ValueAxisPlot, Zoomable, RendererChangeListener, Cloneable, PublicCloneable, Serializable {\r\n\r\n    /**\r\n     * For serialization.\r\n     */\r\n    private static final long serialVersionUID = 7044148245716569264L;\r\n\r\n    /**\r\n     * The default grid line stroke.\r\n     */\r\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] { 2.0f, 2.0f }, 0.0f);\r\n\r\n    /**\r\n     * The default grid line paint.\r\n     */\r\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\r\n\r\n    /**\r\n     * The default crosshair visibility.\r\n     */\r\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\r\n\r\n    /**\r\n     * The default crosshair stroke.\r\n     */\r\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE;\r\n\r\n    /**\r\n     * The default crosshair paint.\r\n     */\r\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\r\n\r\n    /**\r\n     * The resourceBundle for the localization.\r\n     */\r\n    protected static ResourceBundle localizationResources = ResourceBundle.getBundle(\"org.jfree.chart.plot.LocalizationBundle\");\r\n\r\n    /**\r\n     * The plot orientation.\r\n     */\r\n    private PlotOrientation orientation;\r\n\r\n    /**\r\n     * The offset between the data area and the axes.\r\n     */\r\n    private RectangleInsets axisOffset;\r\n\r\n    /**\r\n     * The domain axis / axes (used for the x-values).\r\n     */\r\n    private ObjectList domainAxes;\r\n\r\n    /**\r\n     * The domain axis locations.\r\n     */\r\n    private ObjectList domainAxisLocations;\r\n\r\n    /**\r\n     * The range axis (used for the y-values).\r\n     */\r\n    private ObjectList rangeAxes;\r\n\r\n    /**\r\n     * The range axis location.\r\n     */\r\n    private ObjectList rangeAxisLocations;\r\n\r\n    /**\r\n     * Storage for the datasets.\r\n     */\r\n    private ObjectList datasets;\r\n\r\n    /**\r\n     * Storage for the renderers.\r\n     */\r\n    private ObjectList renderers;\r\n\r\n    /**\r\n     * Storage for keys that map datasets/renderers to domain axes.  If the\r\n     * map contains no entry for a dataset, it is assumed to map to the\r\n     * primary domain axis (index = 0).\r\n     */\r\n    private Map datasetToDomainAxisMap;\r\n\r\n    /**\r\n     * Storage for keys that map datasets/renderers to range axes. If the\r\n     * map contains no entry for a dataset, it is assumed to map to the\r\n     * primary domain axis (index = 0).\r\n     */\r\n    private Map datasetToRangeAxisMap;\r\n\r\n    /**\r\n     * The origin point for the quadrants (if drawn).\r\n     */\r\n    private transient Point2D quadrantOrigin = new Point2D.Double(0.0, 0.0);\r\n\r\n    /**\r\n     * The paint used for each quadrant.\r\n     */\r\n    private transient Paint[] quadrantPaint = new Paint[] { null, null, null, null };\r\n\r\n    /**\r\n     * A flag that controls whether the domain grid-lines are visible.\r\n     */\r\n    private boolean domainGridlinesVisible;\r\n\r\n    /**\r\n     * The stroke used to draw the domain grid-lines.\r\n     */\r\n    private transient Stroke domainGridlineStroke;\r\n\r\n    /**\r\n     * The paint used to draw the domain grid-lines.\r\n     */\r\n    private transient Paint domainGridlinePaint;\r\n\r\n    /**\r\n     * A flag that controls whether the range grid-lines are visible.\r\n     */\r\n    private boolean rangeGridlinesVisible;\r\n\r\n    /**\r\n     * The stroke used to draw the range grid-lines.\r\n     */\r\n    private transient Stroke rangeGridlineStroke;\r\n\r\n    /**\r\n     * The paint used to draw the range grid-lines.\r\n     */\r\n    private transient Paint rangeGridlinePaint;\r\n\r\n    /**\r\n     * A flag that controls whether or not the zero baseline against the domain\r\n     * axis is visible.\r\n     *\r\n     * @since 1.0.5\r\n     */\r\n    private boolean domainZeroBaselineVisible;\r\n\r\n    /**\r\n     * The stroke used for the zero baseline against the domain axis.\r\n     *\r\n     * @since 1.0.5\r\n     */\r\n    private transient Stroke domainZeroBaselineStroke;\r\n\r\n    /**\r\n     * The paint used for the zero baseline against the domain axis.\r\n     *\r\n     * @since 1.0.5\r\n     */\r\n    private transient Paint domainZeroBaselinePaint;\r\n\r\n    /**\r\n     * A flag that controls whether or not the zero baseline against the range\r\n     * axis is visible.\r\n     */\r\n    private boolean rangeZeroBaselineVisible;\r\n\r\n    /**\r\n     * The stroke used for the zero baseline against the range axis.\r\n     */\r\n    private transient Stroke rangeZeroBaselineStroke;\r\n\r\n    /**\r\n     * The paint used for the zero baseline against the range axis.\r\n     */\r\n    private transient Paint rangeZeroBaselinePaint;\r\n\r\n    /**\r\n     * A flag that controls whether or not a domain crosshair is drawn..\r\n     */\r\n    private boolean domainCrosshairVisible;\r\n\r\n    /**\r\n     * The domain crosshair value.\r\n     */\r\n    private double domainCrosshairValue;\r\n\r\n    /**\r\n     * The pen/brush used to draw the crosshair (if any).\r\n     */\r\n    private transient Stroke domainCrosshairStroke;\r\n\r\n    /**\r\n     * The color used to draw the crosshair (if any).\r\n     */\r\n    private transient Paint domainCrosshairPaint;\r\n\r\n    /**\r\n     * A flag that controls whether or not the crosshair locks onto actual\r\n     * data points.\r\n     */\r\n    private boolean domainCrosshairLockedOnData = true;\r\n\r\n    /**\r\n     * A flag that controls whether or not a range crosshair is drawn..\r\n     */\r\n    private boolean rangeCrosshairVisible;\r\n\r\n    /**\r\n     * The range crosshair value.\r\n     */\r\n    private double rangeCrosshairValue;\r\n\r\n    /**\r\n     * The pen/brush used to draw the crosshair (if any).\r\n     */\r\n    private transient Stroke rangeCrosshairStroke;\r\n\r\n    /**\r\n     * The color used to draw the crosshair (if any).\r\n     */\r\n    private transient Paint rangeCrosshairPaint;\r\n\r\n    /**\r\n     * A flag that controls whether or not the crosshair locks onto actual\r\n     * data points.\r\n     */\r\n    private boolean rangeCrosshairLockedOnData = true;\r\n\r\n    /**\r\n     * A map of lists of foreground markers (optional) for the domain axes.\r\n     */\r\n    private Map foregroundDomainMarkers;\r\n\r\n    /**\r\n     * A map of lists of background markers (optional) for the domain axes.\r\n     */\r\n    private Map backgroundDomainMarkers;\r\n\r\n    /**\r\n     * A map of lists of foreground markers (optional) for the range axes.\r\n     */\r\n    private Map foregroundRangeMarkers;\r\n\r\n    /**\r\n     * A map of lists of background markers (optional) for the range axes.\r\n     */\r\n    private Map backgroundRangeMarkers;\r\n\r\n    /**\r\n     * A (possibly empty) list of annotations for the plot.  The list should\r\n     * be initialised in the constructor and never allowed to be\r\n     * <code>null</code>.\r\n     */\r\n    private List annotations;\r\n\r\n    /**\r\n     * The paint used for the domain tick bands (if any).\r\n     */\r\n    private transient Paint domainTickBandPaint;\r\n\r\n    /**\r\n     * The paint used for the range tick bands (if any).\r\n     */\r\n    private transient Paint rangeTickBandPaint;\r\n\r\n    /**\r\n     * The fixed domain axis space.\r\n     */\r\n    private AxisSpace fixedDomainAxisSpace;\r\n\r\n    /**\r\n     * The fixed range axis space.\r\n     */\r\n    private AxisSpace fixedRangeAxisSpace;\r\n\r\n    /**\r\n     * The order of the dataset rendering (REVERSE draws the primary dataset\r\n     * last so that it appears to be on top).\r\n     */\r\n    private DatasetRenderingOrder datasetRenderingOrder = DatasetRenderingOrder.REVERSE;\r\n\r\n    /**\r\n     * The order of the series rendering (REVERSE draws the primary series\r\n     * last so that it appears to be on top).\r\n     */\r\n    private SeriesRenderingOrder seriesRenderingOrder = SeriesRenderingOrder.REVERSE;\r\n\r\n    /**\r\n     * The weight for this plot (only relevant if this is a subplot in a\r\n     * combined plot).\r\n     */\r\n    private int weight;\r\n\r\n    /**\r\n     * An optional collection of legend items that can be returned by the\r\n     * getLegendItems() method.\r\n     */\r\n    private LegendItemCollection fixedLegendItems;\r\n\r\n    /**\r\n     * Creates a new <code>XYPlot</code> instance with no dataset, no axes and\r\n     * no renderer.  You should specify these items before using the plot.\r\n     */\r\n    public XYPlot() {\r\n        this(null, null, null, null);\r\n    }\r\n\r\n    /**\r\n     * Creates a new plot with the specified dataset, axes and renderer.  Any\r\n     * of the arguments can be <code>null</code>, but in that case you should\r\n     * take care to specify the value before using the plot (otherwise a\r\n     * <code>NullPointerException</code> may be thrown).\r\n     *\r\n     * @param dataset  the dataset (<code>null</code> permitted).\r\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\r\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\r\n     * @param renderer  the renderer (<code>null</code> permitted).\r\n     */\r\n    public XYPlot(XYDataset dataset, ValueAxis domainAxis, ValueAxis rangeAxis, XYItemRenderer renderer) {\r\n        super();\r\n        this.orientation = PlotOrientation.VERTICAL;\r\n        // only relevant when this is a subplot\r\n        this.weight = 1;\r\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\r\n        // allocate storage for datasets, axes and renderers (all optional)\r\n        this.domainAxes = new ObjectList();\r\n        this.domainAxisLocations = new ObjectList();\r\n        this.foregroundDomainMarkers = new HashMap();\r\n        this.backgroundDomainMarkers = new HashMap();\r\n        this.rangeAxes = new ObjectList();\r\n        this.rangeAxisLocations = new ObjectList();\r\n        this.foregroundRangeMarkers = new HashMap();\r\n        this.backgroundRangeMarkers = new HashMap();\r\n        this.datasets = new ObjectList();\r\n        this.renderers = new ObjectList();\r\n        this.datasetToDomainAxisMap = new TreeMap();\r\n        this.datasetToRangeAxisMap = new TreeMap();\r\n        this.datasets.set(0, dataset);\r\n        if (dataset != null) {\r\n            dataset.addChangeListener(this);\r\n        }\r\n        this.renderers.set(0, renderer);\r\n        if (renderer != null) {\r\n            renderer.setPlot(this);\r\n            renderer.addChangeListener(this);\r\n        }\r\n        this.domainAxes.set(0, domainAxis);\r\n        this.mapDatasetToDomainAxis(0, 0);\r\n        if (domainAxis != null) {\r\n            domainAxis.setPlot(this);\r\n            domainAxis.addChangeListener(this);\r\n        }\r\n        this.domainAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\r\n        this.rangeAxes.set(0, rangeAxis);\r\n        this.mapDatasetToRangeAxis(0, 0);\r\n        if (rangeAxis != null) {\r\n            rangeAxis.setPlot(this);\r\n            rangeAxis.addChangeListener(this);\r\n        }\r\n        this.rangeAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\r\n        configureDomainAxes();\r\n        configureRangeAxes();\r\n        this.domainGridlinesVisible = true;\r\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\r\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\r\n        this.domainZeroBaselineVisible = false;\r\n        this.domainZeroBaselinePaint = Color.black;\r\n        this.domainZeroBaselineStroke = new BasicStroke(0.5f);\r\n        this.rangeGridlinesVisible = true;\r\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\r\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\r\n        this.rangeZeroBaselineVisible = false;\r\n        this.rangeZeroBaselinePaint = Color.black;\r\n        this.rangeZeroBaselineStroke = new BasicStroke(0.5f);\r\n        this.domainCrosshairVisible = false;\r\n        this.domainCrosshairValue = 0.0;\r\n        this.domainCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\r\n        this.domainCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\r\n        this.rangeCrosshairVisible = false;\r\n        this.rangeCrosshairValue = 0.0;\r\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\r\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\r\n        this.annotations = new java.util.ArrayList();\r\n    }\r\n\r\n    /**\r\n     * Returns the plot type as a string.\r\n     *\r\n     * @return A short string describing the type of plot.\r\n     */\r\n    public String getPlotType() {\r\n        return localizationResources.getString(\"XY_Plot\");\r\n    }\r\n\r\n    /**\r\n     * Returns the orientation of the plot.\r\n     *\r\n     * @return The orientation (never <code>null</code>).\r\n     *\r\n     * @see #setOrientation(PlotOrientation)\r\n     */\r\n    public PlotOrientation getOrientation() {\r\n        return this.orientation;\r\n    }\r\n\r\n    /**\r\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param orientation  the orientation (<code>null</code> not allowed).\r\n     *\r\n     * @see #getOrientation()\r\n     */\r\n    public void setOrientation(PlotOrientation orientation) {\r\n        if (orientation == null) {\r\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\r\n        }\r\n        if (orientation != this.orientation) {\r\n            this.orientation = orientation;\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the axis offset.\r\n     *\r\n     * @return The axis offset (never <code>null</code>).\r\n     *\r\n     * @see #setAxisOffset(RectangleInsets)\r\n     */\r\n    public RectangleInsets getAxisOffset() {\r\n        return this.axisOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the axis offsets (gap between the data area and the axes) and sends\r\n     * a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param offset  the offset (<code>null</code> not permitted).\r\n     *\r\n     * @see #getAxisOffset()\r\n     */\r\n    public void setAxisOffset(RectangleInsets offset) {\r\n        if (offset == null) {\r\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\r\n        }\r\n        this.axisOffset = offset;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the domain axis with index 0.  If the domain axis for this plot\r\n     * is <code>null</code>, then the method will return the parent plot's\r\n     * domain axis (if there is a parent plot).\r\n     *\r\n     * @return The domain axis (possibly <code>null</code>).\r\n     *\r\n     * @see #getDomainAxis(int)\r\n     * @see #setDomainAxis(ValueAxis)\r\n     */\r\n    public ValueAxis getDomainAxis() {\r\n        return getDomainAxis(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the domain axis with the specified index, or <code>null</code>.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The axis (<code>null</code> possible).\r\n     *\r\n     * @see #setDomainAxis(int, ValueAxis)\r\n     */\r\n    public ValueAxis getDomainAxis(int index) {\r\n        ValueAxis result = null;\r\n        if (index < this.domainAxes.size()) {\r\n            result = (ValueAxis) this.domainAxes.get(index);\r\n        }\r\n        if (result == null) {\r\n            Plot parent = getParent();\r\n            if (parent instanceof XYPlot) {\r\n                XYPlot xy = (XYPlot) parent;\r\n                result = xy.getDomainAxis(index);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param axis  the new axis (<code>null</code> permitted).\r\n     *\r\n     * @see #getDomainAxis()\r\n     * @see #setDomainAxis(int, ValueAxis)\r\n     */\r\n    public void setDomainAxis(ValueAxis axis) {\r\n        setDomainAxis(0, axis);\r\n    }\r\n\r\n    /**\r\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param axis  the axis (<code>null</code> permitted).\r\n     *\r\n     * @see #getDomainAxis(int)\r\n     * @see #setRangeAxis(int, ValueAxis)\r\n     */\r\n    public void setDomainAxis(int index, ValueAxis axis) {\r\n        setDomainAxis(index, axis, true);\r\n    }\r\n\r\n    /**\r\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param axis  the axis.\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getDomainAxis(int)\r\n     */\r\n    public void setDomainAxis(int index, ValueAxis axis, boolean notify) {\r\n        ValueAxis existing = getDomainAxis(index);\r\n        if (existing != null) {\r\n            existing.removeChangeListener(this);\r\n        }\r\n        if (axis != null) {\r\n            axis.setPlot(this);\r\n        }\r\n        this.domainAxes.set(index, axis);\r\n        if (axis != null) {\r\n            axis.configure();\r\n            axis.addChangeListener(this);\r\n        }\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param axes  the axes (<code>null</code> not permitted).\r\n     *\r\n     * @see #setRangeAxes(ValueAxis[])\r\n     */\r\n    public void setDomainAxes(ValueAxis[] axes) {\r\n        for (int i = 0; i < axes.length; i++) {\r\n            setDomainAxis(i, axes[i], false);\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the location of the primary domain axis.\r\n     *\r\n     * @return The location (never <code>null</code>).\r\n     *\r\n     * @see #setDomainAxisLocation(AxisLocation)\r\n     */\r\n    public AxisLocation getDomainAxisLocation() {\r\n        return (AxisLocation) this.domainAxisLocations.get(0);\r\n    }\r\n\r\n    /**\r\n     * Sets the location of the primary domain axis and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param location  the location (<code>null</code> not permitted).\r\n     *\r\n     * @see #getDomainAxisLocation()\r\n     */\r\n    public void setDomainAxisLocation(AxisLocation location) {\r\n        // delegate...\r\n        setDomainAxisLocation(0, location, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the location of the domain axis and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param location  the location (<code>null</code> not permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getDomainAxisLocation()\r\n     */\r\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\r\n        // delegate...\r\n        setDomainAxisLocation(0, location, notify);\r\n    }\r\n\r\n    /**\r\n     * Returns the edge for the primary domain axis (taking into account the\r\n     * plot's orientation).\r\n     *\r\n     * @return The edge.\r\n     *\r\n     * @see #getDomainAxisLocation()\r\n     * @see #getOrientation()\r\n     */\r\n    public RectangleEdge getDomainAxisEdge() {\r\n        return Plot.resolveDomainAxisLocation(getDomainAxisLocation(), this.orientation);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of domain axes.\r\n     *\r\n     * @return The axis count.\r\n     *\r\n     * @see #getRangeAxisCount()\r\n     */\r\n    public int getDomainAxisCount() {\r\n        return this.domainAxes.size();\r\n    }\r\n\r\n    /**\r\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @see #clearRangeAxes()\r\n     */\r\n    public void clearDomainAxes() {\r\n        for (int i = 0; i < this.domainAxes.size(); i++) {\r\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\r\n            if (axis != null) {\r\n                axis.removeChangeListener(this);\r\n            }\r\n        }\r\n        this.domainAxes.clear();\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Configures the domain axes.\r\n     */\r\n    public void configureDomainAxes() {\r\n        for (int i = 0; i < this.domainAxes.size(); i++) {\r\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\r\n            if (axis != null) {\r\n                axis.configure();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the location for a domain axis.  If this hasn't been set\r\n     * explicitly, the method returns the location that is opposite to the\r\n     * primary domain axis location.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The location (never <code>null</code>).\r\n     *\r\n     * @see #setDomainAxisLocation(int, AxisLocation)\r\n     */\r\n    public AxisLocation getDomainAxisLocation(int index) {\r\n        AxisLocation result = null;\r\n        if (index < this.domainAxisLocations.size()) {\r\n            result = (AxisLocation) this.domainAxisLocations.get(index);\r\n        }\r\n        if (result == null) {\r\n            result = AxisLocation.getOpposite(getDomainAxisLocation());\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param location  the location (<code>null</code> not permitted for index\r\n     *     0).\r\n     *\r\n     * @see #getDomainAxisLocation(int)\r\n     */\r\n    public void setDomainAxisLocation(int index, AxisLocation location) {\r\n        // delegate...\r\n        setDomainAxisLocation(index, location, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the axis location for a domain axis and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param location  the location (<code>null</code> not permitted for\r\n     *     index 0).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @since 1.0.5\r\n     *\r\n     * @see #getDomainAxisLocation(int)\r\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\r\n     */\r\n    public void setDomainAxisLocation(int index, AxisLocation location, boolean notify) {\r\n        if (index == 0 && location == null) {\r\n            throw new IllegalArgumentException(\"Null 'location' for index 0 not permitted.\");\r\n        }\r\n        this.domainAxisLocations.set(index, location);\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the edge for a domain axis.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The edge.\r\n     *\r\n     * @see #getRangeAxisEdge(int)\r\n     */\r\n    public RectangleEdge getDomainAxisEdge(int index) {\r\n        AxisLocation location = getDomainAxisLocation(index);\r\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\r\n        if (result == null) {\r\n            result = RectangleEdge.opposite(getDomainAxisEdge());\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the range axis for the plot.  If the range axis for this plot is\r\n     * <code>null</code>, then the method will return the parent plot's range\r\n     * axis (if there is a parent plot).\r\n     *\r\n     * @return The range axis.\r\n     *\r\n     * @see #getRangeAxis(int)\r\n     * @see #setRangeAxis(ValueAxis)\r\n     */\r\n    public ValueAxis getRangeAxis() {\r\n        return getRangeAxis(0);\r\n    }\r\n\r\n    /**\r\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param axis  the axis (<code>null</code> permitted).\r\n     *\r\n     * @see #getRangeAxis()\r\n     * @see #setRangeAxis(int, ValueAxis)\r\n     */\r\n    public void setRangeAxis(ValueAxis axis) {\r\n        if (axis != null) {\r\n            axis.setPlot(this);\r\n        }\r\n        // plot is likely registered as a listener with the existing axis...\r\n        ValueAxis existing = getRangeAxis();\r\n        if (existing != null) {\r\n            existing.removeChangeListener(this);\r\n        }\r\n        this.rangeAxes.set(0, axis);\r\n        if (axis != null) {\r\n            axis.configure();\r\n            axis.addChangeListener(this);\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the location of the primary range axis.\r\n     *\r\n     * @return The location (never <code>null</code>).\r\n     *\r\n     * @see #setRangeAxisLocation(AxisLocation)\r\n     */\r\n    public AxisLocation getRangeAxisLocation() {\r\n        return (AxisLocation) this.rangeAxisLocations.get(0);\r\n    }\r\n\r\n    /**\r\n     * Sets the location of the primary range axis and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param location  the location (<code>null</code> not permitted).\r\n     *\r\n     * @see #getRangeAxisLocation()\r\n     */\r\n    public void setRangeAxisLocation(AxisLocation location) {\r\n        // delegate...\r\n        setRangeAxisLocation(0, location, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the location of the primary range axis and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param location  the location (<code>null</code> not permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getRangeAxisLocation()\r\n     */\r\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\r\n        // delegate...\r\n        setRangeAxisLocation(0, location, notify);\r\n    }\r\n\r\n    /**\r\n     * Returns the edge for the primary range axis.\r\n     *\r\n     * @return The range axis edge.\r\n     *\r\n     * @see #getRangeAxisLocation()\r\n     * @see #getOrientation()\r\n     */\r\n    public RectangleEdge getRangeAxisEdge() {\r\n        return Plot.resolveRangeAxisLocation(getRangeAxisLocation(), this.orientation);\r\n    }\r\n\r\n    /**\r\n     * Returns a range axis.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The axis (<code>null</code> possible).\r\n     *\r\n     * @see #setRangeAxis(int, ValueAxis)\r\n     */\r\n    public ValueAxis getRangeAxis(int index) {\r\n        ValueAxis result = null;\r\n        if (index < this.rangeAxes.size()) {\r\n            result = (ValueAxis) this.rangeAxes.get(index);\r\n        }\r\n        if (result == null) {\r\n            Plot parent = getParent();\r\n            if (parent instanceof XYPlot) {\r\n                XYPlot xy = (XYPlot) parent;\r\n                result = xy.getRangeAxis(index);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\r\n     * listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param axis  the axis (<code>null</code> permitted).\r\n     *\r\n     * @see #getRangeAxis(int)\r\n     */\r\n    public void setRangeAxis(int index, ValueAxis axis) {\r\n        setRangeAxis(index, axis, true);\r\n    }\r\n\r\n    /**\r\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param axis  the axis (<code>null</code> permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getRangeAxis(int)\r\n     */\r\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\r\n        ValueAxis existing = getRangeAxis(index);\r\n        if (existing != null) {\r\n            existing.removeChangeListener(this);\r\n        }\r\n        if (axis != null) {\r\n            axis.setPlot(this);\r\n        }\r\n        this.rangeAxes.set(index, axis);\r\n        if (axis != null) {\r\n            axis.configure();\r\n            axis.addChangeListener(this);\r\n        }\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param axes  the axes (<code>null</code> not permitted).\r\n     *\r\n     * @see #setDomainAxes(ValueAxis[])\r\n     */\r\n    public void setRangeAxes(ValueAxis[] axes) {\r\n        for (int i = 0; i < axes.length; i++) {\r\n            setRangeAxis(i, axes[i], false);\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the number of range axes.\r\n     *\r\n     * @return The axis count.\r\n     *\r\n     * @see #getDomainAxisCount()\r\n     */\r\n    public int getRangeAxisCount() {\r\n        return this.rangeAxes.size();\r\n    }\r\n\r\n    /**\r\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @see #clearDomainAxes()\r\n     */\r\n    public void clearRangeAxes() {\r\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\r\n            if (axis != null) {\r\n                axis.removeChangeListener(this);\r\n            }\r\n        }\r\n        this.rangeAxes.clear();\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Configures the range axes.\r\n     *\r\n     * @see #configureDomainAxes()\r\n     */\r\n    public void configureRangeAxes() {\r\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\r\n            if (axis != null) {\r\n                axis.configure();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the location for a range axis.  If this hasn't been set\r\n     * explicitly, the method returns the location that is opposite to the\r\n     * primary range axis location.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The location (never <code>null</code>).\r\n     *\r\n     * @see #setRangeAxisLocation(int, AxisLocation)\r\n     */\r\n    public AxisLocation getRangeAxisLocation(int index) {\r\n        AxisLocation result = null;\r\n        if (index < this.rangeAxisLocations.size()) {\r\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\r\n        }\r\n        if (result == null) {\r\n            result = AxisLocation.getOpposite(getRangeAxisLocation());\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param location  the location (<code>null</code> permitted).\r\n     *\r\n     * @see #getRangeAxisLocation(int)\r\n     */\r\n    public void setRangeAxisLocation(int index, AxisLocation location) {\r\n        // delegate...\r\n        setRangeAxisLocation(index, location, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the axis location for a domain axis and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param location  the location (<code>null</code> not permitted for\r\n     *     index 0).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @since 1.0.5\r\n     *\r\n     * @see #getRangeAxisLocation(int)\r\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\r\n     */\r\n    public void setRangeAxisLocation(int index, AxisLocation location, boolean notify) {\r\n        if (index == 0 && location == null) {\r\n            throw new IllegalArgumentException(\"Null 'location' for index 0 not permitted.\");\r\n        }\r\n        this.rangeAxisLocations.set(index, location);\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the edge for a range axis.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The edge.\r\n     *\r\n     * @see #getRangeAxisLocation(int)\r\n     * @see #getOrientation()\r\n     */\r\n    public RectangleEdge getRangeAxisEdge(int index) {\r\n        AxisLocation location = getRangeAxisLocation(index);\r\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, this.orientation);\r\n        if (result == null) {\r\n            result = RectangleEdge.opposite(getRangeAxisEdge());\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the primary dataset for the plot.\r\n     *\r\n     * @return The primary dataset (possibly <code>null</code>).\r\n     *\r\n     * @see #getDataset(int)\r\n     * @see #setDataset(XYDataset)\r\n     */\r\n    public XYDataset getDataset() {\r\n        return getDataset(0);\r\n    }\r\n\r\n    /**\r\n     * Returns a dataset.\r\n     *\r\n     * @param index  the dataset index.\r\n     *\r\n     * @return The dataset (possibly <code>null</code>).\r\n     *\r\n     * @see #setDataset(int, XYDataset)\r\n     */\r\n    public XYDataset getDataset(int index) {\r\n        XYDataset result = null;\r\n        if (this.datasets.size() > index) {\r\n            result = (XYDataset) this.datasets.get(index);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the primary dataset for the plot, replacing the existing dataset if\r\n     * there is one.\r\n     *\r\n     * @param dataset  the dataset (<code>null</code> permitted).\r\n     *\r\n     * @see #getDataset()\r\n     * @see #setDataset(int, XYDataset)\r\n     */\r\n    public void setDataset(XYDataset dataset) {\r\n        setDataset(0, dataset);\r\n    }\r\n\r\n    /**\r\n     * Sets a dataset for the plot.\r\n     *\r\n     * @param index  the dataset index.\r\n     * @param dataset  the dataset (<code>null</code> permitted).\r\n     *\r\n     * @see #getDataset(int)\r\n     */\r\n    public void setDataset(int index, XYDataset dataset) {\r\n        XYDataset existing = getDataset(index);\r\n        if (existing != null) {\r\n            existing.removeChangeListener(this);\r\n        }\r\n        this.datasets.set(index, dataset);\r\n        if (dataset != null) {\r\n            dataset.addChangeListener(this);\r\n        }\r\n        // send a dataset change event to self...\r\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\r\n        datasetChanged(event);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of datasets.\r\n     *\r\n     * @return The number of datasets.\r\n     */\r\n    public int getDatasetCount() {\r\n        return this.datasets.size();\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the specified dataset, or <code>-1</code> if the\r\n     * dataset does not belong to the plot.\r\n     *\r\n     * @param dataset  the dataset (<code>null</code> not permitted).\r\n     *\r\n     * @return The index.\r\n     */\r\n    public int indexOf(XYDataset dataset) {\r\n        int result = -1;\r\n        for (int i = 0; i < this.datasets.size(); i++) {\r\n            if (dataset == this.datasets.get(i)) {\r\n                result = i;\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Maps a dataset to a particular domain axis.  All data will be plotted\r\n     * against axis zero by default, no mapping is required for this case.\r\n     *\r\n     * @param index  the dataset index (zero-based).\r\n     * @param axisIndex  the axis index.\r\n     *\r\n     * @see #mapDatasetToRangeAxis(int, int)\r\n     */\r\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\r\n        this.datasetToDomainAxisMap.put(new Integer(index), new Integer(axisIndex));\r\n        // fake a dataset change event to update axes...\r\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\r\n    }\r\n\r\n    /**\r\n     * Maps a dataset to a particular range axis.  All data will be plotted\r\n     * against axis zero by default, no mapping is required for this case.\r\n     *\r\n     * @param index  the dataset index (zero-based).\r\n     * @param axisIndex  the axis index.\r\n     *\r\n     * @see #mapDatasetToDomainAxis(int, int)\r\n     */\r\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\r\n        this.datasetToRangeAxisMap.put(new Integer(index), new Integer(axisIndex));\r\n        // fake a dataset change event to update axes...\r\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\r\n    }\r\n\r\n    /**\r\n     * Returns the renderer for the primary dataset.\r\n     *\r\n     * @return The item renderer (possibly <code>null</code>).\r\n     *\r\n     * @see #setRenderer(XYItemRenderer)\r\n     */\r\n    public XYItemRenderer getRenderer() {\r\n        return getRenderer(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the renderer for a dataset, or <code>null</code>.\r\n     *\r\n     * @param index  the renderer index.\r\n     *\r\n     * @return The renderer (possibly <code>null</code>).\r\n     *\r\n     * @see #setRenderer(int, XYItemRenderer)\r\n     */\r\n    public XYItemRenderer getRenderer(int index) {\r\n        XYItemRenderer result = null;\r\n        if (this.renderers.size() > index) {\r\n            result = (XYItemRenderer) this.renderers.get(index);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the renderer for the primary dataset and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.  If the renderer\r\n     * is set to <code>null</code>, no data will be displayed.\r\n     *\r\n     * @param renderer  the renderer (<code>null</code> permitted).\r\n     *\r\n     * @see #getRenderer()\r\n     */\r\n    public void setRenderer(XYItemRenderer renderer) {\r\n        setRenderer(0, renderer);\r\n    }\r\n\r\n    /**\r\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param index  the index.\r\n     * @param renderer  the renderer.\r\n     *\r\n     * @see #getRenderer(int)\r\n     */\r\n    public void setRenderer(int index, XYItemRenderer renderer) {\r\n        setRenderer(index, renderer, true);\r\n    }\r\n\r\n    /**\r\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param index  the index.\r\n     * @param renderer  the renderer.\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getRenderer(int)\r\n     */\r\n    public void setRenderer(int index, XYItemRenderer renderer, boolean notify) {\r\n        XYItemRenderer existing = getRenderer(index);\r\n        if (existing != null) {\r\n            existing.removeChangeListener(this);\r\n        }\r\n        this.renderers.set(index, renderer);\r\n        if (renderer != null) {\r\n            renderer.setPlot(this);\r\n            renderer.addChangeListener(this);\r\n        }\r\n        configureDomainAxes();\r\n        configureRangeAxes();\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param renderers  the renderers (<code>null</code> not permitted).\r\n     */\r\n    public void setRenderers(XYItemRenderer[] renderers) {\r\n        for (int i = 0; i < renderers.length; i++) {\r\n            setRenderer(i, renderers[i], false);\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the dataset rendering order.\r\n     *\r\n     * @return The order (never <code>null</code>).\r\n     *\r\n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\r\n     */\r\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\r\n        return this.datasetRenderingOrder;\r\n    }\r\n\r\n    /**\r\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.  By default, the plot renders the primary dataset\r\n     * last (so that the primary dataset overlays the secondary datasets).\r\n     * You can reverse this if you want to.\r\n     *\r\n     * @param order  the rendering order (<code>null</code> not permitted).\r\n     *\r\n     * @see #getDatasetRenderingOrder()\r\n     */\r\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\r\n        if (order == null) {\r\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\r\n        }\r\n        this.datasetRenderingOrder = order;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the series rendering order.\r\n     *\r\n     * @return the order (never <code>null</code>).\r\n     *\r\n     * @see #setSeriesRenderingOrder(SeriesRenderingOrder)\r\n     */\r\n    public SeriesRenderingOrder getSeriesRenderingOrder() {\r\n        return this.seriesRenderingOrder;\r\n    }\r\n\r\n    /**\r\n     * Sets the series order and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.  By default, the plot renders the primary series\r\n     * last (so that the primary series appears to be on top).\r\n     * You can reverse this if you want to.\r\n     *\r\n     * @param order  the rendering order (<code>null</code> not permitted).\r\n     *\r\n     * @see #getSeriesRenderingOrder()\r\n     */\r\n    public void setSeriesRenderingOrder(SeriesRenderingOrder order) {\r\n        if (order == null) {\r\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\r\n        }\r\n        this.seriesRenderingOrder = order;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the specified renderer, or <code>-1</code> if the\r\n     * renderer is not assigned to this plot.\r\n     *\r\n     * @param renderer  the renderer (<code>null</code> permitted).\r\n     *\r\n     * @return The renderer index.\r\n     */\r\n    public int getIndexOf(XYItemRenderer renderer) {\r\n        return this.renderers.indexOf(renderer);\r\n    }\r\n\r\n    /**\r\n     * Returns the renderer for the specified dataset.  The code first\r\n     * determines the index of the dataset, then checks if there is a\r\n     * renderer with the same index (if not, the method returns renderer(0).\r\n     *\r\n     * @param dataset  the dataset (<code>null</code> permitted).\r\n     *\r\n     * @return The renderer (possibly <code>null</code>).\r\n     */\r\n    public XYItemRenderer getRendererForDataset(XYDataset dataset) {\r\n        XYItemRenderer result = null;\r\n        for (int i = 0; i < this.datasets.size(); i++) {\r\n            if (this.datasets.get(i) == dataset) {\r\n                result = (XYItemRenderer) this.renderers.get(i);\r\n                if (result == null) {\r\n                    result = getRenderer();\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the weight for this plot when it is used as a subplot within a\r\n     * combined plot.\r\n     *\r\n     * @return The weight.\r\n     *\r\n     * @see #setWeight(int)\r\n     */\r\n    public int getWeight() {\r\n        return this.weight;\r\n    }\r\n\r\n    /**\r\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param weight  the weight.\r\n     *\r\n     * @see #getWeight()\r\n     */\r\n    public void setWeight(int weight) {\r\n        this.weight = weight;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns <code>true</code> if the domain gridlines are visible, and\r\n     * <code>false<code> otherwise.\r\n     *\r\n     * @return <code>true</code> or <code>false</code>.\r\n     *\r\n     * @see #setDomainGridlinesVisible(boolean)\r\n     */\r\n    public boolean isDomainGridlinesVisible() {\r\n        return this.domainGridlinesVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that controls whether or not the domain grid-lines are\r\n     * visible.\r\n     * <p>\r\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\r\n     * registered listeners.\r\n     *\r\n     * @param visible  the new value of the flag.\r\n     *\r\n     * @see #isDomainGridlinesVisible()\r\n     */\r\n    public void setDomainGridlinesVisible(boolean visible) {\r\n        if (this.domainGridlinesVisible != visible) {\r\n            this.domainGridlinesVisible = visible;\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the stroke for the grid-lines (if any) plotted against the\r\n     * domain axis.\r\n     *\r\n     * @return The stroke (never <code>null</code>).\r\n     *\r\n     * @see #setDomainGridlineStroke(Stroke)\r\n     */\r\n    public Stroke getDomainGridlineStroke() {\r\n        return this.domainGridlineStroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the stroke for the grid lines plotted against the domain axis, and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     * <p>\r\n     * If you set this to <code>null</code>, no grid lines will be drawn.\r\n     *\r\n     * @param stroke  the stroke (<code>null</code> not permitted).\r\n     *\r\n     * @throws IllegalArgumentException if <code>stroke</code> is\r\n     *     <code>null</code>.\r\n     *\r\n     * @see #getDomainGridlineStroke()\r\n     */\r\n    public void setDomainGridlineStroke(Stroke stroke) {\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        this.domainGridlineStroke = stroke;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint for the grid lines (if any) plotted against the domain\r\n     * axis.\r\n     *\r\n     * @return The paint (never <code>null</code>).\r\n     *\r\n     * @see #setDomainGridlinePaint(Paint)\r\n     */\r\n    public Paint getDomainGridlinePaint() {\r\n        return this.domainGridlinePaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint for the grid lines plotted against the domain axis, and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     *\r\n     * @throws IllegalArgumentException if <code>paint</code> is\r\n     *     <code>null</code>.\r\n     *\r\n     * @see #getDomainGridlinePaint()\r\n     */\r\n    public void setDomainGridlinePaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.domainGridlinePaint = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns <code>true</code> if the range axis grid is visible, and\r\n     * <code>false<code> otherwise.\r\n     *\r\n     * @return A boolean.\r\n     *\r\n     * @see #setRangeGridlinesVisible(boolean)\r\n     */\r\n    public boolean isRangeGridlinesVisible() {\r\n        return this.rangeGridlinesVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that controls whether or not the range axis grid lines\r\n     * are visible.\r\n     * <p>\r\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\r\n     * registered listeners.\r\n     *\r\n     * @param visible  the new value of the flag.\r\n     *\r\n     * @see #isRangeGridlinesVisible()\r\n     */\r\n    public void setRangeGridlinesVisible(boolean visible) {\r\n        if (this.rangeGridlinesVisible != visible) {\r\n            this.rangeGridlinesVisible = visible;\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the stroke for the grid lines (if any) plotted against the\r\n     * range axis.\r\n     *\r\n     * @return The stroke (never <code>null</code>).\r\n     *\r\n     * @see #setRangeGridlineStroke(Stroke)\r\n     */\r\n    public Stroke getRangeGridlineStroke() {\r\n        return this.rangeGridlineStroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the stroke for the grid lines plotted against the range axis,\r\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param stroke  the stroke (<code>null</code> not permitted).\r\n     *\r\n     * @see #getRangeGridlineStroke()\r\n     */\r\n    public void setRangeGridlineStroke(Stroke stroke) {\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        this.rangeGridlineStroke = stroke;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint for the grid lines (if any) plotted against the range\r\n     * axis.\r\n     *\r\n     * @return The paint (never <code>null</code>).\r\n     *\r\n     * @see #setRangeGridlinePaint(Paint)\r\n     */\r\n    public Paint getRangeGridlinePaint() {\r\n        return this.rangeGridlinePaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint for the grid lines plotted against the range axis and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     *\r\n     * @see #getRangeGridlinePaint()\r\n     */\r\n    public void setRangeGridlinePaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.rangeGridlinePaint = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns a flag that controls whether or not a zero baseline is\r\n     * displayed for the domain axis.\r\n     *\r\n     * @return A boolean.\r\n     *\r\n     * @since 1.0.5\r\n     *\r\n     * @see #setDomainZeroBaselineVisible(boolean)\r\n     */\r\n    public boolean isDomainZeroBaselineVisible() {\r\n        return this.domainZeroBaselineVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that controls whether or not the zero baseline is\r\n     * displayed for the domain axis, and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param visible  the flag.\r\n     *\r\n     * @since 1.0.5\r\n     *\r\n     * @see #isDomainZeroBaselineVisible()\r\n     */\r\n    public void setDomainZeroBaselineVisible(boolean visible) {\r\n        this.domainZeroBaselineVisible = visible;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the stroke used for the zero baseline against the domain axis.\r\n     *\r\n     * @return The stroke (never <code>null</code>).\r\n     *\r\n     * @since 1.0.5\r\n     *\r\n     * @see #setDomainZeroBaselineStroke(Stroke)\r\n     */\r\n    public Stroke getDomainZeroBaselineStroke() {\r\n        return this.domainZeroBaselineStroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the stroke for the zero baseline for the domain axis,\r\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param stroke  the stroke (<code>null</code> not permitted).\r\n     *\r\n     * @since 1.0.5\r\n     *\r\n     * @see #getRangeZeroBaselineStroke()\r\n     */\r\n    public void setDomainZeroBaselineStroke(Stroke stroke) {\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        this.domainZeroBaselineStroke = stroke;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint for the zero baseline (if any) plotted against the\r\n     * domain axis.\r\n     *\r\n     * @since 1.0.5\r\n     *\r\n     * @return The paint (never <code>null</code>).\r\n     *\r\n     * @see #setDomainZeroBaselinePaint(Paint)\r\n     */\r\n    public Paint getDomainZeroBaselinePaint() {\r\n        return this.domainZeroBaselinePaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint for the zero baseline plotted against the domain axis and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     *\r\n     * @since 1.0.5\r\n     *\r\n     * @see #getDomainZeroBaselinePaint()\r\n     */\r\n    public void setDomainZeroBaselinePaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.domainZeroBaselinePaint = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns a flag that controls whether or not a zero baseline is\r\n     * displayed for the range axis.\r\n     *\r\n     * @return A boolean.\r\n     *\r\n     * @see #setRangeZeroBaselineVisible(boolean)\r\n     */\r\n    public boolean isRangeZeroBaselineVisible() {\r\n        return this.rangeZeroBaselineVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that controls whether or not the zero baseline is\r\n     * displayed for the range axis, and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param visible  the flag.\r\n     *\r\n     * @see #isRangeZeroBaselineVisible()\r\n     */\r\n    public void setRangeZeroBaselineVisible(boolean visible) {\r\n        this.rangeZeroBaselineVisible = visible;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the stroke used for the zero baseline against the range axis.\r\n     *\r\n     * @return The stroke (never <code>null</code>).\r\n     *\r\n     * @see #setRangeZeroBaselineStroke(Stroke)\r\n     */\r\n    public Stroke getRangeZeroBaselineStroke() {\r\n        return this.rangeZeroBaselineStroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the stroke for the zero baseline for the range axis,\r\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param stroke  the stroke (<code>null</code> not permitted).\r\n     *\r\n     * @see #getRangeZeroBaselineStroke()\r\n     */\r\n    public void setRangeZeroBaselineStroke(Stroke stroke) {\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        this.rangeZeroBaselineStroke = stroke;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint for the zero baseline (if any) plotted against the\r\n     * range axis.\r\n     *\r\n     * @return The paint (never <code>null</code>).\r\n     *\r\n     * @see #setRangeZeroBaselinePaint(Paint)\r\n     */\r\n    public Paint getRangeZeroBaselinePaint() {\r\n        return this.rangeZeroBaselinePaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint for the zero baseline plotted against the range axis and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     *\r\n     * @see #getRangeZeroBaselinePaint()\r\n     */\r\n    public void setRangeZeroBaselinePaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.rangeZeroBaselinePaint = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint used for the domain tick bands.  If this is\r\n     * <code>null</code>, no tick bands will be drawn.\r\n     *\r\n     * @return The paint (possibly <code>null</code>).\r\n     *\r\n     * @see #setDomainTickBandPaint(Paint)\r\n     */\r\n    public Paint getDomainTickBandPaint() {\r\n        return this.domainTickBandPaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint for the domain tick bands.\r\n     *\r\n     * @param paint  the paint (<code>null</code> permitted).\r\n     *\r\n     * @see #getDomainTickBandPaint()\r\n     */\r\n    public void setDomainTickBandPaint(Paint paint) {\r\n        this.domainTickBandPaint = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint used for the range tick bands.  If this is\r\n     * <code>null</code>, no tick bands will be drawn.\r\n     *\r\n     * @return The paint (possibly <code>null</code>).\r\n     *\r\n     * @see #setRangeTickBandPaint(Paint)\r\n     */\r\n    public Paint getRangeTickBandPaint() {\r\n        return this.rangeTickBandPaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint for the range tick bands.\r\n     *\r\n     * @param paint  the paint (<code>null</code> permitted).\r\n     *\r\n     * @see #getRangeTickBandPaint()\r\n     */\r\n    public void setRangeTickBandPaint(Paint paint) {\r\n        this.rangeTickBandPaint = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the origin for the quadrants that can be displayed on the plot.\r\n     * This defaults to (0, 0).\r\n     *\r\n     * @return The origin point (never <code>null</code>).\r\n     *\r\n     * @see #setQuadrantOrigin(Point2D)\r\n     */\r\n    public Point2D getQuadrantOrigin() {\r\n        return this.quadrantOrigin;\r\n    }\r\n\r\n    /**\r\n     * Sets the quadrant origin and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param origin  the origin (<code>null</code> not permitted).\r\n     *\r\n     * @see #getQuadrantOrigin()\r\n     */\r\n    public void setQuadrantOrigin(Point2D origin) {\r\n        if (origin == null) {\r\n            throw new IllegalArgumentException(\"Null 'origin' argument.\");\r\n        }\r\n        this.quadrantOrigin = origin;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint used for the specified quadrant.\r\n     *\r\n     * @param index  the quadrant index (0-3).\r\n     *\r\n     * @return The paint (possibly <code>null</code>).\r\n     *\r\n     * @see #setQuadrantPaint(int, Paint)\r\n     */\r\n    public Paint getQuadrantPaint(int index) {\r\n        if (index < 0 || index > 3) {\r\n            throw new IllegalArgumentException(\"The index value (\" + index + \") should be in the range 0 to 3.\");\r\n        }\r\n        return this.quadrantPaint[index];\r\n    }\r\n\r\n    /**\r\n     * Sets the paint used for the specified quadrant and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index  the quadrant index (0-3).\r\n     * @param paint  the paint (<code>null</code> permitted).\r\n     *\r\n     * @see #getQuadrantPaint(int)\r\n     */\r\n    public void setQuadrantPaint(int index, Paint paint) {\r\n        if (index < 0 || index > 3) {\r\n            throw new IllegalArgumentException(\"The index value (\" + index + \") should be in the range 0 to 3.\");\r\n        }\r\n        this.quadrantPaint[index] = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for the domain axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to the range axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param marker  the marker (<code>null</code> not permitted).\r\n     *\r\n     * @see #addDomainMarker(Marker, Layer)\r\n     * @see #clearDomainMarkers()\r\n     */\r\n    public void addDomainMarker(Marker marker) {\r\n        // defer argument checking...\r\n        addDomainMarker(marker, Layer.FOREGROUND);\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for the domain axis in the specified layer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to the range axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param marker  the marker (<code>null</code> not permitted).\r\n     * @param layer  the layer (foreground or background).\r\n     *\r\n     * @see #addDomainMarker(int, Marker, Layer)\r\n     */\r\n    public void addDomainMarker(Marker marker, Layer layer) {\r\n        addDomainMarker(0, marker, layer);\r\n    }\r\n\r\n    /**\r\n     * Clears all the (foreground and background) domain markers and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @see #addDomainMarker(int, Marker, Layer)\r\n     */\r\n    public void clearDomainMarkers() {\r\n        if (this.backgroundDomainMarkers != null) {\r\n            Set keys = this.backgroundDomainMarkers.keySet();\r\n            Iterator iterator = keys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Integer key = (Integer) iterator.next();\r\n                clearDomainMarkers(key.intValue());\r\n            }\r\n            this.backgroundDomainMarkers.clear();\r\n        }\r\n        if (this.foregroundDomainMarkers != null) {\r\n            Set keys = this.foregroundDomainMarkers.keySet();\r\n            Iterator iterator = keys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Integer key = (Integer) iterator.next();\r\n                clearDomainMarkers(key.intValue());\r\n            }\r\n            this.foregroundDomainMarkers.clear();\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Clears the (foreground and background) domain markers for a particular\r\n     * renderer.\r\n     *\r\n     * @param index  the renderer index.\r\n     *\r\n     * @see #clearRangeMarkers(int)\r\n     */\r\n    public void clearDomainMarkers(int index) {\r\n        Integer key = new Integer(index);\r\n        if (this.backgroundDomainMarkers != null) {\r\n            Collection markers = (Collection) this.backgroundDomainMarkers.get(key);\r\n            if (markers != null) {\r\n                Iterator iterator = markers.iterator();\r\n                while (iterator.hasNext()) {\r\n                    Marker m = (Marker) iterator.next();\r\n                    m.removeChangeListener(this);\r\n                }\r\n                markers.clear();\r\n            }\r\n        }\r\n        if (this.foregroundRangeMarkers != null) {\r\n            Collection markers = (Collection) this.foregroundDomainMarkers.get(key);\r\n            if (markers != null) {\r\n                Iterator iterator = markers.iterator();\r\n                while (iterator.hasNext()) {\r\n                    Marker m = (Marker) iterator.next();\r\n                    m.removeChangeListener(this);\r\n                }\r\n                markers.clear();\r\n            }\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for a specific dataset/renderer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to the domain axis (that the renderer is mapped to), however this is\r\n     * entirely up to the renderer.\r\n     *\r\n     * @param index  the dataset/renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer (foreground or background).\r\n     *\r\n     * @see #clearDomainMarkers(int)\r\n     * @see #addRangeMarker(int, Marker, Layer)\r\n     */\r\n    public void addDomainMarker(int index, Marker marker, Layer layer) {\r\n        addDomainMarker(index, marker, layer, true);\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to the domain axis (that the renderer is mapped to), however this is\r\n     * entirely up to the renderer.\r\n     *\r\n     * @param index  the dataset/renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer (foreground or background).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public void addDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\r\n        if (marker == null) {\r\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\r\n        }\r\n        if (layer == null) {\r\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\r\n        }\r\n        Collection markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (Collection) this.foregroundDomainMarkers.get(new Integer(index));\r\n            if (markers == null) {\r\n                markers = new java.util.ArrayList();\r\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\r\n            }\r\n            markers.add(marker);\r\n        } else if (layer == Layer.BACKGROUND) {\r\n            markers = (Collection) this.backgroundDomainMarkers.get(new Integer(index));\r\n            if (markers == null) {\r\n                markers = new java.util.ArrayList();\r\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\r\n            }\r\n            markers.add(marker);\r\n        }\r\n        marker.addChangeListener(this);\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param marker  the marker.\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public boolean removeDomainMarker(Marker marker) {\r\n        return removeDomainMarker(marker, Layer.FOREGROUND);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for the domain axis in the specified layer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param marker the marker (<code>null</code> not permitted).\r\n     * @param layer the layer (foreground or background).\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\r\n        return removeDomainMarker(0, marker, layer);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for a specific dataset/renderer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index the dataset/renderer index.\r\n     * @param marker the marker.\r\n     * @param layer the layer (foreground or background).\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\r\n        return removeDomainMarker(index, marker, layer, true);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for a specific dataset/renderer and, if requested,\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index  the dataset/renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer (foreground or background).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\r\n        ArrayList markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(index));\r\n        } else {\r\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(index));\r\n        }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n        boolean removed = markers.remove(marker);\r\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for the range axis and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to the range axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param marker  the marker (<code>null</code> not permitted).\r\n     *\r\n     * @see #addRangeMarker(Marker, Layer)\r\n     */\r\n    public void addRangeMarker(Marker marker) {\r\n        addRangeMarker(marker, Layer.FOREGROUND);\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for the range axis in the specified layer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to the range axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param marker  the marker (<code>null</code> not permitted).\r\n     * @param layer  the layer (foreground or background).\r\n     *\r\n     * @see #addRangeMarker(int, Marker, Layer)\r\n     */\r\n    public void addRangeMarker(Marker marker, Layer layer) {\r\n        addRangeMarker(0, marker, layer);\r\n    }\r\n\r\n    /**\r\n     * Clears all the range markers and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @see #clearRangeMarkers()\r\n     */\r\n    public void clearRangeMarkers() {\r\n        if (this.backgroundRangeMarkers != null) {\r\n            Set keys = this.backgroundRangeMarkers.keySet();\r\n            Iterator iterator = keys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Integer key = (Integer) iterator.next();\r\n                clearRangeMarkers(key.intValue());\r\n            }\r\n            this.backgroundRangeMarkers.clear();\r\n        }\r\n        if (this.foregroundRangeMarkers != null) {\r\n            Set keys = this.foregroundRangeMarkers.keySet();\r\n            Iterator iterator = keys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Integer key = (Integer) iterator.next();\r\n                clearRangeMarkers(key.intValue());\r\n            }\r\n            this.foregroundRangeMarkers.clear();\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for a specific dataset/renderer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to the range axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param index  the dataset/renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer (foreground or background).\r\n     *\r\n     * @see #clearRangeMarkers(int)\r\n     * @see #addDomainMarker(int, Marker, Layer)\r\n     */\r\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\r\n        addRangeMarker(index, marker, layer, true);\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to the range axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param index  the dataset/renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer (foreground or background).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\r\n        Collection markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (Collection) this.foregroundRangeMarkers.get(new Integer(index));\r\n            if (markers == null) {\r\n                markers = new java.util.ArrayList();\r\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\r\n            }\r\n            markers.add(marker);\r\n        } else if (layer == Layer.BACKGROUND) {\r\n            markers = (Collection) this.backgroundRangeMarkers.get(new Integer(index));\r\n            if (markers == null) {\r\n                markers = new java.util.ArrayList();\r\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\r\n            }\r\n            markers.add(marker);\r\n        }\r\n        marker.addChangeListener(this);\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the (foreground and background) range markers for a particular\r\n     * renderer.\r\n     *\r\n     * @param index  the renderer index.\r\n     */\r\n    public void clearRangeMarkers(int index) {\r\n        Integer key = new Integer(index);\r\n        if (this.backgroundRangeMarkers != null) {\r\n            Collection markers = (Collection) this.backgroundRangeMarkers.get(key);\r\n            if (markers != null) {\r\n                Iterator iterator = markers.iterator();\r\n                while (iterator.hasNext()) {\r\n                    Marker m = (Marker) iterator.next();\r\n                    m.removeChangeListener(this);\r\n                }\r\n                markers.clear();\r\n            }\r\n        }\r\n        if (this.foregroundRangeMarkers != null) {\r\n            Collection markers = (Collection) this.foregroundRangeMarkers.get(key);\r\n            if (markers != null) {\r\n                Iterator iterator = markers.iterator();\r\n                while (iterator.hasNext()) {\r\n                    Marker m = (Marker) iterator.next();\r\n                    m.removeChangeListener(this);\r\n                }\r\n                markers.clear();\r\n            }\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param marker the marker.\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public boolean removeRangeMarker(Marker marker) {\r\n        return removeRangeMarker(marker, Layer.FOREGROUND);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for the range axis in the specified layer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param marker the marker (<code>null</code> not permitted).\r\n     * @param layer the layer (foreground or background).\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\r\n        return removeRangeMarker(0, marker, layer);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for a specific dataset/renderer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index the dataset/renderer index.\r\n     * @param marker the marker.\r\n     * @param layer the layer (foreground or background).\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\r\n        return removeRangeMarker(index, marker, layer, true);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for a specific dataset/renderer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index  the dataset/renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer (foreground or background).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\r\n        if (marker == null) {\r\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\r\n        }\r\n        ArrayList markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(index));\r\n        } else {\r\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(index));\r\n        }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n        boolean removed = markers.remove(marker);\r\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n\r\n    /**\r\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param annotation  the annotation (<code>null</code> not permitted).\r\n     *\r\n     * @see #getAnnotations()\r\n     * @see #removeAnnotation(XYAnnotation)\r\n     */\r\n    public void addAnnotation(XYAnnotation annotation) {\r\n        addAnnotation(annotation, true);\r\n    }\r\n\r\n    /**\r\n     * Adds an annotation to the plot and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param annotation  the annotation (<code>null</code> not permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public void addAnnotation(XYAnnotation annotation, boolean notify) {\r\n        if (annotation == null) {\r\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\r\n        }\r\n        this.annotations.add(annotation);\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param annotation  the annotation (<code>null</code> not permitted).\r\n     *\r\n     * @return A boolean (indicates whether or not the annotation was removed).\r\n     *\r\n     * @see #addAnnotation(XYAnnotation)\r\n     * @see #getAnnotations()\r\n     */\r\n    public boolean removeAnnotation(XYAnnotation annotation) {\r\n        return removeAnnotation(annotation, true);\r\n    }\r\n\r\n    /**\r\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param annotation  the annotation (<code>null</code> not permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @return A boolean (indicates whether or not the annotation was removed).\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public boolean removeAnnotation(XYAnnotation annotation, boolean notify) {\r\n        if (annotation == null) {\r\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\r\n        }\r\n        boolean removed = this.annotations.remove(annotation);\r\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n\r\n    /**\r\n     * Returns the list of annotations.\r\n     *\r\n     * @return The list of annotations.\r\n     *\r\n     * @since 1.0.1\r\n     *\r\n     * @see #addAnnotation(XYAnnotation)\r\n     */\r\n    public List getAnnotations() {\r\n        return new ArrayList(this.annotations);\r\n    }\r\n\r\n    /**\r\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @see #addAnnotation(XYAnnotation)\r\n     */\r\n    public void clearAnnotations() {\r\n        this.annotations.clear();\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Calculates the space required for all the axes in the plot.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the plot area.\r\n     *\r\n     * @return The required space.\r\n     */\r\n    protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea) {\r\n        AxisSpace space = new AxisSpace();\r\n        space = calculateDomainAxisSpace(g2, plotArea, space);\r\n        space = calculateRangeAxisSpace(g2, plotArea, space);\r\n        return space;\r\n    }\r\n\r\n    /**\r\n     * Calculates the space required for the domain axis/axes.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the plot area.\r\n     * @param space  a carrier for the result (<code>null</code> permitted).\r\n     *\r\n     * @return The required space.\r\n     */\r\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\r\n        if (space == null) {\r\n            space = new AxisSpace();\r\n        }\r\n        // reserve some space for the domain axis...\r\n        if (this.fixedDomainAxisSpace != null) {\r\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\r\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), RectangleEdge.RIGHT);\r\n            } else if (this.orientation == PlotOrientation.VERTICAL) {\r\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), RectangleEdge.TOP);\r\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), RectangleEdge.BOTTOM);\r\n            }\r\n        } else {\r\n            // reserve space for the domain axes...\r\n            for (int i = 0; i < this.domainAxes.size(); i++) {\r\n                Axis axis = (Axis) this.domainAxes.get(i);\r\n                if (axis != null) {\r\n                    RectangleEdge edge = getDomainAxisEdge(i);\r\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\r\n                }\r\n            }\r\n        }\r\n        return space;\r\n    }\r\n\r\n    /**\r\n     * Calculates the space required for the range axis/axes.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the plot area.\r\n     * @param space  a carrier for the result (<code>null</code> permitted).\r\n     *\r\n     * @return The required space.\r\n     */\r\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\r\n        if (space == null) {\r\n            space = new AxisSpace();\r\n        }\r\n        // reserve some space for the range axis...\r\n        if (this.fixedRangeAxisSpace != null) {\r\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), RectangleEdge.TOP);\r\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), RectangleEdge.BOTTOM);\r\n            } else if (this.orientation == PlotOrientation.VERTICAL) {\r\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), RectangleEdge.LEFT);\r\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), RectangleEdge.RIGHT);\r\n            }\r\n        } else {\r\n            // reserve space for the range axes...\r\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n                Axis axis = (Axis) this.rangeAxes.get(i);\r\n                if (axis != null) {\r\n                    RectangleEdge edge = getRangeAxisEdge(i);\r\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\r\n                }\r\n            }\r\n        }\r\n        return space;\r\n    }\r\n\r\n    /**\r\n     * Draws the plot within the specified area on a graphics device.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the plot area (in Java2D space).\r\n     * @param anchor  an anchor point in Java2D space (<code>null</code>\r\n     *                permitted).\r\n     * @param parentState  the state from the parent plot, if there is one\r\n     *                     (<code>null</code> permitted).\r\n     * @param info  collects chart drawing information (<code>null</code>\r\n     *              permitted).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info) {\r\n        // if the plot area is too small, just return...\r\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\r\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\r\n        if (b1 || b2) {\r\n            return;\r\n        }\r\n        // record the plot area...\r\n        if (info != null) {\r\n            info.setPlotArea(area);\r\n        }\r\n        // adjust the drawing area for the plot insets (if any)...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(area);\r\n        AxisSpace space = calculateAxisSpace(g2, area);\r\n        Rectangle2D dataArea = space.shrink(area, null);\r\n        this.axisOffset.trim(dataArea);\r\n        if (info != null) {\r\n            info.setDataArea(dataArea);\r\n        }\r\n        // draw the plot background and axes...\r\n        drawBackground(g2, dataArea);\r\n        Map axisStateMap = drawAxes(g2, area, dataArea, info);\r\n        PlotOrientation orient = getOrientation();\r\n        // the anchor point is typically the point where the mouse last\r\n        // clicked - the crosshairs will be driven off this point...\r\n        if (anchor != null && !dataArea.contains(anchor)) {\r\n            anchor = null;\r\n        }\r\n        CrosshairState crosshairState = new CrosshairState();\r\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\r\n        crosshairState.setAnchor(anchor);\r\n        crosshairState.setAnchorX(Double.NaN);\r\n        crosshairState.setAnchorY(Double.NaN);\r\n        if (anchor != null) {\r\n            ValueAxis domainAxis = getDomainAxis();\r\n            if (domainAxis != null) {\r\n                double x;\r\n                if (orient == PlotOrientation.VERTICAL) {\r\n                    x = domainAxis.java2DToValue(anchor.getX(), dataArea, getDomainAxisEdge());\r\n                } else {\r\n                    x = domainAxis.java2DToValue(anchor.getY(), dataArea, getDomainAxisEdge());\r\n                }\r\n                crosshairState.setAnchorX(x);\r\n            }\r\n            ValueAxis rangeAxis = getRangeAxis();\r\n            if (rangeAxis != null) {\r\n                double y;\r\n                if (orient == PlotOrientation.VERTICAL) {\r\n                    y = rangeAxis.java2DToValue(anchor.getY(), dataArea, getRangeAxisEdge());\r\n                } else {\r\n                    y = rangeAxis.java2DToValue(anchor.getX(), dataArea, getRangeAxisEdge());\r\n                }\r\n                crosshairState.setAnchorY(y);\r\n            }\r\n        }\r\n        crosshairState.setCrosshairX(getDomainCrosshairValue());\r\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\r\n        Shape originalClip = g2.getClip();\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.clip(dataArea);\r\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getForegroundAlpha()));\r\n        AxisState domainAxisState = (AxisState) axisStateMap.get(getDomainAxis());\r\n        if (domainAxisState == null) {\r\n            if (parentState != null) {\r\n                domainAxisState = (AxisState) parentState.getSharedAxisStates().get(getDomainAxis());\r\n            }\r\n        }\r\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\r\n        if (rangeAxisState == null) {\r\n            if (parentState != null) {\r\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates().get(getRangeAxis());\r\n            }\r\n        }\r\n        if (domainAxisState != null) {\r\n            drawDomainTickBands(g2, dataArea, domainAxisState.getTicks());\r\n        }\r\n        if (rangeAxisState != null) {\r\n            drawRangeTickBands(g2, dataArea, rangeAxisState.getTicks());\r\n        }\r\n        if (domainAxisState != null) {\r\n            drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());\r\n            drawZeroDomainBaseline(g2, dataArea);\r\n        }\r\n        if (rangeAxisState != null) {\r\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\r\n            drawZeroRangeBaseline(g2, dataArea);\r\n        }\r\n        // draw the markers that are associated with a specific renderer...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n        // now draw annotations and render data items...\r\n        boolean foundData = false;\r\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\r\n        if (order == DatasetRenderingOrder.FORWARD) {\r\n            // draw background annotations\r\n            int rendererCount = this.renderers.size();\r\n            for (int i = 0; i < rendererCount; i++) {\r\n                XYItemRenderer r = getRenderer(i);\r\n                if (r != null) {\r\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\r\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\r\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.BACKGROUND, info);\r\n                }\r\n            }\r\n            // render data items...\r\n            for (int i = 0; i < getDatasetCount(); i++) {\r\n                foundData = render(g2, dataArea, i, info, crosshairState) || foundData;\r\n            }\r\n            // draw foreground annotations\r\n            for (int i = 0; i < rendererCount; i++) {\r\n                XYItemRenderer r = getRenderer(i);\r\n                if (r != null) {\r\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\r\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\r\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.FOREGROUND, info);\r\n                }\r\n            }\r\n        } else if (order == DatasetRenderingOrder.REVERSE) {\r\n            // draw background annotations\r\n            int rendererCount = this.renderers.size();\r\n            for (int i = rendererCount - 1; i >= 0; i--) {\r\n                XYItemRenderer r = getRenderer(i);\r\n                if (i >= getDatasetCount()) {\r\n                    // we need the dataset to make\r\n                    // a link to the axes\r\n                    continue;\r\n                }\r\n                if (r != null) {\r\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\r\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\r\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.BACKGROUND, info);\r\n                }\r\n            }\r\n            for (int i = getDatasetCount() - 1; i >= 0; i--) {\r\n                foundData = render(g2, dataArea, i, info, crosshairState) || foundData;\r\n            }\r\n            // draw foreground annotations\r\n            for (int i = rendererCount - 1; i >= 0; i--) {\r\n                XYItemRenderer r = getRenderer(i);\r\n                if (i >= getDatasetCount()) {\r\n                    // we need the dataset to make\r\n                    // a link to the axes\r\n                    continue;\r\n                }\r\n                if (r != null) {\r\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\r\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\r\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.FOREGROUND, info);\r\n                }\r\n            }\r\n        }\r\n        // draw domain crosshair if required...\r\n        int xAxisIndex = crosshairState.getDomainAxisIndex();\r\n        ValueAxis xAxis = getDomainAxis(xAxisIndex);\r\n        RectangleEdge xAxisEdge = getDomainAxisEdge(xAxisIndex);\r\n        if (!this.domainCrosshairLockedOnData && anchor != null) {\r\n            double xx;\r\n            if (orient == PlotOrientation.VERTICAL) {\r\n                xx = xAxis.java2DToValue(anchor.getX(), dataArea, xAxisEdge);\r\n            } else {\r\n                xx = xAxis.java2DToValue(anchor.getY(), dataArea, xAxisEdge);\r\n            }\r\n            crosshairState.setCrosshairX(xx);\r\n        }\r\n        setDomainCrosshairValue(crosshairState.getCrosshairX(), false);\r\n        if (isDomainCrosshairVisible()) {\r\n            double x = getDomainCrosshairValue();\r\n            Paint paint = getDomainCrosshairPaint();\r\n            Stroke stroke = getDomainCrosshairStroke();\r\n            drawDomainCrosshair(g2, dataArea, orient, x, xAxis, stroke, paint);\r\n        }\r\n        // draw range crosshair if required...\r\n        int yAxisIndex = crosshairState.getRangeAxisIndex();\r\n        ValueAxis yAxis = getRangeAxis(yAxisIndex);\r\n        RectangleEdge yAxisEdge = getRangeAxisEdge(yAxisIndex);\r\n        if (!this.rangeCrosshairLockedOnData && anchor != null) {\r\n            double yy;\r\n            if (orient == PlotOrientation.VERTICAL) {\r\n                yy = yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\r\n            } else {\r\n                yy = yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\r\n            }\r\n            crosshairState.setCrosshairY(yy);\r\n        }\r\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\r\n        if (isRangeCrosshairVisible()) {\r\n            double y = getRangeCrosshairValue();\r\n            Paint paint = getRangeCrosshairPaint();\r\n            Stroke stroke = getRangeCrosshairStroke();\r\n            drawRangeCrosshair(g2, dataArea, orient, y, yAxis, stroke, paint);\r\n        }\r\n        if (!foundData) {\r\n            drawNoDataMessage(g2, dataArea);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        drawAnnotations(g2, dataArea, info);\r\n        g2.setClip(originalClip);\r\n        g2.setComposite(originalComposite);\r\n        drawOutline(g2, dataArea);\r\n    }\r\n\r\n    /**\r\n     * Draws the background for the plot.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area.\r\n     */\r\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\r\n        fillBackground(g2, area, this.orientation);\r\n        drawQuadrants(g2, area);\r\n        drawBackgroundImage(g2, area);\r\n    }\r\n\r\n    /**\r\n     * Draws the quadrants.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area.\r\n     *\r\n     * @see #setQuadrantOrigin(Point2D)\r\n     * @see #setQuadrantPaint(int, Paint)\r\n     */\r\n    protected void drawQuadrants(Graphics2D g2, Rectangle2D area) {\r\n        //  0 | 1\r\n        //  --+--\r\n        //  2 | 3\r\n        boolean somethingToDraw = false;\r\n        ValueAxis xAxis = getDomainAxis();\r\n        double x = xAxis.getRange().constrain(this.quadrantOrigin.getX());\r\n        double xx = xAxis.valueToJava2D(x, area, getDomainAxisEdge());\r\n        ValueAxis yAxis = getRangeAxis();\r\n        double y = yAxis.getRange().constrain(this.quadrantOrigin.getY());\r\n        double yy = yAxis.valueToJava2D(y, area, getRangeAxisEdge());\r\n        double xmin = xAxis.getLowerBound();\r\n        double xxmin = xAxis.valueToJava2D(xmin, area, getDomainAxisEdge());\r\n        double xmax = xAxis.getUpperBound();\r\n        double xxmax = xAxis.valueToJava2D(xmax, area, getDomainAxisEdge());\r\n        double ymin = yAxis.getLowerBound();\r\n        double yymin = yAxis.valueToJava2D(ymin, area, getRangeAxisEdge());\r\n        double ymax = yAxis.getUpperBound();\r\n        double yymax = yAxis.valueToJava2D(ymax, area, getRangeAxisEdge());\r\n        Rectangle2D[] r = new Rectangle2D[] { null, null, null, null };\r\n        if (this.quadrantPaint[0] != null) {\r\n            if (x > xmin && y < ymax) {\r\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                    r[0] = new Rectangle2D.Double(Math.min(yymax, yy), Math.min(xxmin, xx), Math.abs(yy - yymax), Math.abs(xx - xxmin));\r\n                } else {\r\n                    // PlotOrientation.VERTICAL\r\n                    r[0] = new Rectangle2D.Double(Math.min(xxmin, xx), Math.min(yymax, yy), Math.abs(xx - xxmin), Math.abs(yy - yymax));\r\n                }\r\n                somethingToDraw = true;\r\n            }\r\n        }\r\n        if (this.quadrantPaint[1] != null) {\r\n            if (x < xmax && y < ymax) {\r\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                    r[1] = new Rectangle2D.Double(Math.min(yymax, yy), Math.min(xxmax, xx), Math.abs(yy - yymax), Math.abs(xx - xxmax));\r\n                } else {\r\n                    // PlotOrientation.VERTICAL\r\n                    r[1] = new Rectangle2D.Double(Math.min(xx, xxmax), Math.min(yymax, yy), Math.abs(xx - xxmax), Math.abs(yy - yymax));\r\n                }\r\n                somethingToDraw = true;\r\n            }\r\n        }\r\n        if (this.quadrantPaint[2] != null) {\r\n            if (x > xmin && y > ymin) {\r\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                    r[2] = new Rectangle2D.Double(Math.min(yymin, yy), Math.min(xxmin, xx), Math.abs(yy - yymin), Math.abs(xx - xxmin));\r\n                } else {\r\n                    // PlotOrientation.VERTICAL\r\n                    r[2] = new Rectangle2D.Double(Math.min(xxmin, xx), Math.min(yymin, yy), Math.abs(xx - xxmin), Math.abs(yy - yymin));\r\n                }\r\n                somethingToDraw = true;\r\n            }\r\n        }\r\n        if (this.quadrantPaint[3] != null) {\r\n            if (x < xmax && y > ymin) {\r\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                    r[3] = new Rectangle2D.Double(Math.min(yymin, yy), Math.min(xxmax, xx), Math.abs(yy - yymin), Math.abs(xx - xxmax));\r\n                } else {\r\n                    // PlotOrientation.VERTICAL\r\n                    r[3] = new Rectangle2D.Double(Math.min(xx, xxmax), Math.min(yymin, yy), Math.abs(xx - xxmax), Math.abs(yy - yymin));\r\n                }\r\n                somethingToDraw = true;\r\n            }\r\n        }\r\n        if (somethingToDraw) {\r\n            Composite originalComposite = g2.getComposite();\r\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getBackgroundAlpha()));\r\n            for (int i = 0; i < 4; i++) {\r\n                if (this.quadrantPaint[i] != null && r[i] != null) {\r\n                    g2.setPaint(this.quadrantPaint[i]);\r\n                    g2.fill(r[i]);\r\n                }\r\n            }\r\n            g2.setComposite(originalComposite);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the domain tick bands, if any.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the data area.\r\n     * @param ticks  the ticks.\r\n     *\r\n     * @see #setDomainTickBandPaint(Paint)\r\n     */\r\n    public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks) {\r\n        Paint bandPaint = getDomainTickBandPaint();\r\n        if (bandPaint != null) {\r\n            boolean fillBand = false;\r\n            ValueAxis xAxis = getDomainAxis();\r\n            double previous = xAxis.getLowerBound();\r\n            Iterator iterator = ticks.iterator();\r\n            while (iterator.hasNext()) {\r\n                ValueTick tick = (ValueTick) iterator.next();\r\n                double current = tick.getValue();\r\n                if (fillBand) {\r\n                    getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea, previous, current);\r\n                }\r\n                previous = current;\r\n                fillBand = !fillBand;\r\n            }\r\n            double end = xAxis.getUpperBound();\r\n            if (fillBand) {\r\n                getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea, previous, end);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the range tick bands, if any.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the data area.\r\n     * @param ticks  the ticks.\r\n     *\r\n     * @see #setRangeTickBandPaint(Paint)\r\n     */\r\n    public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks) {\r\n        Paint bandPaint = getRangeTickBandPaint();\r\n        if (bandPaint != null) {\r\n            boolean fillBand = false;\r\n            ValueAxis axis = getRangeAxis();\r\n            double previous = axis.getLowerBound();\r\n            Iterator iterator = ticks.iterator();\r\n            while (iterator.hasNext()) {\r\n                ValueTick tick = (ValueTick) iterator.next();\r\n                double current = tick.getValue();\r\n                if (fillBand) {\r\n                    getRenderer().fillRangeGridBand(g2, this, axis, dataArea, previous, current);\r\n                }\r\n                previous = current;\r\n                fillBand = !fillBand;\r\n            }\r\n            double end = axis.getUpperBound();\r\n            if (fillBand) {\r\n                getRenderer().fillRangeGridBand(g2, this, axis, dataArea, previous, end);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A utility method for drawing the axes.\r\n     *\r\n     * @param g2  the graphics device (<code>null</code> not permitted).\r\n     * @param plotArea  the plot area (<code>null</code> not permitted).\r\n     * @param dataArea  the data area (<code>null</code> not permitted).\r\n     * @param plotState  collects information about the plot (<code>null</code>\r\n     *                   permitted).\r\n     *\r\n     * @return A map containing the state for each axis drawn.\r\n     */\r\n    protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) {\r\n        AxisCollection axisCollection = new AxisCollection();\r\n        // add domain axes to lists...\r\n        for (int index = 0; index < this.domainAxes.size(); index++) {\r\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(index);\r\n            if (axis != null) {\r\n                axisCollection.add(axis, getDomainAxisEdge(index));\r\n            }\r\n        }\r\n        // add range axes to lists...\r\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\r\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\r\n            if (yAxis != null) {\r\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\r\n            }\r\n        }\r\n        Map axisStateMap = new HashMap();\r\n        // draw the top axes\r\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(dataArea.getHeight());\r\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\r\n        while (iterator.hasNext()) {\r\n            ValueAxis axis = (ValueAxis) iterator.next();\r\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.TOP, plotState);\r\n            cursor = info.getCursor();\r\n            axisStateMap.put(axis, info);\r\n        }\r\n        // draw the bottom axes\r\n        cursor = dataArea.getMaxY() + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\r\n        iterator = axisCollection.getAxesAtBottom().iterator();\r\n        while (iterator.hasNext()) {\r\n            ValueAxis axis = (ValueAxis) iterator.next();\r\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.BOTTOM, plotState);\r\n            cursor = info.getCursor();\r\n            axisStateMap.put(axis, info);\r\n        }\r\n        // draw the left axes\r\n        cursor = dataArea.getMinX() - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\r\n        iterator = axisCollection.getAxesAtLeft().iterator();\r\n        while (iterator.hasNext()) {\r\n            ValueAxis axis = (ValueAxis) iterator.next();\r\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.LEFT, plotState);\r\n            cursor = info.getCursor();\r\n            axisStateMap.put(axis, info);\r\n        }\r\n        // draw the right axes\r\n        cursor = dataArea.getMaxX() + this.axisOffset.calculateRightOutset(dataArea.getWidth());\r\n        iterator = axisCollection.getAxesAtRight().iterator();\r\n        while (iterator.hasNext()) {\r\n            ValueAxis axis = (ValueAxis) iterator.next();\r\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.RIGHT, plotState);\r\n            cursor = info.getCursor();\r\n            axisStateMap.put(axis, info);\r\n        }\r\n        return axisStateMap;\r\n    }\r\n\r\n    /**\r\n     * Draws a representation of the data within the dataArea region, using the\r\n     * current renderer.\r\n     * <P>\r\n     * The <code>info</code> and <code>crosshairState</code> arguments may be\r\n     * <code>null</code>.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the region in which the data is to be drawn.\r\n     * @param index  the dataset index.\r\n     * @param info  an optional object for collection dimension information.\r\n     * @param crosshairState  collects crosshair information\r\n     *                        (<code>null</code> permitted).\r\n     *\r\n     * @return A flag that indicates whether any data was actually rendered.\r\n     */\r\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info, CrosshairState crosshairState) {\r\n        boolean foundData = false;\r\n        XYDataset dataset = getDataset(index);\r\n        if (!DatasetUtilities.isEmptyOrNull(dataset)) {\r\n            foundData = true;\r\n            ValueAxis xAxis = getDomainAxisForDataset(index);\r\n            ValueAxis yAxis = getRangeAxisForDataset(index);\r\n            XYItemRenderer renderer = getRenderer(index);\r\n            if (renderer == null) {\r\n                renderer = getRenderer();\r\n                if (renderer == null) {\r\n                    // no default renderer available\r\n                    return foundData;\r\n                }\r\n            }\r\n            XYItemRendererState state = renderer.initialise(g2, dataArea, this, dataset, info);\r\n            int passCount = renderer.getPassCount();\r\n            SeriesRenderingOrder seriesOrder = getSeriesRenderingOrder();\r\n            if (seriesOrder == SeriesRenderingOrder.REVERSE) {\r\n                //render series in reverse order\r\n                for (int pass = 0; pass < passCount; pass++) {\r\n                    int seriesCount = dataset.getSeriesCount();\r\n                    for (int series = seriesCount - 1; series >= 0; series--) {\r\n                        int firstItem = 0;\r\n                        int lastItem = dataset.getItemCount(series) - 1;\r\n                        if (lastItem == -1) {\r\n                            continue;\r\n                        }\r\n                        if (state.getProcessVisibleItemsOnly()) {\r\n                            int[] itemBounds = RendererUtilities.findLiveItems(dataset, series, xAxis.getLowerBound(), xAxis.getUpperBound());\r\n                            firstItem = itemBounds[0];\r\n                            lastItem = itemBounds[1];\r\n                        }\r\n                        for (int item = firstItem; item <= lastItem; item++) {\r\n                            renderer.drawItem(g2, state, dataArea, info, this, xAxis, yAxis, dataset, series, item, crosshairState, pass);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                //render series in forward order\r\n                for (int pass = 0; pass < passCount; pass++) {\r\n                    int seriesCount = dataset.getSeriesCount();\r\n                    for (int series = 0; series < seriesCount; series++) {\r\n                        int firstItem = 0;\r\n                        int lastItem = dataset.getItemCount(series) - 1;\r\n                        if (state.getProcessVisibleItemsOnly()) {\r\n                            int[] itemBounds = RendererUtilities.findLiveItems(dataset, series, xAxis.getLowerBound(), xAxis.getUpperBound());\r\n                            firstItem = itemBounds[0];\r\n                            lastItem = itemBounds[1];\r\n                        }\r\n                        for (int item = firstItem; item <= lastItem; item++) {\r\n                            renderer.drawItem(g2, state, dataArea, info, this, xAxis, yAxis, dataset, series, item, crosshairState, pass);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return foundData;\r\n    }\r\n\r\n    /**\r\n     * Returns the domain axis for a dataset.\r\n     *\r\n     * @param index  the dataset index.\r\n     *\r\n     * @return The axis.\r\n     */\r\n    public ValueAxis getDomainAxisForDataset(int index) {\r\n        if (index < 0 || index >= getDatasetCount()) {\r\n            throw new IllegalArgumentException(\"Index \" + index + \" out of bounds.\");\r\n        }\r\n        ValueAxis valueAxis = null;\r\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(new Integer(index));\r\n        if (axisIndex != null) {\r\n            valueAxis = getDomainAxis(axisIndex.intValue());\r\n        } else {\r\n            valueAxis = getDomainAxis(0);\r\n        }\r\n        return valueAxis;\r\n    }\r\n\r\n    /**\r\n     * Returns the range axis for a dataset.\r\n     *\r\n     * @param index  the dataset index.\r\n     *\r\n     * @return The axis.\r\n     */\r\n    public ValueAxis getRangeAxisForDataset(int index) {\r\n        if (index < 0 || index >= getDatasetCount()) {\r\n            throw new IllegalArgumentException(\"Index \" + index + \" out of bounds.\");\r\n        }\r\n        ValueAxis valueAxis = null;\r\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(new Integer(index));\r\n        if (axisIndex != null) {\r\n            valueAxis = getRangeAxis(axisIndex.intValue());\r\n        } else {\r\n            valueAxis = getRangeAxis(0);\r\n        }\r\n        return valueAxis;\r\n    }\r\n\r\n    /**\r\n     * Draws the gridlines for the plot, if they are visible.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the data area.\r\n     * @param ticks  the ticks.\r\n     *\r\n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\r\n     */\r\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks) {\r\n        // no renderer, no gridlines...\r\n        if (getRenderer() == null) {\r\n            return;\r\n        }\r\n        // draw the domain grid lines, if any...\r\n        if (isDomainGridlinesVisible()) {\r\n            Stroke gridStroke = getDomainGridlineStroke();\r\n            Paint gridPaint = getDomainGridlinePaint();\r\n            Iterator iterator = ticks.iterator();\r\n            while (iterator.hasNext()) {\r\n                ValueTick tick = (ValueTick) iterator.next();\r\n                getRenderer().drawDomainLine(g2, this, getDomainAxis(), dataArea, tick.getValue(), gridPaint, gridStroke);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the gridlines for the plot's primary range axis, if they are\r\n     * visible.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the data area.\r\n     * @param ticks  the ticks.\r\n     *\r\n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D, List)\r\n     */\r\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area, List ticks) {\r\n        // no renderer, no gridlines...\r\n        if (getRenderer() == null) {\r\n            return;\r\n        }\r\n        // draw the range grid lines, if any...\r\n        if (isRangeGridlinesVisible()) {\r\n            Stroke gridStroke = getRangeGridlineStroke();\r\n            Paint gridPaint = getRangeGridlinePaint();\r\n            ValueAxis axis = getRangeAxis();\r\n            if (axis != null) {\r\n                Iterator iterator = ticks.iterator();\r\n                while (iterator.hasNext()) {\r\n                    ValueTick tick = (ValueTick) iterator.next();\r\n                    if (tick.getValue() != 0.0 || !isRangeZeroBaselineVisible()) {\r\n                        getRenderer().drawRangeLine(g2, this, getRangeAxis(), area, tick.getValue(), gridPaint, gridStroke);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws a base line across the chart at value zero on the domain axis.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the data area.\r\n     *\r\n     * @see #setDomainZeroBaselineVisible(boolean)\r\n     *\r\n     * @since 1.0.5\r\n     */\r\n    protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area) {\r\n        if (isDomainZeroBaselineVisible()) {\r\n            XYItemRenderer r = getRenderer();\r\n            r.drawDomainLine(g2, this, getDomainAxis(), area, 0.0, this.domainZeroBaselinePaint, this.domainZeroBaselineStroke);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws a base line across the chart at value zero on the range axis.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the data area.\r\n     *\r\n     * @see #setRangeZeroBaselineVisible(boolean)\r\n     */\r\n    protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\r\n        if (isRangeZeroBaselineVisible()) {\r\n            getRenderer().drawRangeLine(g2, this, getRangeAxis(), area, 0.0, this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the annotations for the plot.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the data area.\r\n     * @param info  the chart rendering info.\r\n     */\r\n    public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info) {\r\n        Iterator iterator = this.annotations.iterator();\r\n        while (iterator.hasNext()) {\r\n            XYAnnotation annotation = (XYAnnotation) iterator.next();\r\n            ValueAxis xAxis = getDomainAxis();\r\n            ValueAxis yAxis = getRangeAxis();\r\n            annotation.draw(g2, this, dataArea, xAxis, yAxis, 0, info);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the domain markers (if any) for an axis and layer.  This method is\r\n     * typically called from within the draw() method.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the data area.\r\n     * @param index  the renderer index.\r\n     * @param layer  the layer (foreground or background).\r\n     */\r\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\r\n        XYItemRenderer r = getRenderer(index);\r\n        if (r == null) {\r\n            return;\r\n        }\r\n        // check that the renderer has a corresponding dataset (it doesn't\r\n        // matter if the dataset is null)\r\n        if (index >= getDatasetCount()) {\r\n            return;\r\n        }\r\n        Collection markers = getDomainMarkers(index, layer);\r\n        ValueAxis axis = getDomainAxisForDataset(index);\r\n        if (markers != null && axis != null) {\r\n            Iterator iterator = markers.iterator();\r\n            while (iterator.hasNext()) {\r\n                Marker marker = (Marker) iterator.next();\r\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the range markers (if any) for a renderer and layer.  This method\r\n     * is typically called from within the draw() method.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the data area.\r\n     * @param index  the renderer index.\r\n     * @param layer  the layer (foreground or background).\r\n     */\r\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\r\n        XYItemRenderer r = getRenderer(index);\r\n        if (r == null) {\r\n            return;\r\n        }\r\n        // check that the renderer has a corresponding dataset (it doesn't\r\n        // matter if the dataset is null)\r\n        if (index >= getDatasetCount()) {\r\n            return;\r\n        }\r\n        Collection markers = getRangeMarkers(index, layer);\r\n        ValueAxis axis = getRangeAxisForDataset(index);\r\n        if (markers != null && axis != null) {\r\n            Iterator iterator = markers.iterator();\r\n            while (iterator.hasNext()) {\r\n                Marker marker = (Marker) iterator.next();\r\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the list of domain markers (read only) for the specified layer.\r\n     *\r\n     * @param layer  the layer (foreground or background).\r\n     *\r\n     * @return The list of domain markers.\r\n     *\r\n     * @see #getRangeMarkers(Layer)\r\n     */\r\n    public Collection getDomainMarkers(Layer layer) {\r\n        return getDomainMarkers(0, layer);\r\n    }\r\n\r\n    /**\r\n     * Returns the list of range markers (read only) for the specified layer.\r\n     *\r\n     * @param layer  the layer (foreground or background).\r\n     *\r\n     * @return The list of range markers.\r\n     *\r\n     * @see #getDomainMarkers(Layer)\r\n     */\r\n    public Collection getRangeMarkers(Layer layer) {\r\n        return getRangeMarkers(0, layer);\r\n    }\r\n\r\n    /**\r\n     * Returns a collection of domain markers for a particular renderer and\r\n     * layer.\r\n     *\r\n     * @param index  the renderer index.\r\n     * @param layer  the layer.\r\n     *\r\n     * @return A collection of markers (possibly <code>null</code>).\r\n     *\r\n     * @see #getRangeMarkers(int, Layer)\r\n     */\r\n    public Collection getDomainMarkers(int index, Layer layer) {\r\n        Collection result = null;\r\n        Integer key = new Integer(index);\r\n        if (layer == Layer.FOREGROUND) {\r\n            result = (Collection) this.foregroundDomainMarkers.get(key);\r\n        } else if (layer == Layer.BACKGROUND) {\r\n            result = (Collection) this.backgroundDomainMarkers.get(key);\r\n        }\r\n        if (result != null) {\r\n            result = Collections.unmodifiableCollection(result);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a collection of range markers for a particular renderer and\r\n     * layer.\r\n     *\r\n     * @param index  the renderer index.\r\n     * @param layer  the layer.\r\n     *\r\n     * @return A collection of markers (possibly <code>null</code>).\r\n     *\r\n     * @see #getDomainMarkers(int, Layer)\r\n     */\r\n    public Collection getRangeMarkers(int index, Layer layer) {\r\n        Collection result = null;\r\n        Integer key = new Integer(index);\r\n        if (layer == Layer.FOREGROUND) {\r\n            result = (Collection) this.foregroundRangeMarkers.get(key);\r\n        } else if (layer == Layer.BACKGROUND) {\r\n            result = (Collection) this.backgroundRangeMarkers.get(key);\r\n        }\r\n        if (result != null) {\r\n            result = Collections.unmodifiableCollection(result);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Utility method for drawing a horizontal line across the data area of the\r\n     * plot.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the data area.\r\n     * @param value  the coordinate, where to draw the line.\r\n     * @param stroke  the stroke to use.\r\n     * @param paint  the paint to use.\r\n     */\r\n    protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) {\r\n        ValueAxis axis = getRangeAxis();\r\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\r\n            axis = getDomainAxis();\r\n        }\r\n        if (axis.getRange().contains(value)) {\r\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\r\n            Line2D line = new Line2D.Double(dataArea.getMinX(), yy, dataArea.getMaxX(), yy);\r\n            g2.setStroke(stroke);\r\n            g2.setPaint(paint);\r\n            g2.draw(line);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws a domain crosshair.\r\n     *\r\n     * @param g2  the graphics target.\r\n     * @param dataArea  the data area.\r\n     * @param orientation  the plot orientation.\r\n     * @param value  the crosshair value.\r\n     * @param axis  the axis against which the value is measured.\r\n     * @param stroke  the stroke used to draw the crosshair line.\r\n     * @param paint  the paint used to draw the crosshair line.\r\n     *\r\n     * @since 1.0.4\r\n     */\r\n    protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) {\r\n        if (axis.getRange().contains(value)) {\r\n            Line2D line = null;\r\n            if (orientation == PlotOrientation.VERTICAL) {\r\n                double xx = axis.valueToJava2D(value, dataArea, RectangleEdge.BOTTOM);\r\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, dataArea.getMaxY());\r\n            } else {\r\n                double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\r\n                line = new Line2D.Double(dataArea.getMinX(), yy, dataArea.getMaxX(), yy);\r\n            }\r\n            g2.setStroke(stroke);\r\n            g2.setPaint(paint);\r\n            g2.draw(line);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Utility method for drawing a vertical line on the data area of the plot.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the data area.\r\n     * @param value  the coordinate, where to draw the line.\r\n     * @param stroke  the stroke to use.\r\n     * @param paint  the paint to use.\r\n     */\r\n    protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) {\r\n        ValueAxis axis = getDomainAxis();\r\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\r\n            axis = getRangeAxis();\r\n        }\r\n        if (axis.getRange().contains(value)) {\r\n            double xx = axis.valueToJava2D(value, dataArea, RectangleEdge.BOTTOM);\r\n            Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx, dataArea.getMaxY());\r\n            g2.setStroke(stroke);\r\n            g2.setPaint(paint);\r\n            g2.draw(line);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws a range crosshair.\r\n     *\r\n     * @param g2  the graphics target.\r\n     * @param dataArea  the data area.\r\n     * @param orientation  the plot orientation.\r\n     * @param value  the crosshair value.\r\n     * @param axis  the axis against which the value is measured.\r\n     * @param stroke  the stroke used to draw the crosshair line.\r\n     * @param paint  the paint used to draw the crosshair line.\r\n     *\r\n     * @since 1.0.4\r\n     */\r\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) {\r\n        if (axis.getRange().contains(value)) {\r\n            Line2D line = null;\r\n            if (orientation == PlotOrientation.HORIZONTAL) {\r\n                double xx = axis.valueToJava2D(value, dataArea, RectangleEdge.BOTTOM);\r\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, dataArea.getMaxY());\r\n            } else {\r\n                double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\r\n                line = new Line2D.Double(dataArea.getMinX(), yy, dataArea.getMaxX(), yy);\r\n            }\r\n            g2.setStroke(stroke);\r\n            g2.setPaint(paint);\r\n            g2.draw(line);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles a 'click' on the plot by updating the anchor values.\r\n     *\r\n     * @param x  the x-coordinate, where the click occurred, in Java2D space.\r\n     * @param y  the y-coordinate, where the click occurred, in Java2D space.\r\n     * @param info  object containing information about the plot dimensions.\r\n     */\r\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\r\n        Rectangle2D dataArea = info.getDataArea();\r\n        if (dataArea.contains(x, y)) {\r\n            // set the anchor value for the horizontal axis...\r\n            ValueAxis da = getDomainAxis();\r\n            if (da != null) {\r\n                double hvalue = da.java2DToValue(x, info.getDataArea(), getDomainAxisEdge());\r\n                setDomainCrosshairValue(hvalue);\r\n            }\r\n            // set the anchor value for the vertical axis...\r\n            ValueAxis ra = getRangeAxis();\r\n            if (ra != null) {\r\n                double vvalue = ra.java2DToValue(y, info.getDataArea(), getRangeAxisEdge());\r\n                setRangeCrosshairValue(vvalue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A utility method that returns a list of datasets that are mapped to a\r\n     * particular axis.\r\n     *\r\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\r\n     *\r\n     * @return A list of datasets.\r\n     */\r\n    private List getDatasetsMappedToDomainAxis(Integer axisIndex) {\r\n        if (axisIndex == null) {\r\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\r\n        }\r\n        List result = new ArrayList();\r\n        for (int i = 0; i < this.datasets.size(); i++) {\r\n            Integer mappedAxis = (Integer) this.datasetToDomainAxisMap.get(new Integer(i));\r\n            if (mappedAxis == null) {\r\n                if (axisIndex.equals(ZERO)) {\r\n                    result.add(this.datasets.get(i));\r\n                }\r\n            } else {\r\n                if (mappedAxis.equals(axisIndex)) {\r\n                    result.add(this.datasets.get(i));\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * A utility method that returns a list of datasets that are mapped to a\r\n     * particular axis.\r\n     *\r\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\r\n     *\r\n     * @return A list of datasets.\r\n     */\r\n    private List getDatasetsMappedToRangeAxis(Integer axisIndex) {\r\n        if (axisIndex == null) {\r\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\r\n        }\r\n        List result = new ArrayList();\r\n        for (int i = 0; i < this.datasets.size(); i++) {\r\n            Integer mappedAxis = (Integer) this.datasetToRangeAxisMap.get(new Integer(i));\r\n            if (mappedAxis == null) {\r\n                if (axisIndex.equals(ZERO)) {\r\n                    result.add(this.datasets.get(i));\r\n                }\r\n            } else {\r\n                if (mappedAxis.equals(axisIndex)) {\r\n                    result.add(this.datasets.get(i));\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the given domain axis.\r\n     *\r\n     * @param axis  the axis.\r\n     *\r\n     * @return The axis index.\r\n     *\r\n     * @see #getRangeAxisIndex(ValueAxis)\r\n     */\r\n    public int getDomainAxisIndex(ValueAxis axis) {\r\n        int result = this.domainAxes.indexOf(axis);\r\n        if (result < 0) {\r\n            // try the parent plot\r\n            Plot parent = getParent();\r\n            if (parent instanceof XYPlot) {\r\n                XYPlot p = (XYPlot) parent;\r\n                result = p.getDomainAxisIndex(axis);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the given range axis.\r\n     *\r\n     * @param axis  the axis.\r\n     *\r\n     * @return The axis index.\r\n     *\r\n     * @see #getDomainAxisIndex(ValueAxis)\r\n     */\r\n    public int getRangeAxisIndex(ValueAxis axis) {\r\n        int result = this.rangeAxes.indexOf(axis);\r\n        if (result < 0) {\r\n            // try the parent plot\r\n            Plot parent = getParent();\r\n            if (parent instanceof XYPlot) {\r\n                XYPlot p = (XYPlot) parent;\r\n                result = p.getRangeAxisIndex(axis);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the range for the specified axis.\r\n     *\r\n     * @param axis  the axis.\r\n     *\r\n     * @return The range.\r\n     */\r\n    public Range getDataRange(ValueAxis axis) {\r\n        Range result = null;\r\n        List mappedDatasets = new ArrayList();\r\n        boolean isDomainAxis = true;\r\n        // is it a domain axis?\r\n        int domainIndex = getDomainAxisIndex(axis);\r\n        if (domainIndex >= 0) {\r\n            isDomainAxis = true;\r\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(new Integer(domainIndex)));\r\n        }\r\n        // or is it a range axis?\r\n        int rangeIndex = getRangeAxisIndex(axis);\r\n        if (rangeIndex >= 0) {\r\n            isDomainAxis = false;\r\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(new Integer(rangeIndex)));\r\n        }\r\n        // iterate through the datasets that map to the axis and get the union\r\n        // of the ranges.\r\n        Iterator iterator = mappedDatasets.iterator();\r\n        while (iterator.hasNext()) {\r\n            XYDataset d = (XYDataset) iterator.next();\r\n            if (d != null) {\r\n                XYItemRenderer r = getRendererForDataset(d);\r\n                if (isDomainAxis) {\r\n                    if (r != null) {\r\n                        result = Range.combine(result, r.findDomainBounds(d));\r\n                    } else {\r\n                        result = Range.combine(result, DatasetUtilities.findDomainBounds(d));\r\n                    }\r\n                } else {\r\n                    if (r != null) {\r\n                        result = Range.combine(result, r.findRangeBounds(d));\r\n                    } else {\r\n                        result = Range.combine(result, DatasetUtilities.findRangeBounds(d));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Receives notification of a change to the plot's dataset.\r\n     * <P>\r\n     * The axis ranges are updated if necessary.\r\n     *\r\n     * @param event  information about the event (not used here).\r\n     */\r\n    public void datasetChanged(DatasetChangeEvent event) {\r\n        configureDomainAxes();\r\n        configureRangeAxes();\r\n        if (getParent() != null) {\r\n            getParent().datasetChanged(event);\r\n        } else {\r\n            PlotChangeEvent e = new PlotChangeEvent(this);\r\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\r\n            notifyListeners(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Receives notification of a renderer change event.\r\n     *\r\n     * @param event  the event.\r\n     */\r\n    public void rendererChanged(RendererChangeEvent event) {\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns a flag indicating whether or not the domain crosshair is visible.\r\n     *\r\n     * @return The flag.\r\n     *\r\n     * @see #setDomainCrosshairVisible(boolean)\r\n     */\r\n    public boolean isDomainCrosshairVisible() {\r\n        return this.domainCrosshairVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag indicating whether or not the domain crosshair is visible\r\n     * and, if the flag changes, sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param flag  the new value of the flag.\r\n     *\r\n     * @see #isDomainCrosshairVisible()\r\n     */\r\n    public void setDomainCrosshairVisible(boolean flag) {\r\n        if (this.domainCrosshairVisible != flag) {\r\n            this.domainCrosshairVisible = flag;\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\r\n     * to actual data values.\r\n     *\r\n     * @return The flag.\r\n     *\r\n     * @see #setDomainCrosshairLockedOnData(boolean)\r\n     */\r\n    public boolean isDomainCrosshairLockedOnData() {\r\n        return this.domainCrosshairLockedOnData;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag indicating whether or not the domain crosshair should\r\n     * \"lock-on\" to actual data values.  If the flag value changes, this\r\n     * method sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param flag  the flag.\r\n     *\r\n     * @see #isDomainCrosshairLockedOnData()\r\n     */\r\n    public void setDomainCrosshairLockedOnData(boolean flag) {\r\n        if (this.domainCrosshairLockedOnData != flag) {\r\n            this.domainCrosshairLockedOnData = flag;\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the domain crosshair value.\r\n     *\r\n     * @return The value.\r\n     *\r\n     * @see #setDomainCrosshairValue(double)\r\n     */\r\n    public double getDomainCrosshairValue() {\r\n        return this.domainCrosshairValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the domain crosshair value and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners (provided that the domain crosshair is visible).\r\n     *\r\n     * @param value  the value.\r\n     *\r\n     * @see #getDomainCrosshairValue()\r\n     */\r\n    public void setDomainCrosshairValue(double value) {\r\n        setDomainCrosshairValue(value, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the domain crosshair value and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners (provided that the\r\n     * domain crosshair is visible).\r\n     *\r\n     * @param value  the new value.\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getDomainCrosshairValue()\r\n     */\r\n    public void setDomainCrosshairValue(double value, boolean notify) {\r\n        this.domainCrosshairValue = value;\r\n        if (isDomainCrosshairVisible() && notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link Stroke} used to draw the crosshair (if visible).\r\n     *\r\n     * @return The crosshair stroke (never <code>null</code>).\r\n     *\r\n     * @see #setDomainCrosshairStroke(Stroke)\r\n     * @see #isDomainCrosshairVisible()\r\n     * @see #getDomainCrosshairPaint()\r\n     */\r\n    public Stroke getDomainCrosshairStroke() {\r\n        return this.domainCrosshairStroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the Stroke used to draw the crosshairs (if visible) and notifies\r\n     * registered listeners that the axis has been modified.\r\n     *\r\n     * @param stroke  the new crosshair stroke (<code>null</code> not\r\n     *     permitted).\r\n     *\r\n     * @see #getDomainCrosshairStroke()\r\n     */\r\n    public void setDomainCrosshairStroke(Stroke stroke) {\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        this.domainCrosshairStroke = stroke;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the domain crosshair paint.\r\n     *\r\n     * @return The crosshair paint (never <code>null</code>).\r\n     *\r\n     * @see #setDomainCrosshairPaint(Paint)\r\n     * @see #isDomainCrosshairVisible()\r\n     * @see #getDomainCrosshairStroke()\r\n     */\r\n    public Paint getDomainCrosshairPaint() {\r\n        return this.domainCrosshairPaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint used to draw the crosshairs (if visible) and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\r\n     *\r\n     * @see #getDomainCrosshairPaint()\r\n     */\r\n    public void setDomainCrosshairPaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.domainCrosshairPaint = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns a flag indicating whether or not the range crosshair is visible.\r\n     *\r\n     * @return The flag.\r\n     *\r\n     * @see #setRangeCrosshairVisible(boolean)\r\n     * @see #isDomainCrosshairVisible()\r\n     */\r\n    public boolean isRangeCrosshairVisible() {\r\n        return this.rangeCrosshairVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag indicating whether or not the range crosshair is visible.\r\n     * If the flag value changes, this method sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param flag  the new value of the flag.\r\n     *\r\n     * @see #isRangeCrosshairVisible()\r\n     */\r\n    public void setRangeCrosshairVisible(boolean flag) {\r\n        if (this.rangeCrosshairVisible != flag) {\r\n            this.rangeCrosshairVisible = flag;\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\r\n     * to actual data values.\r\n     *\r\n     * @return The flag.\r\n     *\r\n     * @see #setRangeCrosshairLockedOnData(boolean)\r\n     */\r\n    public boolean isRangeCrosshairLockedOnData() {\r\n        return this.rangeCrosshairLockedOnData;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag indicating whether or not the range crosshair should\r\n     * \"lock-on\" to actual data values.  If the flag value changes, this method\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param flag  the flag.\r\n     *\r\n     * @see #isRangeCrosshairLockedOnData()\r\n     */\r\n    public void setRangeCrosshairLockedOnData(boolean flag) {\r\n        if (this.rangeCrosshairLockedOnData != flag) {\r\n            this.rangeCrosshairLockedOnData = flag;\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the range crosshair value.\r\n     *\r\n     * @return The value.\r\n     *\r\n     * @see #setRangeCrosshairValue(double)\r\n     */\r\n    public double getRangeCrosshairValue() {\r\n        return this.rangeCrosshairValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the range crosshair value.\r\n     * <P>\r\n     * Registered listeners are notified that the plot has been modified, but\r\n     * only if the crosshair is visible.\r\n     *\r\n     * @param value  the new value.\r\n     *\r\n     * @see #getRangeCrosshairValue()\r\n     */\r\n    public void setRangeCrosshairValue(double value) {\r\n        setRangeCrosshairValue(value, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the range crosshair value and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners, but only if the crosshair is visible.\r\n     *\r\n     * @param value  the new value.\r\n     * @param notify  a flag that controls whether or not listeners are\r\n     *                notified.\r\n     *\r\n     * @see #getRangeCrosshairValue()\r\n     */\r\n    public void setRangeCrosshairValue(double value, boolean notify) {\r\n        this.rangeCrosshairValue = value;\r\n        if (isRangeCrosshairVisible() && notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the stroke used to draw the crosshair (if visible).\r\n     *\r\n     * @return The crosshair stroke (never <code>null</code>).\r\n     *\r\n     * @see #setRangeCrosshairStroke(Stroke)\r\n     * @see #isRangeCrosshairVisible()\r\n     * @see #getRangeCrosshairPaint()\r\n     */\r\n    public Stroke getRangeCrosshairStroke() {\r\n        return this.rangeCrosshairStroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the stroke used to draw the crosshairs (if visible) and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param stroke  the new crosshair stroke (<code>null</code> not\r\n     *         permitted).\r\n     *\r\n     * @see #getRangeCrosshairStroke()\r\n     */\r\n    public void setRangeCrosshairStroke(Stroke stroke) {\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        this.rangeCrosshairStroke = stroke;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the range crosshair paint.\r\n     *\r\n     * @return The crosshair paint (never <code>null</code>).\r\n     *\r\n     * @see #setRangeCrosshairPaint(Paint)\r\n     * @see #isRangeCrosshairVisible()\r\n     * @see #getRangeCrosshairStroke()\r\n     */\r\n    public Paint getRangeCrosshairPaint() {\r\n        return this.rangeCrosshairPaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint used to color the crosshairs (if visible) and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\r\n     *\r\n     * @see #getRangeCrosshairPaint()\r\n     */\r\n    public void setRangeCrosshairPaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.rangeCrosshairPaint = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the fixed domain axis space.\r\n     *\r\n     * @return The fixed domain axis space (possibly <code>null</code>).\r\n     *\r\n     * @see #setFixedDomainAxisSpace(AxisSpace)\r\n     */\r\n    public AxisSpace getFixedDomainAxisSpace() {\r\n        return this.fixedDomainAxisSpace;\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param space  the space (<code>null</code> permitted).\r\n     *\r\n     * @see #getFixedDomainAxisSpace()\r\n     */\r\n    public void setFixedDomainAxisSpace(AxisSpace space) {\r\n        setFixedDomainAxisSpace(space, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed domain axis space and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param space  the space (<code>null</code> permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getFixedDomainAxisSpace()\r\n     *\r\n     * @since 1.0.9\r\n     */\r\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\r\n        this.fixedDomainAxisSpace = space;\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the fixed range axis space.\r\n     *\r\n     * @return The fixed range axis space (possibly <code>null</code>).\r\n     *\r\n     * @see #setFixedRangeAxisSpace(AxisSpace)\r\n     */\r\n    public AxisSpace getFixedRangeAxisSpace() {\r\n        return this.fixedRangeAxisSpace;\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param space  the space (<code>null</code> permitted).\r\n     *\r\n     * @see #getFixedRangeAxisSpace()\r\n     */\r\n    public void setFixedRangeAxisSpace(AxisSpace space) {\r\n        setFixedRangeAxisSpace(space, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed range axis space and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param space  the space (<code>null</code> permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getFixedRangeAxisSpace()\r\n     *\r\n     * @since 1.0.9\r\n     */\r\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\r\n        this.fixedRangeAxisSpace = space;\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Multiplies the range on the domain axis/axes by the specified factor.\r\n     *\r\n     * @param factor  the zoom factor.\r\n     * @param info  the plot rendering info.\r\n     * @param source  the source point (in Java2D space).\r\n     *\r\n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D)\r\n     */\r\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source) {\r\n        // delegate to other method\r\n        zoomDomainAxes(factor, info, source, false);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the range on the domain axis/axes by the specified factor.\r\n     *\r\n     * @param factor  the zoom factor.\r\n     * @param info  the plot rendering info.\r\n     * @param source  the source point (in Java2D space).\r\n     * @param useAnchor  use source point as zoom anchor?\r\n     *\r\n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\r\n        // perform the zoom on each domain axis\r\n        for (int i = 0; i < this.domainAxes.size(); i++) {\r\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\r\n            if (domainAxis != null) {\r\n                if (useAnchor) {\r\n                    // get the relevant source coordinate given the plot\r\n                    // orientation\r\n                    double sourceX = source.getX();\r\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                        sourceX = source.getY();\r\n                    }\r\n                    double anchorX = domainAxis.java2DToValue(sourceX, info.getDataArea(), getDomainAxisEdge());\r\n                    domainAxis.resizeRange(factor, anchorX);\r\n                } else {\r\n                    domainAxis.resizeRange(factor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Zooms in on the domain axis/axes.  The new lower and upper bounds are\r\n     * specified as percentages of the current axis range, where 0 percent is\r\n     * the current lower bound and 100 percent is the current upper bound.\r\n     *\r\n     * @param lowerPercent  a percentage that determines the new lower bound\r\n     *                      for the axis (e.g. 0.20 is twenty percent).\r\n     * @param upperPercent  a percentage that determines the new upper bound\r\n     *                      for the axis (e.g. 0.80 is eighty percent).\r\n     * @param info  the plot rendering info.\r\n     * @param source  the source point (ignored).\r\n     *\r\n     * @see #zoomRangeAxes(double, double, PlotRenderingInfo, Point2D)\r\n     */\r\n    public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source) {\r\n        for (int i = 0; i < this.domainAxes.size(); i++) {\r\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\r\n            if (domainAxis != null) {\r\n                domainAxis.zoomRange(lowerPercent, upperPercent);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Multiplies the range on the range axis/axes by the specified factor.\r\n     *\r\n     * @param factor  the zoom factor.\r\n     * @param info  the plot rendering info.\r\n     * @param source  the source point.\r\n     *\r\n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\r\n     */\r\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source) {\r\n        // delegate to other method\r\n        zoomRangeAxes(factor, info, source, false);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the range on the range axis/axes by the specified factor.\r\n     *\r\n     * @param factor  the zoom factor.\r\n     * @param info  the plot rendering info.\r\n     * @param source  the source point.\r\n     * @param useAnchor  a flag that controls whether or not the source point\r\n     *         is used for the zoom anchor.\r\n     *\r\n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\r\n        // perform the zoom on each range axis\r\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\r\n            if (rangeAxis != null) {\r\n                if (useAnchor) {\r\n                    // get the relevant source coordinate given the plot\r\n                    // orientation\r\n                    double sourceY = source.getY();\r\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                        sourceY = source.getX();\r\n                    }\r\n                    double anchorY = rangeAxis.java2DToValue(sourceY, info.getDataArea(), getRangeAxisEdge());\r\n                    rangeAxis.resizeRange(factor, anchorY);\r\n                } else {\r\n                    rangeAxis.resizeRange(factor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Zooms in on the range axes.\r\n     *\r\n     * @param lowerPercent  the lower bound.\r\n     * @param upperPercent  the upper bound.\r\n     * @param info  the plot rendering info.\r\n     * @param source  the source point.\r\n     *\r\n     * @see #zoomDomainAxes(double, double, PlotRenderingInfo, Point2D)\r\n     */\r\n    public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source) {\r\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\r\n            if (rangeAxis != null) {\r\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns <code>true</code>, indicating that the domain axis/axes for this\r\n     * plot are zoomable.\r\n     *\r\n     * @return A boolean.\r\n     *\r\n     * @see #isRangeZoomable()\r\n     */\r\n    public boolean isDomainZoomable() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns <code>true</code>, indicating that the range axis/axes for this\r\n     * plot are zoomable.\r\n     *\r\n     * @return A boolean.\r\n     *\r\n     * @see #isDomainZoomable()\r\n     */\r\n    public boolean isRangeZoomable() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of series in the primary dataset for this plot.  If\r\n     * the dataset is <code>null</code>, the method returns 0.\r\n     *\r\n     * @return The series count.\r\n     */\r\n    public int getSeriesCount() {\r\n        int result = 0;\r\n        XYDataset dataset = getDataset();\r\n        if (dataset != null) {\r\n            result = dataset.getSeriesCount();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the fixed legend items, if any.\r\n     *\r\n     * @return The legend items (possibly <code>null</code>).\r\n     *\r\n     * @see #setFixedLegendItems(LegendItemCollection)\r\n     */\r\n    public LegendItemCollection getFixedLegendItems() {\r\n        return this.fixedLegendItems;\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed legend items for the plot.  Leave this set to\r\n     * <code>null</code> if you prefer the legend items to be created\r\n     * automatically.\r\n     *\r\n     * @param items  the legend items (<code>null</code> permitted).\r\n     *\r\n     * @see #getFixedLegendItems()\r\n     */\r\n    public void setFixedLegendItems(LegendItemCollection items) {\r\n        this.fixedLegendItems = items;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the legend items for the plot.  Each legend item is generated by\r\n     * the plot's renderer, since the renderer is responsible for the visual\r\n     * representation of the data.\r\n     *\r\n     * @return The legend items.\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        if (this.fixedLegendItems != null) {\r\n            return this.fixedLegendItems;\r\n        }\r\n        LegendItemCollection result = new LegendItemCollection();\r\n        int count = this.datasets.size();\r\n        for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\r\n            XYDataset dataset = getDataset(datasetIndex);\r\n            if (dataset != null) {\r\n                XYItemRenderer renderer = getRenderer(datasetIndex);\r\n                if (renderer == null) {\r\n                    renderer = getRenderer(0);\r\n                }\r\n                if (renderer != null) {\r\n                    int seriesCount = dataset.getSeriesCount();\r\n                    for (int i = 0; i < seriesCount; i++) {\r\n                        if (renderer.isSeriesVisible(i) && renderer.isSeriesVisibleInLegend(i)) {\r\n                            LegendItem item = renderer.getLegendItem(datasetIndex, i);\r\n                            if (item != null) {\r\n                                result.add(item);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Tests this plot for equality with another object.\r\n     *\r\n     * @param obj  the object (<code>null</code> permitted).\r\n     *\r\n     * @return <code>true</code> or <code>false</code>.\r\n     */\r\n    public boolean equals(Object obj) {\r\n        if (obj == this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof XYPlot)) {\r\n            return false;\r\n        }\r\n        XYPlot that = (XYPlot) obj;\r\n        if (this.weight != that.weight) {\r\n            return false;\r\n        }\r\n        if (this.orientation != that.orientation) {\r\n            return false;\r\n        }\r\n        if (!this.domainAxes.equals(that.domainAxes)) {\r\n            return false;\r\n        }\r\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\r\n            return false;\r\n        }\r\n        if (this.rangeCrosshairLockedOnData != that.rangeCrosshairLockedOnData) {\r\n            return false;\r\n        }\r\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\r\n            return false;\r\n        }\r\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\r\n            return false;\r\n        }\r\n        if (this.domainZeroBaselineVisible != that.domainZeroBaselineVisible) {\r\n            return false;\r\n        }\r\n        if (this.rangeZeroBaselineVisible != that.rangeZeroBaselineVisible) {\r\n            return false;\r\n        }\r\n        if (this.domainCrosshairVisible != that.domainCrosshairVisible) {\r\n            return false;\r\n        }\r\n        if (this.domainCrosshairValue != that.domainCrosshairValue) {\r\n            return false;\r\n        }\r\n        if (this.domainCrosshairLockedOnData != that.domainCrosshairLockedOnData) {\r\n            return false;\r\n        }\r\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\r\n            return false;\r\n        }\r\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.rangeAxes, that.rangeAxes)) {\r\n            return false;\r\n        }\r\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, that.datasetToDomainAxisMap)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, that.datasetToRangeAxisMap)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, that.domainGridlineStroke)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.domainGridlinePaint, that.domainGridlinePaint)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, that.rangeGridlineStroke)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, that.rangeGridlinePaint)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.domainZeroBaselinePaint, that.domainZeroBaselinePaint)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.domainZeroBaselineStroke, that.domainZeroBaselineStroke)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.rangeZeroBaselinePaint, that.rangeZeroBaselinePaint)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.rangeZeroBaselineStroke, that.rangeZeroBaselineStroke)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.domainCrosshairStroke, that.domainCrosshairStroke)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.domainCrosshairPaint, that.domainCrosshairPaint)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, that.rangeCrosshairStroke)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, that.rangeCrosshairPaint)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, that.foregroundDomainMarkers)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, that.backgroundDomainMarkers)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, that.foregroundRangeMarkers)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, that.backgroundRangeMarkers)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, that.foregroundDomainMarkers)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, that.backgroundDomainMarkers)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, that.foregroundRangeMarkers)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, that.backgroundRangeMarkers)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.domainTickBandPaint, that.domainTickBandPaint)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.rangeTickBandPaint, that.rangeTickBandPaint)) {\r\n            return false;\r\n        }\r\n        if (!this.quadrantOrigin.equals(that.quadrantOrigin)) {\r\n            return false;\r\n        }\r\n        for (int i = 0; i < 4; i++) {\r\n            if (!PaintUtilities.equal(this.quadrantPaint[i], that.quadrantPaint[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return super.equals(obj);\r\n    }\r\n\r\n    /**\r\n     * Returns a clone of the plot.\r\n     *\r\n     * @return A clone.\r\n     *\r\n     * @throws CloneNotSupportedException  this can occur if some component of\r\n     *         the plot cannot be cloned.\r\n     */\r\n    public Object clone() throws CloneNotSupportedException {\r\n        XYPlot clone = (XYPlot) super.clone();\r\n        clone.domainAxes = (ObjectList) ObjectUtilities.clone(this.domainAxes);\r\n        for (int i = 0; i < this.domainAxes.size(); i++) {\r\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\r\n            if (axis != null) {\r\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\r\n                clone.domainAxes.set(i, clonedAxis);\r\n                clonedAxis.setPlot(clone);\r\n                clonedAxis.addChangeListener(clone);\r\n            }\r\n        }\r\n        clone.domainAxisLocations = (ObjectList) this.domainAxisLocations.clone();\r\n        clone.rangeAxes = (ObjectList) ObjectUtilities.clone(this.rangeAxes);\r\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\r\n            if (axis != null) {\r\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\r\n                clone.rangeAxes.set(i, clonedAxis);\r\n                clonedAxis.setPlot(clone);\r\n                clonedAxis.addChangeListener(clone);\r\n            }\r\n        }\r\n        clone.rangeAxisLocations = (ObjectList) ObjectUtilities.clone(this.rangeAxisLocations);\r\n        // the datasets are not cloned, but listeners need to be added...\r\n        clone.datasets = (ObjectList) ObjectUtilities.clone(this.datasets);\r\n        for (int i = 0; i < clone.datasets.size(); ++i) {\r\n            XYDataset d = getDataset(i);\r\n            if (d != null) {\r\n                d.addChangeListener(clone);\r\n            }\r\n        }\r\n        clone.datasetToDomainAxisMap = new TreeMap();\r\n        clone.datasetToDomainAxisMap.putAll(this.datasetToDomainAxisMap);\r\n        clone.datasetToRangeAxisMap = new TreeMap();\r\n        clone.datasetToRangeAxisMap.putAll(this.datasetToRangeAxisMap);\r\n        clone.renderers = (ObjectList) ObjectUtilities.clone(this.renderers);\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            XYItemRenderer renderer2 = (XYItemRenderer) this.renderers.get(i);\r\n            if (renderer2 instanceof PublicCloneable) {\r\n                PublicCloneable pc = (PublicCloneable) renderer2;\r\n                clone.renderers.set(i, pc.clone());\r\n            }\r\n        }\r\n        clone.foregroundDomainMarkers = (Map) ObjectUtilities.clone(this.foregroundDomainMarkers);\r\n        clone.backgroundDomainMarkers = (Map) ObjectUtilities.clone(this.backgroundDomainMarkers);\r\n        clone.foregroundRangeMarkers = (Map) ObjectUtilities.clone(this.foregroundRangeMarkers);\r\n        clone.backgroundRangeMarkers = (Map) ObjectUtilities.clone(this.backgroundRangeMarkers);\r\n        clone.annotations = (List) ObjectUtilities.deepClone(this.annotations);\r\n        if (this.fixedDomainAxisSpace != null) {\r\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(this.fixedDomainAxisSpace);\r\n        }\r\n        if (this.fixedRangeAxisSpace != null) {\r\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(this.fixedRangeAxisSpace);\r\n        }\r\n        clone.quadrantOrigin = (Point2D) ObjectUtilities.clone(this.quadrantOrigin);\r\n        clone.quadrantPaint = (Paint[]) this.quadrantPaint.clone();\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Provides serialization support.\r\n     *\r\n     * @param stream  the output stream.\r\n     *\r\n     * @throws IOException  if there is an I/O error.\r\n     */\r\n    private void writeObject(ObjectOutputStream stream) throws IOException {\r\n        stream.defaultWriteObject();\r\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\r\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\r\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\r\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\r\n        SerialUtilities.writeStroke(this.rangeZeroBaselineStroke, stream);\r\n        SerialUtilities.writePaint(this.rangeZeroBaselinePaint, stream);\r\n        SerialUtilities.writeStroke(this.domainCrosshairStroke, stream);\r\n        SerialUtilities.writePaint(this.domainCrosshairPaint, stream);\r\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\r\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\r\n        SerialUtilities.writePaint(this.domainTickBandPaint, stream);\r\n        SerialUtilities.writePaint(this.rangeTickBandPaint, stream);\r\n        SerialUtilities.writePoint2D(this.quadrantOrigin, stream);\r\n        for (int i = 0; i < 4; i++) {\r\n            SerialUtilities.writePaint(this.quadrantPaint[i], stream);\r\n        }\r\n        SerialUtilities.writeStroke(this.domainZeroBaselineStroke, stream);\r\n        SerialUtilities.writePaint(this.domainZeroBaselinePaint, stream);\r\n    }\r\n\r\n    /**\r\n     * Provides serialization support.\r\n     *\r\n     * @param stream  the input stream.\r\n     *\r\n     * @throws IOException  if there is an I/O error.\r\n     * @throws ClassNotFoundException  if there is a classpath problem.\r\n     */\r\n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\r\n        stream.defaultReadObject();\r\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\r\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\r\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\r\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\r\n        this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream);\r\n        this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream);\r\n        this.domainCrosshairStroke = SerialUtilities.readStroke(stream);\r\n        this.domainCrosshairPaint = SerialUtilities.readPaint(stream);\r\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\r\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\r\n        this.domainTickBandPaint = SerialUtilities.readPaint(stream);\r\n        this.rangeTickBandPaint = SerialUtilities.readPaint(stream);\r\n        this.quadrantOrigin = SerialUtilities.readPoint2D(stream);\r\n        this.quadrantPaint = new Paint[4];\r\n        for (int i = 0; i < 4; i++) {\r\n            this.quadrantPaint[i] = SerialUtilities.readPaint(stream);\r\n        }\r\n        this.domainZeroBaselineStroke = SerialUtilities.readStroke(stream);\r\n        this.domainZeroBaselinePaint = SerialUtilities.readPaint(stream);\r\n        // register the plot as a listener with its axes, datasets, and\r\n        // renderers...\r\n        int domainAxisCount = this.domainAxes.size();\r\n        for (int i = 0; i < domainAxisCount; i++) {\r\n            Axis axis = (Axis) this.domainAxes.get(i);\r\n            if (axis != null) {\r\n                axis.setPlot(this);\r\n                axis.addChangeListener(this);\r\n            }\r\n        }\r\n        int rangeAxisCount = this.rangeAxes.size();\r\n        for (int i = 0; i < rangeAxisCount; i++) {\r\n            Axis axis = (Axis) this.rangeAxes.get(i);\r\n            if (axis != null) {\r\n                axis.setPlot(this);\r\n                axis.addChangeListener(this);\r\n            }\r\n        }\r\n        int datasetCount = this.datasets.size();\r\n        for (int i = 0; i < datasetCount; i++) {\r\n            Dataset dataset = (Dataset) this.datasets.get(i);\r\n            if (dataset != null) {\r\n                dataset.addChangeListener(this);\r\n            }\r\n        }\r\n        int rendererCount = this.renderers.size();\r\n        for (int i = 0; i < rendererCount; i++) {\r\n            XYItemRenderer renderer = (XYItemRenderer) this.renderers.get(i);\r\n            if (renderer != null) {\r\n                renderer.addChangeListener(this);\r\n            }\r\n        }\r\n    }\r\n}", "content:source_class_code_imports": ["import java.awt.AlphaComposite;", "import java.awt.BasicStroke;", "import java.awt.Color;", "import java.awt.Composite;", "import java.awt.Graphics2D;", "import java.awt.Paint;", "import java.awt.Shape;", "import java.awt.Stroke;", "import java.awt.geom.Line2D;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.io.IOException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.io.Serializable;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.HashMap;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.ResourceBundle;", "import java.util.Set;", "import java.util.TreeMap;", "import org.jfree.chart.LegendItem;", "import org.jfree.chart.LegendItemCollection;", "import org.jfree.chart.annotations.XYAnnotation;", "import org.jfree.chart.axis.Axis;", "import org.jfree.chart.axis.AxisCollection;", "import org.jfree.chart.axis.AxisLocation;", "import org.jfree.chart.axis.AxisSpace;", "import org.jfree.chart.axis.AxisState;", "import org.jfree.chart.axis.ValueAxis;", "import org.jfree.chart.axis.ValueTick;", "import org.jfree.chart.event.ChartChangeEventType;", "import org.jfree.chart.event.PlotChangeEvent;", "import org.jfree.chart.event.RendererChangeEvent;", "import org.jfree.chart.event.RendererChangeListener;", "import org.jfree.chart.renderer.RendererUtilities;", "import org.jfree.chart.renderer.xy.XYItemRenderer;", "import org.jfree.chart.renderer.xy.XYItemRendererState;", "import org.jfree.chart.util.Layer;", "import org.jfree.chart.util.ObjectList;", "import org.jfree.chart.util.ObjectUtilities;", "import org.jfree.chart.util.PaintUtilities;", "import org.jfree.chart.util.PublicCloneable;", "import org.jfree.chart.util.RectangleEdge;", "import org.jfree.chart.util.RectangleInsets;", "import org.jfree.chart.util.SerialUtilities;", "import org.jfree.data.Range;", "import org.jfree.data.general.Dataset;", "import org.jfree.data.general.DatasetChangeEvent;", "import org.jfree.data.general.DatasetUtilities;", "import org.jfree.data.xy.XYDataset;"], "content:source_class_code_path": "D:\\try\\ut4\\d4j_fixed_projects\\Chart_14_fixed\\source\\org\\jfree\\chart\\plot\\XYPlot.java", "content:source_class_code_signature": "org.jfree.chart.plot#XYPlot | addRangeMarker(int, Marker, Layer) | getDomainAxis() | setRangeCrosshairValue(double, boolean) | isRangeCrosshairVisible() | getQuadrantPaint(int) | addRangeMarker(Marker, Layer) | setWeight(int) | removeRangeMarker(int, Marker, Layer) | getDataset() | getAnnotations() | getRangeAxisEdge(int) | setDomainGridlineStroke(Stroke) | getDatasetRenderingOrder() | isDomainZeroBaselineVisible() | drawRangeTickBands(Graphics2D, Rectangle2D, List) | setQuadrantPaint(int, Paint) | setDomainCrosshairVisible(boolean) | getDomainMarkers(Layer) | removeRangeMarker(Marker) | getDomainMarkers(int, Layer) | getFixedRangeAxisSpace() | isDomainZoomable() | rendererChanged(RendererChangeEvent) | clearDomainMarkers(int) | getIndexOf(XYItemRenderer) | getDomainCrosshairPaint() | getRangeAxisLocation(int) | clearAnnotations() | getDataRange(ValueAxis) | setRangeAxisLocation(AxisLocation) | setDataset(XYDataset) | zoomDomainAxes(double, PlotRenderingInfo, Point2D) | setRangeAxis(ValueAxis) | getFixedDomainAxisSpace() | setRangeAxisLocation(AxisLocation, boolean) | setDomainCrosshairLockedOnData(boolean) | getRangeAxisCount() | setDataset(int, XYDataset) | getAxisOffset() | getDatasetCount() | addDomainMarker(int, Marker, Layer) | setRangeZeroBaselineStroke(Stroke) | setRangeGridlinesVisible(boolean) | getRangeAxis() | setOrientation(PlotOrientation) | getDomainGridlinePaint() | getRangeAxis(int) | setRenderer(XYItemRenderer) | getRangeZeroBaselineStroke() | setDomainAxisLocation(AxisLocation, boolean) | isRangeZeroBaselineVisible() | setFixedRangeAxisSpace(AxisSpace) | getOrientation() | getWeight() | removeRangeMarker(Marker, Layer) | zoomDomainAxes(double, double, PlotRenderingInfo, Point2D) | getDomainZeroBaselinePaint() | getDomainAxisIndex(ValueAxis) | removeDomainMarker(Marker) | removeDomainMarker(Marker, Layer) | addDomainMarker(int, Marker, Layer, boolean) | setFixedDomainAxisSpace(AxisSpace) | getRangeCrosshairValue() | getRangeCrosshairPaint() | zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean) | isRangeZoomable() | getDomainZeroBaselineStroke() | getRangeCrosshairStroke() | getDomainGridlineStroke() | getRangeGridlinePaint() | getDomainTickBandPaint() | isDomainCrosshairLockedOnData() | setRangeAxes(ValueAxis[]) | indexOf(XYDataset) | getDomainAxisCount() | setDomainGridlinesVisible(boolean) | getRangeAxisIndex(ValueAxis) | setDomainAxis(int, ValueAxis) | getFixedLegendItems() | isDomainGridlinesVisible() | setRangeZeroBaselinePaint(Paint) | setDomainAxis(int, ValueAxis, boolean) | setFixedLegendItems(LegendItemCollection) | clearRangeAxes() | drawAnnotations(Graphics2D, Rectangle2D, PlotRenderingInfo) | setRangeTickBandPaint(Paint) | getRendererForDataset(XYDataset) | getLegendItems() | clearDomainAxes() | removeAnnotation(XYAnnotation) | clearRangeMarkers(int) | setRangeCrosshairLockedOnData(boolean) | getRangeMarkers(Layer) | addRangeMarker(int, Marker, Layer, boolean) | removeDomainMarker(int, Marker, Layer, boolean) | setRangeCrosshairVisible(boolean) | setRangeZeroBaselineVisible(boolean) | setRangeGridlinePaint(Paint) | getRangeZeroBaselinePaint() | clone() | isRangeCrosshairLockedOnData() | addDomainMarker(Marker) | zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean) | setDomainAxisLocation(int, AxisLocation) | removeDomainMarker(int, Marker, Layer) | setRenderers(XYItemRenderer[]) | setFixedDomainAxisSpace(AxisSpace, boolean) | clearDomainMarkers() | getDomainAxisLocation(int) | setFixedRangeAxisSpace(AxisSpace, boolean) | draw(Graphics2D, Rectangle2D, Point2D, PlotState, PlotRenderingInfo) | setDomainAxis(ValueAxis) | mapDatasetToDomainAxis(int, int) | addAnnotation(XYAnnotation) | setRangeAxisLocation(int, AxisLocation) | isDomainCrosshairVisible() | setDomainZeroBaselinePaint(Paint) | getRangeMarkers(int, Layer) | setDomainCrosshairValue(double, boolean) | clearRangeMarkers() | getPlotType() | getRangeGridlineStroke() | setRangeAxisLocation(int, AxisLocation, boolean) | configureDomainAxes() | setDatasetRenderingOrder(DatasetRenderingOrder) | getDomainAxisLocation() | setRangeAxis(int, ValueAxis) | setRangeCrosshairPaint(Paint) | isRangeGridlinesVisible() | getRenderer() | setDomainAxisLocation(AxisLocation) | getRangeAxisEdge() | zoomRangeAxes(double, PlotRenderingInfo, Point2D) | setRangeGridlineStroke(Stroke) | XYPlot() | getDomainAxis(int) | addDomainMarker(Marker, Layer) | drawBackground(Graphics2D, Rectangle2D) | getRangeTickBandPaint() | getSeriesRenderingOrder() | getSeriesCount() | removeAnnotation(XYAnnotation, boolean) | zoomRangeAxes(double, double, PlotRenderingInfo, Point2D) | getRangeAxisForDataset(int) | getDomainCrosshairValue() | setAxisOffset(RectangleInsets) | removeRangeMarker(int, Marker, Layer, boolean) | getQuadrantOrigin() | drawDomainTickBands(Graphics2D, Rectangle2D, List) | setDomainCrosshairValue(double) | getDomainAxisForDataset(int) | render(Graphics2D, Rectangle2D, int, PlotRenderingInfo, CrosshairState) | setDomainCrosshairStroke(Stroke) | getRangeAxisLocation() | setRangeAxis(int, ValueAxis, boolean) | setDomainZeroBaselineStroke(Stroke) | getDataset(int) | datasetChanged(DatasetChangeEvent) | setDomainZeroBaselineVisible(boolean) | setRangeCrosshairValue(double) | mapDatasetToRangeAxis(int, int) | equals(Object) | getRenderer(int) | configureRangeAxes() | handleClick(int, int, PlotRenderingInfo) | setQuadrantOrigin(Point2D) | getDomainCrosshairStroke() | setSeriesRenderingOrder(SeriesRenderingOrder) | addAnnotation(XYAnnotation, boolean) | setDomainCrosshairPaint(Paint) | setRenderer(int, XYItemRenderer, boolean) | setDomainAxes(ValueAxis[]) | getDomainAxisEdge(int) | setDomainGridlinePaint(Paint) | setRangeCrosshairStroke(Stroke) | getDomainAxisEdge() | setDomainAxisLocation(int, AxisLocation, boolean) | setDomainTickBandPaint(Paint) | setRenderer(int, XYItemRenderer) | addRangeMarker(Marker) | XYPlot(XYDataset, ValueAxis, ValueAxis, XYItemRenderer)", "content:source_class_constructors": ["public XYPlot();", "public XYPlot(XYDataset dataset, ValueAxis domainAxis, ValueAxis rangeAxis, XYItemRenderer renderer);"], "content:source_class_define": "public class XYPlot extends Plot implements ValueAxisPlot, Zoomable, RendererChangeListener, Cloneable, PublicCloneable, Serializable;", "content:source_class_name": "XYPlot", "errorList": [], "extra:language": "Java", "extra:project_name": "Chart_14_fixed", "rowKey": "4ca4b6e6d2b5b9af26d50feab7d5db28", "source:source_method_code_format": "public boolean removeRangeMarker(Marker marker) {\r\n    return removeRangeMarker(marker, Layer.FOREGROUND);\r\n}", "source:source_method_comment": "/**\r\n * Removes a marker for the range axis and sends a {@link PlotChangeEvent}\r\n * to all registered listeners.\r\n *\r\n * @param marker the marker.\r\n *\r\n * @return A boolean indicating whether or not the marker was actually\r\n *         removed.\r\n *\r\n * @since 1.0.7\r\n */\r\n <innerComment> ", "source:source_method_name": "removeRangeMarker", "source:source_method_return_type_class_constructors": [], "source:source_method_signature": "org.jfree.chart.plot#XYPlot#removeRangeMarker(org.jfree.chart.plot#Marker)", "source:source_other_method_signature": ["public void addRangeMarker(int index, Marker marker, Layer layer);", "public ValueAxis getDomainAxis();", "public void setRangeCrosshairValue(double value, boolean notify);", "public boolean isRangeCrosshairVisible();", "public Paint getQuadrantPaint(int index);", "public void addRangeMarker(Marker marker, Layer layer);", "public void setWeight(int weight);", "public boolean removeRangeMarker(int index, Marker marker, Layer layer);", "public XYDataset getDataset();", "public List getAnnotations();", "public RectangleEdge getRangeAxisEdge(int index);", "public void setDomainGridlineStroke(Stroke stroke);", "public DatasetRenderingOrder getDatasetRenderingOrder();", "private void writeObject(ObjectOutputStream stream) throws IOException;", "public boolean isDomainZeroBaselineVisible();", "public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks);", "public void setQuadrantPaint(int index, Paint paint);", "public void setDomainCrosshairVisible(boolean flag);", "public Collection getDomainMarkers(Layer layer);", "public Collection getDomainMarkers(int index, Layer layer);", "public AxisSpace getFixedRangeAxisSpace();", "public boolean isDomainZoomable();", "public void rendererChanged(RendererChangeEvent event);", "public void clearDomainMarkers(int index);", "public int getIndexOf(XYItemRenderer renderer);", "public Paint getDomainCrosshairPaint();", "public AxisLocation getRangeAxisLocation(int index);", "public void clearAnnotations();", "public Range getDataRange(ValueAxis axis);", "public void setRangeAxisLocation(AxisLocation location);", "public void setDataset(XYDataset dataset);", "public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source);", "public void setRangeAxis(ValueAxis axis);", "public AxisSpace getFixedDomainAxisSpace();", "public void setRangeAxisLocation(AxisLocation location, boolean notify);", "public void setDomainCrosshairLockedOnData(boolean flag);", "public int getRangeAxisCount();", "public void setDataset(int index, XYDataset dataset);", "public RectangleInsets getAxisOffset();", "public int getDatasetCount();", "public void addDomainMarker(int index, Marker marker, Layer layer);", "public void setRangeZeroBaselineStroke(Stroke stroke);", "public void setRangeGridlinesVisible(boolean visible);", "public ValueAxis getRangeAxis();", "public void setOrientation(PlotOrientation orientation);", "public Paint getDomainGridlinePaint();", "public ValueAxis getRangeAxis(int index);", "public void setRenderer(XYItemRenderer renderer);", "public Stroke getRangeZeroBaselineStroke();", "public void setDomainAxisLocation(AxisLocation location, boolean notify);", "public boolean isRangeZeroBaselineVisible();", "public void setFixedRangeAxisSpace(AxisSpace space);", "public PlotOrientation getOrientation();", "public int getWeight();", "public boolean removeRangeMarker(Marker marker, Layer layer);", "public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source);", "public Paint getDomainZeroBaselinePaint();", "public int getDomainAxisIndex(ValueAxis axis);", "protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer);", "public boolean removeDomainMarker(Marker marker);", "public boolean removeDomainMarker(Marker marker, Layer layer);", "public void addDomainMarker(int index, Marker marker, Layer layer, boolean notify);", "public void setFixedDomainAxisSpace(AxisSpace space);", "public double getRangeCrosshairValue();", "public Paint getRangeCrosshairPaint();", "public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor);", "public boolean isRangeZoomable();", "public Stroke getDomainZeroBaselineStroke();", "public Stroke getRangeCrosshairStroke();", "public Stroke getDomainGridlineStroke();", "public Paint getRangeGridlinePaint();", "public Paint getDomainTickBandPaint();", "public boolean isDomainCrosshairLockedOnData();", "public void setRangeAxes(ValueAxis[] axes);", "protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area);", "public int indexOf(XYDataset dataset);", "public int getDomainAxisCount();", "public void setDomainGridlinesVisible(boolean visible);", "public int getRangeAxisIndex(ValueAxis axis);", "public void setDomainAxis(int index, ValueAxis axis);", "protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area);", "public LegendItemCollection getFixedLegendItems();", "protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint);", "public boolean isDomainGridlinesVisible();", "public void setRangeZeroBaselinePaint(Paint paint);", "public void setDomainAxis(int index, ValueAxis axis, boolean notify);", "public void setFixedLegendItems(LegendItemCollection items);", "public void clearRangeAxes();", "public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info);", "public void setRangeTickBandPaint(Paint paint);", "public XYItemRenderer getRendererForDataset(XYDataset dataset);", "protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea);", "protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer);", "public LegendItemCollection getLegendItems();", "public void clearDomainAxes();", "public boolean removeAnnotation(XYAnnotation annotation);", "public void clearRangeMarkers(int index);", "private List getDatasetsMappedToRangeAxis(Integer axisIndex);", "public void setRangeCrosshairLockedOnData(boolean flag);", "public Collection getRangeMarkers(Layer layer);", "public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify);", "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify);", "public void setRangeCrosshairVisible(boolean flag);", "public void setRangeZeroBaselineVisible(boolean visible);", "public void setRangeGridlinePaint(Paint paint);", "public Paint getRangeZeroBaselinePaint();", "public Object clone() throws CloneNotSupportedException;", "public boolean isRangeCrosshairLockedOnData();", "public void addDomainMarker(Marker marker);", "public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor);", "public void setDomainAxisLocation(int index, AxisLocation location);", "public boolean removeDomainMarker(int index, Marker marker, Layer layer);", "public void setRenderers(XYItemRenderer[] renderers);", "protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint);", "public void setFixedDomainAxisSpace(AxisSpace space, boolean notify);", "public void clearDomainMarkers();", "public AxisLocation getDomainAxisLocation(int index);", "public void setFixedRangeAxisSpace(AxisSpace space, boolean notify);", "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info);", "public void setDomainAxis(ValueAxis axis);", "public void mapDatasetToDomainAxis(int index, int axisIndex);", "public void addAnnotation(XYAnnotation annotation);", "public void setRangeAxisLocation(int index, AxisLocation location);", "public boolean isDomainCrosshairVisible();", "public void setDomainZeroBaselinePaint(Paint paint);", "public Collection getRangeMarkers(int index, Layer layer);", "public void setDomainCrosshairValue(double value, boolean notify);", "public void clearRangeMarkers();", "protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks);", "public String getPlotType();", "public Stroke getRangeGridlineStroke();", "public void setRangeAxisLocation(int index, AxisLocation location, boolean notify);", "public void configureDomainAxes();", "public void setDatasetRenderingOrder(DatasetRenderingOrder order);", "public AxisLocation getDomainAxisLocation();", "public void setRangeAxis(int index, ValueAxis axis);", "public void setRangeCrosshairPaint(Paint paint);", "public boolean isRangeGridlinesVisible();", "public XYItemRenderer getRenderer();", "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException;", "public void setDomainAxisLocation(AxisLocation location);", "public RectangleEdge getRangeAxisEdge();", "public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source);", "public void setRangeGridlineStroke(Stroke stroke);", "public XYPlot();", "public ValueAxis getDomainAxis(int index);", "public void addDomainMarker(Marker marker, Layer layer);", "public void drawBackground(Graphics2D g2, Rectangle2D area);", "public Paint getRangeTickBandPaint();", "public SeriesRenderingOrder getSeriesRenderingOrder();", "public int getSeriesCount();", "public boolean removeAnnotation(XYAnnotation annotation, boolean notify);", "public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source);", "public ValueAxis getRangeAxisForDataset(int index);", "public double getDomainCrosshairValue();", "protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint);", "public void setAxisOffset(RectangleInsets offset);", "public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify);", "public Point2D getQuadrantOrigin();", "public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea, List ticks);", "public void setDomainCrosshairValue(double value);", "public ValueAxis getDomainAxisForDataset(int index);", "public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info, CrosshairState crosshairState);", "public void setDomainCrosshairStroke(Stroke stroke);", "public AxisLocation getRangeAxisLocation();", "public void setRangeAxis(int index, ValueAxis axis, boolean notify);", "public void setDomainZeroBaselineStroke(Stroke stroke);", "public XYDataset getDataset(int index);", "private List getDatasetsMappedToDomainAxis(Integer axisIndex);", "protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint);", "public void datasetChanged(DatasetChangeEvent event);", "public void setDomainZeroBaselineVisible(boolean visible);", "public void setRangeCrosshairValue(double value);", "public void mapDatasetToRangeAxis(int index, int axisIndex);", "public boolean equals(Object obj);", "protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState);", "protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space);", "public XYItemRenderer getRenderer(int index);", "protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space);", "public void configureRangeAxes();", "public void handleClick(int x, int y, PlotRenderingInfo info);", "public void setQuadrantOrigin(Point2D origin);", "public Stroke getDomainCrosshairStroke();", "public void setSeriesRenderingOrder(SeriesRenderingOrder order);", "public void addAnnotation(XYAnnotation annotation, boolean notify);", "public void setDomainCrosshairPaint(Paint paint);", "public void setRenderer(int index, XYItemRenderer renderer, boolean notify);", "public void setDomainAxes(ValueAxis[] axes);", "public RectangleEdge getDomainAxisEdge(int index);", "protected void drawQuadrants(Graphics2D g2, Rectangle2D area);", "public void setDomainGridlinePaint(Paint paint);", "public void setRangeCrosshairStroke(Stroke stroke);", "public RectangleEdge getDomainAxisEdge();", "public void setDomainAxisLocation(int index, AxisLocation location, boolean notify);", "public void setDomainTickBandPaint(Paint paint);", "public void setRenderer(int index, XYItemRenderer renderer);", "public void addRangeMarker(Marker marker);", "protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area, List ticks);", "public XYPlot(XYDataset dataset, ValueAxis domainAxis, ValueAxis rangeAxis, XYItemRenderer renderer);"], "sourceMethodExistNonEn": "false", "testMethodCodeFormat": [], "testMethodExistNonEn": [], "testMethodSignature": [], "bytecode_signature": "org.jfree.chart.plot.XYPlot.removeRangeMarker(Lorg/jfree/chart/plot/Marker;)Z"}
{"content:callee_code": ["public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\r\n    return removeDomainMarker(index, marker, layer, true);\r\n}"], "content:callee_signature": ["org.jfree.chart.plot#CategoryPlot#removeDomainMarker(java.lang#Integer, org.jfree.chart.plot#Marker, org.jfree.chart.util#Layer)"], "content:parameter_class_code": ["public abstract class Marker implements Cloneable, Serializable {\r\n\r\n    /**\r\n     * For serialization.\r\n     */\r\n    private static final long serialVersionUID = -734389651405327166L;\r\n\r\n    /**\r\n     * The paint.\r\n     */\r\n    private transient Paint paint;\r\n\r\n    /**\r\n     * The stroke.\r\n     */\r\n    private transient Stroke stroke;\r\n\r\n    /**\r\n     * The outline paint.\r\n     */\r\n    private transient Paint outlinePaint;\r\n\r\n    /**\r\n     * The outline stroke.\r\n     */\r\n    private transient Stroke outlineStroke;\r\n\r\n    /**\r\n     * The alpha transparency.\r\n     */\r\n    private float alpha;\r\n\r\n    /**\r\n     * The label.\r\n     */\r\n    private String label = null;\r\n\r\n    /**\r\n     * The label font.\r\n     */\r\n    private Font labelFont;\r\n\r\n    /**\r\n     * The label paint.\r\n     */\r\n    private transient Paint labelPaint;\r\n\r\n    /**\r\n     * The label position.\r\n     */\r\n    private RectangleAnchor labelAnchor;\r\n\r\n    /**\r\n     * The text anchor for the label.\r\n     */\r\n    private TextAnchor labelTextAnchor;\r\n\r\n    /**\r\n     * The label offset from the marker rectangle.\r\n     */\r\n    private RectangleInsets labelOffset;\r\n\r\n    /**\r\n     * The offset type for the domain or range axis (never <code>null</code>).\r\n     */\r\n    private LengthAdjustmentType labelOffsetType;\r\n\r\n    /**\r\n     * Storage for registered change listeners.\r\n     */\r\n    private transient EventListenerList listenerList;\r\n\r\n    /**\r\n     * Creates a new marker with default attributes.\r\n     */\r\n    protected Marker() {\r\n        this(Color.gray);\r\n    }\r\n\r\n    /**\r\n     * Constructs a new marker.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     */\r\n    protected Marker(Paint paint) {\r\n        this(paint, new BasicStroke(0.5f), Color.gray, new BasicStroke(0.5f), 0.80f);\r\n    }\r\n\r\n    /**\r\n     * Constructs a new marker.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     * @param stroke  the stroke (<code>null</code> not permitted).\r\n     * @param outlinePaint  the outline paint (<code>null</code> permitted).\r\n     * @param outlineStroke  the outline stroke (<code>null</code> permitted).\r\n     * @param alpha  the alpha transparency (must be in the range 0.0f to\r\n     *     1.0f).\r\n     *\r\n     * @throws IllegalArgumentException if <code>paint</code> or\r\n     *     <code>stroke</code> is <code>null</code>, or <code>alpha</code> is\r\n     *     not in the specified range.\r\n     */\r\n    protected Marker(Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        if (alpha < 0.0f || alpha > 1.0f)\r\n            throw new IllegalArgumentException(\"The 'alpha' value must be in the range 0.0f to 1.0f\");\r\n        this.paint = paint;\r\n        this.stroke = stroke;\r\n        this.outlinePaint = outlinePaint;\r\n        this.outlineStroke = outlineStroke;\r\n        this.alpha = alpha;\r\n        this.labelFont = new Font(\"SansSerif\", Font.PLAIN, 9);\r\n        this.labelPaint = Color.black;\r\n        this.labelAnchor = RectangleAnchor.TOP_LEFT;\r\n        this.labelOffset = new RectangleInsets(3.0, 3.0, 3.0, 3.0);\r\n        this.labelOffsetType = LengthAdjustmentType.CONTRACT;\r\n        this.labelTextAnchor = TextAnchor.CENTER;\r\n        this.listenerList = new EventListenerList();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint.\r\n     *\r\n     * @return The paint (never <code>null</code>).\r\n     *\r\n     * @see #setPaint(Paint)\r\n     */\r\n    public Paint getPaint() {\r\n        return this.paint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint and sends a {@link MarkerChangeEvent} to all registered\r\n     * listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     *\r\n     * @see #getPaint()\r\n     */\r\n    public void setPaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.paint = paint;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the stroke.\r\n     *\r\n     * @return The stroke (never <code>null</code>).\r\n     *\r\n     * @see #setStroke(Stroke)\r\n     */\r\n    public Stroke getStroke() {\r\n        return this.stroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the stroke and sends a {@link MarkerChangeEvent} to all registered\r\n     * listeners.\r\n     *\r\n     * @param stroke  the stroke (<code>null</code> not permitted).\r\n     *\r\n     * @see #getStroke()\r\n     */\r\n    public void setStroke(Stroke stroke) {\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        this.stroke = stroke;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the outline paint.\r\n     *\r\n     * @return The outline paint (possibly <code>null</code>).\r\n     *\r\n     * @see #setOutlinePaint(Paint)\r\n     */\r\n    public Paint getOutlinePaint() {\r\n        return this.outlinePaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the outline paint and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> permitted).\r\n     *\r\n     * @see #getOutlinePaint()\r\n     */\r\n    public void setOutlinePaint(Paint paint) {\r\n        this.outlinePaint = paint;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the outline stroke.\r\n     *\r\n     * @return The outline stroke (possibly <code>null</code>).\r\n     *\r\n     * @see #setOutlineStroke(Stroke)\r\n     */\r\n    public Stroke getOutlineStroke() {\r\n        return this.outlineStroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the outline stroke and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param stroke  the stroke (<code>null</code> permitted).\r\n     *\r\n     * @see #getOutlineStroke()\r\n     */\r\n    public void setOutlineStroke(Stroke stroke) {\r\n        this.outlineStroke = stroke;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the alpha transparency.\r\n     *\r\n     * @return The alpha transparency.\r\n     *\r\n     * @see #setAlpha(float)\r\n     */\r\n    public float getAlpha() {\r\n        return this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Sets the alpha transparency that should be used when drawing the\r\n     * marker, and sends a {@link MarkerChangeEvent} to all registered\r\n     * listeners.  The alpha transparency is a value in the range 0.0f\r\n     * (completely transparent) to 1.0f (completely opaque).\r\n     *\r\n     * @param alpha  the alpha transparency (must be in the range 0.0f to\r\n     *     1.0f).\r\n     *\r\n     * @throws IllegalArgumentException if <code>alpha</code> is not in the\r\n     *     specified range.\r\n     *\r\n     * @see #getAlpha()\r\n     */\r\n    public void setAlpha(float alpha) {\r\n        if (alpha < 0.0f || alpha > 1.0f)\r\n            throw new IllegalArgumentException(\"The 'alpha' value must be in the range 0.0f to 1.0f\");\r\n        this.alpha = alpha;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label (if <code>null</code> no label is displayed).\r\n     *\r\n     * @return The label (possibly <code>null</code>).\r\n     *\r\n     * @see #setLabel(String)\r\n     */\r\n    public String getLabel() {\r\n        return this.label;\r\n    }\r\n\r\n    /**\r\n     * Sets the label (if <code>null</code> no label is displayed) and sends a\r\n     * {@link MarkerChangeEvent} to all registered listeners.\r\n     *\r\n     * @param label  the label (<code>null</code> permitted).\r\n     *\r\n     * @see #getLabel()\r\n     */\r\n    public void setLabel(String label) {\r\n        this.label = label;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label font.\r\n     *\r\n     * @return The label font (never <code>null</code>).\r\n     *\r\n     * @see #setLabelFont(Font)\r\n     */\r\n    public Font getLabelFont() {\r\n        return this.labelFont;\r\n    }\r\n\r\n    /**\r\n     * Sets the label font and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param font  the font (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelFont()\r\n     */\r\n    public void setLabelFont(Font font) {\r\n        if (font == null) {\r\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\r\n        }\r\n        this.labelFont = font;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label paint.\r\n     *\r\n     * @return The label paint (never </code>null</code>).\r\n     *\r\n     * @see #setLabelPaint(Paint)\r\n     */\r\n    public Paint getLabelPaint() {\r\n        return this.labelPaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the label paint and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelPaint()\r\n     */\r\n    public void setLabelPaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.labelPaint = paint;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label anchor.  This defines the position of the label\r\n     * anchor, relative to the bounds of the marker.\r\n     *\r\n     * @return The label anchor (never <code>null</code>).\r\n     *\r\n     * @see #setLabelAnchor(RectangleAnchor)\r\n     */\r\n    public RectangleAnchor getLabelAnchor() {\r\n        return this.labelAnchor;\r\n    }\r\n\r\n    /**\r\n     * Sets the label anchor and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.  The anchor defines the position of the label\r\n     * anchor, relative to the bounds of the marker.\r\n     *\r\n     * @param anchor  the anchor (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelAnchor()\r\n     */\r\n    public void setLabelAnchor(RectangleAnchor anchor) {\r\n        if (anchor == null) {\r\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\r\n        }\r\n        this.labelAnchor = anchor;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label offset.\r\n     *\r\n     * @return The label offset (never <code>null</code>).\r\n     *\r\n     * @see #setLabelOffset(RectangleInsets)\r\n     */\r\n    public RectangleInsets getLabelOffset() {\r\n        return this.labelOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the label offset and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param offset  the label offset (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelOffset()\r\n     */\r\n    public void setLabelOffset(RectangleInsets offset) {\r\n        if (offset == null) {\r\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\r\n        }\r\n        this.labelOffset = offset;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label offset type.\r\n     *\r\n     * @return The type (never <code>null</code>).\r\n     *\r\n     * @see #setLabelOffsetType(LengthAdjustmentType)\r\n     */\r\n    public LengthAdjustmentType getLabelOffsetType() {\r\n        return this.labelOffsetType;\r\n    }\r\n\r\n    /**\r\n     * Sets the label offset type and sends a {@link MarkerChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param adj  the type (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelOffsetType()\r\n     */\r\n    public void setLabelOffsetType(LengthAdjustmentType adj) {\r\n        if (adj == null) {\r\n            throw new IllegalArgumentException(\"Null 'adj' argument.\");\r\n        }\r\n        this.labelOffsetType = adj;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Returns the label text anchor.\r\n     *\r\n     * @return The label text anchor (never <code>null</code>).\r\n     *\r\n     * @see #setLabelTextAnchor(TextAnchor)\r\n     */\r\n    public TextAnchor getLabelTextAnchor() {\r\n        return this.labelTextAnchor;\r\n    }\r\n\r\n    /**\r\n     * Sets the label text anchor and sends a {@link MarkerChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param anchor  the label text anchor (<code>null</code> not permitted).\r\n     *\r\n     * @see #getLabelTextAnchor()\r\n     */\r\n    public void setLabelTextAnchor(TextAnchor anchor) {\r\n        if (anchor == null) {\r\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\r\n        }\r\n        this.labelTextAnchor = anchor;\r\n        notifyListeners(new MarkerChangeEvent(this));\r\n    }\r\n\r\n    /**\r\n     * Registers an object for notification of changes to the marker.\r\n     *\r\n     * @param listener  the object to be registered.\r\n     *\r\n     * @see #removeChangeListener(MarkerChangeListener)\r\n     *\r\n     * @since 1.0.3\r\n     */\r\n    public void addChangeListener(MarkerChangeListener listener) {\r\n        this.listenerList.add(MarkerChangeListener.class, listener);\r\n    }\r\n\r\n    /**\r\n     * Unregisters an object for notification of changes to the marker.\r\n     *\r\n     * @param listener  the object to be unregistered.\r\n     *\r\n     * @see #addChangeListener(MarkerChangeListener)\r\n     *\r\n     * @since 1.0.3\r\n     */\r\n    public void removeChangeListener(MarkerChangeListener listener) {\r\n        this.listenerList.remove(MarkerChangeListener.class, listener);\r\n    }\r\n\r\n    /**\r\n     * Notifies all registered listeners that the marker has been modified.\r\n     *\r\n     * @param event  information about the change event.\r\n     *\r\n     * @since 1.0.3\r\n     */\r\n    public void notifyListeners(MarkerChangeEvent event) {\r\n        Object[] listeners = this.listenerList.getListenerList();\r\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\r\n            if (listeners[i] == MarkerChangeListener.class) {\r\n                ((MarkerChangeListener) listeners[i + 1]).markerChanged(event);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing all the listeners of the specified type.\r\n     *\r\n     * @param listenerType  the listener type.\r\n     *\r\n     * @return The array of listeners.\r\n     *\r\n     * @since 1.0.3\r\n     */\r\n    public EventListener[] getListeners(Class listenerType) {\r\n        return this.listenerList.getListeners(listenerType);\r\n    }\r\n\r\n    /**\r\n     * Tests the marker for equality with an arbitrary object.\r\n     *\r\n     * @param obj  the object (<code>null</code> permitted).\r\n     *\r\n     * @return A boolean.\r\n     */\r\n    public boolean equals(Object obj) {\r\n        if (obj == this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof Marker)) {\r\n            return false;\r\n        }\r\n        Marker that = (Marker) obj;\r\n        if (!PaintUtilities.equal(this.paint, that.paint)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.stroke, that.stroke)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.outlinePaint, that.outlinePaint)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.outlineStroke, that.outlineStroke)) {\r\n            return false;\r\n        }\r\n        if (this.alpha != that.alpha) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.label, that.label)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.labelFont, that.labelFont)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.labelPaint, that.labelPaint)) {\r\n            return false;\r\n        }\r\n        if (this.labelAnchor != that.labelAnchor) {\r\n            return false;\r\n        }\r\n        if (this.labelTextAnchor != that.labelTextAnchor) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.labelOffset, that.labelOffset)) {\r\n            return false;\r\n        }\r\n        if (!this.labelOffsetType.equals(that.labelOffsetType)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a clone of the marker.\r\n     *\r\n     * @return A clone.\r\n     *\r\n     * @throws CloneNotSupportedException never.\r\n     */\r\n    public Object clone() throws CloneNotSupportedException {\r\n        return super.clone();\r\n    }\r\n\r\n    /**\r\n     * Provides serialization support.\r\n     *\r\n     * @param stream  the output stream.\r\n     *\r\n     * @throws IOException  if there is an I/O error.\r\n     */\r\n    private void writeObject(ObjectOutputStream stream) throws IOException {\r\n        stream.defaultWriteObject();\r\n        SerialUtilities.writePaint(this.paint, stream);\r\n        SerialUtilities.writeStroke(this.stroke, stream);\r\n        SerialUtilities.writePaint(this.outlinePaint, stream);\r\n        SerialUtilities.writeStroke(this.outlineStroke, stream);\r\n        SerialUtilities.writePaint(this.labelPaint, stream);\r\n    }\r\n\r\n    /**\r\n     * Provides serialization support.\r\n     *\r\n     * @param stream  the input stream.\r\n     *\r\n     * @throws IOException  if there is an I/O error.\r\n     * @throws ClassNotFoundException  if there is a classpath problem.\r\n     */\r\n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\r\n        stream.defaultReadObject();\r\n        this.paint = SerialUtilities.readPaint(stream);\r\n        this.stroke = SerialUtilities.readStroke(stream);\r\n        this.outlinePaint = SerialUtilities.readPaint(stream);\r\n        this.outlineStroke = SerialUtilities.readStroke(stream);\r\n        this.labelPaint = SerialUtilities.readPaint(stream);\r\n        this.listenerList = new EventListenerList();\r\n    }\r\n}\n\n", "public final class Layer implements Serializable {\n\n    /**\n     * For serialization.\n     */\n    private static final long serialVersionUID = -1470104570733183430L;\n\n    /**\n     * Foreground.\n     */\n    public static final Layer FOREGROUND = new Layer(\"Layer.FOREGROUND\");\n\n    /**\n     * Background.\n     */\n    public static final Layer BACKGROUND = new Layer(\"Layer.BACKGROUND\");\n\n    /**\n     * The name.\n     */\n    private String name;\n\n    /**\n     * Private constructor.\n     *\n     * @param name  the name.\n     */\n    private Layer(String name) {\n        this.name = name;\n    }\n\n    /**\n     * Returns a string representing the object.\n     *\n     * @return The string.\n     */\n    public String toString() {\n        return this.name;\n    }\n\n    /**\n     * Returns <code>true</code> if this object is equal to the specified\n     * object, and <code>false</code> otherwise.\n     *\n     * @param obj  the other object.\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Layer)) {\n            return false;\n        }\n        Layer layer = (Layer) obj;\n        if (!this.name.equals(layer.name)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return the hashcode\n     */\n    public int hashCode() {\n        return this.name.hashCode();\n    }\n\n    /**\n     * Ensures that serialization returns the unique instances.\n     *\n     * @return The object.\n     *\n     * @throws ObjectStreamException if there is a problem.\n     */\n    private Object readResolve() throws ObjectStreamException {\n        Layer result = null;\n        if (this.equals(Layer.FOREGROUND)) {\n            result = Layer.FOREGROUND;\n        } else if (this.equals(Layer.BACKGROUND)) {\n            result = Layer.BACKGROUND;\n        }\n        return result;\n    }\n}\n\n"], "content:parameter_class_constructors": ["public ValueMarker(double value); | public ValueMarker(double value, Paint paint, Stroke stroke); | public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha); | public IntervalMarker(double start, double end); | public IntervalMarker(double start, double end, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha); | public CategoryMarker(Comparable key, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha); | public CategoryMarker(Comparable key, Paint paint, Stroke stroke); | public CategoryMarker(Comparable key);", "private Layer(String name);"], "content:parameter_class_signature": ["org.jfree.chart.plot#Marker | getStroke() | setLabelAnchor(RectangleAnchor) | getLabel() | setLabel(String) | clone() | getLabelFont() | getPaint() | setLabelFont(Font) | setLabelTextAnchor(TextAnchor) | addChangeListener(MarkerChangeListener) | setOutlineStroke(Stroke) | getLabelTextAnchor() | getOutlineStroke() | notifyListeners(MarkerChangeEvent) | setOutlinePaint(Paint) | setLabelPaint(Paint) | getLabelPaint() | getLabelOffset() | equals(Object) | setStroke(Stroke) | setLabelOffset(RectangleInsets) | setLabelOffsetType(LengthAdjustmentType) | getLabelOffsetType() | setPaint(Paint) | getAlpha() | getLabelAnchor() | removeChangeListener(MarkerChangeListener) | getListeners(Class) | getOutlinePaint() | setAlpha(float)\n\n:public class ValueMarker extends Marker;#org.jfree.chart.plot#ValueMarker | ValueMarker(double) | setValue(double) | ValueMarker(double, Paint, Stroke) | ValueMarker(double, Paint, Stroke, Paint, Stroke, float) | equals(Object) | getValue()\n\npublic class IntervalMarker extends Marker implements Cloneable, Serializable;#org.jfree.chart.plot#IntervalMarker | getGradientPaintTransformer() | getStartValue() | getEndValue() | equals(Object) | IntervalMarker(double, double) | setStartValue(double) | setGradientPaintTransformer(GradientPaintTransformer) | setEndValue(double) | IntervalMarker(double, double, Paint, Stroke, Paint, Stroke, float) | clone()\n\npublic class CategoryMarker extends Marker implements Cloneable, Serializable;#org.jfree.chart.plot#CategoryMarker | getKey() | CategoryMarker(Comparable, Paint, Stroke, Paint, Stroke, float) | getDrawAsLine() | setDrawAsLine(boolean) | CategoryMarker(Comparable, Paint, Stroke) | equals(Object) | setKey(Comparable) | CategoryMarker(Comparable)\n\n", "org.jfree.chart.util#Layer | equals(Object) | toString() | hashCode()\n\n"], "content:parameter_list": ["Marker marker", "Layer layer"], "content:source_class_code_format": "public class CategoryPlot extends Plot implements ValueAxisPlot, Zoomable, RendererChangeListener, Cloneable, PublicCloneable, Serializable {\r\n\r\n    /**\r\n     * For serialization.\r\n     */\r\n    private static final long serialVersionUID = -3537691700434728188L;\r\n\r\n    /**\r\n     * The default visibility of the grid lines plotted against the domain\r\n     * axis.\r\n     */\r\n    public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false;\r\n\r\n    /**\r\n     * The default visibility of the grid lines plotted against the range\r\n     * axis.\r\n     */\r\n    public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true;\r\n\r\n    /**\r\n     * The default grid line stroke.\r\n     */\r\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] { 2.0f, 2.0f }, 0.0f);\r\n\r\n    /**\r\n     * The default grid line paint.\r\n     */\r\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\r\n\r\n    /**\r\n     * The default value label font.\r\n     */\r\n    public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", Font.PLAIN, 10);\r\n\r\n    /**\r\n     * The default crosshair visibility.\r\n     *\r\n     * @since 1.0.5\r\n     */\r\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\r\n\r\n    /**\r\n     * The default crosshair stroke.\r\n     *\r\n     * @since 1.0.5\r\n     */\r\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE;\r\n\r\n    /**\r\n     * The default crosshair paint.\r\n     *\r\n     * @since 1.0.5\r\n     */\r\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\r\n\r\n    /**\r\n     * The resourceBundle for the localization.\r\n     */\r\n    protected static ResourceBundle localizationResources = ResourceBundle.getBundle(\"org.jfree.chart.plot.LocalizationBundle\");\r\n\r\n    /**\r\n     * The plot orientation.\r\n     */\r\n    private PlotOrientation orientation;\r\n\r\n    /**\r\n     * The offset between the data area and the axes.\r\n     */\r\n    private RectangleInsets axisOffset;\r\n\r\n    /**\r\n     * Storage for the domain axes.\r\n     */\r\n    private ObjectList domainAxes;\r\n\r\n    /**\r\n     * Storage for the domain axis locations.\r\n     */\r\n    private ObjectList domainAxisLocations;\r\n\r\n    /**\r\n     * A flag that controls whether or not the shared domain axis is drawn\r\n     * (only relevant when the plot is being used as a subplot).\r\n     */\r\n    private boolean drawSharedDomainAxis;\r\n\r\n    /**\r\n     * Storage for the range axes.\r\n     */\r\n    private ObjectList rangeAxes;\r\n\r\n    /**\r\n     * Storage for the range axis locations.\r\n     */\r\n    private ObjectList rangeAxisLocations;\r\n\r\n    /**\r\n     * Storage for the datasets.\r\n     */\r\n    private ObjectList datasets;\r\n\r\n    /**\r\n     * Storage for keys that map datasets to domain axes.\r\n     */\r\n    private ObjectList datasetToDomainAxisMap;\r\n\r\n    /**\r\n     * Storage for keys that map datasets to range axes.\r\n     */\r\n    private ObjectList datasetToRangeAxisMap;\r\n\r\n    /**\r\n     * Storage for the renderers.\r\n     */\r\n    private ObjectList renderers;\r\n\r\n    /**\r\n     * The dataset rendering order.\r\n     */\r\n    private DatasetRenderingOrder renderingOrder = DatasetRenderingOrder.REVERSE;\r\n\r\n    /**\r\n     * Controls the order in which the columns are traversed when rendering the\r\n     * data items.\r\n     */\r\n    private SortOrder columnRenderingOrder = SortOrder.ASCENDING;\r\n\r\n    /**\r\n     * Controls the order in which the rows are traversed when rendering the\r\n     * data items.\r\n     */\r\n    private SortOrder rowRenderingOrder = SortOrder.ASCENDING;\r\n\r\n    /**\r\n     * A flag that controls whether the grid-lines for the domain axis are\r\n     * visible.\r\n     */\r\n    private boolean domainGridlinesVisible;\r\n\r\n    /**\r\n     * The position of the domain gridlines relative to the category.\r\n     */\r\n    private CategoryAnchor domainGridlinePosition;\r\n\r\n    /**\r\n     * The stroke used to draw the domain grid-lines.\r\n     */\r\n    private transient Stroke domainGridlineStroke;\r\n\r\n    /**\r\n     * The paint used to draw the domain  grid-lines.\r\n     */\r\n    private transient Paint domainGridlinePaint;\r\n\r\n    /**\r\n     * A flag that controls whether the grid-lines for the range axis are\r\n     * visible.\r\n     */\r\n    private boolean rangeGridlinesVisible;\r\n\r\n    /**\r\n     * The stroke used to draw the range axis grid-lines.\r\n     */\r\n    private transient Stroke rangeGridlineStroke;\r\n\r\n    /**\r\n     * The paint used to draw the range axis grid-lines.\r\n     */\r\n    private transient Paint rangeGridlinePaint;\r\n\r\n    /**\r\n     * The anchor value.\r\n     */\r\n    private double anchorValue;\r\n\r\n    /**\r\n     * A flag that controls whether or not a range crosshair is drawn.\r\n     */\r\n    private boolean rangeCrosshairVisible;\r\n\r\n    /**\r\n     * The range crosshair value.\r\n     */\r\n    private double rangeCrosshairValue;\r\n\r\n    /**\r\n     * The pen/brush used to draw the crosshair (if any).\r\n     */\r\n    private transient Stroke rangeCrosshairStroke;\r\n\r\n    /**\r\n     * The color used to draw the crosshair (if any).\r\n     */\r\n    private transient Paint rangeCrosshairPaint;\r\n\r\n    /**\r\n     * A flag that controls whether or not the crosshair locks onto actual\r\n     * data points.\r\n     */\r\n    private boolean rangeCrosshairLockedOnData = true;\r\n\r\n    /**\r\n     * A map containing lists of markers for the domain axes.\r\n     */\r\n    private Map foregroundDomainMarkers;\r\n\r\n    /**\r\n     * A map containing lists of markers for the domain axes.\r\n     */\r\n    private Map backgroundDomainMarkers;\r\n\r\n    /**\r\n     * A map containing lists of markers for the range axes.\r\n     */\r\n    private Map foregroundRangeMarkers;\r\n\r\n    /**\r\n     * A map containing lists of markers for the range axes.\r\n     */\r\n    private Map backgroundRangeMarkers;\r\n\r\n    /**\r\n     * A (possibly empty) list of annotations for the plot.  The list should\r\n     * be initialised in the constructor and never allowed to be\r\n     * <code>null</code>.\r\n     */\r\n    private List annotations;\r\n\r\n    /**\r\n     * The weight for the plot (only relevant when the plot is used as a subplot\r\n     * within a combined plot).\r\n     */\r\n    private int weight;\r\n\r\n    /**\r\n     * The fixed space for the domain axis.\r\n     */\r\n    private AxisSpace fixedDomainAxisSpace;\r\n\r\n    /**\r\n     * The fixed space for the range axis.\r\n     */\r\n    private AxisSpace fixedRangeAxisSpace;\r\n\r\n    /**\r\n     * An optional collection of legend items that can be returned by the\r\n     * getLegendItems() method.\r\n     */\r\n    private LegendItemCollection fixedLegendItems;\r\n\r\n    /**\r\n     * Default constructor.\r\n     */\r\n    public CategoryPlot() {\r\n        this(null, null, null, null);\r\n    }\r\n\r\n    /**\r\n     * Creates a new plot.\r\n     *\r\n     * @param dataset  the dataset (<code>null</code> permitted).\r\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\r\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\r\n     * @param renderer  the item renderer (<code>null</code> permitted).\r\n     */\r\n    public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer) {\r\n        super();\r\n        this.orientation = PlotOrientation.VERTICAL;\r\n        // allocate storage for dataset, axes and renderers\r\n        this.domainAxes = new ObjectList();\r\n        this.domainAxisLocations = new ObjectList();\r\n        this.rangeAxes = new ObjectList();\r\n        this.rangeAxisLocations = new ObjectList();\r\n        this.datasetToDomainAxisMap = new ObjectList();\r\n        this.datasetToRangeAxisMap = new ObjectList();\r\n        this.renderers = new ObjectList();\r\n        this.datasets = new ObjectList();\r\n        this.datasets.set(0, dataset);\r\n        if (dataset != null) {\r\n            dataset.addChangeListener(this);\r\n        }\r\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\r\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\r\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\r\n        this.renderers.set(0, renderer);\r\n        if (renderer != null) {\r\n            renderer.setPlot(this);\r\n            renderer.addChangeListener(this);\r\n        }\r\n        this.domainAxes.set(0, domainAxis);\r\n        this.mapDatasetToDomainAxis(0, 0);\r\n        if (domainAxis != null) {\r\n            domainAxis.setPlot(this);\r\n            domainAxis.addChangeListener(this);\r\n        }\r\n        this.drawSharedDomainAxis = false;\r\n        this.rangeAxes.set(0, rangeAxis);\r\n        this.mapDatasetToRangeAxis(0, 0);\r\n        if (rangeAxis != null) {\r\n            rangeAxis.setPlot(this);\r\n            rangeAxis.addChangeListener(this);\r\n        }\r\n        configureDomainAxes();\r\n        configureRangeAxes();\r\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\r\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\r\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\r\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\r\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\r\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\r\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\r\n        this.foregroundDomainMarkers = new HashMap();\r\n        this.backgroundDomainMarkers = new HashMap();\r\n        this.foregroundRangeMarkers = new HashMap();\r\n        this.backgroundRangeMarkers = new HashMap();\r\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, 0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, 0.5f), new BasicStroke(1.0f), 0.6f);\r\n        addRangeMarker(baseline, Layer.BACKGROUND);\r\n        this.anchorValue = 0.0;\r\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\r\n        this.rangeCrosshairValue = 0.0;\r\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\r\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\r\n        this.annotations = new java.util.ArrayList();\r\n    }\r\n\r\n    /**\r\n     * Returns a string describing the type of plot.\r\n     *\r\n     * @return The type.\r\n     */\r\n    public String getPlotType() {\r\n        return localizationResources.getString(\"Category_Plot\");\r\n    }\r\n\r\n    /**\r\n     * Returns the orientation of the plot.\r\n     *\r\n     * @return The orientation of the plot (never <code>null</code>).\r\n     *\r\n     * @see #setOrientation(PlotOrientation)\r\n     */\r\n    public PlotOrientation getOrientation() {\r\n        return this.orientation;\r\n    }\r\n\r\n    /**\r\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param orientation  the orientation (<code>null</code> not permitted).\r\n     *\r\n     * @see #getOrientation()\r\n     */\r\n    public void setOrientation(PlotOrientation orientation) {\r\n        if (orientation == null) {\r\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\r\n        }\r\n        this.orientation = orientation;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the axis offset.\r\n     *\r\n     * @return The axis offset (never <code>null</code>).\r\n     *\r\n     * @see #setAxisOffset(RectangleInsets)\r\n     */\r\n    public RectangleInsets getAxisOffset() {\r\n        return this.axisOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the axis offsets (gap between the data area and the axes) and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param offset  the offset (<code>null</code> not permitted).\r\n     *\r\n     * @see #getAxisOffset()\r\n     */\r\n    public void setAxisOffset(RectangleInsets offset) {\r\n        if (offset == null) {\r\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\r\n        }\r\n        this.axisOffset = offset;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the domain axis for the plot.  If the domain axis for this plot\r\n     * is <code>null</code>, then the method will return the parent plot's\r\n     * domain axis (if there is a parent plot).\r\n     *\r\n     * @return The domain axis (<code>null</code> permitted).\r\n     *\r\n     * @see #setDomainAxis(CategoryAxis)\r\n     */\r\n    public CategoryAxis getDomainAxis() {\r\n        return getDomainAxis(0);\r\n    }\r\n\r\n    /**\r\n     * Returns a domain axis.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The axis (<code>null</code> possible).\r\n     *\r\n     * @see #setDomainAxis(int, CategoryAxis)\r\n     */\r\n    public CategoryAxis getDomainAxis(int index) {\r\n        CategoryAxis result = null;\r\n        if (index < this.domainAxes.size()) {\r\n            result = (CategoryAxis) this.domainAxes.get(index);\r\n        }\r\n        if (result == null) {\r\n            Plot parent = getParent();\r\n            if (parent instanceof CategoryPlot) {\r\n                CategoryPlot cp = (CategoryPlot) parent;\r\n                result = cp.getDomainAxis(index);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param axis  the axis (<code>null</code> permitted).\r\n     *\r\n     * @see #getDomainAxis()\r\n     */\r\n    public void setDomainAxis(CategoryAxis axis) {\r\n        setDomainAxis(0, axis);\r\n    }\r\n\r\n    /**\r\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param axis  the axis (<code>null</code> permitted).\r\n     *\r\n     * @see #getDomainAxis(int)\r\n     */\r\n    public void setDomainAxis(int index, CategoryAxis axis) {\r\n        setDomainAxis(index, axis, true);\r\n    }\r\n\r\n    /**\r\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param axis  the axis (<code>null</code> permitted).\r\n     * @param notify  notify listeners?\r\n     */\r\n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\r\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\r\n        if (existing != null) {\r\n            existing.removeChangeListener(this);\r\n        }\r\n        if (axis != null) {\r\n            axis.setPlot(this);\r\n        }\r\n        this.domainAxes.set(index, axis);\r\n        if (axis != null) {\r\n            axis.configure();\r\n            axis.addChangeListener(this);\r\n        }\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param axes  the axes (<code>null</code> not permitted).\r\n     *\r\n     * @see #setRangeAxes(ValueAxis[])\r\n     */\r\n    public void setDomainAxes(CategoryAxis[] axes) {\r\n        for (int i = 0; i < axes.length; i++) {\r\n            setDomainAxis(i, axes[i], false);\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\r\n     * is not assigned to the plot.\r\n     *\r\n     * @param axis  the axis (<code>null</code> not permitted).\r\n     *\r\n     * @return The axis index.\r\n     *\r\n     * @see #getDomainAxis(int)\r\n     * @see #getRangeAxisIndex(ValueAxis)\r\n     *\r\n     * @since 1.0.3\r\n     */\r\n    public int getDomainAxisIndex(CategoryAxis axis) {\r\n        if (axis == null) {\r\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\r\n        }\r\n        return this.domainAxes.indexOf(axis);\r\n    }\r\n\r\n    /**\r\n     * Returns the domain axis location for the primary domain axis.\r\n     *\r\n     * @return The location (never <code>null</code>).\r\n     *\r\n     * @see #getRangeAxisLocation()\r\n     */\r\n    public AxisLocation getDomainAxisLocation() {\r\n        return getDomainAxisLocation(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the location for a domain axis.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The location.\r\n     *\r\n     * @see #setDomainAxisLocation(int, AxisLocation)\r\n     */\r\n    public AxisLocation getDomainAxisLocation(int index) {\r\n        AxisLocation result = null;\r\n        if (index < this.domainAxisLocations.size()) {\r\n            result = (AxisLocation) this.domainAxisLocations.get(index);\r\n        }\r\n        if (result == null) {\r\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the location of the domain axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param location  the axis location (<code>null</code> not permitted).\r\n     *\r\n     * @see #getDomainAxisLocation()\r\n     * @see #setDomainAxisLocation(int, AxisLocation)\r\n     */\r\n    public void setDomainAxisLocation(AxisLocation location) {\r\n        // delegate...\r\n        setDomainAxisLocation(0, location, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the location of the domain axis and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param location  the axis location (<code>null</code> not permitted).\r\n     * @param notify  a flag that controls whether listeners are notified.\r\n     */\r\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\r\n        // delegate...\r\n        setDomainAxisLocation(0, location, notify);\r\n    }\r\n\r\n    /**\r\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param location  the location.\r\n     *\r\n     * @see #getDomainAxisLocation(int)\r\n     * @see #setRangeAxisLocation(int, AxisLocation)\r\n     */\r\n    public void setDomainAxisLocation(int index, AxisLocation location) {\r\n        // delegate...\r\n        setDomainAxisLocation(index, location, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param location  the location.\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @since 1.0.5\r\n     *\r\n     * @see #getDomainAxisLocation(int)\r\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\r\n     */\r\n    public void setDomainAxisLocation(int index, AxisLocation location, boolean notify) {\r\n        if (index == 0 && location == null) {\r\n            throw new IllegalArgumentException(\"Null 'location' for index 0 not permitted.\");\r\n        }\r\n        this.domainAxisLocations.set(index, location);\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the domain axis edge.  This is derived from the axis location\r\n     * and the plot orientation.\r\n     *\r\n     * @return The edge (never <code>null</code>).\r\n     */\r\n    public RectangleEdge getDomainAxisEdge() {\r\n        return getDomainAxisEdge(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the edge for a domain axis.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The edge (never <code>null</code>).\r\n     */\r\n    public RectangleEdge getDomainAxisEdge(int index) {\r\n        RectangleEdge result = null;\r\n        AxisLocation location = getDomainAxisLocation(index);\r\n        if (location != null) {\r\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\r\n        } else {\r\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of domain axes.\r\n     *\r\n     * @return The axis count.\r\n     */\r\n    public int getDomainAxisCount() {\r\n        return this.domainAxes.size();\r\n    }\r\n\r\n    /**\r\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     */\r\n    public void clearDomainAxes() {\r\n        for (int i = 0; i < this.domainAxes.size(); i++) {\r\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\r\n            if (axis != null) {\r\n                axis.removeChangeListener(this);\r\n            }\r\n        }\r\n        this.domainAxes.clear();\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Configures the domain axes.\r\n     */\r\n    public void configureDomainAxes() {\r\n        for (int i = 0; i < this.domainAxes.size(); i++) {\r\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\r\n            if (axis != null) {\r\n                axis.configure();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the range axis for the plot.  If the range axis for this plot is\r\n     * null, then the method will return the parent plot's range axis (if there\r\n     * is a parent plot).\r\n     *\r\n     * @return The range axis (possibly <code>null</code>).\r\n     */\r\n    public ValueAxis getRangeAxis() {\r\n        return getRangeAxis(0);\r\n    }\r\n\r\n    /**\r\n     * Returns a range axis.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The axis (<code>null</code> possible).\r\n     */\r\n    public ValueAxis getRangeAxis(int index) {\r\n        ValueAxis result = null;\r\n        if (index < this.rangeAxes.size()) {\r\n            result = (ValueAxis) this.rangeAxes.get(index);\r\n        }\r\n        if (result == null) {\r\n            Plot parent = getParent();\r\n            if (parent instanceof CategoryPlot) {\r\n                CategoryPlot cp = (CategoryPlot) parent;\r\n                result = cp.getRangeAxis(index);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param axis  the axis (<code>null</code> permitted).\r\n     */\r\n    public void setRangeAxis(ValueAxis axis) {\r\n        setRangeAxis(0, axis);\r\n    }\r\n\r\n    /**\r\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\r\n     * listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param axis  the axis.\r\n     */\r\n    public void setRangeAxis(int index, ValueAxis axis) {\r\n        setRangeAxis(index, axis, true);\r\n    }\r\n\r\n    /**\r\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param axis  the axis.\r\n     * @param notify  notify listeners?\r\n     */\r\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\r\n        ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\r\n        if (existing != null) {\r\n            existing.removeChangeListener(this);\r\n        }\r\n        if (axis != null) {\r\n            axis.setPlot(this);\r\n        }\r\n        this.rangeAxes.set(index, axis);\r\n        if (axis != null) {\r\n            axis.configure();\r\n            axis.addChangeListener(this);\r\n        }\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param axes  the axes (<code>null</code> not permitted).\r\n     *\r\n     * @see #setDomainAxes(CategoryAxis[])\r\n     */\r\n    public void setRangeAxes(ValueAxis[] axes) {\r\n        for (int i = 0; i < axes.length; i++) {\r\n            setRangeAxis(i, axes[i], false);\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\r\n     * is not assigned to the plot.\r\n     *\r\n     * @param axis  the axis (<code>null</code> not permitted).\r\n     *\r\n     * @return The axis index.\r\n     *\r\n     * @see #getRangeAxis(int)\r\n     * @see #getDomainAxisIndex(CategoryAxis)\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public int getRangeAxisIndex(ValueAxis axis) {\r\n        if (axis == null) {\r\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\r\n        }\r\n        int result = this.rangeAxes.indexOf(axis);\r\n        if (result < 0) {\r\n            // try the parent plot\r\n            Plot parent = getParent();\r\n            if (parent instanceof CategoryPlot) {\r\n                CategoryPlot p = (CategoryPlot) parent;\r\n                result = p.getRangeAxisIndex(axis);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the range axis location.\r\n     *\r\n     * @return The location (never <code>null</code>).\r\n     */\r\n    public AxisLocation getRangeAxisLocation() {\r\n        return getRangeAxisLocation(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the location for a range axis.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The location.\r\n     *\r\n     * @see #setRangeAxisLocation(int, AxisLocation)\r\n     */\r\n    public AxisLocation getRangeAxisLocation(int index) {\r\n        AxisLocation result = null;\r\n        if (index < this.rangeAxisLocations.size()) {\r\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\r\n        }\r\n        if (result == null) {\r\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the location of the range axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param location  the location (<code>null</code> not permitted).\r\n     *\r\n     * @see #setRangeAxisLocation(AxisLocation, boolean)\r\n     * @see #setDomainAxisLocation(AxisLocation)\r\n     */\r\n    public void setRangeAxisLocation(AxisLocation location) {\r\n        // defer argument checking...\r\n        setRangeAxisLocation(location, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the location of the range axis and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param location  the location (<code>null</code> not permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #setDomainAxisLocation(AxisLocation, boolean)\r\n     */\r\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\r\n        setRangeAxisLocation(0, location, notify);\r\n    }\r\n\r\n    /**\r\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param location  the location.\r\n     *\r\n     * @see #getRangeAxisLocation(int)\r\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\r\n     */\r\n    public void setRangeAxisLocation(int index, AxisLocation location) {\r\n        setRangeAxisLocation(index, location, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param index  the axis index.\r\n     * @param location  the location.\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getRangeAxisLocation(int)\r\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\r\n     */\r\n    public void setRangeAxisLocation(int index, AxisLocation location, boolean notify) {\r\n        if (index == 0 && location == null) {\r\n            throw new IllegalArgumentException(\"Null 'location' for index 0 not permitted.\");\r\n        }\r\n        this.rangeAxisLocations.set(index, location);\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the edge where the primary range axis is located.\r\n     *\r\n     * @return The edge (never <code>null</code>).\r\n     */\r\n    public RectangleEdge getRangeAxisEdge() {\r\n        return getRangeAxisEdge(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the edge for a range axis.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return The edge.\r\n     */\r\n    public RectangleEdge getRangeAxisEdge(int index) {\r\n        AxisLocation location = getRangeAxisLocation(index);\r\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, this.orientation);\r\n        if (result == null) {\r\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of range axes.\r\n     *\r\n     * @return The axis count.\r\n     */\r\n    public int getRangeAxisCount() {\r\n        return this.rangeAxes.size();\r\n    }\r\n\r\n    /**\r\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     */\r\n    public void clearRangeAxes() {\r\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\r\n            if (axis != null) {\r\n                axis.removeChangeListener(this);\r\n            }\r\n        }\r\n        this.rangeAxes.clear();\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Configures the range axes.\r\n     */\r\n    public void configureRangeAxes() {\r\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\r\n            if (axis != null) {\r\n                axis.configure();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the primary dataset for the plot.\r\n     *\r\n     * @return The primary dataset (possibly <code>null</code>).\r\n     *\r\n     * @see #setDataset(CategoryDataset)\r\n     */\r\n    public CategoryDataset getDataset() {\r\n        return getDataset(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the dataset at the given index.\r\n     *\r\n     * @param index  the dataset index.\r\n     *\r\n     * @return The dataset (possibly <code>null</code>).\r\n     *\r\n     * @see #setDataset(int, CategoryDataset)\r\n     */\r\n    public CategoryDataset getDataset(int index) {\r\n        CategoryDataset result = null;\r\n        if (this.datasets.size() > index) {\r\n            result = (CategoryDataset) this.datasets.get(index);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the dataset for the plot, replacing the existing dataset, if there\r\n     * is one.  This method also calls the\r\n     * {@link #datasetChanged(DatasetChangeEvent)} method, which adjusts the\r\n     * axis ranges if necessary and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param dataset  the dataset (<code>null</code> permitted).\r\n     *\r\n     * @see #getDataset()\r\n     */\r\n    public void setDataset(CategoryDataset dataset) {\r\n        setDataset(0, dataset);\r\n    }\r\n\r\n    /**\r\n     * Sets a dataset for the plot.\r\n     *\r\n     * @param index  the dataset index.\r\n     * @param dataset  the dataset (<code>null</code> permitted).\r\n     *\r\n     * @see #getDataset(int)\r\n     */\r\n    public void setDataset(int index, CategoryDataset dataset) {\r\n        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\r\n        if (existing != null) {\r\n            existing.removeChangeListener(this);\r\n        }\r\n        this.datasets.set(index, dataset);\r\n        if (dataset != null) {\r\n            dataset.addChangeListener(this);\r\n        }\r\n        // send a dataset change event to self...\r\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\r\n        datasetChanged(event);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of datasets.\r\n     *\r\n     * @return The number of datasets.\r\n     *\r\n     * @since 1.0.2\r\n     */\r\n    public int getDatasetCount() {\r\n        return this.datasets.size();\r\n    }\r\n\r\n    /**\r\n     * Maps a dataset to a particular domain axis.\r\n     *\r\n     * @param index  the dataset index (zero-based).\r\n     * @param axisIndex  the axis index (zero-based).\r\n     *\r\n     * @see #getDomainAxisForDataset(int)\r\n     */\r\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\r\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));\r\n        // fake a dataset change event to update axes...\r\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\r\n    }\r\n\r\n    /**\r\n     * Returns the domain axis for a dataset.  You can change the axis for a\r\n     * dataset using the {@link #mapDatasetToDomainAxis(int, int)} method.\r\n     *\r\n     * @param index  the dataset index.\r\n     *\r\n     * @return The domain axis.\r\n     *\r\n     * @see #mapDatasetToDomainAxis(int, int)\r\n     */\r\n    public CategoryAxis getDomainAxisForDataset(int index) {\r\n        CategoryAxis result = getDomainAxis();\r\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\r\n        if (axisIndex != null) {\r\n            result = getDomainAxis(axisIndex.intValue());\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Maps a dataset to a particular range axis.\r\n     *\r\n     * @param index  the dataset index (zero-based).\r\n     * @param axisIndex  the axis index (zero-based).\r\n     *\r\n     * @see #getRangeAxisForDataset(int)\r\n     */\r\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\r\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\r\n        // fake a dataset change event to update axes...\r\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\r\n    }\r\n\r\n    /**\r\n     * Returns the range axis for a dataset.  You can change the axis for a\r\n     * dataset using the {@link #mapDatasetToRangeAxis(int, int)} method.\r\n     *\r\n     * @param index  the dataset index.\r\n     *\r\n     * @return The range axis.\r\n     *\r\n     * @see #mapDatasetToRangeAxis(int, int)\r\n     */\r\n    public ValueAxis getRangeAxisForDataset(int index) {\r\n        ValueAxis result = getRangeAxis();\r\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\r\n        if (axisIndex != null) {\r\n            result = getRangeAxis(axisIndex.intValue());\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a reference to the renderer for the plot.\r\n     *\r\n     * @return The renderer.\r\n     *\r\n     * @see #setRenderer(CategoryItemRenderer)\r\n     */\r\n    public CategoryItemRenderer getRenderer() {\r\n        return getRenderer(0);\r\n    }\r\n\r\n    /**\r\n     * Returns the renderer at the given index.\r\n     *\r\n     * @param index  the renderer index.\r\n     *\r\n     * @return The renderer (possibly <code>null</code>).\r\n     *\r\n     * @see #setRenderer(int, CategoryItemRenderer)\r\n     */\r\n    public CategoryItemRenderer getRenderer(int index) {\r\n        CategoryItemRenderer result = null;\r\n        if (this.renderers.size() > index) {\r\n            result = (CategoryItemRenderer) this.renderers.get(index);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\"\r\n     * renderer) and sends a {@link PlotChangeEvent} to all registered\r\n     * listeners.\r\n     *\r\n     * @param renderer  the renderer (<code>null</code> permitted.\r\n     *\r\n     * @see #getRenderer()\r\n     */\r\n    public void setRenderer(CategoryItemRenderer renderer) {\r\n        setRenderer(0, renderer, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\"\r\n     * renderer) and, if requested, sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     * <p>\r\n     * You can set the renderer to <code>null</code>, but this is not\r\n     * recommended because:\r\n     * <ul>\r\n     *   <li>no data will be displayed;</li>\r\n     *   <li>the plot background will not be painted;</li>\r\n     * </ul>\r\n     *\r\n     * @param renderer  the renderer (<code>null</code> permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getRenderer()\r\n     */\r\n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\r\n        setRenderer(0, renderer, notify);\r\n    }\r\n\r\n    /**\r\n     * Sets the renderer at the specified index and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index  the index.\r\n     * @param renderer  the renderer (<code>null</code> permitted).\r\n     *\r\n     * @see #getRenderer(int)\r\n     * @see #setRenderer(int, CategoryItemRenderer, boolean)\r\n     */\r\n    public void setRenderer(int index, CategoryItemRenderer renderer) {\r\n        setRenderer(index, renderer, true);\r\n    }\r\n\r\n    /**\r\n     * Sets a renderer.  A {@link PlotChangeEvent} is sent to all registered\r\n     * listeners.\r\n     *\r\n     * @param index  the index.\r\n     * @param renderer  the renderer (<code>null</code> permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getRenderer(int)\r\n     */\r\n    public void setRenderer(int index, CategoryItemRenderer renderer, boolean notify) {\r\n        // stop listening to the existing renderer...\r\n        CategoryItemRenderer existing = (CategoryItemRenderer) this.renderers.get(index);\r\n        if (existing != null) {\r\n            existing.removeChangeListener(this);\r\n        }\r\n        // register the new renderer...\r\n        this.renderers.set(index, renderer);\r\n        if (renderer != null) {\r\n            renderer.setPlot(this);\r\n            renderer.addChangeListener(this);\r\n        }\r\n        configureDomainAxes();\r\n        configureRangeAxes();\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param renderers  the renderers.\r\n     */\r\n    public void setRenderers(CategoryItemRenderer[] renderers) {\r\n        for (int i = 0; i < renderers.length; i++) {\r\n            setRenderer(i, renderers[i], false);\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the renderer for the specified dataset.  If the dataset doesn't\r\n     * belong to the plot, this method will return <code>null</code>.\r\n     *\r\n     * @param dataset  the dataset (<code>null</code> permitted).\r\n     *\r\n     * @return The renderer (possibly <code>null</code>).\r\n     */\r\n    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\r\n        CategoryItemRenderer result = null;\r\n        for (int i = 0; i < this.datasets.size(); i++) {\r\n            if (this.datasets.get(i) == dataset) {\r\n                result = (CategoryItemRenderer) this.renderers.get(i);\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the specified renderer, or <code>-1</code> if the\r\n     * renderer is not assigned to this plot.\r\n     *\r\n     * @param renderer  the renderer (<code>null</code> permitted).\r\n     *\r\n     * @return The renderer index.\r\n     */\r\n    public int getIndexOf(CategoryItemRenderer renderer) {\r\n        return this.renderers.indexOf(renderer);\r\n    }\r\n\r\n    /**\r\n     * Returns the dataset rendering order.\r\n     *\r\n     * @return The order (never <code>null</code>).\r\n     *\r\n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\r\n     */\r\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\r\n        return this.renderingOrder;\r\n    }\r\n\r\n    /**\r\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.  By default, the plot renders the primary dataset\r\n     * last (so that the primary dataset overlays the secondary datasets).  You\r\n     * can reverse this if you want to.\r\n     *\r\n     * @param order  the rendering order (<code>null</code> not permitted).\r\n     *\r\n     * @see #getDatasetRenderingOrder()\r\n     */\r\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\r\n        if (order == null) {\r\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\r\n        }\r\n        this.renderingOrder = order;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the order in which the columns are rendered.  The default value\r\n     * is <code>SortOrder.ASCENDING</code>.\r\n     *\r\n     * @return The column rendering order (never <code>null</code).\r\n     *\r\n     * @see #setColumnRenderingOrder(SortOrder)\r\n     */\r\n    public SortOrder getColumnRenderingOrder() {\r\n        return this.columnRenderingOrder;\r\n    }\r\n\r\n    /**\r\n     * Sets the column order in which the items in each dataset should be\r\n     * rendered and sends a {@link PlotChangeEvent} to all registered\r\n     * listeners.  Note that this affects the order in which items are drawn,\r\n     * NOT their position in the chart.\r\n     *\r\n     * @param order  the order (<code>null</code> not permitted).\r\n     *\r\n     * @see #getColumnRenderingOrder()\r\n     * @see #setRowRenderingOrder(SortOrder)\r\n     */\r\n    public void setColumnRenderingOrder(SortOrder order) {\r\n        if (order == null) {\r\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\r\n        }\r\n        this.columnRenderingOrder = order;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the order in which the rows should be rendered.  The default\r\n     * value is <code>SortOrder.ASCENDING</code>.\r\n     *\r\n     * @return The order (never <code>null</code>).\r\n     *\r\n     * @see #setRowRenderingOrder(SortOrder)\r\n     */\r\n    public SortOrder getRowRenderingOrder() {\r\n        return this.rowRenderingOrder;\r\n    }\r\n\r\n    /**\r\n     * Sets the row order in which the items in each dataset should be\r\n     * rendered and sends a {@link PlotChangeEvent} to all registered\r\n     * listeners.  Note that this affects the order in which items are drawn,\r\n     * NOT their position in the chart.\r\n     *\r\n     * @param order  the order (<code>null</code> not permitted).\r\n     *\r\n     * @see #getRowRenderingOrder()\r\n     * @see #setColumnRenderingOrder(SortOrder)\r\n     */\r\n    public void setRowRenderingOrder(SortOrder order) {\r\n        if (order == null) {\r\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\r\n        }\r\n        this.rowRenderingOrder = order;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the flag that controls whether the domain grid-lines are visible.\r\n     *\r\n     * @return The <code>true</code> or <code>false</code>.\r\n     *\r\n     * @see #setDomainGridlinesVisible(boolean)\r\n     */\r\n    public boolean isDomainGridlinesVisible() {\r\n        return this.domainGridlinesVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that controls whether or not grid-lines are drawn against\r\n     * the domain axis.\r\n     * <p>\r\n     * If the flag value changes, a {@link PlotChangeEvent} is sent to all\r\n     * registered listeners.\r\n     *\r\n     * @param visible  the new value of the flag.\r\n     *\r\n     * @see #isDomainGridlinesVisible()\r\n     */\r\n    public void setDomainGridlinesVisible(boolean visible) {\r\n        if (this.domainGridlinesVisible != visible) {\r\n            this.domainGridlinesVisible = visible;\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the position used for the domain gridlines.\r\n     *\r\n     * @return The gridline position (never <code>null</code>).\r\n     *\r\n     * @see #setDomainGridlinePosition(CategoryAnchor)\r\n     */\r\n    public CategoryAnchor getDomainGridlinePosition() {\r\n        return this.domainGridlinePosition;\r\n    }\r\n\r\n    /**\r\n     * Sets the position used for the domain gridlines and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param position  the position (<code>null</code> not permitted).\r\n     *\r\n     * @see #getDomainGridlinePosition()\r\n     */\r\n    public void setDomainGridlinePosition(CategoryAnchor position) {\r\n        if (position == null) {\r\n            throw new IllegalArgumentException(\"Null 'position' argument.\");\r\n        }\r\n        this.domainGridlinePosition = position;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the stroke used to draw grid-lines against the domain axis.\r\n     *\r\n     * @return The stroke (never <code>null</code>).\r\n     *\r\n     * @see #setDomainGridlineStroke(Stroke)\r\n     */\r\n    public Stroke getDomainGridlineStroke() {\r\n        return this.domainGridlineStroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the stroke used to draw grid-lines against the domain axis and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param stroke  the stroke (<code>null</code> not permitted).\r\n     *\r\n     * @see #getDomainGridlineStroke()\r\n     */\r\n    public void setDomainGridlineStroke(Stroke stroke) {\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' not permitted.\");\r\n        }\r\n        this.domainGridlineStroke = stroke;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint used to draw grid-lines against the domain axis.\r\n     *\r\n     * @return The paint (never <code>null</code>).\r\n     *\r\n     * @see #setDomainGridlinePaint(Paint)\r\n     */\r\n    public Paint getDomainGridlinePaint() {\r\n        return this.domainGridlinePaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint used to draw the grid-lines (if any) against the domain\r\n     * axis and sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     *\r\n     * @see #getDomainGridlinePaint()\r\n     */\r\n    public void setDomainGridlinePaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.domainGridlinePaint = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the flag that controls whether the range grid-lines are visible.\r\n     *\r\n     * @return The flag.\r\n     *\r\n     * @see #setRangeGridlinesVisible(boolean)\r\n     */\r\n    public boolean isRangeGridlinesVisible() {\r\n        return this.rangeGridlinesVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that controls whether or not grid-lines are drawn against\r\n     * the range axis.  If the flag changes value, a {@link PlotChangeEvent} is\r\n     * sent to all registered listeners.\r\n     *\r\n     * @param visible  the new value of the flag.\r\n     *\r\n     * @see #isRangeGridlinesVisible()\r\n     */\r\n    public void setRangeGridlinesVisible(boolean visible) {\r\n        if (this.rangeGridlinesVisible != visible) {\r\n            this.rangeGridlinesVisible = visible;\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the stroke used to draw the grid-lines against the range axis.\r\n     *\r\n     * @return The stroke (never <code>null</code>).\r\n     *\r\n     * @see #setRangeGridlineStroke(Stroke)\r\n     */\r\n    public Stroke getRangeGridlineStroke() {\r\n        return this.rangeGridlineStroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the stroke used to draw the grid-lines against the range axis and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param stroke  the stroke (<code>null</code> not permitted).\r\n     *\r\n     * @see #getRangeGridlineStroke()\r\n     */\r\n    public void setRangeGridlineStroke(Stroke stroke) {\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        this.rangeGridlineStroke = stroke;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint used to draw the grid-lines against the range axis.\r\n     *\r\n     * @return The paint (never <code>null</code>).\r\n     *\r\n     * @see #setRangeGridlinePaint(Paint)\r\n     */\r\n    public Paint getRangeGridlinePaint() {\r\n        return this.rangeGridlinePaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint used to draw the grid lines against the range axis and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     *\r\n     * @see #getRangeGridlinePaint()\r\n     */\r\n    public void setRangeGridlinePaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.rangeGridlinePaint = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the fixed legend items, if any.\r\n     *\r\n     * @return The legend items (possibly <code>null</code>).\r\n     *\r\n     * @see #setFixedLegendItems(LegendItemCollection)\r\n     */\r\n    public LegendItemCollection getFixedLegendItems() {\r\n        return this.fixedLegendItems;\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed legend items for the plot.  Leave this set to\r\n     * <code>null</code> if you prefer the legend items to be created\r\n     * automatically.\r\n     *\r\n     * @param items  the legend items (<code>null</code> permitted).\r\n     *\r\n     * @see #getFixedLegendItems()\r\n     */\r\n    public void setFixedLegendItems(LegendItemCollection items) {\r\n        this.fixedLegendItems = items;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the legend items for the plot.  By default, this method creates\r\n     * a legend item for each series in each of the datasets.  You can change\r\n     * this behaviour by overriding this method.\r\n     *\r\n     * @return The legend items.\r\n     */\r\n    public LegendItemCollection getLegendItems() {\r\n        LegendItemCollection result = this.fixedLegendItems;\r\n        if (result == null) {\r\n            result = new LegendItemCollection();\r\n            // get the legend items for the datasets...\r\n            int count = this.datasets.size();\r\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\r\n                CategoryDataset dataset = getDataset(datasetIndex);\r\n                if (dataset != null) {\r\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\r\n                    if (renderer != null) {\r\n                        int seriesCount = dataset.getRowCount();\r\n                        for (int i = 0; i < seriesCount; i++) {\r\n                            LegendItem item = renderer.getLegendItem(datasetIndex, i);\r\n                            if (item != null) {\r\n                                result.add(item);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Handles a 'click' on the plot by updating the anchor value.\r\n     *\r\n     * @param x  x-coordinate of the click (in Java2D space).\r\n     * @param y  y-coordinate of the click (in Java2D space).\r\n     * @param info  information about the plot's dimensions.\r\n     */\r\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\r\n        Rectangle2D dataArea = info.getDataArea();\r\n        if (dataArea.contains(x, y)) {\r\n            // set the anchor value for the range axis...\r\n            double java2D = 0.0;\r\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                java2D = x;\r\n            } else if (this.orientation == PlotOrientation.VERTICAL) {\r\n                java2D = y;\r\n            }\r\n            RectangleEdge edge = Plot.resolveRangeAxisLocation(getRangeAxisLocation(), this.orientation);\r\n            double value = getRangeAxis().java2DToValue(java2D, info.getDataArea(), edge);\r\n            setAnchorValue(value);\r\n            setRangeCrosshairValue(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Zooms (in or out) on the plot's value axis.\r\n     * <p>\r\n     * If the value 0.0 is passed in as the zoom percent, the auto-range\r\n     * calculation for the axis is restored (which sets the range to include\r\n     * the minimum and maximum data values, thus displaying all the data).\r\n     *\r\n     * @param percent  the zoom amount.\r\n     */\r\n    public void zoom(double percent) {\r\n        if (percent > 0.0) {\r\n            double range = getRangeAxis().getRange().getLength();\r\n            double scaledRange = range * percent;\r\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0, this.anchorValue + scaledRange / 2.0);\r\n        } else {\r\n            getRangeAxis().setAutoRange(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Receives notification of a change to the plot's dataset.\r\n     * <P>\r\n     * The range axis bounds will be recalculated if necessary.\r\n     *\r\n     * @param event  information about the event (not used here).\r\n     */\r\n    public void datasetChanged(DatasetChangeEvent event) {\r\n        int count = this.rangeAxes.size();\r\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\r\n            ValueAxis yAxis = getRangeAxis(axisIndex);\r\n            if (yAxis != null) {\r\n                yAxis.configure();\r\n            }\r\n        }\r\n        if (getParent() != null) {\r\n            getParent().datasetChanged(event);\r\n        } else {\r\n            PlotChangeEvent e = new PlotChangeEvent(this);\r\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\r\n            notifyListeners(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Receives notification of a renderer change event.\r\n     *\r\n     * @param event  the event.\r\n     */\r\n    public void rendererChanged(RendererChangeEvent event) {\r\n        Plot parent = getParent();\r\n        if (parent != null) {\r\n            if (parent instanceof RendererChangeListener) {\r\n                RendererChangeListener rcl = (RendererChangeListener) parent;\r\n                rcl.rendererChanged(event);\r\n            } else {\r\n                // this should never happen with the existing code, but throw\r\n                // an exception in case future changes make it possible...\r\n                throw new RuntimeException(\"The renderer has changed and I don't know what to do!\");\r\n            }\r\n        } else {\r\n            configureRangeAxes();\r\n            PlotChangeEvent e = new PlotChangeEvent(this);\r\n            notifyListeners(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for display (in the foreground) against the domain axis and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a\r\n     * marker will be drawn by the renderer as a line perpendicular to the\r\n     * domain axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param marker  the marker (<code>null</code> not permitted).\r\n     *\r\n     * @see #removeDomainMarker(Marker)\r\n     */\r\n    public void addDomainMarker(CategoryMarker marker) {\r\n        addDomainMarker(marker, Layer.FOREGROUND);\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for display against the domain axis and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker\r\n     * will be drawn by the renderer as a line perpendicular to the domain\r\n     * axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param marker  the marker (<code>null</code> not permitted).\r\n     * @param layer  the layer (foreground or background) (<code>null</code>\r\n     *               not permitted).\r\n     *\r\n     * @see #removeDomainMarker(Marker, Layer)\r\n     */\r\n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\r\n        addDomainMarker(0, marker, layer);\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for display by a particular renderer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to a domain axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param index  the renderer index.\r\n     * @param marker  the marker (<code>null</code> not permitted).\r\n     * @param layer  the layer (<code>null</code> not permitted).\r\n     *\r\n     * @see #removeDomainMarker(int, Marker, Layer)\r\n     */\r\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\r\n        addDomainMarker(index, marker, layer, true);\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for display by a particular renderer and, if requested,\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to a domain axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param index  the renderer index.\r\n     * @param marker  the marker (<code>null</code> not permitted).\r\n     * @param layer  the layer (<code>null</code> not permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @since 1.0.10\r\n     *\r\n     * @see #removeDomainMarker(int, Marker, Layer, boolean)\r\n     */\r\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer, boolean notify) {\r\n        if (marker == null) {\r\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\r\n        }\r\n        if (layer == null) {\r\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\r\n        }\r\n        Collection markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (Collection) this.foregroundDomainMarkers.get(new Integer(index));\r\n            if (markers == null) {\r\n                markers = new java.util.ArrayList();\r\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\r\n            }\r\n            markers.add(marker);\r\n        } else if (layer == Layer.BACKGROUND) {\r\n            markers = (Collection) this.backgroundDomainMarkers.get(new Integer(index));\r\n            if (markers == null) {\r\n                markers = new java.util.ArrayList();\r\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\r\n            }\r\n            markers.add(marker);\r\n        }\r\n        marker.addChangeListener(this);\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears all the domain markers for the plot and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @see #clearRangeMarkers()\r\n     */\r\n    public void clearDomainMarkers() {\r\n        if (this.backgroundDomainMarkers != null) {\r\n            Set keys = this.backgroundDomainMarkers.keySet();\r\n            Iterator iterator = keys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Integer key = (Integer) iterator.next();\r\n                clearDomainMarkers(key.intValue());\r\n            }\r\n            this.backgroundDomainMarkers.clear();\r\n        }\r\n        if (this.foregroundDomainMarkers != null) {\r\n            Set keys = this.foregroundDomainMarkers.keySet();\r\n            Iterator iterator = keys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Integer key = (Integer) iterator.next();\r\n                clearDomainMarkers(key.intValue());\r\n            }\r\n            this.foregroundDomainMarkers.clear();\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the list of domain markers (read only) for the specified layer.\r\n     *\r\n     * @param layer  the layer (foreground or background).\r\n     *\r\n     * @return The list of domain markers.\r\n     */\r\n    public Collection getDomainMarkers(Layer layer) {\r\n        return getDomainMarkers(0, layer);\r\n    }\r\n\r\n    /**\r\n     * Returns a collection of domain markers for a particular renderer and\r\n     * layer.\r\n     *\r\n     * @param index  the renderer index.\r\n     * @param layer  the layer.\r\n     *\r\n     * @return A collection of markers (possibly <code>null</code>).\r\n     */\r\n    public Collection getDomainMarkers(int index, Layer layer) {\r\n        Collection result = null;\r\n        Integer key = new Integer(index);\r\n        if (layer == Layer.FOREGROUND) {\r\n            result = (Collection) this.foregroundDomainMarkers.get(key);\r\n        } else if (layer == Layer.BACKGROUND) {\r\n            result = (Collection) this.backgroundDomainMarkers.get(key);\r\n        }\r\n        if (result != null) {\r\n            result = Collections.unmodifiableCollection(result);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Clears all the domain markers for the specified renderer.\r\n     *\r\n     * @param index  the renderer index.\r\n     *\r\n     * @see #clearRangeMarkers(int)\r\n     */\r\n    public void clearDomainMarkers(int index) {\r\n        Integer key = new Integer(index);\r\n        if (this.backgroundDomainMarkers != null) {\r\n            Collection markers = (Collection) this.backgroundDomainMarkers.get(key);\r\n            if (markers != null) {\r\n                Iterator iterator = markers.iterator();\r\n                while (iterator.hasNext()) {\r\n                    Marker m = (Marker) iterator.next();\r\n                    m.removeChangeListener(this);\r\n                }\r\n                markers.clear();\r\n            }\r\n        }\r\n        if (this.foregroundDomainMarkers != null) {\r\n            Collection markers = (Collection) this.foregroundDomainMarkers.get(key);\r\n            if (markers != null) {\r\n                Iterator iterator = markers.iterator();\r\n                while (iterator.hasNext()) {\r\n                    Marker m = (Marker) iterator.next();\r\n                    m.removeChangeListener(this);\r\n                }\r\n                markers.clear();\r\n            }\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param marker  the marker.\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public boolean removeDomainMarker(Marker marker) {\r\n        return removeDomainMarker(marker, Layer.FOREGROUND);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for the domain axis in the specified layer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param marker the marker (<code>null</code> not permitted).\r\n     * @param layer the layer (foreground or background).\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\r\n        return removeDomainMarker(0, marker, layer);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for a specific dataset/renderer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index the dataset/renderer index.\r\n     * @param marker the marker.\r\n     * @param layer the layer (foreground or background).\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\r\n        return removeDomainMarker(index, marker, layer, true);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for a specific dataset/renderer and, if requested,\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index the dataset/renderer index.\r\n     * @param marker the marker.\r\n     * @param layer the layer (foreground or background).\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) {\r\n        ArrayList markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(index));\r\n        } else {\r\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(index));\r\n        }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n        boolean removed = markers.remove(marker);\r\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for display (in the foreground) against the range axis and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a\r\n     * marker will be drawn by the renderer as a line perpendicular to the\r\n     * range axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param marker  the marker (<code>null</code> not permitted).\r\n     *\r\n     * @see #removeRangeMarker(Marker)\r\n     */\r\n    public void addRangeMarker(Marker marker) {\r\n        addRangeMarker(marker, Layer.FOREGROUND);\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for display against the range axis and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker\r\n     * will be drawn by the renderer as a line perpendicular to the range axis,\r\n     * however this is entirely up to the renderer.\r\n     *\r\n     * @param marker  the marker (<code>null</code> not permitted).\r\n     * @param layer  the layer (foreground or background) (<code>null</code>\r\n     *               not permitted).\r\n     *\r\n     * @see #removeRangeMarker(Marker, Layer)\r\n     */\r\n    public void addRangeMarker(Marker marker, Layer layer) {\r\n        addRangeMarker(0, marker, layer);\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for display by a particular renderer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to a range axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param index  the renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer.\r\n     *\r\n     * @see #removeRangeMarker(int, Marker, Layer)\r\n     */\r\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\r\n        addRangeMarker(index, marker, layer, true);\r\n    }\r\n\r\n    /**\r\n     * Adds a marker for display by a particular renderer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     * <P>\r\n     * Typically a marker will be drawn by the renderer as a line perpendicular\r\n     * to a range axis, however this is entirely up to the renderer.\r\n     *\r\n     * @param index  the renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer.\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @since 1.0.10\r\n     *\r\n     * @see #removeRangeMarker(int, Marker, Layer, boolean)\r\n     */\r\n    public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\r\n        Collection markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (Collection) this.foregroundRangeMarkers.get(new Integer(index));\r\n            if (markers == null) {\r\n                markers = new java.util.ArrayList();\r\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\r\n            }\r\n            markers.add(marker);\r\n        } else if (layer == Layer.BACKGROUND) {\r\n            markers = (Collection) this.backgroundRangeMarkers.get(new Integer(index));\r\n            if (markers == null) {\r\n                markers = new java.util.ArrayList();\r\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\r\n            }\r\n            markers.add(marker);\r\n        }\r\n        marker.addChangeListener(this);\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears all the range markers for the plot and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @see #clearDomainMarkers()\r\n     */\r\n    public void clearRangeMarkers() {\r\n        if (this.backgroundRangeMarkers != null) {\r\n            Set keys = this.backgroundRangeMarkers.keySet();\r\n            Iterator iterator = keys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Integer key = (Integer) iterator.next();\r\n                clearRangeMarkers(key.intValue());\r\n            }\r\n            this.backgroundRangeMarkers.clear();\r\n        }\r\n        if (this.foregroundRangeMarkers != null) {\r\n            Set keys = this.foregroundRangeMarkers.keySet();\r\n            Iterator iterator = keys.iterator();\r\n            while (iterator.hasNext()) {\r\n                Integer key = (Integer) iterator.next();\r\n                clearRangeMarkers(key.intValue());\r\n            }\r\n            this.foregroundRangeMarkers.clear();\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the list of range markers (read only) for the specified layer.\r\n     *\r\n     * @param layer  the layer (foreground or background).\r\n     *\r\n     * @return The list of range markers.\r\n     *\r\n     * @see #getRangeMarkers(int, Layer)\r\n     */\r\n    public Collection getRangeMarkers(Layer layer) {\r\n        return getRangeMarkers(0, layer);\r\n    }\r\n\r\n    /**\r\n     * Returns a collection of range markers for a particular renderer and\r\n     * layer.\r\n     *\r\n     * @param index  the renderer index.\r\n     * @param layer  the layer.\r\n     *\r\n     * @return A collection of markers (possibly <code>null</code>).\r\n     */\r\n    public Collection getRangeMarkers(int index, Layer layer) {\r\n        Collection result = null;\r\n        Integer key = new Integer(index);\r\n        if (layer == Layer.FOREGROUND) {\r\n            result = (Collection) this.foregroundRangeMarkers.get(key);\r\n        } else if (layer == Layer.BACKGROUND) {\r\n            result = (Collection) this.backgroundRangeMarkers.get(key);\r\n        }\r\n        if (result != null) {\r\n            result = Collections.unmodifiableCollection(result);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Clears all the range markers for the specified renderer.\r\n     *\r\n     * @param index  the renderer index.\r\n     *\r\n     * @see #clearDomainMarkers(int)\r\n     */\r\n    public void clearRangeMarkers(int index) {\r\n        Integer key = new Integer(index);\r\n        if (this.backgroundRangeMarkers != null) {\r\n            Collection markers = (Collection) this.backgroundRangeMarkers.get(key);\r\n            if (markers != null) {\r\n                Iterator iterator = markers.iterator();\r\n                while (iterator.hasNext()) {\r\n                    Marker m = (Marker) iterator.next();\r\n                    m.removeChangeListener(this);\r\n                }\r\n                markers.clear();\r\n            }\r\n        }\r\n        if (this.foregroundRangeMarkers != null) {\r\n            Collection markers = (Collection) this.foregroundRangeMarkers.get(key);\r\n            if (markers != null) {\r\n                Iterator iterator = markers.iterator();\r\n                while (iterator.hasNext()) {\r\n                    Marker m = (Marker) iterator.next();\r\n                    m.removeChangeListener(this);\r\n                }\r\n                markers.clear();\r\n            }\r\n        }\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param marker the marker.\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     *\r\n     * @see #addRangeMarker(Marker)\r\n     */\r\n    public boolean removeRangeMarker(Marker marker) {\r\n        return removeRangeMarker(marker, Layer.FOREGROUND);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for the range axis in the specified layer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param marker the marker (<code>null</code> not permitted).\r\n     * @param layer the layer (foreground or background).\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     *\r\n     * @see #addRangeMarker(Marker, Layer)\r\n     */\r\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\r\n        return removeRangeMarker(0, marker, layer);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for a specific dataset/renderer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index the dataset/renderer index.\r\n     * @param marker the marker.\r\n     * @param layer the layer (foreground or background).\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.7\r\n     *\r\n     * @see #addRangeMarker(int, Marker, Layer)\r\n     */\r\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\r\n        return removeRangeMarker(index, marker, layer, true);\r\n    }\r\n\r\n    /**\r\n     * Removes a marker for a specific dataset/renderer and sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param index  the dataset/renderer index.\r\n     * @param marker  the marker.\r\n     * @param layer  the layer (foreground or background).\r\n     * @param notify  notify listeners.\r\n     *\r\n     * @return A boolean indicating whether or not the marker was actually\r\n     *         removed.\r\n     *\r\n     * @since 1.0.10\r\n     *\r\n     * @see #addRangeMarker(int, Marker, Layer, boolean)\r\n     */\r\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) {\r\n        if (marker == null) {\r\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\r\n        }\r\n        ArrayList markers;\r\n        if (layer == Layer.FOREGROUND) {\r\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(index));\r\n        } else {\r\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(index));\r\n        }\r\n        if (markers == null) {\r\n            return false;\r\n        }\r\n        boolean removed = markers.remove(marker);\r\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n\r\n    /**\r\n     * Returns a flag indicating whether or not the range crosshair is visible.\r\n     *\r\n     * @return The flag.\r\n     *\r\n     * @see #setRangeCrosshairVisible(boolean)\r\n     */\r\n    public boolean isRangeCrosshairVisible() {\r\n        return this.rangeCrosshairVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag indicating whether or not the range crosshair is visible.\r\n     *\r\n     * @param flag  the new value of the flag.\r\n     *\r\n     * @see #isRangeCrosshairVisible()\r\n     */\r\n    public void setRangeCrosshairVisible(boolean flag) {\r\n        if (this.rangeCrosshairVisible != flag) {\r\n            this.rangeCrosshairVisible = flag;\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\r\n     * to actual data values.\r\n     *\r\n     * @return The flag.\r\n     *\r\n     * @see #setRangeCrosshairLockedOnData(boolean)\r\n     */\r\n    public boolean isRangeCrosshairLockedOnData() {\r\n        return this.rangeCrosshairLockedOnData;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag indicating whether or not the range crosshair should\r\n     * \"lock-on\" to actual data values.\r\n     *\r\n     * @param flag  the flag.\r\n     *\r\n     * @see #isRangeCrosshairLockedOnData()\r\n     */\r\n    public void setRangeCrosshairLockedOnData(boolean flag) {\r\n        if (this.rangeCrosshairLockedOnData != flag) {\r\n            this.rangeCrosshairLockedOnData = flag;\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the range crosshair value.\r\n     *\r\n     * @return The value.\r\n     *\r\n     * @see #setRangeCrosshairValue(double)\r\n     */\r\n    public double getRangeCrosshairValue() {\r\n        return this.rangeCrosshairValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the domain crosshair value.\r\n     * <P>\r\n     * Registered listeners are notified that the plot has been modified, but\r\n     * only if the crosshair is visible.\r\n     *\r\n     * @param value  the new value.\r\n     *\r\n     * @see #getRangeCrosshairValue()\r\n     */\r\n    public void setRangeCrosshairValue(double value) {\r\n        setRangeCrosshairValue(value, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the range crosshair value and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners (but only if the\r\n     * crosshair is visible).\r\n     *\r\n     * @param value  the new value.\r\n     * @param notify  a flag that controls whether or not listeners are\r\n     *                notified.\r\n     *\r\n     * @see #getRangeCrosshairValue()\r\n     */\r\n    public void setRangeCrosshairValue(double value, boolean notify) {\r\n        this.rangeCrosshairValue = value;\r\n        if (isRangeCrosshairVisible() && notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the pen-style (<code>Stroke</code>) used to draw the crosshair\r\n     * (if visible).\r\n     *\r\n     * @return The crosshair stroke (never <code>null</code>).\r\n     *\r\n     * @see #setRangeCrosshairStroke(Stroke)\r\n     * @see #isRangeCrosshairVisible()\r\n     * @see #getRangeCrosshairPaint()\r\n     */\r\n    public Stroke getRangeCrosshairStroke() {\r\n        return this.rangeCrosshairStroke;\r\n    }\r\n\r\n    /**\r\n     * Sets the pen-style (<code>Stroke</code>) used to draw the range\r\n     * crosshair (if visible), and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param stroke  the new crosshair stroke (<code>null</code> not\r\n     *         permitted).\r\n     *\r\n     * @see #getRangeCrosshairStroke()\r\n     */\r\n    public void setRangeCrosshairStroke(Stroke stroke) {\r\n        if (stroke == null) {\r\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\r\n        }\r\n        this.rangeCrosshairStroke = stroke;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the paint used to draw the range crosshair.\r\n     *\r\n     * @return The paint (never <code>null</code>).\r\n     *\r\n     * @see #setRangeCrosshairPaint(Paint)\r\n     * @see #isRangeCrosshairVisible()\r\n     * @see #getRangeCrosshairStroke()\r\n     */\r\n    public Paint getRangeCrosshairPaint() {\r\n        return this.rangeCrosshairPaint;\r\n    }\r\n\r\n    /**\r\n     * Sets the paint used to draw the range crosshair (if visible) and\r\n     * sends a {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param paint  the paint (<code>null</code> not permitted).\r\n     *\r\n     * @see #getRangeCrosshairPaint()\r\n     */\r\n    public void setRangeCrosshairPaint(Paint paint) {\r\n        if (paint == null) {\r\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\r\n        }\r\n        this.rangeCrosshairPaint = paint;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the list of annotations.\r\n     *\r\n     * @return The list of annotations (never <code>null</code>).\r\n     */\r\n    public List getAnnotations() {\r\n        return this.annotations;\r\n    }\r\n\r\n    /**\r\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param annotation  the annotation (<code>null</code> not permitted).\r\n     *\r\n     * @see #removeAnnotation(CategoryAnnotation)\r\n     */\r\n    public void addAnnotation(CategoryAnnotation annotation) {\r\n        addAnnotation(annotation, true);\r\n    }\r\n\r\n    /**\r\n     * Adds an annotation to the plot and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param annotation  the annotation (<code>null</code> not permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public void addAnnotation(CategoryAnnotation annotation, boolean notify) {\r\n        if (annotation == null) {\r\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\r\n        }\r\n        this.annotations.add(annotation);\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param annotation  the annotation (<code>null</code> not permitted).\r\n     *\r\n     * @return A boolean (indicates whether or not the annotation was removed).\r\n     *\r\n     * @see #addAnnotation(CategoryAnnotation)\r\n     */\r\n    public boolean removeAnnotation(CategoryAnnotation annotation) {\r\n        return removeAnnotation(annotation, true);\r\n    }\r\n\r\n    /**\r\n     * Removes an annotation from the plot and, if requested, sends a\r\n     * {@link PlotChangeEvent} to all registered listeners.\r\n     *\r\n     * @param annotation  the annotation (<code>null</code> not permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @return A boolean (indicates whether or not the annotation was removed).\r\n     *\r\n     * @since 1.0.10\r\n     */\r\n    public boolean removeAnnotation(CategoryAnnotation annotation, boolean notify) {\r\n        if (annotation == null) {\r\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\r\n        }\r\n        boolean removed = this.annotations.remove(annotation);\r\n        if (removed && notify) {\r\n            fireChangeEvent();\r\n        }\r\n        return removed;\r\n    }\r\n\r\n    /**\r\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     */\r\n    public void clearAnnotations() {\r\n        this.annotations.clear();\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Calculates the space required for the domain axis/axes.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the plot area.\r\n     * @param space  a carrier for the result (<code>null</code> permitted).\r\n     *\r\n     * @return The required space.\r\n     */\r\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\r\n        if (space == null) {\r\n            space = new AxisSpace();\r\n        }\r\n        // reserve some space for the domain axis...\r\n        if (this.fixedDomainAxisSpace != null) {\r\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\r\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), RectangleEdge.RIGHT);\r\n            } else if (this.orientation == PlotOrientation.VERTICAL) {\r\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), RectangleEdge.TOP);\r\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), RectangleEdge.BOTTOM);\r\n            }\r\n        } else {\r\n            // reserve space for the primary domain axis...\r\n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(getDomainAxisLocation(), this.orientation);\r\n            if (this.drawSharedDomainAxis) {\r\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, domainEdge, space);\r\n            }\r\n            // reserve space for any domain axes...\r\n            for (int i = 0; i < this.domainAxes.size(); i++) {\r\n                Axis xAxis = (Axis) this.domainAxes.get(i);\r\n                if (xAxis != null) {\r\n                    RectangleEdge edge = getDomainAxisEdge(i);\r\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\r\n                }\r\n            }\r\n        }\r\n        return space;\r\n    }\r\n\r\n    /**\r\n     * Calculates the space required for the range axis/axes.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the plot area.\r\n     * @param space  a carrier for the result (<code>null</code> permitted).\r\n     *\r\n     * @return The required space.\r\n     */\r\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space) {\r\n        if (space == null) {\r\n            space = new AxisSpace();\r\n        }\r\n        // reserve some space for the range axis...\r\n        if (this.fixedRangeAxisSpace != null) {\r\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), RectangleEdge.TOP);\r\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), RectangleEdge.BOTTOM);\r\n            } else if (this.orientation == PlotOrientation.VERTICAL) {\r\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), RectangleEdge.LEFT);\r\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), RectangleEdge.RIGHT);\r\n            }\r\n        } else {\r\n            // reserve space for the range axes (if any)...\r\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\r\n                if (yAxis != null) {\r\n                    RectangleEdge edge = getRangeAxisEdge(i);\r\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\r\n                }\r\n            }\r\n        }\r\n        return space;\r\n    }\r\n\r\n    /**\r\n     * Calculates the space required for the axes.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the plot area.\r\n     *\r\n     * @return The space required for the axes.\r\n     */\r\n    protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea) {\r\n        AxisSpace space = new AxisSpace();\r\n        space = calculateRangeAxisSpace(g2, plotArea, space);\r\n        space = calculateDomainAxisSpace(g2, plotArea, space);\r\n        return space;\r\n    }\r\n\r\n    /**\r\n     * Draws the plot on a Java 2D graphics device (such as the screen or a\r\n     * printer).\r\n     * <P>\r\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\r\n     * If you do, it will be populated with information about the drawing,\r\n     * including various plot dimensions and tooltip info.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area within which the plot (including axes) should\r\n     *              be drawn.\r\n     * @param anchor  the anchor point (<code>null</code> permitted).\r\n     * @param parentState  the state from the parent plot, if there is one.\r\n     * @param state  collects info as the chart is drawn (possibly\r\n     *               <code>null</code>).\r\n     */\r\n    public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state) {\r\n        // if the plot area is too small, just return...\r\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\r\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\r\n        if (b1 || b2) {\r\n            return;\r\n        }\r\n        // record the plot area...\r\n        if (state == null) {\r\n            // if the incoming state is null, no information will be passed\r\n            // back to the caller - but we create a temporary state to record\r\n            // the plot area, since that is used later by the axes\r\n            state = new PlotRenderingInfo(null);\r\n        }\r\n        state.setPlotArea(area);\r\n        // adjust the drawing area for the plot insets (if any)...\r\n        RectangleInsets insets = getInsets();\r\n        insets.trim(area);\r\n        // calculate the data area...\r\n        AxisSpace space = calculateAxisSpace(g2, area);\r\n        Rectangle2D dataArea = space.shrink(area, null);\r\n        this.axisOffset.trim(dataArea);\r\n        state.setDataArea(dataArea);\r\n        // if there is a renderer, it draws the background, otherwise use the\r\n        // default background...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawBackground(g2, this, dataArea);\r\n        } else {\r\n            drawBackground(g2, dataArea);\r\n        }\r\n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\r\n        // don't let anyone draw outside the data area\r\n        Shape savedClip = g2.getClip();\r\n        g2.clip(dataArea);\r\n        drawDomainGridlines(g2, dataArea);\r\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\r\n        if (rangeAxisState == null) {\r\n            if (parentState != null) {\r\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates().get(getRangeAxis());\r\n            }\r\n        }\r\n        if (rangeAxisState != null) {\r\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\r\n        }\r\n        // draw the markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\r\n        }\r\n        // now render data items...\r\n        boolean foundData = false;\r\n        // set up the alpha-transparency...\r\n        Composite originalComposite = g2.getComposite();\r\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getForegroundAlpha()));\r\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\r\n        if (order == DatasetRenderingOrder.FORWARD) {\r\n            // draw background annotations\r\n            int datasetCount = this.datasets.size();\r\n            for (int i = 0; i < datasetCount; i++) {\r\n                CategoryItemRenderer r = getRenderer(i);\r\n                if (r != null) {\r\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\r\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\r\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.BACKGROUND, state);\r\n                }\r\n            }\r\n            for (int i = 0; i < datasetCount; i++) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;\r\n            }\r\n            // draw foreground annotations\r\n            for (int i = 0; i < datasetCount; i++) {\r\n                CategoryItemRenderer r = getRenderer(i);\r\n                if (r != null) {\r\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\r\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\r\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.FOREGROUND, state);\r\n                }\r\n            }\r\n        } else {\r\n            // DatasetRenderingOrder.REVERSE\r\n            // draw background annotations\r\n            int datasetCount = this.datasets.size();\r\n            for (int i = datasetCount - 1; i >= 0; i--) {\r\n                CategoryItemRenderer r = getRenderer(i);\r\n                if (r != null) {\r\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\r\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\r\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.BACKGROUND, state);\r\n                }\r\n            }\r\n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\r\n                foundData = render(g2, dataArea, i, state) || foundData;\r\n            }\r\n            // draw foreground annotations\r\n            for (int i = datasetCount - 1; i >= 0; i--) {\r\n                CategoryItemRenderer r = getRenderer(i);\r\n                if (r != null) {\r\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\r\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\r\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis, Layer.FOREGROUND, state);\r\n                }\r\n            }\r\n        }\r\n        // draw the foreground markers...\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        for (int i = 0; i < this.renderers.size(); i++) {\r\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\r\n        }\r\n        // draw the plot's annotations (if any)...\r\n        drawAnnotations(g2, dataArea, state);\r\n        g2.setClip(savedClip);\r\n        g2.setComposite(originalComposite);\r\n        if (!foundData) {\r\n            drawNoDataMessage(g2, dataArea);\r\n        }\r\n        // draw range crosshair if required...\r\n        if (isRangeCrosshairVisible()) {\r\n            // FIXME: this doesn't handle multiple range axes\r\n            drawRangeCrosshair(g2, dataArea, getOrientation(), getRangeCrosshairValue(), getRangeAxis(), getRangeCrosshairStroke(), getRangeCrosshairPaint());\r\n        }\r\n        // draw an outline around the plot area...\r\n        if (getRenderer() != null) {\r\n            getRenderer().drawOutline(g2, this, dataArea);\r\n        } else {\r\n            drawOutline(g2, dataArea);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the plot background (the background color and/or image).\r\n     * <P>\r\n     * This method will be called during the chart drawing process and is\r\n     * declared public so that it can be accessed by the renderers used by\r\n     * certain subclasses.  You shouldn't need to call this method directly.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param area  the area within which the plot should be drawn.\r\n     */\r\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\r\n        fillBackground(g2, area, this.orientation);\r\n        drawBackgroundImage(g2, area);\r\n    }\r\n\r\n    /**\r\n     * A utility method for drawing the plot's axes.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param plotArea  the plot area.\r\n     * @param dataArea  the data area.\r\n     * @param plotState  collects information about the plot (<code>null</code>\r\n     *                   permitted).\r\n     *\r\n     * @return A map containing the axis states.\r\n     */\r\n    protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) {\r\n        AxisCollection axisCollection = new AxisCollection();\r\n        // add domain axes to lists...\r\n        for (int index = 0; index < this.domainAxes.size(); index++) {\r\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\r\n            if (xAxis != null) {\r\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\r\n            }\r\n        }\r\n        // add range axes to lists...\r\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\r\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\r\n            if (yAxis != null) {\r\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\r\n            }\r\n        }\r\n        Map axisStateMap = new HashMap();\r\n        // draw the top axes\r\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(dataArea.getHeight());\r\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\r\n        while (iterator.hasNext()) {\r\n            Axis axis = (Axis) iterator.next();\r\n            if (axis != null) {\r\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.TOP, plotState);\r\n                cursor = axisState.getCursor();\r\n                axisStateMap.put(axis, axisState);\r\n            }\r\n        }\r\n        // draw the bottom axes\r\n        cursor = dataArea.getMaxY() + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\r\n        iterator = axisCollection.getAxesAtBottom().iterator();\r\n        while (iterator.hasNext()) {\r\n            Axis axis = (Axis) iterator.next();\r\n            if (axis != null) {\r\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.BOTTOM, plotState);\r\n                cursor = axisState.getCursor();\r\n                axisStateMap.put(axis, axisState);\r\n            }\r\n        }\r\n        // draw the left axes\r\n        cursor = dataArea.getMinX() - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\r\n        iterator = axisCollection.getAxesAtLeft().iterator();\r\n        while (iterator.hasNext()) {\r\n            Axis axis = (Axis) iterator.next();\r\n            if (axis != null) {\r\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.LEFT, plotState);\r\n                cursor = axisState.getCursor();\r\n                axisStateMap.put(axis, axisState);\r\n            }\r\n        }\r\n        // draw the right axes\r\n        cursor = dataArea.getMaxX() + this.axisOffset.calculateRightOutset(dataArea.getWidth());\r\n        iterator = axisCollection.getAxesAtRight().iterator();\r\n        while (iterator.hasNext()) {\r\n            Axis axis = (Axis) iterator.next();\r\n            if (axis != null) {\r\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.RIGHT, plotState);\r\n                cursor = axisState.getCursor();\r\n                axisStateMap.put(axis, axisState);\r\n            }\r\n        }\r\n        return axisStateMap;\r\n    }\r\n\r\n    /**\r\n     * Draws a representation of a dataset within the dataArea region using the\r\n     * appropriate renderer.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the region in which the data is to be drawn.\r\n     * @param index  the dataset and renderer index.\r\n     * @param info  an optional object for collection dimension information.\r\n     *\r\n     * @return A boolean that indicates whether or not real data was found.\r\n     */\r\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info) {\r\n        boolean foundData = false;\r\n        CategoryDataset currentDataset = getDataset(index);\r\n        CategoryItemRenderer renderer = getRenderer(index);\r\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\r\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\r\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\r\n        if (hasData && renderer != null) {\r\n            foundData = true;\r\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea, this, index, info);\r\n            int columnCount = currentDataset.getColumnCount();\r\n            int rowCount = currentDataset.getRowCount();\r\n            int passCount = renderer.getPassCount();\r\n            for (int pass = 0; pass < passCount; pass++) {\r\n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\r\n                    for (int column = 0; column < columnCount; column++) {\r\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\r\n                            for (int row = 0; row < rowCount; row++) {\r\n                                renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, pass);\r\n                            }\r\n                        } else {\r\n                            for (int row = rowCount - 1; row >= 0; row--) {\r\n                                renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, pass);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    for (int column = columnCount - 1; column >= 0; column--) {\r\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\r\n                            for (int row = 0; row < rowCount; row++) {\r\n                                renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, pass);\r\n                            }\r\n                        } else {\r\n                            for (int row = rowCount - 1; row >= 0; row--) {\r\n                                renderer.drawItem(g2, state, dataArea, this, domainAxis, rangeAxis, currentDataset, row, column, pass);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return foundData;\r\n    }\r\n\r\n    /**\r\n     * Draws the gridlines for the plot.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the area inside the axes.\r\n     *\r\n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\r\n     */\r\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\r\n        // draw the domain grid lines, if any...\r\n        if (isDomainGridlinesVisible()) {\r\n            CategoryAnchor anchor = getDomainGridlinePosition();\r\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\r\n            Stroke gridStroke = getDomainGridlineStroke();\r\n            Paint gridPaint = getDomainGridlinePaint();\r\n            if ((gridStroke != null) && (gridPaint != null)) {\r\n                // iterate over the categories\r\n                CategoryDataset data = getDataset();\r\n                if (data != null) {\r\n                    CategoryAxis axis = getDomainAxis();\r\n                    if (axis != null) {\r\n                        int columnCount = data.getColumnCount();\r\n                        for (int c = 0; c < columnCount; c++) {\r\n                            double xx = axis.getCategoryJava2DCoordinate(anchor, c, columnCount, dataArea, domainAxisEdge);\r\n                            CategoryItemRenderer renderer1 = getRenderer();\r\n                            if (renderer1 != null) {\r\n                                renderer1.drawDomainGridline(g2, this, dataArea, xx);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the gridlines for the plot.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the area inside the axes.\r\n     * @param ticks  the ticks.\r\n     *\r\n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D)\r\n     */\r\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks) {\r\n        // draw the range grid lines, if any...\r\n        if (isRangeGridlinesVisible()) {\r\n            Stroke gridStroke = getRangeGridlineStroke();\r\n            Paint gridPaint = getRangeGridlinePaint();\r\n            if ((gridStroke != null) && (gridPaint != null)) {\r\n                ValueAxis axis = getRangeAxis();\r\n                if (axis != null) {\r\n                    Iterator iterator = ticks.iterator();\r\n                    while (iterator.hasNext()) {\r\n                        ValueTick tick = (ValueTick) iterator.next();\r\n                        CategoryItemRenderer renderer1 = getRenderer();\r\n                        if (renderer1 != null) {\r\n                            renderer1.drawRangeGridline(g2, this, getRangeAxis(), dataArea, tick.getValue());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the annotations.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the data area.\r\n     * @param info  the plot rendering info (<code>null</code> permitted).\r\n     */\r\n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info) {\r\n        Iterator iterator = getAnnotations().iterator();\r\n        while (iterator.hasNext()) {\r\n            CategoryAnnotation annotation = (CategoryAnnotation) iterator.next();\r\n            annotation.draw(g2, this, dataArea, getDomainAxis(), getRangeAxis(), 0, info);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the domain markers (if any) for an axis and layer.  This method is\r\n     * typically called from within the draw() method.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the data area.\r\n     * @param index  the renderer index.\r\n     * @param layer  the layer (foreground or background).\r\n     *\r\n     * @see #drawRangeMarkers(Graphics2D, Rectangle2D, int, Layer)\r\n     */\r\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\r\n        CategoryItemRenderer r = getRenderer(index);\r\n        if (r == null) {\r\n            return;\r\n        }\r\n        Collection markers = getDomainMarkers(index, layer);\r\n        CategoryAxis axis = getDomainAxisForDataset(index);\r\n        if (markers != null && axis != null) {\r\n            Iterator iterator = markers.iterator();\r\n            while (iterator.hasNext()) {\r\n                CategoryMarker marker = (CategoryMarker) iterator.next();\r\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the range markers (if any) for an axis and layer.  This method is\r\n     * typically called from within the draw() method.\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the data area.\r\n     * @param index  the renderer index.\r\n     * @param layer  the layer (foreground or background).\r\n     *\r\n     * @see #drawDomainMarkers(Graphics2D, Rectangle2D, int, Layer)\r\n     */\r\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {\r\n        CategoryItemRenderer r = getRenderer(index);\r\n        if (r == null) {\r\n            return;\r\n        }\r\n        Collection markers = getRangeMarkers(index, layer);\r\n        ValueAxis axis = getRangeAxisForDataset(index);\r\n        if (markers != null && axis != null) {\r\n            Iterator iterator = markers.iterator();\r\n            while (iterator.hasNext()) {\r\n                Marker marker = (Marker) iterator.next();\r\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Utility method for drawing a line perpendicular to the range axis (used\r\n     * for crosshairs).\r\n     *\r\n     * @param g2  the graphics device.\r\n     * @param dataArea  the area defined by the axes.\r\n     * @param value  the data value.\r\n     * @param stroke  the line stroke (<code>null</code> not permitted).\r\n     * @param paint  the line paint (<code>null</code> not permitted).\r\n     */\r\n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint) {\r\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea, getRangeAxisEdge());\r\n        Line2D line = null;\r\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, dataArea.getMaxY());\r\n        } else if (this.orientation == PlotOrientation.VERTICAL) {\r\n            line = new Line2D.Double(dataArea.getMinX(), java2D, dataArea.getMaxX(), java2D);\r\n        }\r\n        g2.setStroke(stroke);\r\n        g2.setPaint(paint);\r\n        g2.draw(line);\r\n    }\r\n\r\n    /**\r\n     * Draws a range crosshair.\r\n     *\r\n     * @param g2  the graphics target.\r\n     * @param dataArea  the data area.\r\n     * @param orientation  the plot orientation.\r\n     * @param value  the crosshair value.\r\n     * @param axis  the axis against which the value is measured.\r\n     * @param stroke  the stroke used to draw the crosshair line.\r\n     * @param paint  the paint used to draw the crosshair line.\r\n     *\r\n     * @since 1.0.5\r\n     */\r\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint) {\r\n        if (!axis.getRange().contains(value)) {\r\n            return;\r\n        }\r\n        Line2D line = null;\r\n        if (orientation == PlotOrientation.HORIZONTAL) {\r\n            double xx = axis.valueToJava2D(value, dataArea, RectangleEdge.BOTTOM);\r\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx, dataArea.getMaxY());\r\n        } else {\r\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\r\n            line = new Line2D.Double(dataArea.getMinX(), yy, dataArea.getMaxX(), yy);\r\n        }\r\n        g2.setStroke(stroke);\r\n        g2.setPaint(paint);\r\n        g2.draw(line);\r\n    }\r\n\r\n    /**\r\n     * Returns the range of data values that will be plotted against the range\r\n     * axis.  If the dataset is <code>null</code>, this method returns\r\n     * <code>null</code>.\r\n     *\r\n     * @param axis  the axis.\r\n     *\r\n     * @return The data range.\r\n     */\r\n    public Range getDataRange(ValueAxis axis) {\r\n        Range result = null;\r\n        List mappedDatasets = new ArrayList();\r\n        int rangeIndex = this.rangeAxes.indexOf(axis);\r\n        if (rangeIndex >= 0) {\r\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\r\n        } else if (axis == getRangeAxis()) {\r\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\r\n        }\r\n        // iterate through the datasets that map to the axis and get the union\r\n        // of the ranges.\r\n        Iterator iterator = mappedDatasets.iterator();\r\n        while (iterator.hasNext()) {\r\n            CategoryDataset d = (CategoryDataset) iterator.next();\r\n            CategoryItemRenderer r = getRendererForDataset(d);\r\n            if (r != null) {\r\n                result = Range.combine(result, r.findRangeBounds(d));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the datasets that are mapped to the axis with the\r\n     * specified index.\r\n     *\r\n     * @param axisIndex  the axis index.\r\n     *\r\n     * @return The list (possibly empty, but never <code>null</code>).\r\n     *\r\n     * @since 1.0.3\r\n     */\r\n    private List datasetsMappedToDomainAxis(int axisIndex) {\r\n        List result = new ArrayList();\r\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); datasetIndex++) {\r\n            Object dataset = this.datasets.get(datasetIndex);\r\n            if (dataset != null) {\r\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(datasetIndex);\r\n                if (m == null) {\r\n                    // a dataset with no mapping is assigned to\r\n                    // axis 0\r\n                    if (axisIndex == 0) {\r\n                        result.add(dataset);\r\n                    }\r\n                } else {\r\n                    if (m.intValue() == axisIndex) {\r\n                        result.add(dataset);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * A utility method that returns a list of datasets that are mapped to a\r\n     * given range axis.\r\n     *\r\n     * @param index  the axis index.\r\n     *\r\n     * @return A list of datasets.\r\n     */\r\n    private List datasetsMappedToRangeAxis(int index) {\r\n        List result = new ArrayList();\r\n        for (int i = 0; i < this.datasets.size(); i++) {\r\n            Object dataset = this.datasets.get(i);\r\n            if (dataset != null) {\r\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\r\n                if (m == null) {\r\n                    // a dataset with no mapping is assigned to\r\n                    // axis 0\r\n                    if (index == 0) {\r\n                        result.add(dataset);\r\n                    }\r\n                } else {\r\n                    if (m.intValue() == index) {\r\n                        result.add(dataset);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the weight for this plot when it is used as a subplot within a\r\n     * combined plot.\r\n     *\r\n     * @return The weight.\r\n     *\r\n     * @see #setWeight(int)\r\n     */\r\n    public int getWeight() {\r\n        return this.weight;\r\n    }\r\n\r\n    /**\r\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param weight  the weight.\r\n     *\r\n     * @see #getWeight()\r\n     */\r\n    public void setWeight(int weight) {\r\n        this.weight = weight;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns the fixed domain axis space.\r\n     *\r\n     * @return The fixed domain axis space (possibly <code>null</code>).\r\n     *\r\n     * @see #setFixedDomainAxisSpace(AxisSpace)\r\n     */\r\n    public AxisSpace getFixedDomainAxisSpace() {\r\n        return this.fixedDomainAxisSpace;\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param space  the space (<code>null</code> permitted).\r\n     *\r\n     * @see #getFixedDomainAxisSpace()\r\n     */\r\n    public void setFixedDomainAxisSpace(AxisSpace space) {\r\n        setFixedDomainAxisSpace(space, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param space  the space (<code>null</code> permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getFixedDomainAxisSpace()\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\r\n        this.fixedDomainAxisSpace = space;\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the fixed range axis space.\r\n     *\r\n     * @return The fixed range axis space (possibly <code>null</code>).\r\n     *\r\n     * @see #setFixedRangeAxisSpace(AxisSpace)\r\n     */\r\n    public AxisSpace getFixedRangeAxisSpace() {\r\n        return this.fixedRangeAxisSpace;\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param space  the space (<code>null</code> permitted).\r\n     *\r\n     * @see #getFixedRangeAxisSpace()\r\n     */\r\n    public void setFixedRangeAxisSpace(AxisSpace space) {\r\n        setFixedRangeAxisSpace(space, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to\r\n     * all registered listeners.\r\n     *\r\n     * @param space  the space (<code>null</code> permitted).\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getFixedRangeAxisSpace()\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\r\n        this.fixedRangeAxisSpace = space;\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the categories in the plot's primary dataset.\r\n     *\r\n     * @return A list of the categories in the plot's primary dataset.\r\n     *\r\n     * @see #getCategoriesForAxis(CategoryAxis)\r\n     */\r\n    public List getCategories() {\r\n        List result = null;\r\n        if (getDataset() != null) {\r\n            result = Collections.unmodifiableList(getDataset().getColumnKeys());\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a list of the categories that should be displayed for the\r\n     * specified axis.\r\n     *\r\n     * @param axis  the axis (<code>null</code> not permitted)\r\n     *\r\n     * @return The categories.\r\n     *\r\n     * @since 1.0.3\r\n     */\r\n    public List getCategoriesForAxis(CategoryAxis axis) {\r\n        List result = new ArrayList();\r\n        int axisIndex = this.domainAxes.indexOf(axis);\r\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\r\n        Iterator iterator = datasets.iterator();\r\n        while (iterator.hasNext()) {\r\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\r\n            // add the unique categories from this dataset\r\n            for (int i = 0; i < dataset.getColumnCount(); i++) {\r\n                Comparable category = dataset.getColumnKey(i);\r\n                if (!result.contains(category)) {\r\n                    result.add(category);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the flag that controls whether or not the shared domain axis is\r\n     * drawn for each subplot.\r\n     *\r\n     * @return A boolean.\r\n     *\r\n     * @see #setDrawSharedDomainAxis(boolean)\r\n     */\r\n    public boolean getDrawSharedDomainAxis() {\r\n        return this.drawSharedDomainAxis;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that controls whether the shared domain axis is drawn when\r\n     * this plot is being used as a subplot.\r\n     *\r\n     * @param draw  a boolean.\r\n     *\r\n     * @see #getDrawSharedDomainAxis()\r\n     */\r\n    public void setDrawSharedDomainAxis(boolean draw) {\r\n        this.drawSharedDomainAxis = draw;\r\n        fireChangeEvent();\r\n    }\r\n\r\n    /**\r\n     * Returns <code>false</code> to indicate that the domain axes are not\r\n     * zoomable.\r\n     *\r\n     * @return A boolean.\r\n     *\r\n     * @see #isRangeZoomable()\r\n     */\r\n    public boolean isDomainZoomable() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns <code>true</code> to indicate that the range axes are zoomable.\r\n     *\r\n     * @return A boolean.\r\n     *\r\n     * @see #isDomainZoomable()\r\n     */\r\n    public boolean isRangeZoomable() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * This method does nothing, because <code>CategoryPlot</code> doesn't\r\n     * support zooming on the domain.\r\n     *\r\n     * @param factor  the zoom factor.\r\n     * @param state  the plot state.\r\n     * @param source  the source point (in Java2D space) for the zoom.\r\n     */\r\n    public void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source) {\r\n        // can't zoom domain axis\r\n    }\r\n\r\n    /**\r\n     * This method does nothing, because <code>CategoryPlot</code> doesn't\r\n     * support zooming on the domain.\r\n     *\r\n     * @param lowerPercent  the lower bound.\r\n     * @param upperPercent  the upper bound.\r\n     * @param state  the plot state.\r\n     * @param source  the source point (in Java2D space) for the zoom.\r\n     */\r\n    public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) {\r\n        // can't zoom domain axis\r\n    }\r\n\r\n    /**\r\n     * This method does nothing, because <code>CategoryPlot</code> doesn't\r\n     * support zooming on the domain.\r\n     *\r\n     * @param factor  the zoom factor.\r\n     * @param info  the plot rendering info.\r\n     * @param source  the source point (in Java2D space).\r\n     * @param useAnchor  use source point as zoom anchor?\r\n     *\r\n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\r\n        // can't zoom domain axis\r\n    }\r\n\r\n    /**\r\n     * Multiplies the range on the range axis/axes by the specified factor.\r\n     *\r\n     * @param factor  the zoom factor.\r\n     * @param state  the plot state.\r\n     * @param source  the source point (in Java2D space) for the zoom.\r\n     */\r\n    public void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source) {\r\n        // delegate to other method\r\n        zoomRangeAxes(factor, state, source, false);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the range on the range axis/axes by the specified factor.\r\n     *\r\n     * @param factor  the zoom factor.\r\n     * @param info  the plot rendering info.\r\n     * @param source  the source point.\r\n     * @param useAnchor  a flag that controls whether or not the source point\r\n     *         is used for the zoom anchor.\r\n     *\r\n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\r\n     *\r\n     * @since 1.0.7\r\n     */\r\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor) {\r\n        // perform the zoom on each range axis\r\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\r\n            if (rangeAxis != null) {\r\n                if (useAnchor) {\r\n                    // get the relevant source coordinate given the plot\r\n                    // orientation\r\n                    double sourceY = source.getY();\r\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\r\n                        sourceY = source.getX();\r\n                    }\r\n                    double anchorY = rangeAxis.java2DToValue(sourceY, info.getDataArea(), getRangeAxisEdge());\r\n                    rangeAxis.resizeRange(factor, anchorY);\r\n                } else {\r\n                    rangeAxis.resizeRange(factor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Zooms in on the range axes.\r\n     *\r\n     * @param lowerPercent  the lower bound.\r\n     * @param upperPercent  the upper bound.\r\n     * @param state  the plot state.\r\n     * @param source  the source point (in Java2D space) for the zoom.\r\n     */\r\n    public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source) {\r\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\r\n            if (rangeAxis != null) {\r\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the anchor value.\r\n     *\r\n     * @return The anchor value.\r\n     *\r\n     * @see #setAnchorValue(double)\r\n     */\r\n    public double getAnchorValue() {\r\n        return this.anchorValue;\r\n    }\r\n\r\n    /**\r\n     * Sets the anchor value and sends a {@link PlotChangeEvent} to all\r\n     * registered listeners.\r\n     *\r\n     * @param value  the anchor value.\r\n     *\r\n     * @see #getAnchorValue()\r\n     */\r\n    public void setAnchorValue(double value) {\r\n        setAnchorValue(value, true);\r\n    }\r\n\r\n    /**\r\n     * Sets the anchor value and, if requested, sends a {@link PlotChangeEvent}\r\n     * to all registered listeners.\r\n     *\r\n     * @param value  the value.\r\n     * @param notify  notify listeners?\r\n     *\r\n     * @see #getAnchorValue()\r\n     */\r\n    public void setAnchorValue(double value, boolean notify) {\r\n        this.anchorValue = value;\r\n        if (notify) {\r\n            fireChangeEvent();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Tests the plot for equality with an arbitrary object.\r\n     *\r\n     * @param obj  the object to test against (<code>null</code> permitted).\r\n     *\r\n     * @return A boolean.\r\n     */\r\n    public boolean equals(Object obj) {\r\n        if (obj == this) {\r\n            return true;\r\n        }\r\n        if (!(obj instanceof CategoryPlot)) {\r\n            return false;\r\n        }\r\n        if (!super.equals(obj)) {\r\n            return false;\r\n        }\r\n        CategoryPlot that = (CategoryPlot) obj;\r\n        if (this.orientation != that.orientation) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\r\n            return false;\r\n        }\r\n        if (!this.domainAxes.equals(that.domainAxes)) {\r\n            return false;\r\n        }\r\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\r\n            return false;\r\n        }\r\n        if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) {\r\n            return false;\r\n        }\r\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\r\n            return false;\r\n        }\r\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, that.datasetToDomainAxisMap)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, that.datasetToRangeAxisMap)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\r\n            return false;\r\n        }\r\n        if (this.renderingOrder != that.renderingOrder) {\r\n            return false;\r\n        }\r\n        if (this.columnRenderingOrder != that.columnRenderingOrder) {\r\n            return false;\r\n        }\r\n        if (this.rowRenderingOrder != that.rowRenderingOrder) {\r\n            return false;\r\n        }\r\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\r\n            return false;\r\n        }\r\n        if (this.domainGridlinePosition != that.domainGridlinePosition) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, that.domainGridlineStroke)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.domainGridlinePaint, that.domainGridlinePaint)) {\r\n            return false;\r\n        }\r\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, that.rangeGridlineStroke)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, that.rangeGridlinePaint)) {\r\n            return false;\r\n        }\r\n        if (this.anchorValue != that.anchorValue) {\r\n            return false;\r\n        }\r\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\r\n            return false;\r\n        }\r\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, that.rangeCrosshairStroke)) {\r\n            return false;\r\n        }\r\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, that.rangeCrosshairPaint)) {\r\n            return false;\r\n        }\r\n        if (this.rangeCrosshairLockedOnData != that.rangeCrosshairLockedOnData) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, that.foregroundRangeMarkers)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, that.backgroundRangeMarkers)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\r\n            return false;\r\n        }\r\n        if (this.weight != that.weight) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, that.fixedDomainAxisSpace)) {\r\n            return false;\r\n        }\r\n        if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, that.fixedRangeAxisSpace)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns a clone of the plot.\r\n     *\r\n     * @return A clone.\r\n     *\r\n     * @throws CloneNotSupportedException  if the cloning is not supported.\r\n     */\r\n    public Object clone() throws CloneNotSupportedException {\r\n        CategoryPlot clone = (CategoryPlot) super.clone();\r\n        clone.domainAxes = new ObjectList();\r\n        for (int i = 0; i < this.domainAxes.size(); i++) {\r\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\r\n            if (xAxis != null) {\r\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\r\n                clone.setDomainAxis(i, clonedAxis);\r\n            }\r\n        }\r\n        clone.domainAxisLocations = (ObjectList) this.domainAxisLocations.clone();\r\n        clone.rangeAxes = new ObjectList();\r\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\r\n            if (yAxis != null) {\r\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\r\n                clone.setRangeAxis(i, clonedAxis);\r\n            }\r\n        }\r\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\r\n        clone.datasets = (ObjectList) this.datasets.clone();\r\n        for (int i = 0; i < clone.datasets.size(); i++) {\r\n            CategoryDataset dataset = clone.getDataset(i);\r\n            if (dataset != null) {\r\n                dataset.addChangeListener(clone);\r\n            }\r\n        }\r\n        clone.datasetToDomainAxisMap = (ObjectList) this.datasetToDomainAxisMap.clone();\r\n        clone.datasetToRangeAxisMap = (ObjectList) this.datasetToRangeAxisMap.clone();\r\n        clone.renderers = (ObjectList) this.renderers.clone();\r\n        if (this.fixedDomainAxisSpace != null) {\r\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(this.fixedDomainAxisSpace);\r\n        }\r\n        if (this.fixedRangeAxisSpace != null) {\r\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(this.fixedRangeAxisSpace);\r\n        }\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Provides serialization support.\r\n     *\r\n     * @param stream  the output stream.\r\n     *\r\n     * @throws IOException  if there is an I/O error.\r\n     */\r\n    private void writeObject(ObjectOutputStream stream) throws IOException {\r\n        stream.defaultWriteObject();\r\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\r\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\r\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\r\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\r\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\r\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\r\n    }\r\n\r\n    /**\r\n     * Provides serialization support.\r\n     *\r\n     * @param stream  the input stream.\r\n     *\r\n     * @throws IOException  if there is an I/O error.\r\n     * @throws ClassNotFoundException  if there is a classpath problem.\r\n     */\r\n    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {\r\n        stream.defaultReadObject();\r\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\r\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\r\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\r\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\r\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\r\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\r\n        for (int i = 0; i < this.domainAxes.size(); i++) {\r\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\r\n            if (xAxis != null) {\r\n                xAxis.setPlot(this);\r\n                xAxis.addChangeListener(this);\r\n            }\r\n        }\r\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\r\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\r\n            if (yAxis != null) {\r\n                yAxis.setPlot(this);\r\n                yAxis.addChangeListener(this);\r\n            }\r\n        }\r\n        int datasetCount = this.datasets.size();\r\n        for (int i = 0; i < datasetCount; i++) {\r\n            Dataset dataset = (Dataset) this.datasets.get(i);\r\n            if (dataset != null) {\r\n                dataset.addChangeListener(this);\r\n            }\r\n        }\r\n        int rendererCount = this.renderers.size();\r\n        for (int i = 0; i < rendererCount; i++) {\r\n            CategoryItemRenderer renderer = (CategoryItemRenderer) this.renderers.get(i);\r\n            if (renderer != null) {\r\n                renderer.addChangeListener(this);\r\n            }\r\n        }\r\n    }\r\n}", "content:source_class_code_imports": ["import java.awt.AlphaComposite;", "import java.awt.BasicStroke;", "import java.awt.Color;", "import java.awt.Composite;", "import java.awt.Font;", "import java.awt.Graphics2D;", "import java.awt.Paint;", "import java.awt.Shape;", "import java.awt.Stroke;", "import java.awt.geom.Line2D;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.io.IOException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.io.Serializable;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.HashMap;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.ResourceBundle;", "import java.util.Set;", "import org.jfree.chart.LegendItem;", "import org.jfree.chart.LegendItemCollection;", "import org.jfree.chart.annotations.CategoryAnnotation;", "import org.jfree.chart.axis.Axis;", "import org.jfree.chart.axis.AxisCollection;", "import org.jfree.chart.axis.AxisLocation;", "import org.jfree.chart.axis.AxisSpace;", "import org.jfree.chart.axis.AxisState;", "import org.jfree.chart.axis.CategoryAnchor;", "import org.jfree.chart.axis.CategoryAxis;", "import org.jfree.chart.axis.ValueAxis;", "import org.jfree.chart.axis.ValueTick;", "import org.jfree.chart.event.ChartChangeEventType;", "import org.jfree.chart.event.PlotChangeEvent;", "import org.jfree.chart.event.RendererChangeEvent;", "import org.jfree.chart.event.RendererChangeListener;", "import org.jfree.chart.renderer.category.CategoryItemRenderer;", "import org.jfree.chart.renderer.category.CategoryItemRendererState;", "import org.jfree.chart.util.Layer;", "import org.jfree.chart.util.ObjectList;", "import org.jfree.chart.util.ObjectUtilities;", "import org.jfree.chart.util.PaintUtilities;", "import org.jfree.chart.util.PublicCloneable;", "import org.jfree.chart.util.RectangleEdge;", "import org.jfree.chart.util.RectangleInsets;", "import org.jfree.chart.util.SerialUtilities;", "import org.jfree.chart.util.SortOrder;", "import org.jfree.data.Range;", "import org.jfree.data.category.CategoryDataset;", "import org.jfree.data.general.Dataset;", "import org.jfree.data.general.DatasetChangeEvent;", "import org.jfree.data.general.DatasetUtilities;"], "content:source_class_code_path": "D:\\try\\ut4\\d4j_fixed_projects\\Chart_14_fixed\\source\\org\\jfree\\chart\\plot\\CategoryPlot.java", "content:source_class_code_signature": "org.jfree.chart.plot#CategoryPlot | setRangeAxisLocation(int, AxisLocation, boolean) | addRangeMarker(Marker, Layer) | setAnchorValue(double, boolean) | setFixedRangeAxisSpace(AxisSpace, boolean) | setRangeAxis(int, ValueAxis) | setDataset(CategoryDataset) | setRangeCrosshairValue(double, boolean) | configureDomainAxes() | removeDomainMarker(int, Marker, Layer, boolean) | setRangeCrosshairLockedOnData(boolean) | setDrawSharedDomainAxis(boolean) | setDomainAxis(CategoryAxis) | setDomainAxis(int, CategoryAxis) | clone() | drawBackground(Graphics2D, Rectangle2D) | setColumnRenderingOrder(SortOrder) | setFixedRangeAxisSpace(AxisSpace) | setRenderers(CategoryItemRenderer[]) | getDatasetRenderingOrder() | getFixedLegendItems() | setRangeGridlineStroke(Stroke) | setDomainGridlinesVisible(boolean) | getIndexOf(CategoryItemRenderer) | getRangeAxisCount() | handleClick(int, int, PlotRenderingInfo) | getRangeCrosshairValue() | CategoryPlot() | setRangeAxisLocation(AxisLocation, boolean) | clearDomainMarkers() | getRenderer() | addDomainMarker(CategoryMarker, Layer) | getRangeAxisLocation(int) | setDomainGridlineStroke(Stroke) | getRangeCrosshairPaint() | getAnchorValue() | addDomainMarker(CategoryMarker) | addDomainMarker(int, CategoryMarker, Layer) | mapDatasetToRangeAxis(int, int) | rendererChanged(RendererChangeEvent) | setFixedDomainAxisSpace(AxisSpace) | isDomainGridlinesVisible() | addRangeMarker(int, Marker, Layer) | zoomDomainAxes(double, PlotRenderingInfo, Point2D) | clearAnnotations() | setRangeGridlinesVisible(boolean) | setAnchorValue(double) | setDomainAxisLocation(int, AxisLocation) | addRangeMarker(int, Marker, Layer, boolean) | getCategoriesForAxis(CategoryAxis) | setRangeAxes(ValueAxis[]) | setDomainAxes(CategoryAxis[]) | setDomainAxisLocation(int, AxisLocation, boolean) | setDomainGridlinePosition(CategoryAnchor) | clearDomainMarkers(int) | getFixedDomainAxisSpace() | setDataset(int, CategoryDataset) | removeRangeMarker(Marker, Layer) | getPlotType() | getRowRenderingOrder() | getAxisOffset() | getDrawSharedDomainAxis() | setRenderer(CategoryItemRenderer) | setRangeAxisLocation(AxisLocation) | setFixedDomainAxisSpace(AxisSpace, boolean) | draw(Graphics2D, Rectangle2D, Point2D, PlotState, PlotRenderingInfo) | getRangeAxisEdge() | getOrientation() | setRangeAxisLocation(int, AxisLocation) | setOrientation(PlotOrientation) | getDomainAxis(int) | CategoryPlot(CategoryDataset, CategoryAxis, ValueAxis, CategoryItemRenderer) | getDomainGridlineStroke() | equals(Object) | clearRangeAxes() | setFixedLegendItems(LegendItemCollection) | getDatasetCount() | setAxisOffset(RectangleInsets) | getDomainAxisEdge() | getDomainAxisForDataset(int) | isRangeCrosshairVisible() | isRangeCrosshairLockedOnData() | setRenderer(int, CategoryItemRenderer, boolean) | setRangeAxis(int, ValueAxis, boolean) | getRangeAxisLocation() | getLegendItems() | getDomainAxis() | clearRangeMarkers(int) | setRangeCrosshairStroke(Stroke) | getRangeAxis() | getRendererForDataset(CategoryDataset) | setDatasetRenderingOrder(DatasetRenderingOrder) | getDomainMarkers(Layer) | addAnnotation(CategoryAnnotation) | getDomainAxisCount() | getRangeAxisEdge(int) | zoomDomainAxes(double, double, PlotRenderingInfo, Point2D) | getRangeAxisIndex(ValueAxis) | zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean) | zoomRangeAxes(double, double, PlotRenderingInfo, Point2D) | setDomainAxisLocation(AxisLocation) | setDomainAxisLocation(AxisLocation, boolean) | setDomainAxis(int, CategoryAxis, boolean) | getAnnotations() | setWeight(int) | addAnnotation(CategoryAnnotation, boolean) | getDomainAxisEdge(int) | getCategories() | isDomainZoomable() | getFixedRangeAxisSpace() | getDomainAxisLocation(int) | render(Graphics2D, Rectangle2D, int, PlotRenderingInfo) | removeDomainMarker(Marker) | setRangeCrosshairPaint(Paint) | isRangeZoomable() | zoom(double) | getDomainMarkers(int, Layer) | setRowRenderingOrder(SortOrder) | clearRangeMarkers() | getRangeMarkers(Layer) | getRangeGridlineStroke() | setDomainGridlinePaint(Paint) | getDomainAxisLocation() | removeDomainMarker(int, Marker, Layer) | getRangeGridlinePaint() | getWeight() | isRangeGridlinesVisible() | mapDatasetToDomainAxis(int, int) | setRangeCrosshairValue(double) | zoomRangeAxes(double, PlotRenderingInfo, Point2D) | getRangeMarkers(int, Layer) | getDataset() | getColumnRenderingOrder() | configureRangeAxes() | setRenderer(CategoryItemRenderer, boolean) | setRenderer(int, CategoryItemRenderer) | datasetChanged(DatasetChangeEvent) | getDataset(int) | getRenderer(int) | getRangeAxis(int) | setRangeGridlinePaint(Paint) | removeAnnotation(CategoryAnnotation) | removeAnnotation(CategoryAnnotation, boolean) | clearDomainAxes() | getRangeAxisForDataset(int) | removeRangeMarker(int, Marker, Layer, boolean) | setRangeCrosshairVisible(boolean) | getDomainAxisIndex(CategoryAxis) | addDomainMarker(int, CategoryMarker, Layer, boolean) | removeDomainMarker(Marker, Layer) | getDataRange(ValueAxis) | getRangeCrosshairStroke() | removeRangeMarker(Marker) | setRangeAxis(ValueAxis) | zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean) | getDomainGridlinePaint() | removeRangeMarker(int, Marker, Layer) | addRangeMarker(Marker) | getDomainGridlinePosition()", "content:source_class_constructors": ["public CategoryPlot();", "public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer);"], "content:source_class_define": "public class CategoryPlot extends Plot implements ValueAxisPlot, Zoomable, RendererChangeListener, Cloneable, PublicCloneable, Serializable;", "content:source_class_name": "CategoryPlot", "errorList": [], "extra:language": "Java", "extra:project_name": "Chart_14_fixed", "rowKey": "a182422f43515815c35a672f8e72976f", "source:source_method_code_format": "public boolean removeDomainMarker(Marker marker, Layer layer) {\r\n    return removeDomainMarker(0, marker, layer);\r\n}", "source:source_method_comment": "/**\r\n * Removes a marker for the domain axis in the specified layer and sends a\r\n * {@link PlotChangeEvent} to all registered listeners.\r\n *\r\n * @param marker the marker (<code>null</code> not permitted).\r\n * @param layer the layer (foreground or background).\r\n *\r\n * @return A boolean indicating whether or not the marker was actually\r\n *         removed.\r\n *\r\n * @since 1.0.7\r\n */\r\n <innerComment> ", "source:source_method_name": "removeDomainMarker", "source:source_method_return_type_class_constructors": [], "source:source_method_signature": "org.jfree.chart.plot#CategoryPlot#removeDomainMarker(org.jfree.chart.plot#Marker, org.jfree.chart.util#Layer)", "source:source_other_method_signature": ["public void setRangeAxisLocation(int index, AxisLocation location, boolean notify);", "public void addRangeMarker(Marker marker, Layer layer);", "public void setAnchorValue(double value, boolean notify);", "public void setFixedRangeAxisSpace(AxisSpace space, boolean notify);", "public void setRangeAxis(int index, ValueAxis axis);", "public void setDataset(CategoryDataset dataset);", "public void setRangeCrosshairValue(double value, boolean notify);", "protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space);", "public void configureDomainAxes();", "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify);", "public void setRangeCrosshairLockedOnData(boolean flag);", "public void setDrawSharedDomainAxis(boolean draw);", "public void setDomainAxis(CategoryAxis axis);", "public void setDomainAxis(int index, CategoryAxis axis);", "public Object clone() throws CloneNotSupportedException;", "public void drawBackground(Graphics2D g2, Rectangle2D area);", "public void setColumnRenderingOrder(SortOrder order);", "public void setFixedRangeAxisSpace(AxisSpace space);", "public void setRenderers(CategoryItemRenderer[] renderers);", "public DatasetRenderingOrder getDatasetRenderingOrder();", "public LegendItemCollection getFixedLegendItems();", "public void setRangeGridlineStroke(Stroke stroke);", "public void setDomainGridlinesVisible(boolean visible);", "public int getIndexOf(CategoryItemRenderer renderer);", "public int getRangeAxisCount();", "public void handleClick(int x, int y, PlotRenderingInfo info);", "public double getRangeCrosshairValue();", "public CategoryPlot();", "public void setRangeAxisLocation(AxisLocation location, boolean notify);", "public void clearDomainMarkers();", "public CategoryItemRenderer getRenderer();", "public void addDomainMarker(CategoryMarker marker, Layer layer);", "protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState);", "public AxisLocation getRangeAxisLocation(int index);", "public void setDomainGridlineStroke(Stroke stroke);", "public Paint getRangeCrosshairPaint();", "private List datasetsMappedToDomainAxis(int axisIndex);", "protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer);", "protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea, double value, Stroke stroke, Paint paint);", "public double getAnchorValue();", "public void addDomainMarker(CategoryMarker marker);", "protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks);", "public void addDomainMarker(int index, CategoryMarker marker, Layer layer);", "private List datasetsMappedToRangeAxis(int index);", "public void mapDatasetToRangeAxis(int index, int axisIndex);", "public void rendererChanged(RendererChangeEvent event);", "public void setFixedDomainAxisSpace(AxisSpace space);", "public boolean isDomainGridlinesVisible();", "public void addRangeMarker(int index, Marker marker, Layer layer);", "public void zoomDomainAxes(double factor, PlotRenderingInfo state, Point2D source);", "public void clearAnnotations();", "public void setRangeGridlinesVisible(boolean visible);", "public void setAnchorValue(double value);", "public void setDomainAxisLocation(int index, AxisLocation location);", "protected AxisSpace calculateAxisSpace(Graphics2D g2, Rectangle2D plotArea);", "public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify);", "public List getCategoriesForAxis(CategoryAxis axis);", "public void setRangeAxes(ValueAxis[] axes);", "public void setDomainAxes(CategoryAxis[] axes);", "public void setDomainAxisLocation(int index, AxisLocation location, boolean notify);", "public void setDomainGridlinePosition(CategoryAnchor position);", "public void clearDomainMarkers(int index);", "public AxisSpace getFixedDomainAxisSpace();", "public void setDataset(int index, CategoryDataset dataset);", "public boolean removeRangeMarker(Marker marker, Layer layer);", "public String getPlotType();", "public SortOrder getRowRenderingOrder();", "public RectangleInsets getAxisOffset();", "public boolean getDrawSharedDomainAxis();", "protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea, PlotRenderingInfo info);", "public void setRenderer(CategoryItemRenderer renderer);", "public void setRangeAxisLocation(AxisLocation location);", "public void setFixedDomainAxisSpace(AxisSpace space, boolean notify);", "public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo state);", "public RectangleEdge getRangeAxisEdge();", "public PlotOrientation getOrientation();", "public void setRangeAxisLocation(int index, AxisLocation location);", "public void setOrientation(PlotOrientation orientation);", "public CategoryAxis getDomainAxis(int index);", "public CategoryPlot(CategoryDataset dataset, CategoryAxis domainAxis, ValueAxis rangeAxis, CategoryItemRenderer renderer);", "public Stroke getDomainGridlineStroke();", "public boolean equals(Object obj);", "public void clearRangeAxes();", "public void setFixedLegendItems(LegendItemCollection items);", "public int getDatasetCount();", "private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException;", "protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer);", "public void setAxisOffset(RectangleInsets offset);", "public RectangleEdge getDomainAxisEdge();", "public CategoryAxis getDomainAxisForDataset(int index);", "public boolean isRangeCrosshairVisible();", "public boolean isRangeCrosshairLockedOnData();", "protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, PlotOrientation orientation, double value, ValueAxis axis, Stroke stroke, Paint paint);", "public void setRenderer(int index, CategoryItemRenderer renderer, boolean notify);", "public void setRangeAxis(int index, ValueAxis axis, boolean notify);", "public AxisLocation getRangeAxisLocation();", "public LegendItemCollection getLegendItems();", "public CategoryAxis getDomainAxis();", "public void clearRangeMarkers(int index);", "public void setRangeCrosshairStroke(Stroke stroke);", "public ValueAxis getRangeAxis();", "public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset);", "public void setDatasetRenderingOrder(DatasetRenderingOrder order);", "public Collection getDomainMarkers(Layer layer);", "public void addAnnotation(CategoryAnnotation annotation);", "public int getDomainAxisCount();", "public RectangleEdge getRangeAxisEdge(int index);", "public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source);", "public int getRangeAxisIndex(ValueAxis axis);", "public void zoomDomainAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor);", "public void zoomRangeAxes(double lowerPercent, double upperPercent, PlotRenderingInfo state, Point2D source);", "public void setDomainAxisLocation(AxisLocation location);", "public void setDomainAxisLocation(AxisLocation location, boolean notify);", "public void setDomainAxis(int index, CategoryAxis axis, boolean notify);", "public List getAnnotations();", "public void setWeight(int weight);", "public void addAnnotation(CategoryAnnotation annotation, boolean notify);", "private void writeObject(ObjectOutputStream stream) throws IOException;", "public RectangleEdge getDomainAxisEdge(int index);", "public List getCategories();", "public boolean isDomainZoomable();", "protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, Rectangle2D plotArea, AxisSpace space);", "public AxisSpace getFixedRangeAxisSpace();", "public AxisLocation getDomainAxisLocation(int index);", "public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, PlotRenderingInfo info);", "public boolean removeDomainMarker(Marker marker);", "public void setRangeCrosshairPaint(Paint paint);", "public boolean isRangeZoomable();", "public void zoom(double percent);", "public Collection getDomainMarkers(int index, Layer layer);", "public void setRowRenderingOrder(SortOrder order);", "public void clearRangeMarkers();", "public Collection getRangeMarkers(Layer layer);", "public Stroke getRangeGridlineStroke();", "public void setDomainGridlinePaint(Paint paint);", "public AxisLocation getDomainAxisLocation();", "public boolean removeDomainMarker(int index, Marker marker, Layer layer);", "public Paint getRangeGridlinePaint();", "public int getWeight();", "public boolean isRangeGridlinesVisible();", "public void mapDatasetToDomainAxis(int index, int axisIndex);", "public void setRangeCrosshairValue(double value);", "public void zoomRangeAxes(double factor, PlotRenderingInfo state, Point2D source);", "public Collection getRangeMarkers(int index, Layer layer);", "public CategoryDataset getDataset();", "public SortOrder getColumnRenderingOrder();", "public void configureRangeAxes();", "public void setRenderer(CategoryItemRenderer renderer, boolean notify);", "public void setRenderer(int index, CategoryItemRenderer renderer);", "public void datasetChanged(DatasetChangeEvent event);", "public CategoryDataset getDataset(int index);", "public CategoryItemRenderer getRenderer(int index);", "public ValueAxis getRangeAxis(int index);", "public void setRangeGridlinePaint(Paint paint);", "public boolean removeAnnotation(CategoryAnnotation annotation);", "public boolean removeAnnotation(CategoryAnnotation annotation, boolean notify);", "protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea);", "public void clearDomainAxes();", "public ValueAxis getRangeAxisForDataset(int index);", "public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify);", "public void setRangeCrosshairVisible(boolean flag);", "public int getDomainAxisIndex(CategoryAxis axis);", "public void addDomainMarker(int index, CategoryMarker marker, Layer layer, boolean notify);", "public Range getDataRange(ValueAxis axis);", "public Stroke getRangeCrosshairStroke();", "public boolean removeRangeMarker(Marker marker);", "public void setRangeAxis(ValueAxis axis);", "public void zoomRangeAxes(double factor, PlotRenderingInfo info, Point2D source, boolean useAnchor);", "public Paint getDomainGridlinePaint();", "public boolean removeRangeMarker(int index, Marker marker, Layer layer);", "public void addRangeMarker(Marker marker);", "public CategoryAnchor getDomainGridlinePosition();"], "sourceMethodExistNonEn": "false", "testMethodCodeFormat": [], "testMethodExistNonEn": [], "testMethodSignature": [], "bytecode_signature": "org.jfree.chart.plot.CategoryPlot.removeDomainMarker(Lorg/jfree/chart/plot/Marker;Lorg/jfree/chart/util/Layer;)Z"}
