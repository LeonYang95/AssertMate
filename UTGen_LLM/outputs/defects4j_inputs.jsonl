{"bug_id": "Closure_29", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.InlineObjectLiterals#process(Node#externs,Node#root)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_29/fixed/src/com/google/javascript/jscomp/InlineObjectLiterals.java", "focal_method": "@Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior());\n    callback.process(externs, root);\n  }", "return_type": "void", "assertion_subject_candidates": [], "focal_class": {"name": "InlineObjectLiterals", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_29/fixed/src/com/google/javascript/jscomp/InlineObjectLiterals.java", "superclass": "", "interface": "implements CompilerPass", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.base.Supplier;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Sets;", "import com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior;", "import com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;", "import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;", "import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.rhino.IR;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;"], "fields": ["public static final String VAR_PREFIX = \"JSCompiler_object_inline_\"", "private final AbstractCompiler compiler", "private final Supplier<String> safeNameIdSupplier"], "methods": [], "other_methods": [], "fields_dict": {"String#VAR_PREFIX": "public static final String VAR_PREFIX = \"JSCompiler_object_inline_\"", "AbstractCompiler#compiler": "private final AbstractCompiler compiler", "Supplier<String>#safeNameIdSupplier": "private final Supplier<String> safeNameIdSupplier"}, "text": "/*\n * Copyright 2011 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.Behavior;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.Reference;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceMap;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n\n/**\n * Using the infrastructure provided by {@link ReferenceCollectingCallback},\n * identify variables that are only ever assigned to object literals\n * and that are never used in entirety, and expand the objects into\n * individual variables.\n *\n * Based on the InlineVariables pass\n *\n */\nclass InlineObjectLiterals implements CompilerPass {\n\n  public static final String VAR_PREFIX = \"JSCompiler_object_inline_\";\n\n  private final AbstractCompiler compiler;\n\n  private final Supplier<String> safeNameIdSupplier;\n\n  InlineObjectLiterals(\n      AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier) {\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior());\n    callback.process(externs, root);\n  }\n\n  /**\n   * Builds up information about nodes in each scope. When exiting the\n   * scope, inspects all variables in that scope, and inlines any\n   * that we can.\n   */\n  private class InliningBehavior implements Behavior {\n\n    /**\n     * A list of variables that should not be inlined, because their\n     * reference information is out of sync with the state of the AST.\n     */\n    private final Set<Var> staleVars = Sets.newHashSet();\n\n    @Override\n    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        if (isVarInlineForbidden(v)) {\n          continue;\n        }\n\n        ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n        if (isInlinableObject(referenceInfo.references)) {\n          // Blacklist the object itself, as well as any other values\n          // that it refers to, since they will have been moved around.\n          staleVars.add(v);\n\n          Reference declaration = referenceInfo.references.get(0);\n          Reference init = referenceInfo.getInitializingReference();\n\n          // Split up the object into individual variables if the object\n          // is never referenced directly in full.\n          splitObject(v, declaration, init, referenceInfo);\n        }\n      }\n    }\n\n    /**\n     * If there are any variable references in the given node tree,\n     * blacklist them to prevent the pass from trying to inline the\n     * variable. Any code modifications will have potentially made the\n     * ReferenceCollection invalid.\n     */\n    private void blacklistVarReferencesInTree(Node root, final Scope scope) {\n      NodeUtil.visitPreOrder(root, new NodeUtil.Visitor() {\n        @Override\n        public void visit(Node node) {\n          if (node.isName()) {\n            staleVars.add(scope.getVar(node.getString()));\n          }\n        }\n      }, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n\n    /**\n     * Whether the given variable is forbidden from being inlined.\n     */\n    private boolean isVarInlineForbidden(Var var) {\n      // A variable may not be inlined if:\n      // 1) The variable is defined in the externs\n      // 2) The variable is exported,\n      // 3) Don't inline the special RENAME_PROPERTY_FUNCTION_NAME\n      // 4) A reference to the variable has been inlined. We're downstream\n      //    of the mechanism that creates variable references, so we don't\n      //    have a good way to update the reference. Just punt on it.\n\n      // Additionally, exclude global variables for now.\n\n      return var.isGlobal()\n          || var.isExtern()\n          || compiler.getCodingConvention().isExported(var.name)\n          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)\n          || staleVars.contains(var);\n    }\n\n    /**\n     * Counts the number of direct (full) references to an object.\n     * Specifically we check for references of the following type:\n     * <pre>\n     *   x;\n     *   x.fn();\n     * </pre>\n     */\n    private boolean isInlinableObject(List<Reference> refs) {\n      boolean ret = false;\n      Set<String> validProperties = Sets.newHashSet();\n      for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        // Ignore indirect references, like x.y (except x.y(), since\n        // the function referenced by y might reference 'this').\n        //\n        if (parent.isGetProp()) {\n          Preconditions.checkState(parent.getFirstChild() == name);\n          // A call target maybe using the object as a 'this' value.\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot. It assumes that if a property isn't defined on an\n          // object, then the value is undefined. This is not true, because\n          // Object.prototype can have arbitrary properties on it.\n          //\n          // We short-circuit this problem by bailing out if we see a reference\n          // to a property that isn't defined on the object literal. This\n          // isn't a perfect algorithm, but it should catch most cases.\n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n          continue;\n        }\n\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n           return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment.\n          continue;\n        }\n\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n          return false;\n        }\n\n        // Make sure that the value is not self-refential. IOW,\n        // disallow things like x = {b: x.a}.\n        //\n        // TODO: Only exclude unorderable self-referential\n        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n        // but x = {a: 1, b: x.a} is.\n        //\n        // Also, ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            // ES5 get/set not supported.\n            return false;\n          }\n\n          validProperties.add(child.getString());\n\n          Node childVal = child.getFirstChild();\n          // Check if childVal is the parent of any of the passed in\n          // references, as that is how self-referential assignments\n          // will happen.\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                // There's a self-referential assignment\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n        }\n\n\n        // We have found an acceptable object literal assignment. As\n        // long as there are no other assignments that mess things up,\n        // we can inline.\n        ret = true;\n      }\n      return ret;\n    }\n\n    private boolean isVarOrAssignExprLhs(Node n) {\n      Node parent = n.getParent();\n      return parent.isVar() ||\n          (parent.isAssign()\n              && parent.getFirstChild() == n\n              && parent.getParent().isExprResult());\n    }\n\n    /**\n     * Computes a list of ever-referenced keys in the object being\n     * inlined, and returns a mapping of key name -> generated\n     * variable name.\n     */\n    private Map<String, String> computeVarList(\n        Var v, ReferenceCollection referenceInfo) {\n      Map<String, String> varmap = Maps.newLinkedHashMap();\n\n      for (Reference ref : referenceInfo.references) {\n        if (ref.isLvalue() || ref.isInitializingDeclaration()) {\n          Node val = ref.getAssignedValue();\n          if (val != null) {\n            Preconditions.checkState(val.isObjectLit());\n            for (Node child = val.getFirstChild(); child != null;\n                 child = child.getNext()) {\n              String varname = child.getString();\n              if (varmap.containsKey(varname)) {\n                continue;\n              }\n\n              String var = VAR_PREFIX + varname + \"_\" +\n                safeNameIdSupplier.get();\n              varmap.put(varname, var);\n            }\n          }\n        } else if (ref.getParent().isVar()) {\n          // This is the var. There is no value.\n        } else {\n          Node getprop = ref.getParent();\n          Preconditions.checkState(getprop.isGetProp());\n\n          // The key being looked up in the original map.\n          String varname = getprop.getLastChild().getString();\n          if (varmap.containsKey(varname)) {\n            continue;\n          }\n\n          String var = VAR_PREFIX + varname + \"_\" + safeNameIdSupplier.get();\n          varmap.put(varname, var);\n        }\n      }\n\n      return varmap;\n    }\n\n    /**\n     * Populates a map of key names -> initial assigned values. The\n     * object literal these are being pulled from is invalidated as\n     * a result.\n     */\n    private void fillInitialValues(Reference init, Map<String, Node> initvals) {\n      Node object = init.getAssignedValue();\n      Preconditions.checkState(object.isObjectLit());\n      for (Node key = object.getFirstChild(); key != null;\n           key = key.getNext()) {\n        initvals.put(key.getString(), key.removeFirstChild());\n      }\n    }\n\n    /**\n     * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n     * Note that the resulting expression will always evaluate to\n     * true, as would the x = {...} expression.\n     */\n    private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n      // Compute all of the assignments necessary\n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.isObjectLit());\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n      for (Node key = val.getFirstChild(); key != null;\n           key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        // TODO(user): Copy type information.\n        nodes.add(\n            IR.assign(\n                IR.name(varmap.get(var)),\n                value));\n        all.remove(var);\n      }\n\n      // TODO(user): Better source information.\n      for (String var : all) {\n        nodes.add(\n            IR.assign(\n                IR.name(varmap.get(var)),\n                NodeUtil.newUndefinedNode(null)));\n      }\n\n      Node replacement;\n      if (nodes.isEmpty()) {\n        replacement = IR.trueNode();\n      } else {\n        // All assignments evaluate to true, so make sure that the\n        // expr statement evaluates to true in case it matters.\n        nodes.add(IR.trueNode());\n\n        // Join these using COMMA.  A COMMA node must have 2 children, so we\n        // create a tree. In the tree the first child be the COMMA to match\n        // the parser, otherwise tree equality tests fail.\n        nodes = Lists.reverse(nodes);\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i));\n          Node t = new Node(Token.COMMA);\n          cur.addChildToFront(t);\n          cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n      }\n\n      Node replace = ref.getParent();\n      replacement.copyInformationFromForTree(replace);\n\n      if (replace.isVar()) {\n        replace.getParent().replaceChild(\n            replace, NodeUtil.newExpr(replacement));\n      } else {\n        replace.getParent().replaceChild(replace, replacement);\n      }\n    }\n\n    /**\n     * Splits up the object literal into individual variables, and\n     * updates all uses.\n     */\n    private void splitObject(Var v, Reference declaration,\n                             Reference init,\n                             ReferenceCollection referenceInfo) {\n      // First figure out the FULL set of possible keys, so that they\n      // can all be properly set as necessary.\n      Map<String, String> varmap = computeVarList(v, referenceInfo);\n\n      Map<String, Node> initvals = Maps.newHashMap();\n      // Figure out the top-level of the var assign node. If it's a plain\n      // ASSIGN, then there's an EXPR_STATEMENT above it, if it's a\n      // VAR then it should be directly replaced.\n      Node vnode;\n      boolean defined = referenceInfo.isWellDefined() &&\n          init.getParent().isVar();\n      if (defined) {\n        vnode = init.getParent();\n        fillInitialValues(init, initvals);\n      } else {\n        // TODO(user): More test / rewrite this part.\n        // Find the beginning of the function / script.\n        vnode = v.getScope().getRootNode().getLastChild().getFirstChild();\n      }\n\n      for (Map.Entry<String, String> entry : varmap.entrySet()) {\n        Node val = initvals.get(entry.getKey());\n        Node varnode = NodeUtil.newVarNode(entry.getValue(), val);\n        if (val == null) {\n          // is this right?\n          varnode.copyInformationFromForTree(vnode);\n        } else {\n          blacklistVarReferencesInTree(val, v.scope);\n        }\n        vnode.getParent().addChildBefore(varnode, vnode);\n      }\n\n      if (defined) {\n        vnode.getParent().removeChild(vnode);\n      }\n\n      for (Reference ref : referenceInfo.references) {\n        // The init/decl have already been converted.\n        if (defined && ref == init) continue;\n\n        if (ref.isLvalue()) {\n          // Assignments have to be handled specially, since they\n          // expand out into multiple assignments.\n          replaceAssignmentExpression(v, ref, varmap);\n        } else if (ref.getParent().isVar()) {\n          // The old variable declaration. It didn't have a\n          // value. Remove it entirely as it should now be unused.\n          ref.getGrandparent().removeChild(ref.getParent());\n        } else {\n          // Make sure that the reference is a GETPROP as we expect it to be.\n          Node getprop = ref.getParent();\n          Preconditions.checkState(getprop.isGetProp());\n\n          // The key being looked up in the original map.\n          String var = getprop.getChildAtIndex(1).getString();\n\n          // If the variable hasn't already been declared, add an empty\n          // declaration near all the other declarations.\n          Preconditions.checkState(varmap.containsKey(var));\n\n          // Replace the GETPROP node with a NAME.\n          Node replacement = IR.name(varmap.get(var));\n          replacement.copyInformationFrom(getprop);\n          ref.getGrandparent().replaceChild(ref.getParent(), replacement);\n        }\n      }\n\n      compiler.reportCodeChange();\n    }\n  }\n}\n"}}
{"bug_id": "Closure_15", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.FlowSensitiveInlineVariables#enterScope(NodeTraversal#t)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_15/fixed/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "focal_method": "@Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n      }\n    }\n  }", "return_type": "void", "assertion_subject_candidates": [], "focal_class": {"name": "FlowSensitiveInlineVariables", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_15/fixed/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "superclass": "extends AbstractPostOrderCallback", "interface": "implements CompilerPass, ScopedCallback", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.base.Predicate;", "import com.google.common.base.Predicates;", "import com.google.common.collect.Lists;", "import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;", "import com.google.javascript.jscomp.ControlFlowGraph.Branch;", "import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;", "import com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef;", "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;", "import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;", "import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.Collection;", "import java.util.List;"], "fields": ["private final AbstractCompiler compiler", "private ControlFlowGraph<Node> cfg", "private List<Candidate> candidates", "private MustBeReachingVariableDef reachingDef", "private MaybeReachingVariableUse reachingUses", "private static final Predicate<Node> SIDE_EFFECT_PREDICATE = new Predicate<Node>() {\n      @Override\n      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // TODO(user): We only care about calls to functions that\n        // passes one of the dependent variable to a non-side-effect free\n        // function.\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isDelProp()) {\n          return true;\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n  }"], "methods": ["void com.google.javascript.jscomp.FlowSensitiveInlineVariables#exitScope(NodeTraversal#t)", "void com.google.javascript.jscomp.FlowSensitiveInlineVariables#process(Node#externs,Node#root)", "void com.google.javascript.jscomp.FlowSensitiveInlineVariables#visit(NodeTraversal#t,Node#n,Node#parent)", "boolean com.google.javascript.jscomp.FlowSensitiveInlineVariables#checkRightOf(Node#n,Node#expressionRoot,Predicate<Node>#predicate)", "boolean com.google.javascript.jscomp.FlowSensitiveInlineVariables#checkLeftOf(Node#n,Node#expressionRoot,Predicate<Node>#predicate)"], "other_methods": ["@Override\n  public void exitScope(NodeTraversal t);", "@Override\n  public void process(Node externs,Node root);", "@Override\n  public void visit(NodeTraversal t,Node n,Node parent);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "ControlFlowGraph<Node>#cfg": "private ControlFlowGraph<Node> cfg", "List<Candidate>#candidates": "private List<Candidate> candidates", "MustBeReachingVariableDef#reachingDef": "private MustBeReachingVariableDef reachingDef", "MaybeReachingVariableUse#reachingUses": "private MaybeReachingVariableUse reachingUses", "Predicate<Node>#SIDE_EFFECT_PREDICATE": "private static final Predicate<Node> SIDE_EFFECT_PREDICATE = new Predicate<Node>() {\n      @Override\n      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // TODO(user): We only care about calls to functions that\n        // passes one of the dependent variable to a non-side-effect free\n        // function.\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isDelProp()) {\n          return true;\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n  }"}, "text": "/*\n * Copyright 2009 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\nimport com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\nimport com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Inline variables when possible. Using the information from\n * {@link MaybeReachingVariableUse} and {@link MustBeReachingVariableDef},\n * this pass attempts to inline a variable by placing the value at the\n * definition where the variable is used. The basic requirements for inlining\n * are the following:\n *\n * <ul>\n * <li> There is exactly one reaching definition at the use of that variable\n * </li>\n * <li> There is exactly one use for that definition of the variable\n * </li>\n * </ul>\n *\n * <p>Other requirements can be found in {@link Candidate#canInline}. Currently\n * this pass does not operate on the global scope due to compilation time.\n *\n */\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n\n  /**\n   * Implementation:\n   *\n   * This pass first perform a traversal to gather a list of Candidates that\n   * could be inlined using {@link GatherCandiates}.\n   *\n   * The second step involves verifying that each candidate is actually safe\n   * to inline with {@link Candidate#canInline()} and finally perform inlining\n   * using {@link Candidate#inlineVariable()}.\n   *\n   * The reason for the delayed evaluation of the candidates is because we\n   * need two separate dataflow result.\n   */\n  private final AbstractCompiler compiler;\n\n  // These two pieces of data is persistent in the whole execution of enter\n  // scope.\n  private ControlFlowGraph<Node> cfg;\n  private List<Candidate> candidates;\n  private MustBeReachingVariableDef reachingDef;\n  private MaybeReachingVariableUse reachingUses;\n\n  private static final Predicate<Node> SIDE_EFFECT_PREDICATE =\n    new Predicate<Node>() {\n      @Override\n      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // TODO(user): We only care about calls to functions that\n        // passes one of the dependent variable to a non-side-effect free\n        // function.\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isDelProp()) {\n          return true;\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n  };\n\n  public FlowSensitiveInlineVariables(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n      }\n    }\n  }\n\n  @Override\n  public void exitScope(NodeTraversal t) {}\n\n  @Override\n  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // TODO(user): While the helpers do a subtree traversal on the AST, the\n    // compiler pass itself only traverse the AST to look for function\n    // declarations to perform dataflow analysis on. We could combine\n    // the traversal in DataFlowAnalysis's computeEscaped later to save some\n    // time.\n  }\n\n  /**\n   * Gathers a list of possible candidates for inlining based only on\n   * information from {@link MustBeReachingVariableDef}. The list will be stored\n   * in {@code candidates} and the validity of each inlining Candidate should\n   * be later verified with {@link Candidate#canInline()} when\n   * {@link MaybeReachingVariableUse} has been performed.\n   */\n  private class GatherCandiates extends AbstractShallowCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      DiGraphNode<Node, Branch> graphNode = cfg.getDirectedGraphNode(n);\n      if (graphNode == null) {\n        // Not a CFG node.\n        return;\n      }\n      FlowState<MustDef> state = graphNode.getAnnotation();\n      final MustDef defs = state.getIn();\n      final Node cfgNode = n;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName()) {\n\n            // n.getParent() isn't null. This just the case where n is the root\n            // node that gatherCb started at.\n            if (parent == null) {\n              return;\n            }\n\n            // Make sure that the name node is purely a read.\n            if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n                || parent.isVar() || parent.isInc() || parent.isDec() ||\n                parent.isParamList() || parent.isCatch()) {\n              return;\n            }\n\n            String name = n.getString();\n            if (compiler.getCodingConvention().isExported(name)) {\n              return;\n            }\n\n            Node defNode = reachingDef.getDef(name, cfgNode);\n            // TODO(nicksantos): We need to add some notion of @const outer\n            // scope vars. We can inline those just fine.\n            if (defNode != null &&\n                !reachingDef.dependsOnOuterScopeVars(name, cfgNode)) {\n              candidates.add(new Candidate(name, defNode, n, cfgNode));\n            }\n          }\n        }\n      };\n\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }\n  }\n\n  /**\n   * Models the connection between a definition and a use of that definition.\n   */\n  private class Candidate {\n\n    // Name of the variable.\n    private final String varName;\n\n    // Nodes related to the definition.\n    private Node def;\n    private final Node defCfgNode;\n\n    // Nodes related to the use.\n    private final Node use;\n    private final Node useCfgNode;\n\n    // Number of uses of the variable within the CFG node that represented the\n    // use in the CFG.\n    private int numUseWithinUseCfgNode;\n\n    Candidate(String varName, Node defCfgNode, Node use, Node useCfgNode) {\n      Preconditions.checkArgument(use.isName());\n      this.varName = varName;\n      this.defCfgNode = defCfgNode;\n      this.use = use;\n      this.useCfgNode = useCfgNode;\n    }\n\n    private boolean canInline() {\n\n      // Cannot inline a parameter.\n      if (defCfgNode.isFunction()) {\n        return false;\n      }\n\n      getDefinition(defCfgNode, null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, defCfgNode);\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has GETPROP, GETELEM,\n      // or anything that creates a new object.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(defCfgNode.getParent()) &&\n          defCfgNode.getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(defCfgNode),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    /**\n     * Actual transformation.\n     */\n    private void inlineVariable() {\n      Node defParent = def.getParent();\n      Node useParent = use.getParent();\n      if (def.isAssign()) {\n        Node rhs = def.getLastChild();\n        rhs.detachFromParent();\n        // Oh yes! I have grandparent to remove this.\n        Preconditions.checkState(defParent.isExprResult());\n        while (defParent.getParent().isLabel()) {\n          defParent = defParent.getParent();\n        }\n        defParent.detachFromParent();\n        useParent.replaceChild(use, rhs);\n      } else if (defParent.isVar()) {\n        Node rhs = def.getLastChild();\n        def.removeChild(rhs);\n        useParent.replaceChild(use, rhs);\n      } else {\n        Preconditions.checkState(false, \"No other definitions can be inlined.\");\n      }\n      compiler.reportCodeChange();\n    }\n\n    /**\n     * Set the def node\n     *\n     * @param n A node that has a corresponding CFG node in the CFG.\n     */\n    private void getDefinition(Node n, Node parent) {\n      AbstractCfgNodeTraversalCallback gatherCb =\n        new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          switch (n.getType()) {\n            case Token.NAME:\n              if (n.getString().equals(varName) && n.hasChildren()) {\n                def = n;\n              }\n              return;\n\n            case Token.ASSIGN:\n              Node lhs = n.getFirstChild();\n              if (lhs.isName() && lhs.getString().equals(varName)) {\n                def = n;\n              }\n              return;\n          }\n        }\n      };\n      NodeTraversal.traverse(compiler, n, gatherCb);\n    }\n\n    /**\n     * Computes the number of uses of the variable varName and store it in\n     * numUseWithinUseCfgNode.\n     */\n    private void getNumUseInUseCfgNode(Node n, Node parant) {\n\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName() && n.getString().equals(varName) &&\n              // do not count in if it is left child of an assignment operator\n              !(parent.isAssign() &&\n               (parent.getFirstChild() == n))) {\n            numUseWithinUseCfgNode++;\n          }\n        }\n      };\n\n      NodeTraversal.traverse(compiler, n, gatherCb);\n    }\n  }\n\n  /**\n   * Given an expression by its root and sub-expression n, return true if there\n   * the predicate is true for some expression on the right of n.\n   *\n   * Example:\n   *\n   * NotChecked(), NotChecked(), n, Checked(), Checked();\n   */\n  private static boolean checkRightOf(\n      Node n, Node expressionRoot, Predicate<Node> predicate) {\n    for (Node p = n; p != expressionRoot; p = p.getParent()) {\n      for (Node cur = p.getNext(); cur != null; cur = cur.getNext()) {\n        if (predicate.apply(cur)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Given an expression by its root and sub-expression n, return true if there\n   * the predicate is true for some expression on the left of n.\n   *\n   * Example:\n   *\n   * Checked(), Checked(), n, NotChecked(), NotChecked();\n   */\n  private static boolean checkLeftOf(\n      Node n, Node expressionRoot, Predicate<Node> predicate) {\n    for (Node p = n.getParent(); p != expressionRoot; p = p.getParent()) {\n      for (Node cur = p.getParent().getFirstChild(); cur != p;\n          cur = cur.getNext()) {\n        if (predicate.apply(cur)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n"}}
{"bug_id": "Closure_15", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.FlowSensitiveInlineVariables#visit(NodeTraversal#t,Node#n,Node#parent)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_15/fixed/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "focal_method": "@Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // TODO(user): While the helpers do a subtree traversal on the AST, the\n    // compiler pass itself only traverse the AST to look for function\n    // declarations to perform dataflow analysis on. We could combine\n    // the traversal in DataFlowAnalysis's computeEscaped later to save some\n    // time.\n  }", "return_type": "void", "assertion_subject_candidates": [], "focal_class": {"name": "FlowSensitiveInlineVariables", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_15/fixed/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "superclass": "extends AbstractPostOrderCallback", "interface": "implements CompilerPass, ScopedCallback", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.base.Predicate;", "import com.google.common.base.Predicates;", "import com.google.common.collect.Lists;", "import com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;", "import com.google.javascript.jscomp.ControlFlowGraph.Branch;", "import com.google.javascript.jscomp.DataFlowAnalysis.FlowState;", "import com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef;", "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;", "import com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;", "import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.Collection;", "import java.util.List;"], "fields": ["private final AbstractCompiler compiler", "private ControlFlowGraph<Node> cfg", "private List<Candidate> candidates", "private MustBeReachingVariableDef reachingDef", "private MaybeReachingVariableUse reachingUses", "private static final Predicate<Node> SIDE_EFFECT_PREDICATE = new Predicate<Node>() {\n      @Override\n      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // TODO(user): We only care about calls to functions that\n        // passes one of the dependent variable to a non-side-effect free\n        // function.\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isDelProp()) {\n          return true;\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n  }"], "methods": ["void com.google.javascript.jscomp.FlowSensitiveInlineVariables#enterScope(NodeTraversal#t)", "void com.google.javascript.jscomp.FlowSensitiveInlineVariables#exitScope(NodeTraversal#t)", "void com.google.javascript.jscomp.FlowSensitiveInlineVariables#process(Node#externs,Node#root)", "boolean com.google.javascript.jscomp.FlowSensitiveInlineVariables#checkRightOf(Node#n,Node#expressionRoot,Predicate<Node>#predicate)", "boolean com.google.javascript.jscomp.FlowSensitiveInlineVariables#checkLeftOf(Node#n,Node#expressionRoot,Predicate<Node>#predicate)"], "other_methods": ["@Override\n  public void enterScope(NodeTraversal t);", "@Override\n  public void exitScope(NodeTraversal t);", "@Override\n  public void process(Node externs,Node root);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "ControlFlowGraph<Node>#cfg": "private ControlFlowGraph<Node> cfg", "List<Candidate>#candidates": "private List<Candidate> candidates", "MustBeReachingVariableDef#reachingDef": "private MustBeReachingVariableDef reachingDef", "MaybeReachingVariableUse#reachingUses": "private MaybeReachingVariableUse reachingUses", "Predicate<Node>#SIDE_EFFECT_PREDICATE": "private static final Predicate<Node> SIDE_EFFECT_PREDICATE = new Predicate<Node>() {\n      @Override\n      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // TODO(user): We only care about calls to functions that\n        // passes one of the dependent variable to a non-side-effect free\n        // function.\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isDelProp()) {\n          return true;\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n  }"}, "text": "/*\n * Copyright 2009 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.ControlFlowGraph.AbstractCfgNodeTraversalCallback;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.DataFlowAnalysis.FlowState;\nimport com.google.javascript.jscomp.MustBeReachingVariableDef.MustDef;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractShallowCallback;\nimport com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.List;\n\n/**\n * Inline variables when possible. Using the information from\n * {@link MaybeReachingVariableUse} and {@link MustBeReachingVariableDef},\n * this pass attempts to inline a variable by placing the value at the\n * definition where the variable is used. The basic requirements for inlining\n * are the following:\n *\n * <ul>\n * <li> There is exactly one reaching definition at the use of that variable\n * </li>\n * <li> There is exactly one use for that definition of the variable\n * </li>\n * </ul>\n *\n * <p>Other requirements can be found in {@link Candidate#canInline}. Currently\n * this pass does not operate on the global scope due to compilation time.\n *\n */\nclass FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n    implements CompilerPass, ScopedCallback {\n\n  /**\n   * Implementation:\n   *\n   * This pass first perform a traversal to gather a list of Candidates that\n   * could be inlined using {@link GatherCandiates}.\n   *\n   * The second step involves verifying that each candidate is actually safe\n   * to inline with {@link Candidate#canInline()} and finally perform inlining\n   * using {@link Candidate#inlineVariable()}.\n   *\n   * The reason for the delayed evaluation of the candidates is because we\n   * need two separate dataflow result.\n   */\n  private final AbstractCompiler compiler;\n\n  // These two pieces of data is persistent in the whole execution of enter\n  // scope.\n  private ControlFlowGraph<Node> cfg;\n  private List<Candidate> candidates;\n  private MustBeReachingVariableDef reachingDef;\n  private MaybeReachingVariableUse reachingUses;\n\n  private static final Predicate<Node> SIDE_EFFECT_PREDICATE =\n    new Predicate<Node>() {\n      @Override\n      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // TODO(user): We only care about calls to functions that\n        // passes one of the dependent variable to a non-side-effect free\n        // function.\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isDelProp()) {\n          return true;\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }\n  };\n\n  public FlowSensitiveInlineVariables(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n      }\n    }\n  }\n\n  @Override\n  public void exitScope(NodeTraversal t) {}\n\n  @Override\n  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // TODO(user): While the helpers do a subtree traversal on the AST, the\n    // compiler pass itself only traverse the AST to look for function\n    // declarations to perform dataflow analysis on. We could combine\n    // the traversal in DataFlowAnalysis's computeEscaped later to save some\n    // time.\n  }\n\n  /**\n   * Gathers a list of possible candidates for inlining based only on\n   * information from {@link MustBeReachingVariableDef}. The list will be stored\n   * in {@code candidates} and the validity of each inlining Candidate should\n   * be later verified with {@link Candidate#canInline()} when\n   * {@link MaybeReachingVariableUse} has been performed.\n   */\n  private class GatherCandiates extends AbstractShallowCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      DiGraphNode<Node, Branch> graphNode = cfg.getDirectedGraphNode(n);\n      if (graphNode == null) {\n        // Not a CFG node.\n        return;\n      }\n      FlowState<MustDef> state = graphNode.getAnnotation();\n      final MustDef defs = state.getIn();\n      final Node cfgNode = n;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName()) {\n\n            // n.getParent() isn't null. This just the case where n is the root\n            // node that gatherCb started at.\n            if (parent == null) {\n              return;\n            }\n\n            // Make sure that the name node is purely a read.\n            if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n                || parent.isVar() || parent.isInc() || parent.isDec() ||\n                parent.isParamList() || parent.isCatch()) {\n              return;\n            }\n\n            String name = n.getString();\n            if (compiler.getCodingConvention().isExported(name)) {\n              return;\n            }\n\n            Node defNode = reachingDef.getDef(name, cfgNode);\n            // TODO(nicksantos): We need to add some notion of @const outer\n            // scope vars. We can inline those just fine.\n            if (defNode != null &&\n                !reachingDef.dependsOnOuterScopeVars(name, cfgNode)) {\n              candidates.add(new Candidate(name, defNode, n, cfgNode));\n            }\n          }\n        }\n      };\n\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }\n  }\n\n  /**\n   * Models the connection between a definition and a use of that definition.\n   */\n  private class Candidate {\n\n    // Name of the variable.\n    private final String varName;\n\n    // Nodes related to the definition.\n    private Node def;\n    private final Node defCfgNode;\n\n    // Nodes related to the use.\n    private final Node use;\n    private final Node useCfgNode;\n\n    // Number of uses of the variable within the CFG node that represented the\n    // use in the CFG.\n    private int numUseWithinUseCfgNode;\n\n    Candidate(String varName, Node defCfgNode, Node use, Node useCfgNode) {\n      Preconditions.checkArgument(use.isName());\n      this.varName = varName;\n      this.defCfgNode = defCfgNode;\n      this.use = use;\n      this.useCfgNode = useCfgNode;\n    }\n\n    private boolean canInline() {\n\n      // Cannot inline a parameter.\n      if (defCfgNode.isFunction()) {\n        return false;\n      }\n\n      getDefinition(defCfgNode, null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, defCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, defCfgNode);\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has GETPROP, GETELEM,\n      // or anything that creates a new object.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(defCfgNode.getParent()) &&\n          defCfgNode.getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(defCfgNode),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    /**\n     * Actual transformation.\n     */\n    private void inlineVariable() {\n      Node defParent = def.getParent();\n      Node useParent = use.getParent();\n      if (def.isAssign()) {\n        Node rhs = def.getLastChild();\n        rhs.detachFromParent();\n        // Oh yes! I have grandparent to remove this.\n        Preconditions.checkState(defParent.isExprResult());\n        while (defParent.getParent().isLabel()) {\n          defParent = defParent.getParent();\n        }\n        defParent.detachFromParent();\n        useParent.replaceChild(use, rhs);\n      } else if (defParent.isVar()) {\n        Node rhs = def.getLastChild();\n        def.removeChild(rhs);\n        useParent.replaceChild(use, rhs);\n      } else {\n        Preconditions.checkState(false, \"No other definitions can be inlined.\");\n      }\n      compiler.reportCodeChange();\n    }\n\n    /**\n     * Set the def node\n     *\n     * @param n A node that has a corresponding CFG node in the CFG.\n     */\n    private void getDefinition(Node n, Node parent) {\n      AbstractCfgNodeTraversalCallback gatherCb =\n        new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          switch (n.getType()) {\n            case Token.NAME:\n              if (n.getString().equals(varName) && n.hasChildren()) {\n                def = n;\n              }\n              return;\n\n            case Token.ASSIGN:\n              Node lhs = n.getFirstChild();\n              if (lhs.isName() && lhs.getString().equals(varName)) {\n                def = n;\n              }\n              return;\n          }\n        }\n      };\n      NodeTraversal.traverse(compiler, n, gatherCb);\n    }\n\n    /**\n     * Computes the number of uses of the variable varName and store it in\n     * numUseWithinUseCfgNode.\n     */\n    private void getNumUseInUseCfgNode(Node n, Node parant) {\n\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (n.isName() && n.getString().equals(varName) &&\n              // do not count in if it is left child of an assignment operator\n              !(parent.isAssign() &&\n               (parent.getFirstChild() == n))) {\n            numUseWithinUseCfgNode++;\n          }\n        }\n      };\n\n      NodeTraversal.traverse(compiler, n, gatherCb);\n    }\n  }\n\n  /**\n   * Given an expression by its root and sub-expression n, return true if there\n   * the predicate is true for some expression on the right of n.\n   *\n   * Example:\n   *\n   * NotChecked(), NotChecked(), n, Checked(), Checked();\n   */\n  private static boolean checkRightOf(\n      Node n, Node expressionRoot, Predicate<Node> predicate) {\n    for (Node p = n; p != expressionRoot; p = p.getParent()) {\n      for (Node cur = p.getNext(); cur != null; cur = cur.getNext()) {\n        if (predicate.apply(cur)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Given an expression by its root and sub-expression n, return true if there\n   * the predicate is true for some expression on the left of n.\n   *\n   * Example:\n   *\n   * Checked(), Checked(), n, NotChecked(), NotChecked();\n   */\n  private static boolean checkLeftOf(\n      Node n, Node expressionRoot, Predicate<Node> predicate) {\n    for (Node p = n.getParent(); p != expressionRoot; p = p.getParent()) {\n      for (Node cur = p.getParent().getFirstChild(); cur != p;\n          cur = cur.getNext()) {\n        if (predicate.apply(cur)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n"}}
{"bug_id": "Closure_114", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.NameAnalyzer#process(Node#externs,Node#root)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_114/fixed/src/com/google/javascript/jscomp/NameAnalyzer.java", "focal_method": "@Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, externs, new ProcessExternals());\n    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());\n    NodeTraversal.traverse(\n        compiler, root, new HoistVariableAndFunctionDeclarations());\n    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());\n    NodeTraversal.traverse(compiler, root, new FindReferences());\n\n    // Create bi-directional references between parent names and their\n    // descendants. This may create new names.\n    referenceParentNames();\n\n    // If we modify the property of an alias, make sure that modification\n    // gets reflected in the original object.\n    referenceAliases();\n\n    calculateReferences();\n\n    if (removeUnreferenced) {\n      removeUnreferenced();\n    }\n  }", "return_type": "void", "assertion_subject_candidates": [], "focal_class": {"name": "NameAnalyzer", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_114/fixed/src/com/google/javascript/jscomp/NameAnalyzer.java", "superclass": "", "interface": "implements CompilerPass", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.base.Predicate;", "import com.google.common.collect.ImmutableSet;", "import com.google.common.collect.LinkedListMultimap;", "import com.google.common.collect.ListMultimap;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Sets;", "import com.google.javascript.jscomp.CodingConvention.SubclassRelationship;", "import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.GetReplacementSideEffectSubexpressions;", "import com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.SideEffectAccumulator;", "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.jscomp.graph.DiGraph;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;", "import com.google.javascript.jscomp.graph.FixedPointGraphTraversal;", "import com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;", "import com.google.javascript.jscomp.graph.LinkedDirectedGraph;", "import com.google.javascript.rhino.IR;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.Collections;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;"], "fields": ["private final AbstractCompiler compiler", "private final Map<String, JsName> allNames = Maps.newTreeMap()", "private DiGraph<JsName, RefType> referenceGraph = LinkedDirectedGraph.createWithoutAnnotations()", "private final ListMultimap<Node, NameInformation> scopes = LinkedListMultimap.create()", "private static final String PROTOTYPE_SUBSTRING = \".prototype.\"", "private static final int PROTOTYPE_SUBSTRING_LEN = PROTOTYPE_SUBSTRING.length()", "private static final int PROTOTYPE_SUFFIX_LEN = \".prototype\".length()", "private static final String WINDOW = \"window\"", "private static final String FUNCTION = \"Function\"", "static final Set<String> DEFAULT_GLOBAL_NAMES = ImmutableSet.of(\n      \"window\", \"goog.global\")", "private final boolean removeUnreferenced", "private final Set<String> globalNames", "private final AstChangeProxy changeProxy", "private final Set<String> externalNames = Sets.newHashSet()", "private final List<RefNode> refNodes = Lists.newArrayList()", "private final Map<String, AliasSet> aliases = Maps.newHashMap()", "private static final Predicate<Node> NON_LOCAL_RESULT_PREDICATE = new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n          if (input.isCall()) {\n            return false;\n          }\n          // TODO(johnlenz): handle NEW calls that record their 'this'\n          // in global scope and effectively return an alias.\n          // Other non-local references are handled by this pass.\n          return true;\n        }\n      }"], "methods": ["void com.google.javascript.jscomp.NameAnalyzer#recordAlias(String#fromName,String#toName)", "void com.google.javascript.jscomp.NameAnalyzer#recordReference(String#fromName,String#toName,RefType#depType)", "void com.google.javascript.jscomp.NameAnalyzer#removeUnreferenced()", "String com.google.javascript.jscomp.NameAnalyzer#getHtmlReport()", "void com.google.javascript.jscomp.NameAnalyzer#appendListItem(StringBuilder#sb,String#text)", "String com.google.javascript.jscomp.NameAnalyzer#nameLink(String#name)", "String com.google.javascript.jscomp.NameAnalyzer#nameAnchor(String#name)", "JsName com.google.javascript.jscomp.NameAnalyzer#getName(String#name,boolean#canCreate)", "void com.google.javascript.jscomp.NameAnalyzer#createName(String#name)", "void com.google.javascript.jscomp.NameAnalyzer#referenceAliases()", "void com.google.javascript.jscomp.NameAnalyzer#referenceParentNames()", "NameInformation com.google.javascript.jscomp.NameAnalyzer#createNameInformation(NodeTraversal#t,Node#n)", "NameInformation com.google.javascript.jscomp.NameAnalyzer#createNameInformation(String#name,Scope#scope,Node#rootNameNode)", "boolean com.google.javascript.jscomp.NameAnalyzer#isExternallyReferenceable(Scope#scope,String#name)", "List<NameInformation> com.google.javascript.jscomp.NameAnalyzer#getDependencyScope(Node#n)", "List<NameInformation> com.google.javascript.jscomp.NameAnalyzer#getEnclosingFunctionDependencyScope(NodeTraversal#t)", "void com.google.javascript.jscomp.NameAnalyzer#calculateReferences()", "int com.google.javascript.jscomp.NameAnalyzer#countOf(TriState#isClass,TriState#referenced)", "List<Node> com.google.javascript.jscomp.NameAnalyzer#getSideEffectNodes(Node#n)", "void com.google.javascript.jscomp.NameAnalyzer#replaceWithRhs(Node#parent,Node#n)", "void com.google.javascript.jscomp.NameAnalyzer#replaceTopLevelExpressionWithRhs(Node#parent,Node#n)", "boolean com.google.javascript.jscomp.NameAnalyzer#valueConsumedByParent(Node#n,Node#parent)", "Node com.google.javascript.jscomp.NameAnalyzer#collapseReplacements(List<Node>#replacements)", "List<Node> com.google.javascript.jscomp.NameAnalyzer#getRhsSubexpressions(Node#n)"], "other_methods": [], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "Map<String, JsName>#allNames": "private final Map<String, JsName> allNames = Maps.newTreeMap()", "DiGraph<JsName, RefType>#referenceGraph": "private DiGraph<JsName, RefType> referenceGraph = LinkedDirectedGraph.createWithoutAnnotations()", "ListMultimap<Node, NameInformation>#scopes": "private final ListMultimap<Node, NameInformation> scopes = LinkedListMultimap.create()", "String#PROTOTYPE_SUBSTRING": "private static final String PROTOTYPE_SUBSTRING = \".prototype.\"", "int#PROTOTYPE_SUBSTRING_LEN": "private static final int PROTOTYPE_SUBSTRING_LEN = PROTOTYPE_SUBSTRING.length()", "int#PROTOTYPE_SUFFIX_LEN": "private static final int PROTOTYPE_SUFFIX_LEN = \".prototype\".length()", "String#WINDOW": "private static final String WINDOW = \"window\"", "String#FUNCTION": "private static final String FUNCTION = \"Function\"", "Set<String>#DEFAULT_GLOBAL_NAMES": "static final Set<String> DEFAULT_GLOBAL_NAMES = ImmutableSet.of(\n      \"window\", \"goog.global\")", "boolean#removeUnreferenced": "private final boolean removeUnreferenced", "Set<String>#globalNames": "private final Set<String> globalNames", "AstChangeProxy#changeProxy": "private final AstChangeProxy changeProxy", "Set<String>#externalNames": "private final Set<String> externalNames = Sets.newHashSet()", "List<RefNode>#refNodes": "private final List<RefNode> refNodes = Lists.newArrayList()", "Map<String, AliasSet>#aliases": "private final Map<String, AliasSet> aliases = Maps.newHashMap()", "Predicate<Node>#NON_LOCAL_RESULT_PREDICATE": "private static final Predicate<Node> NON_LOCAL_RESULT_PREDICATE = new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n          if (input.isCall()) {\n            return false;\n          }\n          // TODO(johnlenz): handle NEW calls that record their 'this'\n          // in global scope and effectively return an alias.\n          // Other non-local references are handled by this pass.\n          return true;\n        }\n      }"}, "text": "/*\n * Copyright 2006 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.LinkedListMultimap;\nimport com.google.common.collect.ListMultimap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.CodingConvention.SubclassRelationship;\nimport com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.GetReplacementSideEffectSubexpressions;\nimport com.google.javascript.jscomp.GatherSideEffectSubexpressionsCallback.SideEffectAccumulator;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.graph.DiGraph;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\nimport com.google.javascript.jscomp.graph.FixedPointGraphTraversal;\nimport com.google.javascript.jscomp.graph.FixedPointGraphTraversal.EdgeCallback;\nimport com.google.javascript.jscomp.graph.LinkedDirectedGraph;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * This pass identifies all global names, simple (e.g. <code>a</code>) or\n * qualified (e.g. <code>a.b.c</code>), and the dependencies between them, then\n * removes code associated with unreferenced names. It starts by assuming that\n * only externally accessible names (e.g. <code>window</code>) are referenced,\n * then iteratively marks additional names as referenced (e.g. <code>Foo</code>\n * in <code>window['foo'] = new Foo();</code>). This makes it possible to\n * eliminate code containing circular references.\n *\n * <p>Qualified names can be defined using dotted or object literal syntax\n * (<code>a.b.c = x;</code> or <code>a.b = {c: x};</code>, respectively).\n *\n * <p>Removal of prototype classes is currently all or nothing. In other words,\n * prototype properties and methods are never individually removed.\n *\n * <p>Optionally generates pretty HTML output of data so that it is easy to\n * analyze dependencies.\n *\n * <p>Only operates on names defined in the global scope, but it would be easy\n * to extend the pass to names defined in local scopes.\n *\n * TODO(nicksantos): In the initial implementation of this pass, it was\n * important to understand namespaced names (e.g., that a.b is distinct from\n * a.b.c). Now that this pass comes after CollapseProperties, this is no longer\n * necessary. For now, I've changed so that {@code referenceParentNames}\n * creates a two-way reference between a.b and a.b.c, so that they're\n * effectively the same name. When someone has the time, we should completely\n * rip out all the logic that understands namespaces.\n *\n */\nfinal class NameAnalyzer implements CompilerPass {\n\n  /** Reference to the JS compiler */\n  private final AbstractCompiler compiler;\n\n  /** Map of all JS names found */\n  private final Map<String, JsName> allNames = Maps.newTreeMap();\n\n  /** Reference dependency graph */\n  private DiGraph<JsName, RefType> referenceGraph =\n      LinkedDirectedGraph.createWithoutAnnotations();\n\n  /**\n   * Map of name scopes - all children of the Node key have a dependency on the\n   * name value.\n   *\n   * If scopes.get(node).equals(name) && node2 is a child of node, then node2\n   * will not get executed unless name is referenced via a get operation\n   */\n  private final ListMultimap<Node, NameInformation> scopes =\n      LinkedListMultimap.create();\n\n  /** Used to parse prototype names */\n  private static final String PROTOTYPE_SUBSTRING = \".prototype.\";\n\n  private static final int PROTOTYPE_SUBSTRING_LEN =\n      PROTOTYPE_SUBSTRING.length();\n\n  private static final int PROTOTYPE_SUFFIX_LEN = \".prototype\".length();\n\n  /** Window root */\n  private static final String WINDOW = \"window\";\n\n  /** Function class name */\n  private static final String FUNCTION = \"Function\";\n\n  /** All of these refer to global scope. These can be moved to config */\n  static final Set<String> DEFAULT_GLOBAL_NAMES = ImmutableSet.of(\n      \"window\", \"goog.global\");\n\n  /** Whether to remove unreferenced variables in main pass */\n  private final boolean removeUnreferenced;\n\n  /** Names that refer to the global scope */\n  private final Set<String> globalNames;\n\n  /** Ast change helper */\n  private final AstChangeProxy changeProxy;\n\n  /** Names that are externally defined */\n  private final Set<String> externalNames = Sets.newHashSet();\n\n  /** Name declarations or assignments, in post-order traversal order */\n  private final List<RefNode> refNodes = Lists.newArrayList();\n\n  /**\n   * When multiple names in the global scope point to the same object, we\n   * call them aliases. Store a map from each alias name to the alias set.\n   */\n  private final Map<String, AliasSet> aliases = Maps.newHashMap();\n\n  /**\n   * All the aliases in a program form a graph, where each global name is\n   * a node in the graph, and two names are connected if one directly aliases\n   * the other.\n   *\n   * An {@code AliasSet} represents a connected component in that graph. We do\n   * not explicitly track the graph--we just track the connected components.\n   */\n  private static class AliasSet {\n    Set<String> names = Sets.newHashSet();\n\n    // Every alias set starts with exactly 2 names.\n    AliasSet(String name1, String name2) {\n      names.add(name1);\n      names.add(name2);\n    }\n  }\n\n  /**\n   * Relationship between the two names.\n   * Currently only two different reference types exists:\n   * goog.inherits class relations and all other references.\n   */\n  private static enum RefType {\n    REGULAR,\n    INHERITANCE,\n  }\n\n  /**\n   * Callback that propagates reference information.\n   */\n  private static class ReferencePropagationCallback\n      implements EdgeCallback<JsName, RefType> {\n    @Override\n    public boolean traverseEdge(JsName from,\n                                RefType callSite,\n                                JsName to) {\n      if (from.referenced && !to.referenced) {\n        to.referenced = true;\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }\n\n  /**\n   * Class to hold information that can be determined from a node tree about a\n   * given name\n   */\n  private static class NameInformation {\n    /** Fully qualified name */\n    String name;\n\n    /** Whether the name is guaranteed to be externally referenceable */\n    boolean isExternallyReferenceable = false;\n\n    /** Whether this name is a prototype function */\n    boolean isPrototype = false;\n\n    /** Name of the prototype class, i.e. \"a\" if name is \"a.prototype.b\" */\n    String prototypeClass = null;\n\n    /** Local name of prototype property i.e. \"b\" if name is \"a.prototype.b\" */\n    String prototypeProperty = null;\n\n    /** Name of the super class of name */\n    String superclass = null;\n\n    /** Whether this is a call that only affects the class definition */\n    boolean onlyAffectsClassDef = false;\n  }\n\n  /**\n   * Struct to hold information about a fully qualified JS name\n   */\n  private static class JsName implements Comparable<JsName> {\n    /** Fully qualified name */\n    String name;\n\n    /** Name of prototype functions attached to this name */\n    List<String> prototypeNames = Lists.newArrayList();\n\n    /** Whether this is an externally defined name */\n    boolean externallyDefined = false;\n\n    /** Whether this node is referenced */\n    boolean referenced = false;\n\n    /** Whether the name has descendants that are written to. */\n    boolean hasWrittenDescendants = false;\n\n    /** Whether the name is used in a instanceof check */\n    boolean hasInstanceOfReference = false;\n\n    /**\n     * Output the node as a string\n     *\n     * @return Node as a string\n     */\n    @Override\n    public String toString() {\n      StringBuilder out = new StringBuilder();\n      out.append(name);\n\n      if (prototypeNames.size() > 0) {\n        out.append(\" (CLASS)\\n\");\n        out.append(\" - FUNCTIONS: \");\n        Iterator<String> pIter = prototypeNames.iterator();\n        while (pIter.hasNext()) {\n          out.append(pIter.next());\n          if (pIter.hasNext()) {\n            out.append(\", \");\n          }\n        }\n      }\n\n      return out.toString();\n    }\n\n    @Override\n    public int compareTo(JsName rhs) {\n      return this.name.compareTo(rhs.name);\n    }\n  }\n\n  /**\n   * Interface to get information about and remove unreferenced names.\n   */\n  interface RefNode {\n    JsName name();\n    void remove();\n  }\n\n  /**\n   * Class for nodes that reference a fully-qualified JS name. Fully qualified\n   * names are of form A or A.B (A.B.C, etc.). References can get the value or\n   * set the value of the JS name.\n   */\n  private class JsNameRefNode implements RefNode {\n    /** JsName node for this reference */\n    JsName name;\n\n    /**\n     * Top GETPROP or NAME or STRING [objlit key] node defining the name of\n     * this node\n     */\n    @SuppressWarnings(\"unused\")\n    Node node;\n\n    /**\n     * Parent node of the name access\n     * (ASSIGN, VAR, FUNCTION, OBJECTLIT, or CALL)\n     */\n    Node parent;\n\n\n    /**\n     * Create a node that refers to a name\n     *\n     * @param name The name\n     * @param node The top node representing the name (GETPROP, NAME, STRING)\n     */\n    JsNameRefNode(JsName name, Node node) {\n      this.name = name;\n      this.node = node;\n      this.parent = node.getParent();\n    }\n\n    @Override\n    public JsName name() {\n      return name;\n    }\n\n    @Override\n    public void remove() {\n      // Setters have VAR, FUNCTION, or ASSIGN parent nodes. CALL parent\n      // nodes are global refs, and are handled later in this function.\n      Node containingNode = parent.getParent();\n      switch (parent.getType()) {\n        case Token.VAR:\n          Preconditions.checkState(parent.hasOneChild());\n          replaceWithRhs(containingNode, parent);\n          break;\n        case Token.FUNCTION:\n          replaceWithRhs(containingNode, parent);\n          break;\n        case Token.ASSIGN:\n          if (containingNode.isExprResult()) {\n            replaceWithRhs(containingNode.getParent(), containingNode);\n          } else {\n            replaceWithRhs(containingNode, parent);\n          }\n          break;\n        case Token.OBJECTLIT:\n          // TODO(nicksantos): Come up with a way to remove this.\n          // If we remove object lit keys, then we will need to also\n          // create dependency scopes for them.\n          break;\n      }\n    }\n  }\n\n\n  /**\n   * Class for nodes that set prototype properties or methods.\n   */\n  private class PrototypeSetNode extends JsNameRefNode {\n    /**\n     * Create a set node from the name & setter node\n     *\n     * @param name The name\n     * @param parent Parent node that assigns the expression (an ASSIGN)\n     */\n    PrototypeSetNode(JsName name, Node parent) {\n      super(name, parent.getFirstChild());\n\n      Preconditions.checkState(parent.isAssign());\n    }\n\n    @Override public void remove() {\n      Node gramps = parent.getParent();\n      if (gramps.isExprResult()) {\n        // name.prototype.foo = function() { ... };\n        changeProxy.removeChild(gramps.getParent(), gramps);\n      } else {\n        // ... name.prototype.foo = function() { ... } ...\n        changeProxy.replaceWith(gramps, parent,\n                                parent.getLastChild().detachFromParent());\n      }\n    }\n  }\n\n  /**\n   * Base class for special reference nodes.\n   */\n  private abstract class SpecialReferenceNode implements RefNode {\n    /** JsName node for the function */\n    JsName name;\n\n    /** The CALL node */\n    Node node;\n\n    /**\n     * Create a special reference node.\n     *\n     * @param name The name\n     * @param node The CALL node\n     */\n    SpecialReferenceNode(JsName name, Node node) {\n      this.name = name;\n      this.node = node;\n    }\n\n    @Override\n    public JsName name() {\n      return name;\n    }\n\n    Node getParent() {\n      return node.getParent();\n    }\n\n    Node getGramps() {\n      return node.getParent() == null ? null : node.getParent().getParent();\n    }\n  }\n\n\n\n  /**\n   * Class for nodes that are function calls that may change a function's\n   * prototype\n   */\n  private class ClassDefiningFunctionNode extends SpecialReferenceNode {\n    /**\n     * Create a class defining function node from the name & setter node\n     *\n     * @param name The name\n     * @param node The CALL node\n     */\n    ClassDefiningFunctionNode(JsName name, Node node) {\n      super(name, node);\n      Preconditions.checkState(node.isCall());\n    }\n\n    @Override\n    public void remove() {\n      Preconditions.checkState(node.isCall());\n      Node parent = getParent();\n      if (parent.isExprResult()) {\n        changeProxy.removeChild(getGramps(), parent);\n      } else {\n        changeProxy.replaceWith(parent, node, IR.voidNode(IR.number(0)));\n      }\n    }\n  }\n\n\n\n  /**\n   * Class for nodes that check instanceof\n   */\n  private class InstanceOfCheckNode extends SpecialReferenceNode {\n    /**\n     * Create an instanceof node from the name and parent node\n     *\n     * @param name The name\n     * @param node The qualified name node\n     */\n    InstanceOfCheckNode(JsName name, Node node) {\n      super(name, node);\n      Preconditions.checkState(node.isQualifiedName());\n      Preconditions.checkState(getParent().isInstanceOf());\n    }\n\n    @Override\n    public void remove() {\n      changeProxy.replaceWith(getGramps(), getParent(), IR.falseNode());\n    }\n  }\n\n  /**\n   * Walk through externs and mark nodes as externally declared if declared\n   */\n  private class ProcessExternals extends AbstractPostOrderCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      NameInformation ns = null;\n      if (NodeUtil.isVarDeclaration(n)) {\n        ns = createNameInformation(t, n);\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        ns = createNameInformation(t, n.getFirstChild());\n      }\n      if (ns != null) {\n        JsName jsName = getName(ns.name, true);\n        jsName.externallyDefined = true;\n        externalNames.add(ns.name);\n      }\n    }\n  }\n\n  /**\n   * <p>Identifies all dependency scopes.\n   *\n   * <p>A dependency scope is a relationship between a node tree and a name that\n   * implies that the node tree will not execute (and thus can be eliminated) if\n   * the name is never referenced.\n   *\n   * <p>The entire parse tree is ultimately in a dependency scope relationship\n   * with <code>window</code> (or an equivalent name for the global scope), but\n   * the goal here is to find finer-grained relationships. This callback creates\n   * dependency scopes for every assignment statement, variable declaration, and\n   * function call in the global scope.\n   *\n   * <p>Note that dependency scope node trees aren't necessarily disjoint.\n   * In the following code snippet, for example, the function definition\n   * forms a dependency scope with the name <code>f</code> and the assignment\n   * inside the function forms a dependency scope with the name <code>x</code>.\n   * <pre>\n   * var x; function f() { x = 1; }\n   * </pre>\n   */\n  private class FindDependencyScopes extends AbstractPostOrderCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!t.inGlobalScope()) {\n        return;\n      }\n\n      if (n.isAssign()) {\n        recordAssignment(t, n, n);\n        if (!NodeUtil.isImmutableResult(n.getLastChild())) {\n          recordConsumers(t, n, n);\n        }\n      } else if (NodeUtil.isVarDeclaration(n)) {\n        NameInformation ns = createNameInformation(t, n);\n        recordDepScope(n, ns);\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        NameInformation ns = createNameInformation(t, n.getFirstChild());\n        recordDepScope(n, ns);\n      } else if (NodeUtil.isExprCall(n)) {\n        Node callNode = n.getFirstChild();\n        Node nameNode = callNode.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode);\n        if (ns != null && ns.onlyAffectsClassDef) {\n          recordDepScope(n, ns);\n        }\n      }\n    }\n\n    private void recordConsumers(NodeTraversal t, Node n, Node recordNode) {\n      Node parent = n.getParent();\n      switch (parent.getType()) {\n        case Token.ASSIGN:\n          if (n == parent.getLastChild()) {\n            recordAssignment(t, parent, recordNode);\n          }\n          recordConsumers(t, parent, recordNode);\n          break;\n        case Token.NAME:\n          NameInformation ns = createNameInformation(t, parent);\n          recordDepScope(recordNode, ns);\n          break;\n        case Token.OR:\n          recordConsumers(t, parent, recordNode);\n          break;\n        case Token.AND:\n          // In \"a && b\" only \"b\" can be meaningfully aliased.\n          // \"a\" must be falsy, which it must be an immutable, non-Object\n        case Token.COMMA:\n        case Token.HOOK:\n          if (n != parent.getFirstChild()) {\n            recordConsumers(t, parent, recordNode);\n          }\n          break;\n      }\n    }\n\n    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node nameNode = n.getFirstChild();\n      Node parent = n.getParent();\n      NameInformation ns = createNameInformation(t, nameNode);\n      if (ns != null) {\n        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n          // Patch for assignments that appear in the init,\n          // condition or iteration part of a FOR loop.  Without\n          // this change, all 3 of those parts try to claim the for\n          // loop as their dependency scope.  The last assignment in\n          // those three fields wins, which can result in incorrect\n          // reference edges between referenced and assigned variables.\n          //\n          // TODO(user) revisit the dependency scope calculation\n          // logic.\n          if (parent.getFirstChild().getNext() != n) {\n            recordDepScope(recordNode, ns);\n          } else {\n            recordDepScope(nameNode, ns);\n          }\n        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n          // The rhs of the assignment is the caller, so it's used by the\n          // context. Don't associate it w/ the lhs.\n          // FYI: this fixes only the specific case where the assignment is the\n          // caller expression, but it could be nested deeper in the caller and\n          // we would still get a bug.\n          // See testAssignWithCall2 for an example of this.\n          recordDepScope(recordNode, ns);\n        }\n      }\n    }\n\n    /**\n     * Defines a dependency scope.\n     */\n    private void recordDepScope(Node node, NameInformation name) {\n      Preconditions.checkNotNull(name);\n      scopes.put(node, name);\n    }\n  }\n\n  /**\n   * Create JsName objects for variable and function declarations in\n   * the global scope before computing name references.  In JavaScript\n   * it is legal to refer to variable and function names before the\n   * actual declaration.\n   */\n  private class HoistVariableAndFunctionDeclarations\n      extends NodeTraversal.AbstractShallowCallback {\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (NodeUtil.isVarDeclaration(n)) {\n        NameInformation ns = createNameInformation(t, n);\n        Preconditions.checkNotNull(ns, \"NameInformation is null\");\n        createName(ns.name);\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode);\n        Preconditions.checkNotNull(ns, \"NameInformation is null\");\n        createName(nameNode.getString());\n      }\n    }\n  }\n\n  /**\n   * Identifies all declarations of global names and setter statements\n   * affecting global symbols (assignments to global names).\n   *\n   * All declarations and setters must be gathered in a single\n   * traversal and stored in traversal order so \"removeUnreferenced\"\n   * can perform modifications in traversal order.\n   */\n  private class FindDeclarationsAndSetters extends AbstractPostOrderCallback {\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      // Record global variable and function declarations\n      if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n          NameInformation ns = createNameInformation(t, n);\n          Preconditions.checkNotNull(ns);\n          recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n          Node nameNode = n.getFirstChild();\n          NameInformation ns = createNameInformation(t, nameNode);\n          if (ns != null) {\n            JsName nameInfo = getName(nameNode.getString(), true);\n            recordSet(nameInfo.name, nameNode);\n          }\n        } else if (NodeUtil.isObjectLitKey(n)) {\n          NameInformation ns = createNameInformation(t, n);\n          if (ns != null) {\n            recordSet(ns.name, n);\n          }\n        }\n      }\n\n      // Record assignments and call sites\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n\n        NameInformation ns = createNameInformation(t, nameNode);\n        if (ns != null) {\n          if (ns.isPrototype) {\n            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n          } else {\n            recordSet(ns.name, nameNode);\n          }\n        }\n      } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode);\n        if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, true);\n          refNodes.add(new ClassDefiningFunctionNode(name, n));\n        }\n      }\n    }\n\n    /**\n     * Records the assignment of a value to a global name.\n     *\n     * @param name Fully qualified name\n     * @param node The top node representing the name (GETPROP, NAME, or STRING\n     * [objlit key])\n     */\n    private void recordSet(String name, Node node) {\n      JsName jsn = getName(name, true);\n      JsNameRefNode nameRefNode = new JsNameRefNode(jsn, node);\n      refNodes.add(nameRefNode);\n\n      // Now, look at all parent names and record that their properties have\n      // been written to.\n      if (node.isGetElem()) {\n        recordWriteOnProperties(name);\n      } else if (name.indexOf('.') != -1) {\n        recordWriteOnProperties(name.substring(0, name.lastIndexOf('.')));\n      }\n    }\n\n    /**\n     * Records the assignment to a prototype property of a global name,\n     * if possible.\n     *\n     * @param className The name of the class.\n     * @param prototypeProperty The name of the prototype property.\n     * @param node The top node representing the name (GETPROP)\n     */\n    private void recordPrototypeSet(String className, String prototypeProperty,\n        Node node) {\n      JsName name = getName(className, true);\n      name.prototypeNames.add(prototypeProperty);\n      refNodes.add(new PrototypeSetNode(name, node));\n      recordWriteOnProperties(className);\n    }\n\n    /**\n     * Record that the properties of this name have been written to.\n     */\n    private void recordWriteOnProperties(String parentName) {\n      do {\n        JsName parent = getName(parentName, true);\n        if (parent.hasWrittenDescendants) {\n          // If we already recorded this name, then all its parents must\n          // also be recorded. short-circuit this loop.\n          return;\n        } else {\n          parent.hasWrittenDescendants = true;\n        }\n\n        if (parentName.indexOf('.') == -1) {\n          return;\n        }\n        parentName = parentName.substring(0, parentName.lastIndexOf('.'));\n      } while(true);\n    }\n  }\n\n  private static final Predicate<Node> NON_LOCAL_RESULT_PREDICATE =\n      new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n          if (input.isCall()) {\n            return false;\n          }\n          // TODO(johnlenz): handle NEW calls that record their 'this'\n          // in global scope and effectively return an alias.\n          // Other non-local references are handled by this pass.\n          return true;\n        }\n      };\n\n  /**\n   * <p>Identifies all references between global names.\n   *\n   * <p>A reference from a name <code>f</code> to a name <code>g</code> means\n   * that if the name <code>f</code> must be defined, then the name\n   * <code>g</code> must also be defined. This would be the case if, for\n   * example, <code>f</code> were a function that called <code>g</code>.\n   */\n  private class FindReferences implements Callback {\n    Set<Node> nodesToKeep;\n    FindReferences() {\n      nodesToKeep = Sets.newHashSet();\n    }\n\n    private void addAllChildren(Node n) {\n      nodesToKeep.add(n);\n      for (Node child = n.getFirstChild();\n           child != null;\n           child = child.getNext()) {\n        addAllChildren(child);\n      }\n    }\n\n    private void addSimplifiedChildren(Node n) {\n      NodeTraversal.traverse(\n          compiler, n,\n          new GatherSideEffectSubexpressionsCallback(\n              compiler, new NodeAccumulator()));\n    }\n\n    private void addSimplifiedExpression(Node n, Node parent) {\n      if (parent.isVar()) {\n        Node value = n.getFirstChild();\n        if (value != null) {\n          addSimplifiedChildren(value);\n        }\n      } else if (n.isAssign() &&\n          (parent.isExprResult() ||\n           parent.isFor() ||\n           parent.isReturn())) {\n        for (Node child : n.children()) {\n          addSimplifiedChildren(child);\n        }\n      } else if (n.isCall() &&\n                 parent.isExprResult()) {\n        addSimplifiedChildren(n);\n      } else {\n        addAllChildren(n);\n      }\n    }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (parent == null) {\n        return true;\n      }\n\n      // Gather the list of nodes that either have side effects, are\n      // arguments to function calls with side effects or are used in\n      // control structure predicates.  These names are always\n      // referenced when the enclosing function is called.\n      if (n.isFor()) {\n        if (!NodeUtil.isForIn(n)) {\n          Node decl = n.getFirstChild();\n          Node pred = decl.getNext();\n          Node step = pred.getNext();\n          addSimplifiedExpression(decl, n);\n          addSimplifiedExpression(pred, n);\n          addSimplifiedExpression(step, n);\n        } else { // n.getChildCount() == 3\n          Node decl = n.getFirstChild();\n          Node iter = decl.getNext();\n          addAllChildren(decl);\n          addAllChildren(iter);\n        }\n      }\n\n      if (parent.isVar() ||\n          parent.isExprResult() ||\n          parent.isReturn() ||\n          parent.isThrow()) {\n        addSimplifiedExpression(n, parent);\n      }\n\n      if ((parent.isIf() ||\n           parent.isWhile() ||\n           parent.isWith() ||\n           parent.isSwitch() ||\n           parent.isCase()) &&\n          parent.getFirstChild() == n) {\n        addAllChildren(n);\n      }\n\n      if (parent.isDo() && parent.getLastChild() == n) {\n        addAllChildren(n);\n      }\n\n      return true;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (!(n.isName() || (NodeUtil.isGet(n) && !parent.isGetProp()))) {\n        // This is not a simple or qualified name.\n        return;\n      }\n\n      NameInformation nameInfo = createNameInformation(t, n);\n      if (nameInfo == null) {\n        // The name is not a global name\n        return;\n      }\n\n      if (nameInfo.onlyAffectsClassDef) {\n        if (nameInfo.superclass != null) {\n          recordReference(\n              nameInfo.name, nameInfo.superclass, RefType.INHERITANCE);\n        }\n\n        // Make sure that we record a reference to the function that does\n        // the inheritance, so that the inherits() function itself does\n        // not get stripped.\n        String nodeName = n.getQualifiedName();\n        if (nodeName != null) {\n          recordReference(\n              nameInfo.name, nodeName, RefType.REGULAR);\n        }\n\n        return;\n      }\n\n      if (parent.isInstanceOf() &&\n          parent.getLastChild() == n &&\n          // Don't cover GETELEMs with a global root node.\n          n.isQualifiedName()) {\n        JsName checkedClass = getName(nameInfo.name, true);\n        refNodes.add(new InstanceOfCheckNode(checkedClass, n));\n        checkedClass.hasInstanceOfReference = true;\n        return;\n      }\n\n      // Determine which name might be potentially referring to this one by\n      // looking up the nearest enclosing dependency scope. It's unnecessary to\n      // determine all enclosing dependency scopes because this callback should\n      // create a chain of references between them.\n      List<NameInformation> referers = getDependencyScope(n);\n      if (referers.isEmpty()) {\n        maybeRecordReferenceOrAlias(t, n, parent, nameInfo, null);\n      } else {\n        for (NameInformation referring : referers) {\n          maybeRecordReferenceOrAlias(t, n, parent, nameInfo, referring);\n        }\n        recordAliases(referers);\n      }\n    }\n\n    private void maybeRecordReferenceOrAlias(\n        NodeTraversal t, Node n, Node parent,\n        NameInformation nameInfo, NameInformation referring) {\n      String referringName = \"\";\n      if (referring != null) {\n        referringName = referring.isPrototype\n                      ? referring.prototypeClass\n                      : referring.name;\n      }\n\n      String name = nameInfo.name;\n\n      // A value whose result is the return value of a function call\n      // can be an alias to global object.\n      // Here we add an alias to the general \"global\" object\n      // to act as a placeholder for the actual (unnamed) value.\n      if (maybeHiddenAlias(n)) {\n        recordAlias(name, WINDOW);\n      }\n\n      // An externally referenceable name must always be defined, so we add a\n      // reference to it from the global scope (a.k.a. window).\n      if (nameInfo.isExternallyReferenceable) {\n        recordReference(WINDOW, name, RefType.REGULAR);\n        maybeRecordAlias(name, parent, referring, referringName);\n        return;\n      }\n\n      // An assignment implies a reference from the enclosing dependency scope.\n      // For example, foo references bar in: function foo() {bar=5}.\n      if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n        if (referring != null) {\n          recordReference(referringName, name, RefType.REGULAR);\n        }\n        return;\n      }\n\n      if (nodesToKeep.contains(n)) {\n        List<NameInformation> functionScopes =\n            getEnclosingFunctionDependencyScope(t);\n        if (!functionScopes.isEmpty()) {\n          for (NameInformation functionScope : functionScopes) {\n            recordReference(functionScope.name, name, RefType.REGULAR);\n          }\n        } else {\n          recordReference(WINDOW, name, RefType.REGULAR);\n          if (referring != null) {\n            maybeRecordAlias(name, parent, referring, referringName);\n          }\n        }\n      } else if (referring != null) {\n        if (!maybeRecordAlias(name, parent, referring, referringName)) {\n          RefType depType = referring.onlyAffectsClassDef ?\n              RefType.INHERITANCE : RefType.REGULAR;\n          recordReference(referringName, name, depType);\n        }\n      } else {\n        // No named dependency scope found.  Unfortunately that might\n        // mean that the expression is a child of an function expression\n        // or assignment with a complex lhs.  In those cases,\n        // protect this node by creating a reference to WINDOW.\n        for (Node ancestor : n.getAncestors()) {\n          if (NodeUtil.isAssignmentOp(ancestor) ||\n              ancestor.isFunction()) {\n            recordReference(WINDOW, name, RefType.REGULAR);\n            break;\n          }\n        }\n      }\n    }\n\n    private void recordAliases(List<NameInformation> referers) {\n      int size = referers.size();\n      for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n          recordAlias(referers.get(i).name, referers.get(j).name);\n          recordAlias(referers.get(j).name, referers.get(i).name);\n        }\n      }\n    }\n\n    /**\n     * A value whose result is the return value of a function call\n     * can be an alias to global object. The dependency on the call target will\n     * prevent the removal of the function and its dependent values, but won't\n     * prevent the alias' removal.\n     */\n    private boolean maybeHiddenAlias(Node n) {\n      Node parent = n.getParent();\n      if (NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n        Node rhs = (parent.isVar())\n            ? n.getFirstChild() : parent.getLastChild();\n        return (rhs != null && !NodeUtil.evaluatesToLocalValue(\n            rhs, NON_LOCAL_RESULT_PREDICATE));\n      }\n      return false;\n    }\n\n    /**\n     * @return Whether the alias was recorded.\n     */\n    private boolean maybeRecordAlias(\n        String name, Node parent,\n        NameInformation referring, String referringName) {\n      // A common type of reference is\n      // function F() {}\n      // F.prototype.bar = goog.nullFunction;\n      //\n      // In this specific case, we do not want a reference to goog.nullFunction\n      // to preserve F.\n      //\n      // In the general case, the user could do something like\n      // function F() {}\n      // F.prototype.bar = goog.nullFunction;\n      // F.prototype.bar.baz = 3;\n      // where it would not be safe to remove F.\n      //\n      // So we do not treat this alias as a backdoor for people to mutate the\n      // original object. We think that this heuristic will always be\n      // OK in real code.\n      boolean isPrototypePropAssignment =\n          parent.isAssign()\n          && NodeUtil.isPrototypeProperty(parent.getFirstChild());\n\n      if ((parent.isName() ||\n          parent.isAssign()) &&\n          !isPrototypePropAssignment &&\n          referring != null &&\n          scopes.get(parent).contains(referring)) {\n        recordAlias(referringName, name);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Helper class that gathers the list of nodes that would be left\n     * behind after simplification.\n     */\n    private class NodeAccumulator\n        implements SideEffectAccumulator {\n\n      @Override\n      public boolean classDefiningCallsHaveSideEffects() {\n        return false;\n      }\n\n      @Override\n      public void keepSubTree(Node original) {\n        addAllChildren(original);\n      }\n\n      @Override\n      public void keepSimplifiedShortCircuitExpression(Node original) {\n        Node condition = original.getFirstChild();\n        Node thenBranch = condition.getNext();\n        addAllChildren(condition);\n        addSimplifiedChildren(thenBranch);\n      }\n\n      @Override\n      public void keepSimplifiedHookExpression(Node hook,\n                                               boolean thenHasSideEffects,\n                                               boolean elseHasSideEffects) {\n        Node condition = hook.getFirstChild();\n        Node thenBranch = condition.getNext();\n        Node elseBranch = thenBranch.getNext();\n        addAllChildren(condition);\n        if (thenHasSideEffects) {\n          addSimplifiedChildren(thenBranch);\n        }\n        if (elseHasSideEffects) {\n          addSimplifiedChildren(elseBranch);\n        }\n      }\n    }\n  }\n\n  private class RemoveListener implements AstChangeProxy.ChangeListener {\n    @Override\n    public void nodeRemoved(Node n) {\n      compiler.reportCodeChange();\n    }\n  }\n\n  /**\n   * Creates a name analyzer, with option to remove unreferenced variables when\n   * calling process().\n   *\n   * The analyzer make a best guess at whether functions affect global scope\n   * based on usage (no assignment of return value means that a function has\n   * side effects).\n   *\n   * @param compiler The AbstractCompiler\n   * @param removeUnreferenced If true, remove unreferenced variables during\n   *        process()\n   */\n  NameAnalyzer(AbstractCompiler compiler, boolean removeUnreferenced) {\n    this.compiler = compiler;\n    this.removeUnreferenced = removeUnreferenced;\n    this.globalNames = DEFAULT_GLOBAL_NAMES;\n    this.changeProxy = new AstChangeProxy();\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, externs, new ProcessExternals());\n    NodeTraversal.traverse(compiler, root, new FindDependencyScopes());\n    NodeTraversal.traverse(\n        compiler, root, new HoistVariableAndFunctionDeclarations());\n    NodeTraversal.traverse(compiler, root, new FindDeclarationsAndSetters());\n    NodeTraversal.traverse(compiler, root, new FindReferences());\n\n    // Create bi-directional references between parent names and their\n    // descendants. This may create new names.\n    referenceParentNames();\n\n    // If we modify the property of an alias, make sure that modification\n    // gets reflected in the original object.\n    referenceAliases();\n\n    calculateReferences();\n\n    if (removeUnreferenced) {\n      removeUnreferenced();\n    }\n  }\n\n  /**\n   * Records an alias of one name to another name.\n   */\n  private void recordAlias(String fromName, String toName) {\n    recordReference(fromName, toName, RefType.REGULAR);\n\n    // We need to add an edge to the alias graph. The alias graph is expressed\n    // implicitly as a set of connected components, called AliasSets.\n    //\n    // There are three possibilities:\n    // 1) Neither name is part of a connected component. Create a new one.\n    // 2) Exactly one name is part of a connected component. Merge the new\n    //    name into the component.\n    // 3) The two names are already part of connected components. Merge\n    //    those components together.\n    AliasSet toNameAliasSet = aliases.get(toName);\n    AliasSet fromNameAliasSet = aliases.get(fromName);\n    AliasSet resultSet = null;\n    if (toNameAliasSet == null && fromNameAliasSet == null) {\n      resultSet = new AliasSet(toName, fromName);\n    } else if (toNameAliasSet != null && fromNameAliasSet != null) {\n      resultSet = toNameAliasSet;\n      resultSet.names.addAll(fromNameAliasSet.names);\n      for (String name : fromNameAliasSet.names) {\n        aliases.put(name, resultSet);\n      }\n    } else if (toNameAliasSet != null) {\n      resultSet = toNameAliasSet;\n      resultSet.names.add(fromName);\n    } else {\n      resultSet = fromNameAliasSet;\n      resultSet.names.add(toName);\n    }\n    aliases.put(fromName, resultSet);\n    aliases.put(toName, resultSet);\n  }\n\n  /**\n   * Records a reference from one name to another name.\n   */\n  private void recordReference(String fromName, String toName,\n                               RefType depType) {\n    if (fromName.equals(toName)) {\n      // Don't bother recording self-references.\n      return;\n    }\n\n    JsName from = getName(fromName, true);\n    JsName to = getName(toName, true);\n    referenceGraph.createNode(from);\n    referenceGraph.createNode(to);\n    if (!referenceGraph.isConnectedInDirection(from, depType, to)) {\n      referenceGraph.connect(from, depType, to);\n    }\n  }\n\n  /**\n   * Removes all unreferenced variables.\n   */\n  void removeUnreferenced() {\n    RemoveListener listener = new RemoveListener();\n    changeProxy.registerListener(listener);\n\n    for (RefNode refNode : refNodes) {\n      JsName name = refNode.name();\n      if (!name.referenced && !name.externallyDefined) {\n        refNode.remove();\n      }\n    }\n\n    changeProxy.unregisterListener(listener);\n  }\n\n  /**\n   * Generates an HTML report\n   *\n   * @return The report\n   */\n  String getHtmlReport() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"<html><body><style type=\\\"text/css\\\">\"\n        + \"body, td, p {font-family: Arial; font-size: 83%} \"\n        + \"ul {margin-top:2px; margin-left:0px; padding-left:1em;} \"\n        + \"li {margin-top:3px; margin-left:24px; padding-left:0px;\"\n        + \"padding-bottom: 4px}</style>\");\n    sb.append(\"OVERALL STATS<ul>\");\n    appendListItem(sb, \"Total Names: \" + countOf(TriState.BOTH, TriState.BOTH));\n    appendListItem(sb, \"Total Classes: \"\n        + countOf(TriState.TRUE, TriState.BOTH));\n    appendListItem(sb, \"Total Static Functions: \"\n        + countOf(TriState.FALSE, TriState.BOTH));\n    appendListItem(sb, \"Referenced Names: \"\n        + countOf(TriState.BOTH, TriState.TRUE));\n    appendListItem(sb, \"Referenced Classes: \"\n        + countOf(TriState.TRUE, TriState.TRUE));\n    appendListItem(sb, \"Referenced Functions: \"\n        + countOf(TriState.FALSE, TriState.TRUE));\n    sb.append(\"</ul>\");\n\n    sb.append(\"ALL NAMES<ul>\\n\");\n    for (JsName node : allNames.values()) {\n      sb.append(\"<li>\" + nameAnchor(node.name) + \"<ul>\");\n      if (node.prototypeNames.size() > 0) {\n        sb.append(\"<li>PROTOTYPES: \");\n        Iterator<String> protoIter = node.prototypeNames.iterator();\n        while (protoIter.hasNext()) {\n          sb.append(protoIter.next());\n          if (protoIter.hasNext()) {\n            sb.append(\", \");\n          }\n        }\n      }\n\n      if (referenceGraph.hasNode(node)) {\n        List<DiGraphEdge<JsName, RefType>> refersTo =\n            referenceGraph.getOutEdges(node);\n        if (refersTo.size() > 0) {\n          sb.append(\"<li>REFERS TO: \");\n          Iterator<DiGraphEdge<JsName, RefType>> toIter = refersTo.iterator();\n          while (toIter.hasNext()) {\n            sb.append(nameLink(toIter.next().getDestination().getValue().name));\n            if (toIter.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n        }\n\n        List<DiGraphEdge<JsName, RefType>> referencedBy =\n            referenceGraph.getInEdges(node);\n        if (referencedBy.size() > 0) {\n          sb.append(\"<li>REFERENCED BY: \");\n          Iterator<DiGraphEdge<JsName, RefType>> fromIter = refersTo.iterator();\n          while (fromIter.hasNext()) {\n            sb.append(\n                nameLink(fromIter.next().getDestination().getValue().name));\n            if (fromIter.hasNext()) {\n              sb.append(\", \");\n            }\n          }\n        }\n      }\n      sb.append(\"</li>\");\n      sb.append(\"</ul></li>\");\n    }\n    sb.append(\"</ul>\");\n    sb.append(\"</body></html>\");\n\n    return sb.toString();\n  }\n\n  private void appendListItem(StringBuilder sb, String text) {\n    sb.append(\"<li>\" + text + \"</li>\\n\");\n  }\n\n  private String nameLink(String name) {\n    return \"<a href=\\\"#\" + name + \"\\\">\" + name + \"</a>\";\n  }\n\n  private String nameAnchor(String name) {\n    return \"<a name=\\\"\" + name + \"\\\">\" + name + \"</a>\";\n  }\n\n  /**\n   * Looks up a {@link JsName} by name, optionally creating one if it doesn't\n   * already exist.\n   *\n   * @param name A fully qualified name\n   * @param canCreate Whether to create the object if necessary\n   * @return The {@code JsName} object, or null if one can't be found and\n   *   can't be created.\n   */\n  private JsName getName(String name, boolean canCreate) {\n    if (canCreate) {\n      createName(name);\n    }\n    return allNames.get(name);\n  }\n\n  /**\n   * Creates a {@link JsName} for the given name if it doesn't already\n   * exist.\n   *\n   * @param name A fully qualified name\n   */\n  private void createName(String name) {\n    JsName jsn = allNames.get(name);\n    if (jsn == null) {\n      jsn = new JsName();\n      jsn.name = name;\n      allNames.put(name, jsn);\n    }\n  }\n\n  /**\n   * The NameAnalyzer algorithm works best when all objects have a canonical\n   * name in the global scope. When multiple names in the global scope\n   * point to the same object, things start to break down.\n   *\n   * For example, if we have\n   * <code>\n   * var a = {};\n   * var b = a;\n   * a.foo = 3;\n   * alert(b.foo);\n   * </code>\n   * then a.foo and b.foo are the same name, even though NameAnalyzer doesn't\n   * represent them as such.\n   *\n   * To handle this case, we look at all the aliases in the program.\n   * If descendant properties of that alias are assigned, then we create a\n   * directional reference from the original name to the alias. For example,\n   * in this case, the assign to {@code a.foo} triggers a reference from\n   * {@code b} to {@code a}, but NOT from a to b.\n   *\n   * Similarly, \"instanceof\" checks do not prevent the removal\n   * of a unaliased name but an instanceof check on an alias can only be removed\n   * if the other aliases are also removed, so we add a connection here.\n   */\n  private void referenceAliases() {\n    for (Map.Entry<String, AliasSet> entry : aliases.entrySet()) {\n      JsName name = getName(entry.getKey(), false);\n      if (name.hasWrittenDescendants || name.hasInstanceOfReference) {\n        for (String alias : entry.getValue().names) {\n          recordReference(alias, entry.getKey(), RefType.REGULAR);\n        }\n      }\n    }\n  }\n\n  /**\n   * Adds mutual references between all known global names and their parent\n   * names. (e.g. between <code>a.b.c</code> and <code>a.b</code>).\n   */\n  private void referenceParentNames() {\n    // Duplicate set of nodes to process so we don't modify set we are\n    // currently iterating over\n    Set<JsName> allNamesCopy = Sets.newHashSet(allNames.values());\n\n    for (JsName name : allNamesCopy) {\n      String curName = name.name;\n      JsName curJsName = name;\n      while (curName.indexOf('.') != -1) {\n        String parentName = curName.substring(0, curName.lastIndexOf('.'));\n        if (!globalNames.contains(parentName)) {\n\n          JsName parentJsName = getName(parentName, true);\n\n          recordReference(curJsName.name, parentJsName.name, RefType.REGULAR);\n          recordReference(parentJsName.name, curJsName.name, RefType.REGULAR);\n\n          curJsName = parentJsName;\n        }\n        curName = parentName;\n      }\n    }\n  }\n\n  /**\n   * Creates name information for the current node during a traversal.\n   *\n   * @param t The node traversal\n   * @param n The current node\n   * @return The name information, or null if the name is irrelevant to this\n   *     pass\n   */\n  private NameInformation createNameInformation(NodeTraversal t, Node n) {\n    Node parent = n.getParent();\n    // Build the full name and find its root node by iterating down through all\n    // GETPROP/GETELEM nodes.\n    String name = \"\";\n    Node rootNameNode = n;\n    boolean bNameWasShortened = false;\n    while (true) {\n      if (NodeUtil.isGet(rootNameNode)) {\n        Node prop = rootNameNode.getLastChild();\n        if (rootNameNode.isGetProp()) {\n          name = \".\" + prop.getString() + name;\n        } else {\n          // We consider the name to be \"a.b\" in a.b['c'] or a.b[x].d.\n          bNameWasShortened = true;\n          name = \"\";\n        }\n        rootNameNode = rootNameNode.getFirstChild();\n      } else if (NodeUtil.isObjectLitKey(rootNameNode)) {\n        name = \".\" + rootNameNode.getString() + name;\n\n        // Check if this is an object literal assigned to something.\n        Node objLit = rootNameNode.getParent();\n        Node objLitParent = objLit.getParent();\n        if (objLitParent.isAssign()) {\n          // This must be the right side of the assign.\n          rootNameNode = objLitParent.getFirstChild();\n        } else if (objLitParent.isName()) {\n          // This must be a VAR initialization.\n          rootNameNode = objLitParent;\n        } else if (objLitParent.isStringKey()) {\n          // This must be a object literal key initialization.\n          rootNameNode = objLitParent;\n        } else {\n          return null;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Check whether this is a class-defining call. Classes may only be defined\n    // in the global scope.\n    if (parent.isCall() && t.inGlobalScope()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship classes = convention.getClassesDefinedByCall(parent);\n      if (classes != null) {\n        NameInformation nameInfo = new NameInformation();\n        nameInfo.name = classes.subclassName;\n        nameInfo.onlyAffectsClassDef = true;\n        nameInfo.superclass = classes.superclassName;\n        return nameInfo;\n      }\n\n      String singletonGetterClass =\n          convention.getSingletonGetterClassName(parent);\n      if (singletonGetterClass != null) {\n        NameInformation nameInfo = new NameInformation();\n        nameInfo.name = singletonGetterClass;\n        nameInfo.onlyAffectsClassDef = true;\n        return nameInfo;\n      }\n    }\n\n    switch (rootNameNode.getType()) {\n      case Token.NAME:\n        // Check whether this is an assignment to a prototype property\n        // of an object defined in the global scope.\n        if (!bNameWasShortened &&\n            n.isGetProp() &&\n            parent.isAssign() &&\n            \"prototype\".equals(n.getLastChild().getString())) {\n          if (createNameInformation(t, n.getFirstChild()) != null) {\n            name = rootNameNode.getString() + name;\n            name = name.substring(0, name.length() - PROTOTYPE_SUFFIX_LEN);\n            NameInformation nameInfo = new NameInformation();\n            nameInfo.name = name;\n            return nameInfo;\n          } else {\n            return null;\n          }\n        }\n        return createNameInformation(\n            rootNameNode.getString() + name, t.getScope(), rootNameNode);\n      case Token.THIS:\n        if (t.inGlobalScope()) {\n          NameInformation nameInfo = new NameInformation();\n          if (name.indexOf('.') == 0) {\n            nameInfo.name = name.substring(1);  // strip leading \".\"\n          } else {\n            nameInfo.name = name;\n          }\n          nameInfo.isExternallyReferenceable = true;\n          return nameInfo;\n        }\n        return null;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Creates name information for a particular qualified name that occurs in a\n   * particular scope.\n   *\n   * @param name A qualified name (e.g. \"x\" or \"a.b.c\")\n   * @param scope The scope in which {@code name} occurs\n   * @param rootNameNode The NAME node for the first token of {@code name}\n   * @return The name information, or null if the name is irrelevant to this\n   *     pass\n   */\n  private NameInformation createNameInformation(\n      String name, Scope scope, Node rootNameNode) {\n    // Check the scope. Currently we're only looking at globally scoped vars.\n    String rootName = rootNameNode.getString();\n    Var v = scope.getVar(rootName);\n    boolean isExtern = (v == null && externalNames.contains(rootName));\n    boolean isGlobalRef = (v != null && v.isGlobal()) || isExtern ||\n        rootName.equals(WINDOW);\n    if (!isGlobalRef) {\n      return null;\n    }\n\n    NameInformation nameInfo = new NameInformation();\n\n    // If a prototype property or method, fill in prototype information.\n    int idx = name.indexOf(PROTOTYPE_SUBSTRING);\n    if (idx != -1) {\n      nameInfo.isPrototype = true;\n      nameInfo.prototypeClass = name.substring(0, idx);\n      nameInfo.prototypeProperty = name.substring(\n          idx + PROTOTYPE_SUBSTRING_LEN);\n    }\n\n    nameInfo.name = name;\n    nameInfo.isExternallyReferenceable =\n        isExtern || isExternallyReferenceable(scope, name);\n    return nameInfo;\n  }\n\n  /**\n   * Checks whether a name can be referenced outside of the compiled code.\n   * These names will be the root of dependency trees.\n   *\n   * @param scope The current variable scope\n   * @param name The name\n   * @return True if can be referenced outside\n   */\n  private boolean isExternallyReferenceable(Scope scope, String name) {\n    if (compiler.getCodingConvention().isExported(name)) {\n      return true;\n    }\n    if (scope.isLocal()) {\n      return false;\n    }\n    for (String s : globalNames) {\n      if (name.startsWith(s)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the nearest enclosing dependency scope, or null if there isn't one.\n   */\n  private List<NameInformation> getDependencyScope(Node n) {\n    for (Node node : n.getAncestors()) {\n      List<NameInformation> refs = scopes.get(node);\n      if (!refs.isEmpty()) {\n        return refs;\n      }\n    }\n\n    return Collections.emptyList();\n  }\n\n  /**\n   * Get dependency scope defined by the enclosing function, or null.\n   * If enclosing function is a function expression, determine scope based on\n   * its parent if the parent node is a variable declaration or\n   * assignment.\n   */\n  private List<NameInformation> getEnclosingFunctionDependencyScope(\n      NodeTraversal t) {\n    Node function = t.getEnclosingFunction();\n    if (function == null) {\n      return Collections.emptyList();\n    }\n\n    List<NameInformation> refs = scopes.get(function);\n    if (!refs.isEmpty()) {\n      return refs;\n    }\n\n    // Function expression.  try to get a name from the parent var\n    // declaration or assignment.\n    Node parent = function.getParent();\n    if (parent != null) {\n      // Account for functions defined in the form:\n      //   var a = cond ? function a() {} : function b() {};\n      while (parent.isHook()) {\n        parent = parent.getParent();\n      }\n\n      if (parent.isName()) {\n        return scopes.get(parent);\n      }\n\n      if (parent.isAssign()) {\n        return scopes.get(parent);\n      }\n    }\n\n    return Collections.emptyList();\n  }\n\n  /**\n   * Propagate \"referenced\" property down the graph.\n   */\n  private void calculateReferences() {\n    JsName window = getName(WINDOW, true);\n    window.referenced = true;\n    JsName function = getName(FUNCTION, true);\n    function.referenced = true;\n\n    // Propagate \"referenced\" property to a fixed point.\n    FixedPointGraphTraversal.newTraversal(new ReferencePropagationCallback())\n        .computeFixedPoint(referenceGraph);\n  }\n\n\n  /**\n   * Enum for saying a value can be true, false, or either (cleaner than using a\n   * Boolean with null)\n   */\n  private enum TriState {\n    /** If value is true */\n    TRUE,\n    /** If value is false */\n    FALSE,\n    /** If value can be true or false */\n    BOTH\n  }\n\n  /**\n   * Gets the count of nodes matching the criteria\n   *\n   * @param isClass Whether the node is a class\n   * @param referenced Whether the node is referenced\n   * @return Number of matches\n   */\n  private int countOf(TriState isClass, TriState referenced) {\n    int count = 0;\n    for (JsName name : allNames.values()) {\n\n      boolean nodeIsClass = name.prototypeNames.size() > 0;\n\n      boolean classMatch = isClass == TriState.BOTH\n          || (nodeIsClass && isClass == TriState.TRUE)\n          || (!nodeIsClass && isClass == TriState.FALSE);\n\n      boolean referenceMatch = referenced == TriState.BOTH\n          || (name.referenced && referenced == TriState.TRUE)\n          || (!name.referenced && referenced == TriState.FALSE);\n\n      if (classMatch && referenceMatch && !name.externallyDefined) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n\n  /**\n   * Extract a list of replacement nodes to use.\n   */\n  private List<Node> getSideEffectNodes(Node n) {\n    List<Node> subexpressions = Lists.newArrayList();\n    NodeTraversal.traverse(\n        compiler, n,\n        new GatherSideEffectSubexpressionsCallback(\n            compiler,\n            new GetReplacementSideEffectSubexpressions(\n                compiler, subexpressions)));\n\n    List<Node> replacements =\n        Lists.newArrayListWithExpectedSize(subexpressions.size());\n    for (Node subexpression : subexpressions) {\n      replacements.add(NodeUtil.newExpr(subexpression));\n    }\n    return replacements;\n  }\n\n  /**\n   * Replace n with a simpler expression, while preserving program\n   * behavior.\n   *\n   * If the n's value is used, replace it with its RHS; otherwise\n   * replace it with the subexpressions that have side effects.\n   */\n  private void replaceWithRhs(Node parent, Node n) {\n    if (valueConsumedByParent(n, parent)) {\n      // parent reads from n directly; replace it with n's rhs + lhs\n      // subexpressions with side effects.\n      List<Node> replacements = getRhsSubexpressions(n);\n      List<Node> newReplacements = Lists.newArrayList();\n      for (int i = 0; i < replacements.size() - 1; i++) {\n        newReplacements.addAll(getSideEffectNodes(replacements.get(i)));\n      }\n      Node valueExpr = replacements.get(replacements.size() - 1);\n      valueExpr.detachFromParent();\n      newReplacements.add(valueExpr);\n      changeProxy.replaceWith(\n          parent, n, collapseReplacements(newReplacements));\n    } else if (n.isAssign() && !parent.isFor()) {\n      // assignment appears in a RHS expression.  we have already\n      // considered names in the assignment's RHS as being referenced;\n      // replace the assignment with its RHS.\n      // TODO(user) make the pass smarter about these cases and/or run\n      // this pass and RemoveConstantExpressions together in a loop.\n      Node replacement = n.getLastChild();\n      replacement.detachFromParent();\n      changeProxy.replaceWith(parent, n, replacement);\n    } else {\n      replaceTopLevelExpressionWithRhs(parent, n);\n    }\n  }\n\n  /**\n   * Simplify a toplevel expression, while preserving program\n   * behavior.\n   */\n  private void replaceTopLevelExpressionWithRhs(Node parent, Node n) {\n    // validate inputs\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.SCRIPT:\n      case Token.FOR:\n      case Token.LABEL:\n        break;\n      default:\n        throw new IllegalArgumentException(\n            \"Unsupported parent node type in replaceWithRhs \" +\n            Token.name(parent.getType()));\n    }\n\n    switch (n.getType()) {\n      case Token.EXPR_RESULT:\n      case Token.FUNCTION:\n      case Token.VAR:\n        break;\n      case Token.ASSIGN:\n        Preconditions.checkArgument(parent.isFor(),\n            \"Unsupported assignment in replaceWithRhs. parent: %s\",\n            Token.name(parent.getType()));\n        break;\n      default:\n        throw new IllegalArgumentException(\n            \"Unsupported node type in replaceWithRhs \" +\n            Token.name(n.getType()));\n    }\n\n    // gather replacements\n    List<Node> replacements = Lists.newArrayList();\n    for (Node rhs : getRhsSubexpressions(n)) {\n      replacements.addAll(getSideEffectNodes(rhs));\n    }\n\n    if (parent.isFor()) {\n      // tweak replacements array s.t. it is a single expression node.\n      if (replacements.isEmpty()) {\n        replacements.add(IR.empty());\n      } else {\n        Node expr = collapseReplacements(replacements);\n        replacements.clear();\n        replacements.add(expr);\n      }\n    }\n\n    changeProxy.replaceWith(parent, n, replacements);\n  }\n\n  /**\n   * Determine if the parent reads the value of a child expression\n   * directly.  This is true children used in predicates, RETURN\n   * statements and, RHS of variable declarations and assignments.\n   *\n   * In the case of:\n   * if (a) b else c\n   *\n   * This method returns true for \"a\", and false for \"b\" and \"c\": the\n   * IF expression does something special based on \"a\"'s value.  \"b\"\n   * and \"c\" are effectively outputs.  Same logic applies to FOR,\n   * WHILE and DO loop predicates.  AND/OR/HOOK expressions are\n   * syntactic sugar for IF statements; therefore this method returns\n   * true for the predicate and false otherwise.\n   */\n  private boolean valueConsumedByParent(Node n, Node parent) {\n    if (NodeUtil.isAssignmentOp(parent)) {\n      return parent.getLastChild() == n;\n    }\n\n    switch (parent.getType()) {\n      case Token.NAME:\n      case Token.RETURN:\n        return true;\n      case Token.AND:\n      case Token.OR:\n      case Token.HOOK:\n        return parent.getFirstChild() == n;\n      case Token.FOR:\n        return parent.getFirstChild().getNext() == n;\n      case Token.IF:\n      case Token.WHILE:\n        return parent.getFirstChild() == n;\n      case Token.DO:\n        return parent.getLastChild() == n;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Merge a list of nodes into a single expression.  The value of the\n   * new expression is determined by the last expression in the list.\n   */\n  private Node collapseReplacements(List<Node> replacements) {\n    Node expr = null;\n    for (Node rep : replacements) {\n      if (rep.isExprResult()) {\n        rep = rep.getFirstChild();\n        rep.detachFromParent();\n      }\n\n      if (expr == null) {\n        expr = rep;\n      } else {\n        expr = IR.comma(expr, rep);\n      }\n    }\n\n    return expr;\n  }\n\n  /**\n   * Extract a list of subexpressions that act as right hand sides.\n   */\n  private List<Node> getRhsSubexpressions(Node n) {\n    switch (n.getType()) {\n      case Token.EXPR_RESULT:\n        // process body\n        return getRhsSubexpressions(n.getFirstChild());\n      case Token.FUNCTION:\n        // function nodes have no RHS\n        return Collections.emptyList();\n      case Token.NAME:\n        {\n          // parent is a var node.  RHS is the first child\n          Node rhs = n.getFirstChild();\n          if (rhs != null) {\n            return Lists.newArrayList(rhs);\n          } else {\n            return Collections.emptyList();\n          }\n        }\n      case Token.ASSIGN:\n        {\n          // add LHS and RHS expressions - LHS may be a complex expression\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          return Lists.newArrayList(lhs, rhs);\n        }\n      case Token.VAR:\n        {\n          // recurse on all children\n          List<Node> nodes = Lists.newArrayList();\n          for (Node child : n.children()) {\n            nodes.addAll(getRhsSubexpressions(child));\n          }\n          return nodes;\n        }\n      default:\n        throw new IllegalArgumentException(\"AstChangeProxy::getRhs \" + n);\n    }\n  }\n}\n"}}
{"bug_id": "Closure_100", "version": "fixed", "focal_method_signature": "boolean com.google.javascript.jscomp.CheckGlobalThis#shouldTraverse(NodeTraversal#t,Node#n,Node#parent)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_100/fixed/src/com/google/javascript/jscomp/CheckGlobalThis.java", "focal_method": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n      \n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (lhs.getType() == Token.GETPROP) {\n          if (lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          String leftName = lhs.getQualifiedName();\n          if (leftName != null && leftName.contains(\".prototype.\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }", "return_type": "boolean", "assertion_subject_candidates": ["boolean"], "focal_class": {"name": "CheckGlobalThis", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_100/fixed/src/com/google/javascript/jscomp/CheckGlobalThis.java", "superclass": "", "interface": "implements Callback", "imports": ["import com.google.javascript.jscomp.CheckLevel;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;"], "fields": ["static final DiagnosticType GLOBAL_THIS = DiagnosticType.warning(\n      \"JSC_USED_GLOBAL_THIS\",\n      \"dangerous use of the global 'this' object\")", "private final AbstractCompiler compiler", "private final CheckLevel level", "private Node assignLhsChild = null"], "methods": ["void com.google.javascript.jscomp.CheckGlobalThis#visit(NodeTraversal#t,Node#n,Node#parent)", "boolean com.google.javascript.jscomp.CheckGlobalThis#shouldReportThis(Node#n,Node#parent)", "JSDocInfo com.google.javascript.jscomp.CheckGlobalThis#getFunctionJsDocInfo(Node#n)"], "other_methods": ["public void visit(NodeTraversal t,Node n,Node parent);"], "fields_dict": {"DiagnosticType#GLOBAL_THIS": "static final DiagnosticType GLOBAL_THIS = DiagnosticType.warning(\n      \"JSC_USED_GLOBAL_THIS\",\n      \"dangerous use of the global 'this' object\")", "AbstractCompiler#compiler": "private final AbstractCompiler compiler", "CheckLevel#level": "private final CheckLevel level", "Node#assignLhsChild": "private Node assignLhsChild = null"}, "text": "/*\n * Copyright 2007 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.javascript.jscomp.CheckLevel;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\n/**\n * Checks for certain uses of the {@code this} keyword that are considered\n * unsafe because they are likely to reference the global {@code this} object\n * unintentionally.\n *\n * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n * assignment or a property access, and not inside one of the following:\n * <ol>\n * <li>a prototype method\n * <li>a function annotated with {@code @constructor}\n * <li>a function annotated with {@code @this}.\n * <li>a function where there's no logical place to put a\n *     {@code this} annotation.\n * </ol>\n *\n * <p>Note that this check does not track assignments of {@code this} to\n * variables or objects. The code\n * <pre>\n * function evil() {\n *   var a = this;\n *   a.useful = undefined;\n * }\n * </pre>\n * will not get flagged, even though it is semantically equivalent to\n * <pre>\n * function evil() {\n *   this.useful = undefined;\n * }\n * </pre>\n * which would get flagged.\n *\n*\n*\n */\nfinal class CheckGlobalThis implements Callback {\n\n  static final DiagnosticType GLOBAL_THIS = DiagnosticType.warning(\n      \"JSC_USED_GLOBAL_THIS\",\n      \"dangerous use of the global 'this' object\");\n\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n  \n  /**\n   * If {@code assignLhsChild != null}, then the node being traversed is\n   * a descendant of the first child of an ASSIGN node. assignLhsChild's\n   * parent is this ASSIGN node.\n   */\n  private Node assignLhsChild = null;\n\n  CheckGlobalThis(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.level = level;\n  }\n\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n      \n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (lhs.getType() == Token.GETPROP) {\n          if (lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          String leftName = lhs.getQualifiedName();\n          if (leftName != null && leftName.contains(\".prototype.\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {\n      compiler.report(t.makeError(n, level, GLOBAL_THIS));\n    }\n    if (n == assignLhsChild) {\n      assignLhsChild = null;\n    }\n  }\n\n  private boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n      // Always report a THIS on the left side of an assign.\n      return true;\n    }\n\n    // Also report a THIS with a property access.\n    return parent != null && NodeUtil.isGet(parent);\n  }\n\n  /**\n   * Gets a function's JSDoc information, if it has any. Checks for a few\n   * patterns (ellipses show where JSDoc would be):\n   * <pre>\n   * ... function() {}\n   * ... x = function() {};\n   * var ... x = function() {};\n   * ... var x = function() {};\n   * </pre>\n   */\n  private JSDocInfo getFunctionJsDocInfo(Node n) {\n    JSDocInfo jsDoc = n.getJSDocInfo();\n    Node parent = n.getParent();\n    if (jsDoc == null) {\n      int parentType = parent.getType();\n      if (parentType == Token.NAME || parentType == Token.ASSIGN) {\n        jsDoc = parent.getJSDocInfo();\n        if (jsDoc == null && parentType == Token.NAME) {\n          Node gramps = parent.getParent();\n          if (gramps.getType() == Token.VAR) {\n            jsDoc = gramps.getJSDocInfo();\n          }\n        }\n      }\n    }\n    return jsDoc;\n  }\n}\n"}}
{"bug_id": "Closure_100", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.CheckGlobalThis#visit(NodeTraversal#t,Node#n,Node#parent)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_100/fixed/src/com/google/javascript/jscomp/CheckGlobalThis.java", "focal_method": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {\n      compiler.report(t.makeError(n, level, GLOBAL_THIS));\n    }\n    if (n == assignLhsChild) {\n      assignLhsChild = null;\n    }\n  }", "return_type": "void", "assertion_subject_candidates": [], "focal_class": {"name": "CheckGlobalThis", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_100/fixed/src/com/google/javascript/jscomp/CheckGlobalThis.java", "superclass": "", "interface": "implements Callback", "imports": ["import com.google.javascript.jscomp.CheckLevel;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;"], "fields": ["static final DiagnosticType GLOBAL_THIS = DiagnosticType.warning(\n      \"JSC_USED_GLOBAL_THIS\",\n      \"dangerous use of the global 'this' object\")", "private final AbstractCompiler compiler", "private final CheckLevel level", "private Node assignLhsChild = null"], "methods": ["boolean com.google.javascript.jscomp.CheckGlobalThis#shouldTraverse(NodeTraversal#t,Node#n,Node#parent)", "boolean com.google.javascript.jscomp.CheckGlobalThis#shouldReportThis(Node#n,Node#parent)", "JSDocInfo com.google.javascript.jscomp.CheckGlobalThis#getFunctionJsDocInfo(Node#n)"], "other_methods": ["public boolean shouldTraverse(NodeTraversal t,Node n,Node parent);"], "fields_dict": {"DiagnosticType#GLOBAL_THIS": "static final DiagnosticType GLOBAL_THIS = DiagnosticType.warning(\n      \"JSC_USED_GLOBAL_THIS\",\n      \"dangerous use of the global 'this' object\")", "AbstractCompiler#compiler": "private final AbstractCompiler compiler", "CheckLevel#level": "private final CheckLevel level", "Node#assignLhsChild": "private Node assignLhsChild = null"}, "text": "/*\n * Copyright 2007 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.javascript.jscomp.CheckLevel;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\n/**\n * Checks for certain uses of the {@code this} keyword that are considered\n * unsafe because they are likely to reference the global {@code this} object\n * unintentionally.\n *\n * <p>A use of {@code this} is considered unsafe if it's on the left side of an\n * assignment or a property access, and not inside one of the following:\n * <ol>\n * <li>a prototype method\n * <li>a function annotated with {@code @constructor}\n * <li>a function annotated with {@code @this}.\n * <li>a function where there's no logical place to put a\n *     {@code this} annotation.\n * </ol>\n *\n * <p>Note that this check does not track assignments of {@code this} to\n * variables or objects. The code\n * <pre>\n * function evil() {\n *   var a = this;\n *   a.useful = undefined;\n * }\n * </pre>\n * will not get flagged, even though it is semantically equivalent to\n * <pre>\n * function evil() {\n *   this.useful = undefined;\n * }\n * </pre>\n * which would get flagged.\n *\n*\n*\n */\nfinal class CheckGlobalThis implements Callback {\n\n  static final DiagnosticType GLOBAL_THIS = DiagnosticType.warning(\n      \"JSC_USED_GLOBAL_THIS\",\n      \"dangerous use of the global 'this' object\");\n\n  private final AbstractCompiler compiler;\n  private final CheckLevel level;\n  \n  /**\n   * If {@code assignLhsChild != null}, then the node being traversed is\n   * a descendant of the first child of an ASSIGN node. assignLhsChild's\n   * parent is this ASSIGN node.\n   */\n  private Node assignLhsChild = null;\n\n  CheckGlobalThis(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.level = level;\n  }\n\n  /**\n   * Since this pass reports errors only when a global {@code this} keyword\n   * is encountered, there is no reason to traverse non global contexts.\n   */\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN)) {\n        return false;\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n      \n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (lhs.getType() == Token.GETPROP) {\n          if (lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          String leftName = lhs.getQualifiedName();\n          if (leftName != null && leftName.contains(\".prototype.\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {\n      compiler.report(t.makeError(n, level, GLOBAL_THIS));\n    }\n    if (n == assignLhsChild) {\n      assignLhsChild = null;\n    }\n  }\n\n  private boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n      // Always report a THIS on the left side of an assign.\n      return true;\n    }\n\n    // Also report a THIS with a property access.\n    return parent != null && NodeUtil.isGet(parent);\n  }\n\n  /**\n   * Gets a function's JSDoc information, if it has any. Checks for a few\n   * patterns (ellipses show where JSDoc would be):\n   * <pre>\n   * ... function() {}\n   * ... x = function() {};\n   * var ... x = function() {};\n   * ... var x = function() {};\n   * </pre>\n   */\n  private JSDocInfo getFunctionJsDocInfo(Node n) {\n    JSDocInfo jsDoc = n.getJSDocInfo();\n    Node parent = n.getParent();\n    if (jsDoc == null) {\n      int parentType = parent.getType();\n      if (parentType == Token.NAME || parentType == Token.ASSIGN) {\n        jsDoc = parent.getJSDocInfo();\n        if (jsDoc == null && parentType == Token.NAME) {\n          Node gramps = parent.getParent();\n          if (gramps.getType() == Token.VAR) {\n            jsDoc = gramps.getJSDocInfo();\n          }\n        }\n      }\n    }\n    return jsDoc;\n  }\n}\n"}}
{"bug_id": "Closure_129", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.PrepareAst#process(Node#externs,Node#root)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_129/fixed/src/com/google/javascript/jscomp/PrepareAst.java", "focal_method": "@Override\n  public void process(Node externs, Node root) {\n    if (checkOnly) {\n      normalizeNodeTypes(root);\n    } else {\n      // Don't perform \"PrepareAnnotations\" when doing checks as\n      // they currently aren't valid during sanity checks.  In particular,\n      // they DIRECT_EVAL shouldn't be applied after inlining has been\n      // performed.\n      if (externs != null) {\n        NodeTraversal.traverse(\n            compiler, externs, new PrepareAnnotations());\n      }\n      if (root != null) {\n        NodeTraversal.traverse(\n            compiler, root, new PrepareAnnotations());\n      }\n    }\n  }", "return_type": "void", "assertion_subject_candidates": [], "focal_class": {"name": "PrepareAst", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_129/fixed/src/com/google/javascript/jscomp/PrepareAst.java", "superclass": "", "interface": "implements CompilerPass", "imports": ["import com.google.common.base.Preconditions;", "import com.google.javascript.rhino.IR;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;"], "fields": ["private final AbstractCompiler compiler", "private final boolean checkOnly"], "methods": ["void com.google.javascript.jscomp.PrepareAst#reportChange()", "void com.google.javascript.jscomp.PrepareAst#normalizeNodeTypes(Node#n)", "void com.google.javascript.jscomp.PrepareAst#normalizeBlocks(Node#n)"], "other_methods": [], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "boolean#checkOnly": "private final boolean checkOnly"}, "text": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\n/**\n * Prepare the AST before we do any checks or optimizations on it.\n *\n * This pass must run. It should bring the AST into a consistent state,\n * and add annotations where necessary. It should not make any transformations\n * on the tree that would lose source information, since we need that source\n * information for checks.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass PrepareAst implements CompilerPass {\n\n  private final AbstractCompiler compiler;\n  private final boolean checkOnly;\n\n  PrepareAst(AbstractCompiler compiler) {\n    this(compiler, false);\n  }\n\n  PrepareAst(AbstractCompiler compiler, boolean checkOnly) {\n    this.compiler = compiler;\n    this.checkOnly = checkOnly;\n  }\n\n  private void reportChange() {\n    if (checkOnly) {\n      Preconditions.checkState(false, \"normalizeNodeType constraints violated\");\n    }\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    if (checkOnly) {\n      normalizeNodeTypes(root);\n    } else {\n      // Don't perform \"PrepareAnnotations\" when doing checks as\n      // they currently aren't valid during sanity checks.  In particular,\n      // they DIRECT_EVAL shouldn't be applied after inlining has been\n      // performed.\n      if (externs != null) {\n        NodeTraversal.traverse(\n            compiler, externs, new PrepareAnnotations());\n      }\n      if (root != null) {\n        NodeTraversal.traverse(\n            compiler, root, new PrepareAnnotations());\n      }\n    }\n  }\n\n  /**\n   * Covert EXPR_VOID to EXPR_RESULT to simplify the rest of the code.\n   */\n  private void normalizeNodeTypes(Node n) {\n    normalizeBlocks(n);\n\n    for (Node child = n.getFirstChild();\n         child != null; child = child.getNext()) {\n      // This pass is run during the CompilerTestCase validation, so this\n      // parent pointer check serves as a more general check.\n      Preconditions.checkState(child.getParent() == n);\n\n      normalizeNodeTypes(child);\n    }\n  }\n\n  /**\n   * Add blocks to IF, WHILE, DO, etc.\n   */\n  private void normalizeBlocks(Node n) {\n    if (NodeUtil.isControlStructure(n)\n        && !n.isLabel()\n        && !n.isSwitch()) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (NodeUtil.isControlStructureCodeBlock(n,c) &&\n            !c.isBlock()) {\n          Node newBlock = IR.block().srcref(n);\n          n.replaceChild(c, newBlock);\n          if (!c.isEmpty()) {\n            newBlock.addChildrenToFront(c);\n          } else {\n            newBlock.setWasEmptyNode(true);\n          }\n          c = newBlock;\n          reportChange();\n        }\n      }\n    }\n  }\n\n  /**\n   * Normalize where annotations appear on the AST. Copies\n   * around existing JSDoc annotations as well as internal annotations.\n   */\n  static class PrepareAnnotations\n      implements NodeTraversal.Callback {\n\n    PrepareAnnotations() {\n    }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.isObjectLit()) {\n        normalizeObjectLiteralAnnotations(n);\n      }\n      return true;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.CALL:\n          annotateCalls(n);\n          break;\n\n        case Token.FUNCTION:\n          annotateDispatchers(n, parent);\n          break;\n      }\n    }\n\n    private void normalizeObjectLiteralAnnotations(Node objlit) {\n      Preconditions.checkState(objlit.isObjectLit());\n      for (Node key = objlit.getFirstChild();\n           key != null; key = key.getNext()) {\n        Node value = key.getFirstChild();\n        normalizeObjectLiteralKeyAnnotations(objlit, key, value);\n      }\n    }\n\n    /**\n     * There are two types of calls we are interested in calls without explicit\n     * \"this\" values (what we are call \"free\" calls) and direct call to eval.\n     */\n    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.isCall());\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n\n      // ignore cast nodes.\n      while (first.isCast()) {\n        first = first.getFirstChild();\n      }\n\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (first.isName() &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }\n\n    /**\n     * Translate dispatcher info into the property expected node.\n     */\n    private void annotateDispatchers(Node n, Node parent) {\n      Preconditions.checkState(n.isFunction());\n      if (parent.getJSDocInfo() != null\n          && parent.getJSDocInfo().isJavaDispatch()) {\n        if (parent.isAssign()) {\n          Preconditions.checkState(parent.getLastChild() == n);\n          n.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n      }\n    }\n\n    /**\n     * In the AST that Rhino gives us, it needs to make a distinction\n     * between JsDoc on the object literal node and JsDoc on the object literal\n     * value. For example,\n     * <pre>\n     * var x = {\n     *   / JSDOC /\n     *   a: 'b',\n     *   c: / JSDOC / 'd'\n     * };\n     * </pre>\n     *\n     * But in few narrow cases (in particular, function literals), it's\n     * a lot easier for us if the doc is attached to the value.\n     */\n    private void normalizeObjectLiteralKeyAnnotations(\n        Node objlit, Node key, Node value) {\n      Preconditions.checkState(objlit.isObjectLit());\n      if (key.getJSDocInfo() != null &&\n          value.isFunction()) {\n        value.setJSDocInfo(key.getJSDocInfo());\n      }\n    }\n  }\n}\n"}}
{"bug_id": "Closure_101", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.CommandLineRunner#main(String[]#args)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_101/fixed/src/com/google/javascript/jscomp/CommandLineRunner.java", "focal_method": "public static void main(String[] args) {\n    try {\n      (new CommandLineRunner(args)).run();\n    } catch (CmdLineException e) {\n      System.exit(-1);\n    }\n  }", "return_type": "void", "assertion_subject_candidates": [], "focal_class": {"name": "CommandLineRunner", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_101/fixed/src/com/google/javascript/jscomp/CommandLineRunner.java", "superclass": "extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions>", "interface": "", "imports": ["import com.google.common.collect.Lists;", "import com.google.common.collect.Sets;", "import com.google.common.io.LimitInputStream;", "import org.kohsuke.args4j.CmdLineException;", "import org.kohsuke.args4j.CmdLineParser;", "import org.kohsuke.args4j.Option;", "import org.kohsuke.args4j.OptionDef;", "import org.kohsuke.args4j.spi.OptionHandler;", "import org.kohsuke.args4j.spi.Parameters;", "import org.kohsuke.args4j.spi.Setter;", "import java.io.IOException;", "import java.io.InputStream;", "import java.io.PrintStream;", "import java.util.List;", "import java.util.Set;", "import java.util.logging.Level;", "import java.util.regex.Matcher;", "import java.util.regex.Pattern;", "import java.util.zip.ZipEntry;", "import java.util.zip.ZipInputStream;"], "fields": ["private final Flags flags = new Flags()"], "methods": ["void com.google.javascript.jscomp.CommandLineRunner#initConfigFromFlags(String[]#args,PrintStream#err)", "CompilerOptions com.google.javascript.jscomp.CommandLineRunner#createOptions()", "Compiler com.google.javascript.jscomp.CommandLineRunner#createCompiler()", "List<JSSourceFile> com.google.javascript.jscomp.CommandLineRunner#createExterns()", "List<JSSourceFile> com.google.javascript.jscomp.CommandLineRunner#getDefaultExterns()"], "other_methods": [], "fields_dict": {"Flags#flags": "private final Flags flags = new Flags()"}, "text": "/*\n * Copyright 2009 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.google.common.io.LimitInputStream;\n\nimport org.kohsuke.args4j.CmdLineException;\nimport org.kohsuke.args4j.CmdLineParser;\nimport org.kohsuke.args4j.Option;\nimport org.kohsuke.args4j.OptionDef;\nimport org.kohsuke.args4j.spi.OptionHandler;\nimport org.kohsuke.args4j.spi.Parameters;\nimport org.kohsuke.args4j.spi.Setter;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * CommandLineRunner translates flags into Java API calls on the Compiler.\n *\n * This class may be extended and used to create other Java classes\n * that behave the same as running the Compiler from the command line. If you\n * want to run the compiler in-process in Java, you should look at this class\n * for hints on what API calls to make, but you should not use this class directly.\n *\n * Example:\n * <pre>\n * class MyCommandLineRunner extends CommandLineRunner {\n *   MyCommandLineRunner(String[] args) throws CmdLineException {\n *     super(args);\n *   }\n *\n *   {@code @Override} protected CompilerOptions createOptions() {\n *     CompilerOptions options = super.createOptions();\n *     addMyCrazyCompilerPassThatOutputsAnExtraFile(options);\n *     return options;\n *   }\n *\n *   public static void main(String[] args) {\n *     try {\n *       (new MyCommandLineRunner(args)).run();\n *     } catch (CmdLineException e) {\n *       System.exit(-1);\n *     }\n *   }\n * }\n * </pre>\n * @author bolinfest@google.com (Michael Bolin)\n */\npublic class CommandLineRunner extends\n    AbstractCommandLineRunner<Compiler, CompilerOptions> {\n\n  private static class Flags {\n    @Option(name = \"--print_tree\",\n        handler = BooleanOptionHandler.class,\n        usage = \"Prints out the parse tree and exits\")\n    private boolean print_tree = false;\n\n    @Option(name = \"--compute_phase_ordering\",\n        handler = BooleanOptionHandler.class,\n        usage = \"Runs the compile job many times, then prints out the \" +\n        \"best phase ordering from this run\")\n    private boolean compute_phase_ordering = false;\n\n    @Option(name = \"--print_ast\",\n        handler = BooleanOptionHandler.class,\n        usage = \"Prints a dot file describing the internal abstract syntax\"\n        + \" tree and exits\")\n    private boolean print_ast = false;\n\n    @Option(name = \"--print_pass_graph\",\n        usage = \"Prints a dot file describing the passes that will get run\"\n        + \" and exits\")\n    private boolean print_pass_graph = false;\n\n    @Option(name = \"--jscomp_dev_mode\",\n        usage = \"Turns on extra sanity checks\",\n        aliases = {\"--dev_mode\"})\n    private CompilerOptions.DevMode jscomp_dev_mode =\n        CompilerOptions.DevMode.OFF;\n\n    // TODO(nicksantos): Make the next 2 flags package-private.\n    @Option(name = \"--logging_level\",\n        usage = \"The logging level (standard java.util.logging.Level\"\n        + \" values) for Compiler progress. Does not control errors or\"\n        + \" warnings for the JavaScript code under compilation\")\n    private String logging_level = Level.WARNING.getName();\n\n    @Option(name = \"--externs\",\n        usage = \"The file containing javascript externs. You may specify\"\n        + \" multiple\")\n    private List<String> externs = Lists.newArrayList();\n\n    @Option(name = \"--js\",\n        usage = \"The javascript filename. You may specify multiple\")\n    private List<String> js = Lists.newArrayList();\n\n    @Option(name = \"--js_output_file\",\n        usage = \"Primary output filename. If not specified, output is \" +\n        \"written to stdout\")\n    private String js_output_file = \"\";\n\n    @Option(name = \"--module\",\n        usage = \"A javascript module specification. The format is \"\n        + \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \"\n        + \"unique. Each dep is the name of a module that this module \"\n        + \"depends on. Modules must be listed in dependency order, and js \"\n        + \"source files must be listed in the corresponding order. Where \"\n        + \"--module flags occur in relation to --js flags is unimportant\")\n    private List<String> module = Lists.newArrayList();\n\n    @Option(name = \"--variable_map_input_file\",\n        usage = \"File containing the serialized version of the variable \"\n        + \"renaming map produced by a previous compilation\")\n    private String variable_map_input_file = \"\";\n\n    @Option(name = \"--property_map_input_file\",\n        usage = \"File containing the serialized version of the property \"\n        + \"renaming map produced by a previous compilation\")\n    private String property_map_input_file = \"\";\n\n    @Option(name = \"--variable_map_output_file\",\n        usage = \"File where the serialized version of the variable \"\n        + \"renaming map produced should be saved\")\n    private String variable_map_output_file = \"\";\n\n    @Option(name = \"--create_name_map_files\",\n        handler = BooleanOptionHandler.class,\n        usage = \"If true, variable renaming and property renaming map \"\n        + \"files will be produced as {binary name}_vars_map.out and \"\n        + \"{binary name}_props_map.out. Note that this flag cannot be used \"\n        + \"in conjunction with either variable_map_output_file or \"\n        + \"property_map_output_file\")\n    private boolean create_name_map_files = false;\n\n    @Option(name = \"--property_map_output_file\",\n        usage = \"File where the serialized version of the property \"\n        + \"renaming map produced should be saved\")\n    private String property_map_output_file = \"\";\n\n    @Option(name = \"--third_party\",\n        handler = BooleanOptionHandler.class,\n        usage = \"Check source validity but do not enforce Closure style \"\n        + \"rules and conventions\")\n    private boolean third_party = false;\n\n\n    @Option(name = \"--summary_detail_level\",\n        usage = \"Controls how detailed the compilation summary is. Values:\"\n        + \" 0 (never print summary), 1 (print summary only if there are \"\n        + \"errors or warnings), 2 (print summary if type checking is on, \"\n        + \"see --check_types), 3 (always print summary). The default level \"\n        + \"is 1\")\n    private int summary_detail_level = 1;\n\n    @Option(name = \"--output_wrapper\",\n        usage = \"Interpolate output into this string at the place denoted\"\n        + \" by the marker token %output%. See --output_wrapper_marker\")\n    private String output_wrapper = \"\";\n\n    @Option(name = \"--output_wrapper_marker\",\n        usage = \"Use this token as output marker in the value of\"\n        + \" --output_wrapper\")\n    private String output_wrapper_marker = \"%output%\";\n\n    @Option(name = \"--module_wrapper\",\n        usage = \"An output wrapper for a javascript module (optional). \"\n        + \"The format is <name>:<wrapper>. The module name must correspond \"\n        + \"with a module specified using --module. The wrapper must \"\n        + \"contain %s as the code placeholder\")\n    private List<String> module_wrapper = Lists.newArrayList();\n\n    @Option(name = \"--module_output_path_prefix\",\n        usage = \"Prefix for filenames of compiled js modules. \"\n        + \"<module-name>.js will be appended to this prefix. Directories \"\n        + \"will be created as needed. Use with --module\")\n    private String module_output_path_prefix = \"./\";\n\n    @Option(name = \"--create_source_map\",\n        usage = \"If specified, a source map file mapping the generated \" +\n        \"source files back to the original source file will be \" +\n        \"output to the specified path. The %outname% placeholder will \" +\n        \"expand to the name of the output file that the source map \" +\n        \"corresponds to.\")\n    private String create_source_map = \"\";\n\n    @Option(name = \"--jscomp_error\",\n        usage = \"Make the named class of warnings an error. Options:\" +\n        DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n    private List<String> jscomp_error = Lists.newArrayList();\n\n    @Option(name = \"--jscomp_warning\",\n        usage = \"Make the named class of warnings a normal warning. \" +\n        \"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n    private List<String> jscomp_warning =  Lists.newArrayList();\n\n    @Option(name = \"--jscomp_off\",\n        usage = \"Turn off the named class of warnings. Options:\" +\n        DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n    private List<String> jscomp_off = Lists.newArrayList();\n\n    @Option(name = \"--define\",\n        aliases = {\"--D\", \"-D\"},\n        usage = \"Override the value of a variable annotated @define. \" +\n        \"The format is <name>[=<val>], where <name> is the name of a @define \" +\n        \"variable and <val> is a boolean, number, or a single-quoted string \" +\n        \"that contains no single quotes. If [=<val>] is omitted, \" +\n        \"the variable is marked true\")\n    private List<String> define = Lists.newArrayList();\n\n    @Option(name = \"--charset\",\n        usage = \"Input charset for all files.\")\n    private String charset = \"\";\n\n    @Option(name = \"--compilation_level\",\n        usage = \"Specifies the compilation level to use. Options: \" +\n        \"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\")\n    private CompilationLevel compilation_level =\n        CompilationLevel.SIMPLE_OPTIMIZATIONS;\n\n    @Option(name = \"--warning_level\",\n        usage = \"Specifies the warning level to use. Options: \" +\n        \"QUIET, DEFAULT, VERBOSE\")\n    private WarningLevel warning_level = WarningLevel.DEFAULT;\n\n    @Option(name = \"--use_only_custom_externs\",\n        handler = BooleanOptionHandler.class,\n        usage = \"Specifies whether the default externs should be excluded\")\n    private boolean use_only_custom_externs = false;\n\n    @Option(name = \"--debug\",\n        handler = BooleanOptionHandler.class,\n        usage = \"Enable debugging options\")\n    private boolean debug = false;\n\n    @Option(name = \"--formatting\",\n        usage = \"Specifies which formatting options, if any, should be \"\n        + \"applied to the output JS. Options: \"\n        + \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\")\n    private List<FormattingOption> formatting = Lists.newArrayList();\n\n    @Option(name = \"--process_closure_primitives\",\n        handler = BooleanOptionHandler.class,\n        usage = \"Processes built-ins from the Closure library, such as \"\n        + \"goog.require(), goog.provide(), and goog.exportSymbol()\")\n    private boolean process_closure_primitives = true;\n\n    // Our own option parser to be backwards-compatible.\n    // It needs to be public because of the crazy reflection that args4j does.\n    public static class BooleanOptionHandler extends OptionHandler<Boolean> {\n      private static final Set<String> TRUES =\n          Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\");\n      private static final Set<String> FALSES =\n          Sets.newHashSet(\"false\", \"off\", \"no\", \"0\");\n\n      public BooleanOptionHandler(\n          CmdLineParser parser, OptionDef option,\n          Setter<? super Boolean> setter) {\n        super(parser, option, setter);\n      }\n\n      @Override\n      public int parseArguments(Parameters params) throws CmdLineException {\n        String param = params.getParameter(0);\n        if (param == null) {\n          setter.addValue(true);\n          return 0;\n        } else {\n          String lowerParam = param.toLowerCase();\n          if (TRUES.contains(lowerParam)) {\n            setter.addValue(true);\n          } else if (FALSES.contains(lowerParam)) {\n            setter.addValue(false);\n          } else {\n            throw new CmdLineException(owner,\n               \"Illegal boolean value: \" + lowerParam);\n          }\n          return 1;\n        }\n      }\n\n      @Override\n      public String getDefaultMetaVariable() {\n        return null;\n      }\n    }\n  }\n\n  /**\n   * Set of options that can be used with the --formatting flag.\n   */\n  private static enum FormattingOption {\n    PRETTY_PRINT,\n    PRINT_INPUT_DELIMITER,\n    ;\n\n    private void applyToOptions(CompilerOptions options) {\n      switch (this) {\n        case PRETTY_PRINT:\n          options.prettyPrint = true;\n          break;\n        case PRINT_INPUT_DELIMITER:\n          options.printInputDelimiter = true;\n          break;\n        default:\n          throw new RuntimeException(\"Unknown formatting option: \" + this);\n      }\n    }\n  }\n\n  private final Flags flags = new Flags();\n\n  /**\n   * Create a new command-line runner. You should only need to call\n   * the constructor if you're extending this class. Otherwise, the main\n   * method should instantiate it.\n   */\n  protected CommandLineRunner(String[] args)\n      throws CmdLineException {\n    super();\n    initConfigFromFlags(args, System.err);\n  }\n\n  protected CommandLineRunner(String[] args, PrintStream out, PrintStream err)\n      throws CmdLineException {\n    super(out, err);\n    initConfigFromFlags(args, err);\n  }\n\n  private void initConfigFromFlags(\n      String[] args, PrintStream err)\n      throws CmdLineException {\n    // Args4j has a different format that the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n    for (String arg : args) {\n      Matcher matcher = argPattern.matcher(arg);\n      if (matcher.matches()) {\n        processedArgs.add(matcher.group(1));\n\n        String value = matcher.group(2);\n        Matcher quotesMatcher = quotesPattern.matcher(value);\n        if (quotesMatcher.matches()) {\n          processedArgs.add(quotesMatcher.group(1));\n        } else {\n          processedArgs.add(value);\n        }\n      } else {\n        processedArgs.add(arg);\n      }\n    }\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      parser.printUsage(err);\n      throw e;\n    }\n    getCommandLineConfig()\n        .setPrintTree(flags.print_tree)\n        .setComputePhaseOrdering(flags.compute_phase_ordering)\n        .setPrintAst(flags.print_ast)\n        .setPrintPassGraph(flags.print_pass_graph)\n        .setJscompDevMode(flags.jscomp_dev_mode)\n        .setLoggingLevel(flags.logging_level)\n        .setExterns(flags.externs)\n        .setJs(flags.js)\n        .setJsOutputFile(flags.js_output_file)\n        .setModule(flags.module)\n        .setVariableMapInputFile(flags.variable_map_input_file)\n        .setPropertyMapInputFile(flags.property_map_input_file)\n        .setVariableMapOutputFile(flags.variable_map_output_file)\n        .setCreateNameMapFiles(flags.create_name_map_files)\n        .setPropertyMapOutputFile(flags.property_map_output_file)\n        .setThirdParty(flags.third_party)\n        .setSummaryDetailLevel(flags.summary_detail_level)\n        .setOutputWrapper(flags.output_wrapper)\n        .setOutputWrapperMarker(flags.output_wrapper_marker)\n        .setModuleWrapper(flags.module_wrapper)\n        .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n        .setCreateSourceMap(flags.create_source_map)\n        .setJscompError(flags.jscomp_error)\n        .setJscompWarning(flags.jscomp_warning)\n        .setJscompOff(flags.jscomp_off)\n        .setDefine(flags.define)\n        .setCharset(flags.charset);\n  }\n\n  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.process_closure_primitives;\n    initOptionsFromFlags(options);\n    return options;\n  }\n\n  @Override\n  protected Compiler createCompiler() {\n    return new Compiler(getErrorPrintStream());\n  }\n\n  @Override\n  protected List<JSSourceFile> createExterns() throws FlagUsageException,\n      IOException {\n    List<JSSourceFile> externs = super.createExterns();\n    if (!flags.use_only_custom_externs) {\n      List<JSSourceFile> defaultExterns = getDefaultExterns();\n      defaultExterns.addAll(externs);\n      return defaultExterns;\n    } else {\n      return externs;\n    }\n  }\n\n  /**\n   * @return a mutable list\n   * @throws IOException\n   */\n  private List<JSSourceFile> getDefaultExterns() throws IOException {\n    InputStream input = CommandLineRunner.class.getResourceAsStream(\n        \"/externs.zip\");\n    ZipInputStream zip = new ZipInputStream(input);\n    List<JSSourceFile> externs = Lists.newLinkedList();\n    for (ZipEntry entry = null; (entry = zip.getNextEntry()) != null; ) {\n      LimitInputStream entryStream = new LimitInputStream(zip, entry.getSize());\n      externs.add(JSSourceFile.fromInputStream(entry.getName(), entryStream));\n    }\n    return externs;\n  }\n\n  /**\n   * Runs the Compiler. Exits cleanly in the event of an error.\n   */\n  public static void main(String[] args) {\n    try {\n      (new CommandLineRunner(args)).run();\n    } catch (CmdLineException e) {\n      System.exit(-1);\n    }\n  }\n}\n"}}
{"bug_id": "Closure_115", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.FunctionInjector#setKnownConstants(Set<String>#knownConstants)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_115/fixed/src/com/google/javascript/jscomp/FunctionInjector.java", "focal_method": "public void setKnownConstants(Set<String> knownConstants) {\n    // This is only expected to be set once. The same set should be used\n    // when evaluating call-sites and inlining calls.\n    Preconditions.checkState(this.knownConstants.isEmpty());\n    this.knownConstants = knownConstants;\n  }", "return_type": "void", "assertion_subject_candidates": ["ExpressionDecomposer com.google.javascript.jscomp.FunctionInjector#getDecomposer()"], "focal_class": {"name": "FunctionInjector", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_115/fixed/src/com/google/javascript/jscomp/FunctionInjector.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.base.Predicate;", "import com.google.common.base.Predicates;", "import com.google.common.base.Supplier;", "import com.google.common.collect.Sets;", "import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.Collection;", "import java.util.Map;", "import java.util.Set;"], "fields": ["private final AbstractCompiler compiler", "private final Supplier<String> safeNameIdSupplier", "private final boolean allowDecomposition", "private Set<String> knownConstants = Sets.newHashSet()", "private final boolean assumeStrictThis", "private final boolean assumeMinimumCapture", "private static final int NAME_COST_ESTIMATE = InlineCostEstimator.ESTIMATED_IDENTIFIER_COST", "private static final int COMMA_COST = 1", "private static final int PAREN_COST = 2"], "methods": ["boolean com.google.javascript.jscomp.FunctionInjector#doesFunctionMeetMinimumRequirements(String#fnName,Node#fnNode)", "CanInlineResult com.google.javascript.jscomp.FunctionInjector#canInlineReferenceToFunction(NodeTraversal#t,Node#callNode,Node#fnNode,Set<String>#needAliases,InliningMode#mode,boolean#referencesThis,boolean#containsFunctions)", "boolean com.google.javascript.jscomp.FunctionInjector#isSupportedCallType(Node#callNode)", "Node com.google.javascript.jscomp.FunctionInjector#inline(Node#callNode,String#fnName,Node#fnNode,InliningMode#mode)", "Node com.google.javascript.jscomp.FunctionInjector#inlineReturnValue(Node#callNode,Node#fnNode)", "CallSiteType com.google.javascript.jscomp.FunctionInjector#classifyCallSite(Node#callNode)", "ExpressionDecomposer com.google.javascript.jscomp.FunctionInjector#getDecomposer()", "void com.google.javascript.jscomp.FunctionInjector#maybePrepareCall(Node#callNode)", "Node com.google.javascript.jscomp.FunctionInjector#inlineFunction(Node#callNode,Node#fnNode,String#fnName)", "boolean com.google.javascript.jscomp.FunctionInjector#isDirectCallNodeReplacementPossible(Node#fnNode)", "CanInlineResult com.google.javascript.jscomp.FunctionInjector#canInlineReferenceAsStatementBlock(NodeTraversal#t,Node#callNode,Node#fnNode,Set<String>#namesToAlias)", "boolean com.google.javascript.jscomp.FunctionInjector#callMeetsBlockInliningRequirements(NodeTraversal#t,Node#callNode,Node#fnNode,Set<String>#namesToAlias)", "CanInlineResult com.google.javascript.jscomp.FunctionInjector#canInlineReferenceDirectly(Node#callNode,Node#fnNode)", "boolean com.google.javascript.jscomp.FunctionInjector#inliningLowersCost(JSModule#fnModule,Node#fnNode,Collection<? extends Reference>#refs,Set<String>#namesToAlias,boolean#isRemovable,boolean#referencesThis)", "boolean com.google.javascript.jscomp.FunctionInjector#doesLowerCost(Node#fnNode,int#callCost,int#directInlines,int#costDeltaDirect,int#blockInlines,int#costDeltaBlock,boolean#removable)", "int com.google.javascript.jscomp.FunctionInjector#estimateCallCost(Node#fnNode,boolean#referencesThis)", "int com.google.javascript.jscomp.FunctionInjector#inlineCostDelta(Node#fnNode,Set<String>#namesToAlias,InliningMode#mode)"], "other_methods": [], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "Supplier<String>#safeNameIdSupplier": "private final Supplier<String> safeNameIdSupplier", "boolean#allowDecomposition": "private final boolean allowDecomposition", "Set<String>#knownConstants": "private Set<String> knownConstants = Sets.newHashSet()", "boolean#assumeStrictThis": "private final boolean assumeStrictThis", "boolean#assumeMinimumCapture": "private final boolean assumeMinimumCapture", "int#NAME_COST_ESTIMATE": "private static final int NAME_COST_ESTIMATE = InlineCostEstimator.ESTIMATED_IDENTIFIER_COST", "int#COMMA_COST": "private static final int COMMA_COST = 1", "int#PAREN_COST": "private static final int PAREN_COST = 2"}, "text": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A set of utility functions that replaces CALL with a specified\n * FUNCTION body, replacing and aliasing function parameters as\n * necessary.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionInjector {\n\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n  private final boolean allowDecomposition;\n  private Set<String> knownConstants = Sets.newHashSet();\n  private final boolean assumeStrictThis;\n  private final boolean assumeMinimumCapture;\n\n  /**\n   * @param allowDecomposition Whether an effort should be made to break down\n   * expressions into simpler expressions to allow functions to be injected\n   * where they would otherwise be disallowed.\n   */\n  public FunctionInjector(\n      AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean allowDecomposition,\n      boolean assumeStrictThis,\n      boolean assumeMinimumCapture) {\n    Preconditions.checkNotNull(compiler);\n    Preconditions.checkNotNull(safeNameIdSupplier);\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n    this.allowDecomposition = allowDecomposition;\n    this.assumeStrictThis = assumeStrictThis;\n    this.assumeMinimumCapture = assumeMinimumCapture;\n  }\n\n  /** The type of inlining to perform. */\n  enum InliningMode {\n    /**\n     * Directly replace the call expression. Only functions of meeting\n     * strict preconditions can be inlined.\n     */\n    DIRECT,\n\n    /**\n     * Replaces the call expression with a block of statements. Conditions\n     * on the function are looser in mode, but stricter on the call site.\n     */\n    BLOCK\n  }\n\n  /** Holds a reference to the call node of a function call */\n  static class Reference {\n    final Node callNode;\n    final JSModule module;\n    final InliningMode mode;\n\n    Reference(Node callNode, JSModule module, InliningMode mode){\n      this.callNode = callNode;\n      this.module = module;\n      this.mode = mode;\n    }\n  }\n\n  /**\n   * In order to estimate the cost of lining, we make the assumption that\n   * Identifiers are reduced 2 characters. For the call arguments, the important\n   * thing is that the cost is assumed to be the same in the call and the\n   * function, so the actual length doesn't matter in most cases.\n   */\n  private static final int NAME_COST_ESTIMATE =\n      InlineCostEstimator.ESTIMATED_IDENTIFIER_COST;\n\n  /** The cost of a argument separator (a comma). */\n  private static final int COMMA_COST = 1;\n\n  /** The cost of the parentheses needed to make a call.*/\n  private static final int PAREN_COST = 2;\n\n\n  /**\n   * @param fnName The name of this function. This either the name of the\n   *  variable to which the function is assigned or the name from the FUNCTION\n   *  node.\n   * @param fnNode The FUNCTION node of the function to inspect.\n   * @return Whether the function node meets the minimum requirements for\n   * inlining.\n   */\n  boolean doesFunctionMeetMinimumRequirements(\n      final String fnName, Node fnNode) {\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Basic restrictions on functions that can be inlined:\n    // 0) The function is inlinable by convention\n    // 1) It contains a reference to itself.\n    // 2) It uses its parameters indirectly using \"arguments\" (it isn't\n    //    handled yet.\n    // 3) It references \"eval\". Inline a function containing eval can have\n    //    large performance implications.\n\n    if (!compiler.getCodingConvention().isInlinableFunction(fnNode)) {\n      return false;\n    }\n\n    final String fnRecursionName = fnNode.getFirstChild().getString();\n    Preconditions.checkState(fnRecursionName != null);\n\n    // If the function references \"arguments\" directly in the function\n    boolean referencesArguments = NodeUtil.isNameReferenced(\n        block, \"arguments\", NodeUtil.MATCH_NOT_FUNCTION);\n\n    // or it references \"eval\" or one of its names anywhere.\n    Predicate<Node> p = new Predicate<Node>(){\n      @Override\n      public boolean apply(Node n) {\n        if (n.isName()) {\n          return n.getString().equals(\"eval\")\n            || (!fnName.isEmpty()\n                && n.getString().equals(fnName))\n            || (!fnRecursionName.isEmpty()\n                && n.getString().equals(fnRecursionName));\n        }\n        return false;\n      }\n    };\n\n    return !referencesArguments\n        && !NodeUtil.has(block, p, Predicates.<Node>alwaysTrue());\n  }\n\n  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n        // TODO(johnlenz): Allow inlining into any scope without local names or\n        // inner functions.\n        return CanInlineResult.NO;\n      } else if (NodeUtil.isWithinLoop(callNode)) {\n        // An inner closure maybe relying on a local value holding a value for a\n        // single iteration through a loop.\n        return CanInlineResult.NO;\n      }\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }\n\n  /**\n   * Only \".call\" calls and direct calls to functions are supported.\n   * @param callNode The call evaluate.\n   * @return Whether the call is of a type that is supported.\n   */\n  private boolean isSupportedCallType(Node callNode) {\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        if (!assumeStrictThis) {\n          Node thisValue = callNode.getFirstChild().getNext();\n          if (thisValue == null || !thisValue.isThis()) {\n            return false;\n          }\n        }\n      } else if (NodeUtil.isFunctionObjectApply(callNode)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Inline a function into the call site.\n   */\n  Node inline(\n      Node callNode, String fnName, Node fnNode, InliningMode mode) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    if (mode == InliningMode.DIRECT) {\n      return inlineReturnValue(callNode, fnNode);\n    } else {\n      return inlineFunction(callNode, fnNode, fnName);\n    }\n  }\n\n  /**\n   * Inline a function that fulfills the requirements of\n   * canInlineReferenceDirectly into the call site, replacing only the CALL\n   * node.\n   */\n  private Node inlineReturnValue(Node callNode, Node fnNode) {\n    Node block = fnNode.getLastChild();\n    Node callParentNode = callNode.getParent();\n\n    // NOTE: As the normalize pass guarantees globals aren't being\n    // shadowed and an expression can't introduce new names, there is\n    // no need to check for conflicts.\n\n    // Create an argName -> expression map, checking for side effects.\n    Map<String, Node> argMap =\n        FunctionArgumentInjector.getFunctionCallParameterMap(\n            fnNode, callNode, this.safeNameIdSupplier);\n\n    Node newExpression;\n    if (!block.hasChildren()) {\n      Node srcLocation = block;\n      newExpression = NodeUtil.newUndefinedNode(srcLocation);\n    } else {\n      Node returnNode = block.getFirstChild();\n      Preconditions.checkArgument(returnNode.isReturn());\n\n      // Clone the return node first.\n      Node safeReturnNode = returnNode.cloneTree();\n      Node inlineResult = FunctionArgumentInjector.inject(\n          null, safeReturnNode, null, argMap);\n      Preconditions.checkArgument(safeReturnNode == inlineResult);\n      newExpression = safeReturnNode.removeFirstChild();\n    }\n\n    callParentNode.replaceChild(callNode, newExpression);\n    return newExpression;\n  }\n\n  /**\n   * Supported call site types.\n   */\n  private enum CallSiteType {\n\n    /**\n     * Used for a call site for which there does not exist a method\n     * to inline it.\n     */\n    UNSUPPORTED() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        throw new IllegalStateException(\"unexpected\");\n      }\n    },\n\n    /**\n     * A call as a statement. For example: \"foo();\".\n     *   EXPR_RESULT\n     *     CALL\n     */\n    SIMPLE_CALL() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        // Nothing to do.\n      }\n    },\n\n    /**\n     * An assignment, where the result of the call is assigned to a simple\n     * name. For example: \"a = foo();\".\n     *   EXPR_RESULT\n     *     NAME A\n     *     CALL\n     *       FOO\n     */\n    SIMPLE_ASSIGNMENT() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        // Nothing to do.\n      }\n    },\n    /**\n     * An var declaration and initialization, where the result of the call is\n     * assigned to the declared name\n     * name. For example: \"a = foo();\".\n     *   VAR\n     *     NAME A\n     *       CALL\n     *         FOO\n     */\n    VAR_DECL_SIMPLE_ASSIGNMENT() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        // Nothing to do.\n      }\n    },\n    /**\n     * An arbitrary expression, the root of which is a EXPR_RESULT, IF,\n     * RETURN, SWITCH or VAR.  The call must be the first side-effect in\n     * the expression.\n     *\n     * Examples include:\n     *   \"if (foo()) {...\"\n     *   \"return foo();\"\n     *   \"var a = 1 + foo();\"\n     *   \"a = 1 + foo()\"\n     *   \"foo() ? 1:0\"\n     *   \"foo() && x\"\n     */\n    EXPRESSION() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        injector.getDecomposer().moveExpression(callNode);\n\n        // Reclassify after move\n        CallSiteType callSiteType = injector.classifyCallSite(callNode);\n        Preconditions.checkState(this != callSiteType);\n        callSiteType.prepare(injector, callNode);\n      }\n    },\n\n    /**\n     * An arbitrary expression, the root of which is a EXPR_RESULT, IF,\n     * RETURN, SWITCH or VAR.  Where the call is not the first side-effect in\n     * the expression.\n     */\n    DECOMPOSABLE_EXPRESSION() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        injector.getDecomposer().maybeExposeExpression(callNode);\n\n        // Reclassify after decomposition\n        CallSiteType callSiteType = injector.classifyCallSite(callNode);\n        Preconditions.checkState(this != callSiteType);\n        callSiteType.prepare(injector, callNode);\n      }\n    };\n\n    public abstract void prepare(FunctionInjector injector, Node callNode);\n  }\n\n  /**\n   * Determine which, if any, of the supported types the call site is.\n   */\n  private CallSiteType classifyCallSite(Node callNode) {\n    Node parent = callNode.getParent();\n    Node grandParent = parent.getParent();\n\n    // Verify the call site:\n    if (NodeUtil.isExprCall(parent)) {\n      // This is a simple call?  Example: \"foo();\".\n      return CallSiteType.SIMPLE_CALL;\n    } else if (NodeUtil.isExprAssign(grandParent)\n        && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent)\n        && parent.getFirstChild().isName()\n        && !NodeUtil.isConstantName(parent.getFirstChild())) {\n      // This is a simple assignment.  Example: \"x = foo();\"\n      return CallSiteType.SIMPLE_ASSIGNMENT;\n    } else if (parent.isName()\n        && !NodeUtil.isConstantName(parent)\n        && grandParent.isVar()\n        && grandParent.hasOneChild()) {\n      // This is a var declaration.  Example: \"var x = foo();\"\n      // TODO(johnlenz): Should we be checking for constants on the\n      // left-hand-side of the assignments and handling them as EXPRESSION?\n      return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;\n    } else {\n      Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode);\n      if (expressionRoot != null) {\n        ExpressionDecomposer decomposer = new ExpressionDecomposer(\n            compiler, safeNameIdSupplier, knownConstants);\n        DecompositionType type = decomposer.canExposeExpression(\n            callNode);\n        if (type == DecompositionType.MOVABLE) {\n          return CallSiteType.EXPRESSION;\n        } else if (type == DecompositionType.DECOMPOSABLE) {\n          return CallSiteType.DECOMPOSABLE_EXPRESSION;\n        } else {\n          Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE);\n        }\n      }\n    }\n\n    return CallSiteType.UNSUPPORTED;\n  }\n\n  private ExpressionDecomposer getDecomposer() {\n    return new ExpressionDecomposer(\n        compiler, safeNameIdSupplier, knownConstants);\n  }\n\n  /**\n   * If required, rewrite the statement containing the call expression.\n   * @see ExpressionDecomposer#canExposeExpression\n   */\n  void maybePrepareCall(Node callNode) {\n    CallSiteType callSiteType = classifyCallSite(callNode);\n    callSiteType.prepare(this, callNode);\n  }\n\n  /**\n   * Inline a function which fulfills the requirements of\n   * canInlineReferenceAsStatementBlock into the call site, replacing the\n   * parent expression.\n   */\n  private Node inlineFunction(\n      Node callNode, Node fnNode, String fnName) {\n    Node parent = callNode.getParent();\n    Node grandParent = parent.getParent();\n\n    // TODO(johnlenz): Consider storing the callSite classification in the\n    // reference object and passing it in here.\n    CallSiteType callSiteType = classifyCallSite(callNode);\n    Preconditions.checkArgument(callSiteType != CallSiteType.UNSUPPORTED);\n\n    boolean isCallInLoop = NodeUtil.isWithinLoop(callNode);\n\n    // Store the name for the result. This will be used to\n    // replace \"return expr\" statements with \"resultName = expr\"\n    // to replace\n    String resultName = null;\n    boolean needsDefaultReturnResult = true;\n    switch (callSiteType) {\n      case SIMPLE_ASSIGNMENT:\n        resultName = parent.getFirstChild().getString();\n        break;\n\n      case VAR_DECL_SIMPLE_ASSIGNMENT:\n        resultName = parent.getString();\n        break;\n\n      case SIMPLE_CALL:\n        resultName = null;  // \"foo()\" doesn't need a result.\n        needsDefaultReturnResult = false;\n        break;\n\n      case EXPRESSION:\n        throw new IllegalStateException(\n            \"Movable expressions must be moved before inlining.\");\n\n      case DECOMPOSABLE_EXPRESSION:\n        throw new IllegalStateException(\n            \"Decomposable expressions must be decomposed before inlining.\");\n\n      default:\n        throw new IllegalStateException(\"Unexpected call site type.\");\n    }\n\n    FunctionToBlockMutator mutator = new FunctionToBlockMutator(\n        compiler, this.safeNameIdSupplier);\n\n    Node newBlock = mutator.mutate(\n        fnName, fnNode, callNode, resultName,\n        needsDefaultReturnResult, isCallInLoop);\n\n    // TODO(nicksantos): Create a common mutation function that\n    // can replace either a VAR name assignment, assignment expression or\n    // a EXPR_RESULT.\n    Node greatGrandParent = grandParent.getParent();\n    switch (callSiteType) {\n      case VAR_DECL_SIMPLE_ASSIGNMENT:\n        // Remove the call from the name node.\n        parent.removeChild(parent.getFirstChild());\n        Preconditions.checkState(parent.getFirstChild() == null);\n        // Add the call, after the VAR.\n        greatGrandParent.addChildAfter(newBlock, grandParent);\n        break;\n\n      case SIMPLE_ASSIGNMENT:\n        // The assignment is now part of the inline function so\n        // replace it completely.\n        Preconditions.checkState(grandParent.isExprResult());\n        greatGrandParent.replaceChild(grandParent, newBlock);\n        break;\n\n      case SIMPLE_CALL:\n        // If nothing is looking at the result just replace the call.\n        Preconditions.checkState(parent.isExprResult());\n        grandParent.replaceChild(parent, newBlock);\n        break;\n\n      default:\n        throw new IllegalStateException(\"Unexpected call site type.\");\n    }\n\n    return newBlock;\n  }\n\n  /**\n   * Checks if the given function matches the criteria for an inlinable\n   * function, and if so, adds it to our set of inlinable functions.\n   */\n  boolean isDirectCallNodeReplacementPossible(Node fnNode) {\n    // Only inline single-statement functions\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Check if this function is suitable for direct replacement of a CALL node:\n    // a function that consists of single return that returns an expression.\n    if (!block.hasChildren()) {\n      // special case empty functions.\n      return true;\n    } else if (block.hasOneChild()) {\n      // Only inline functions that return something.\n      if (block.getFirstChild().isReturn()\n          && block.getFirstChild().getFirstChild() != null) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  enum CanInlineResult {\n    YES,\n    AFTER_PREPARATION,\n    NO\n  }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * - It must be a simple call, or assignment, or var initialization.\n   * <pre>\n   *    f();\n   *    a = foo();\n   *    var a = foo();\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceAsStatementBlock(\n      NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias) {\n    CallSiteType callSiteType = classifyCallSite(callNode);\n    if (callSiteType == CallSiteType.UNSUPPORTED) {\n      return CanInlineResult.NO;\n    }\n\n    if (!allowDecomposition\n        && (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION\n            || callSiteType == CallSiteType.EXPRESSION)) {\n      return CanInlineResult.NO;\n    }\n\n    if (!callMeetsBlockInliningRequirements(\n            t, callNode, fnNode, namesToAlias)) {\n      return CanInlineResult.NO;\n    }\n\n    if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION\n        || callSiteType == CallSiteType.EXPRESSION) {\n      return CanInlineResult.AFTER_PREPARATION;\n    } else {\n      return CanInlineResult.YES;\n    }\n  }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * - Don't inline if the calling function contains an inner function and\n   * inlining would introduce new globals.\n   */\n  private boolean callMeetsBlockInliningRequirements(\n      NodeTraversal t, Node callNode, final Node fnNode,\n      Set<String> namesToAlias) {\n    final boolean assumeMinimumCapture = this.assumeMinimumCapture;\n\n    // Note: functions that contain function definitions are filtered out\n    // in isCandidateFunction.\n\n    // TODO(johnlenz): Determining if the called function contains VARs\n    // or if the caller contains inner functions accounts for 20% of the\n    // run-time cost of this pass.\n\n    // Don't inline functions with var declarations into a scope with inner\n    // functions as the new vars would leak into the inner function and\n    // cause memory leaks.\n    boolean fnContainsVars = NodeUtil.has(\n        NodeUtil.getFunctionBody(fnNode),\n        new NodeUtil.MatchDeclaration(),\n        new NodeUtil.MatchShallowStatement());\n    boolean forbidTemps = false;\n    if (!t.inGlobalScope()) {\n      Node fnCaller = t.getScopeRoot();\n      Node fnCallerBody = fnCaller.getLastChild();\n\n      // Don't allow any new vars into a scope that contains eval or one\n      // that contains functions (excluding the function being inlined).\n      Predicate<Node> match = new Predicate<Node>(){\n        @Override\n        public boolean apply(Node n) {\n          if (n.isName()) {\n            return n.getString().equals(\"eval\");\n          }\n          if (!assumeMinimumCapture && n.isFunction()) {\n            return n != fnNode;\n          }\n          return false;\n        }\n      };\n      forbidTemps = NodeUtil.has(fnCallerBody,\n          match, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n\n    if (fnContainsVars && forbidTemps) {\n      return false;\n    }\n\n    // If the caller contains functions or evals, verify we aren't adding any\n    // additional VAR declarations because aliasing is needed.\n    if (forbidTemps) {\n      Map<String, Node> args =\n          FunctionArgumentInjector.getFunctionCallParameterMap(\n              fnNode, callNode, this.safeNameIdSupplier);\n      boolean hasArgs = !args.isEmpty();\n      if (hasArgs) {\n        // Limit the inlining\n        Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias);\n        FunctionArgumentInjector.maybeAddTempsForCallArguments(\n            fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n        if (!allNamesToAlias.isEmpty()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }\n\n  /**\n   * Determine if inlining the function is likely to reduce the code size.\n   * @param namesToAlias\n   */\n  boolean inliningLowersCost(\n      JSModule fnModule, Node fnNode, Collection<? extends Reference> refs,\n      Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {\n    int referenceCount = refs.size();\n    if (referenceCount == 0) {\n      return true;\n    }\n\n    int referencesUsingBlockInlining = 0;\n\n    boolean checkModules = isRemovable && fnModule != null;\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n\n    for (Reference ref : refs) {\n      if (ref.mode == InliningMode.BLOCK) {\n        referencesUsingBlockInlining++;\n      }\n\n      // Check if any of the references cross the module boundaries.\n      if (checkModules && ref.module != null) {\n        if (ref.module != fnModule &&\n            !moduleGraph.dependsOn(ref.module, fnModule)) {\n          // Calculate the cost as if the function were non-removable,\n          // if it still lowers the cost inline it.\n          isRemovable = false;\n          checkModules = false;  // no need to check additional modules.\n        }\n      }\n    }\n\n    int referencesUsingDirectInlining = referenceCount -\n        referencesUsingBlockInlining;\n\n    // Don't bother calculating the cost of function for simple functions where\n    // possible.\n    // However, when inlining a complex function, even a single reference may be\n    // larger than the original function if there are many returns (resulting\n    // in additional assignments) or many parameters that need to be aliased\n    // so use the cost estimating.\n    if (referenceCount == 1 && isRemovable &&\n        referencesUsingDirectInlining == 1) {\n      return true;\n    }\n\n    int callCost = estimateCallCost(fnNode, referencesThis);\n    int overallCallCost = callCost * referenceCount;\n\n    int costDeltaDirect = inlineCostDelta(\n        fnNode, namesToAlias, InliningMode.DIRECT);\n    int costDeltaBlock = inlineCostDelta(\n        fnNode, namesToAlias, InliningMode.BLOCK);\n\n    return doesLowerCost(fnNode, overallCallCost,\n        referencesUsingDirectInlining, costDeltaDirect,\n        referencesUsingBlockInlining, costDeltaBlock,\n        isRemovable);\n  }\n\n  /**\n   * @return Whether inlining will lower cost.\n   */\n  private boolean doesLowerCost(\n      Node fnNode, int callCost,\n      int directInlines, int costDeltaDirect,\n      int blockInlines, int costDeltaBlock,\n      boolean removable) {\n\n    // Determine the threshold value for this inequality:\n    //     inline_cost < call_cost\n    // But solve it for the function declaration size so the size of it\n    // is only calculated once and terminated early if possible.\n\n    int fnInstanceCount = directInlines + blockInlines - (removable ? 1 : 0);\n    // Prevent division by zero.\n    if (fnInstanceCount == 0) {\n      // Special case single reference function that are being block inlined:\n      // If the cost of the inline is greater than the function definition size,\n      // don't inline.\n      if (blockInlines > 0 && costDeltaBlock > 0) {\n        return false;\n      }\n      return true;\n    }\n\n    int costDelta = (directInlines * costDeltaDirect) +\n        (blockInlines * costDeltaBlock);\n    int threshold = (callCost - costDelta) / fnInstanceCount;\n\n    return InlineCostEstimator.getCost(fnNode, threshold + 1) <= threshold;\n  }\n\n  /**\n   * Gets an estimate of the cost in characters of making the function call:\n   * the sum of the identifiers and the separators.\n   * @param referencesThis\n   */\n  private static int estimateCallCost(Node fnNode, boolean referencesThis) {\n    Node argsNode = NodeUtil.getFunctionParameters(fnNode);\n    int numArgs = argsNode.getChildCount();\n\n    int callCost = NAME_COST_ESTIMATE + PAREN_COST;\n    if (numArgs > 0) {\n      callCost += (numArgs * NAME_COST_ESTIMATE) + ((numArgs - 1) * COMMA_COST);\n    }\n\n    if (referencesThis) {\n      // TODO(johnlenz): Update this if we start supporting inlining\n      // other functions that reference this.\n      // The only functions that reference this that are currently inlined\n      // are those that are called via \".call\" with an explicit \"this\".\n      callCost += 5 + 5;  // \".call\" + \"this,\"\n    }\n\n    return callCost;\n  }\n\n  /**\n   * @return The difference between the function definition cost and\n   *     inline cost.\n   */\n  private static int inlineCostDelta(\n      Node fnNode, Set<String> namesToAlias, InliningMode mode) {\n    // The part of the function that is never inlined:\n    //    \"function xx(xx,xx){}\" (15 + (param count * 3) -1;\n    int paramCount = NodeUtil.getFunctionParameters(fnNode).getChildCount();\n    int commaCount = (paramCount > 1) ? paramCount - 1 : 0;\n    int costDeltaFunctionOverhead = 15 + commaCount +\n        (paramCount * InlineCostEstimator.ESTIMATED_IDENTIFIER_COST);\n\n    Node block = fnNode.getLastChild();\n    if (!block.hasChildren()) {\n      // Assume the inline cost is zero for empty functions.\n      return -costDeltaFunctionOverhead;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      // The part of the function that is inlined using direct inlining:\n      //    \"return \" (7)\n      return -(costDeltaFunctionOverhead + 7);\n    } else {\n      int aliasCount = namesToAlias.size();\n\n      // Originally, we estimated purely base on the function code size, relying\n      // on later optimizations. But that did not produce good results, so here\n      // we try to estimate the something closer to the actual inlined coded.\n\n      // NOTE 1: Result overhead is only if there is an assignment, but\n      // getting that information would require some refactoring.\n      // NOTE 2: The aliasing overhead is currently an under-estimate,\n      // as some parameters are aliased because of the parameters used.\n      // Perhaps we should just assume all parameters will be aliased?\n      final int inlineBlockOverhead = 4; // \"X:{}\"\n      final int perReturnOverhead = 2;   // \"return\" --> \"break X\"\n      final int perReturnResultOverhead = 3; // \"XX=\"\n      final int perAliasOverhead = 3; // \"XX=\"\n\n      // TODO(johnlenz): Counting the number of returns is relatively expensive\n      //   this information should be determined during the traversal and\n      //   cached.\n      int returnCount = NodeUtil.getNodeTypeReferenceCount(\n          block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n      int resultCount = (returnCount > 0) ? returnCount - 1 : 0;\n      int baseOverhead = (returnCount > 0) ? inlineBlockOverhead : 0;\n\n      int overhead = baseOverhead\n          + returnCount * perReturnOverhead\n          + resultCount * perReturnResultOverhead\n          + aliasCount * perAliasOverhead;\n\n      return (overhead - costDeltaFunctionOverhead);\n    }\n  }\n\n  /**\n   * Store the names of known constants to be used when classifying call-sites\n   * in expressions.\n   */\n  public void setKnownConstants(Set<String> knownConstants) {\n    // This is only expected to be set once. The same set should be used\n    // when evaluating call-sites and inlining calls.\n    Preconditions.checkState(this.knownConstants.isEmpty());\n    this.knownConstants = knownConstants;\n  }\n}\n"}}
{"bug_id": "Closure_14", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.ControlFlowAnalysis#process(Node#externs,Node#root)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_14/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "focal_method": "@Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.isFunction()) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }", "return_type": "void", "assertion_subject_candidates": ["ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()"], "focal_class": {"name": "ControlFlowAnalysis", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_14/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "superclass": "", "interface": "implements Callback, CompilerPass", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.collect.HashMultimap;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Multimap;", "import com.google.javascript.jscomp.ControlFlowGraph.Branch;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.ArrayDeque;", "import java.util.Comparator;", "import java.util.Deque;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.PriorityQueue;"], "fields": ["private final AbstractCompiler compiler", "private ControlFlowGraph<Node> cfg", "private Map<Node, Integer> astPosition", "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "private int astPositionCounter", "private int priorityCounter", "private final boolean shouldTraverseFunctions", "private final boolean edgeAnnotations", "private Node root", "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"], "methods": ["ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()", "void com.google.javascript.jscomp.ControlFlowAnalysis#prioritizeFromEntryNode(DiGraphNode<Node, Branch>#entry)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#shouldTraverse(NodeTraversal#nodeTraversal,Node#n,Node#parent)", "void com.google.javascript.jscomp.ControlFlowAnalysis#visit(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleIf(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWhile(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDo(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFor(Node#forNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleSwitch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCase(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDefault(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWith(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmtList(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFunction(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleExpr(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleThrow(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleTry(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCatch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleBreak(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleContinue(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleReturn(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmt(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#node,ControlFlowAnalysis#cfa)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#fromNode,Node#node,ControlFlowAnalysis#cfa)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFallThrough(Node#n)", "void com.google.javascript.jscomp.ControlFlowAnalysis#createEdge(Node#fromNode,ControlFlowGraph.Branch#branch,Node#toNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#connectToPossibleExceptionHandler(Node#cfgNode,Node#target)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getNextSiblingOfType(Node#first,#int ... types)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakTarget(Node#target,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueTarget(Node#target,Node#parent,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#matchLabel(Node#target,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#mayThrowException(Node#n)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakStructure(Node#n,boolean#labeled)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueStructure(Node#n)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getExceptionHandler(Node#n)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getCatchHandlerForBlock(Node#block)"], "other_methods": ["@Override\n  public boolean shouldTraverse(NodeTraversal nodeTraversal,Node n,Node parent);", "@Override\n  public void visit(NodeTraversal t,Node n,Node parent);", "public static boolean isBreakTarget(Node target,String label);", "public static boolean mayThrowException(Node n);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "ControlFlowGraph<Node>#cfg": "private ControlFlowGraph<Node> cfg", "Map<Node, Integer>#astPosition": "private Map<Node, Integer> astPosition", "Map<DiGraphNode<Node, Branch>, Integer>#nodePriorities": "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "Comparator<DiGraphNode<Node, Branch>>#priorityComparator": "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "int#astPositionCounter": "private int astPositionCounter", "int#priorityCounter": "private int priorityCounter", "boolean#shouldTraverseFunctions": "private final boolean shouldTraverseFunctions", "boolean#edgeAnnotations": "private final boolean edgeAnnotations", "Node#root": "private Node root", "Deque<Node>#exceptionHandler": "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "Multimap<Node, Node>#finallyMap": "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"}, "text": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.ArrayDeque;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\n/**\n * This is a compiler pass that computes a control flow graph.\n *\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n\n  /**\n   * Based roughly on the first few pages of\n   *\n   * \"Declarative Intraprocedural Flow Analysis of Java Source Code by\n   * Nilsson-Nyman, Hedin, Magnusson & Ekman\",\n   *\n   * this pass computes the control flow graph from the AST. However, a full\n   * attribute grammar is not necessary. We will compute the flow edges with a\n   * single post order traversal. The \"follow()\" of a given node will be\n   * computed recursively in a demand driven fashion.\n   *\n   * As of this moment, we are not performing any inter-procedural analysis\n   * within our framework.\n   */\n\n  private final AbstractCompiler compiler;\n\n  private ControlFlowGraph<Node> cfg;\n\n  private Map<Node, Integer> astPosition;\n\n  // TODO(nicksantos): should these be node annotations?\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n\n  // We order CFG nodes by by looking at the AST positions.\n  // CFG nodes that come first lexically should be visited first, because\n  // they will often be executed first in the source program.\n  private final Comparator<DiGraphNode<Node, Branch>> priorityComparator =\n      new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  };\n\n  private int astPositionCounter;\n  private int priorityCounter;\n\n  private final boolean shouldTraverseFunctions;\n  private final boolean edgeAnnotations;\n\n  // We need to store where we started, in case we aren't doing a flow analysis\n  // for the whole scope. This happens, for example, when running type inference\n  // on only the externs.\n  private Node root;\n\n  /*\n   * This stack captures the structure of nested TRY blocks. The top of the\n   * stack is the inner most TRY block. A FUNCTION node in this stack implies\n   * that the handler is determined by the caller of the function at runtime.\n   */\n  private final Deque<Node> exceptionHandler = new ArrayDeque<Node>();\n\n  /*\n   * This map is used to handle the follow of FINALLY. For example:\n   *\n   * while(x) {\n   *  try {\n   *    try {\n   *      break;\n   *    } catch (a) {\n   *    } finally {\n   *      foo();\n   *    }\n   *    fooFollow();\n   *  } catch (b) {\n   *  } finally {\n   *    bar();\n   *  }\n   *  barFollow();\n   * }\n   * END();\n   *\n   * In this case finallyMap will contain a map from:\n   *    first FINALLY -> bar()\n   *    second FINALLY -> END()\n   *\n   * When we are connecting foo() and bar() to to their respective follow, we\n   * must also look up this map and connect:\n   *   foo() -> bar()\n   *   bar() -> END\n   */\n  private final Multimap<Node, Node> finallyMap = HashMultimap.create();\n\n  /**\n   * Constructor.\n   *\n   * @param compiler Compiler instance.\n   * @param shouldTraverseFunctions Whether functions should be traversed (true\n   *    by default).\n   * @param edgeAnnotations Whether to allow edge annotations. By default,\n   *    only node annotations are allowed.\n   */\n  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n    this.edgeAnnotations = edgeAnnotations;\n  }\n\n  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.isFunction()) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }\n\n  /**\n   * Given an entry node, find all the nodes reachable from that node\n   * and prioritize them.\n   */\n  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }\n\n  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT_CASE:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }\n\n  private void handleIf(Node node) {\n    Node thenBlock = node.getFirstChild().getNext();\n    Node elseBlock = thenBlock.getNext();\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));\n\n    if (elseBlock == null) {\n      createEdge(node, Branch.ON_FALSE,\n          computeFollowNode(node, this)); // not taken branch\n    } else {\n      createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n    }\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleWhile(Node node) {\n    // Control goes to the first statement if the condition evaluates to true.\n    createEdge(node, Branch.ON_TRUE,\n        computeFallThrough(node.getFirstChild().getNext()));\n\n    // Control goes to the follow() if the condition evaluates to false.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleDo(Node node) {\n    // The first edge can be the initial iteration as well as the iterations\n    // after.\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild()));\n    // The edge that leaves the do loop if the condition fails.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleFor(Node forNode) {\n    if (forNode.getChildCount() == 4) {\n      // We have for (init; cond; iter) { body }\n      Node init = forNode.getFirstChild();\n      Node cond = init.getNext();\n      Node iter = cond.getNext();\n      Node body = iter.getNext();\n      // After initialization, we transfer to the FOR which is in charge of\n      // checking the condition (for the first time).\n      createEdge(init, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      // The end of the body will have a unconditional branch to our iter\n      // (handled by calling computeFollowNode of the last instruction of the\n      // body. Our iter will jump to the forNode again to another condition\n      // check.\n      createEdge(iter, Branch.UNCOND, forNode);\n      connectToPossibleExceptionHandler(init, init);\n      connectToPossibleExceptionHandler(forNode, cond);\n      connectToPossibleExceptionHandler(iter, iter);\n    } else {\n      // We have for (item in collection) { body }\n      Node item = forNode.getFirstChild();\n      Node collection = item.getNext();\n      Node body = collection.getNext();\n      // The collection behaves like init.\n      createEdge(collection, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      connectToPossibleExceptionHandler(forNode, collection);\n    }\n  }\n\n  private void handleSwitch(Node node) {\n    // Transfer to the first non-DEFAULT CASE. if there are none, transfer\n    // to the DEFAULT or the EMPTY node.\n    Node next = getNextSiblingOfType(\n        node.getFirstChild().getNext(), Token.CASE, Token.EMPTY);\n    if (next != null) { // Has at least one CASE or EMPTY\n      createEdge(node, Branch.UNCOND, next);\n    } else { // Has no CASE but possibly a DEFAULT\n      if (node.getFirstChild().getNext() != null) {\n        createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());\n      } else { // No CASE, no DEFAULT\n        createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleCase(Node node) {\n    // Case is a bit tricky....First it goes into the body if condition is true.\n    createEdge(node, Branch.ON_TRUE,\n        node.getFirstChild().getNext());\n    // Look for the next CASE, skipping over DEFAULT.\n    Node next = getNextSiblingOfType(node.getNext(), Token.CASE);\n    if (next != null) { // Found a CASE\n      Preconditions.checkState(next.isCase());\n      createEdge(node, Branch.ON_FALSE, next);\n    } else { // No more CASE found, go back and search for a DEFAULT.\n      Node parent = node.getParent();\n      Node deflt = getNextSiblingOfType(\n        parent.getFirstChild().getNext(), Token.DEFAULT_CASE);\n      if (deflt != null) { // Has a DEFAULT\n        createEdge(node, Branch.ON_FALSE, deflt);\n      } else { // No DEFAULT found, go to the follow of the SWITCH.\n        createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleDefault(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleWith(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.isBlock() && parent != null &&\n        parent.isTry() &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.isFunction()) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT_CASE:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.isBlock() && node.isSyntheticBlock()) {\n            createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n          }\n          break;\n      }\n    }\n  }\n\n  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }\n\n  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleThrow(Node node) {\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleTry(Node node) {\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleCatch(Node node) {\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n  }\n\n  private void handleBreak(Node node) {\n    String label = null;\n    // See if it is a break with label.\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n    Node parent = node.getParent();\n    /*\n     * Continuously look up the ancestor tree for the BREAK target or the target\n     * with the corresponding label and connect to it. If along the path we\n     * discover a FINALLY, we will connect the BREAK to that FINALLY. From then\n     * on, we will just record the control flow changes in the finallyMap. This\n     * is due to the fact that we need to connect any node that leaves its own\n     * FINALLY block to the outer FINALLY or the BREAK's target but those nodes\n     * are not known yet due to the way we traverse the nodes.\n     */\n    for (cur = node, lastJump = node;\n        !isBreakTarget(cur, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, computeFallThrough(\n              cur.getLastChild()));\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      if (parent == null) {\n        if (compiler.isIdeMode()) {\n          // In IDE mode, we expect that the data flow graph may\n          // not be well-formed.\n          return;\n        } else {\n          throw new IllegalStateException(\"Cannot find break target.\");\n        }\n      }\n      previous = cur;\n    }\n    if (lastJump == node) {\n      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur, this));\n    } else {\n      finallyMap.put(lastJump, computeFollowNode(cur, this));\n    }\n  }\n\n  private void handleContinue(Node node) {\n    String label = null;\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n\n    // Similar to handBreak's logic with a few minor variation.\n    Node parent = node.getParent();\n    for (cur = node, lastJump = node;\n        !isContinueTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, cur.getLastChild());\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find continue target.\");\n      previous = cur;\n    }\n    Node iter = cur;\n    if (cur.getChildCount() == 4) {\n      iter = cur.getFirstChild().getNext().getNext();\n    }\n\n    if (lastJump == node) {\n      createEdge(node, Branch.UNCOND, iter);\n    } else {\n      finallyMap.put(lastJump, iter);\n    }\n  }\n\n  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (curHandler.isFunction()) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }\n\n  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n    return computeFollowNode(node, node, cfa);\n  }\n\n  static Node computeFollowNode(Node node) {\n    return computeFollowNode(node, node, null);\n  }\n\n  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n\n  /**\n   * Computes the destination node of n when we want to fallthrough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   */\n  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n\n  /**\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   */\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n\n  /**\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   */\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (handler.isFunction()) {\n          return;\n        }\n        Preconditions.checkState(handler.isTry());\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n\n  /**\n   * Get the next sibling (including itself) of one of the given types.\n   */\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n    for (Node c = first; c != null; c = c.getNext()) {\n      for (int type : types) {\n        if (c.getType() == type) {\n          return c;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   */\n  public static boolean isBreakTarget(Node target, String label) {\n    return isBreakStructure(target, label != null) &&\n      matchLabel(target.getParent(), label);\n  }\n\n  /**\n   * Checks if target is actually the continue target of labeled continue. The\n   * label can be null if it is an unlabeled continue.\n   */\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n    return isContinueStructure(target) && matchLabel(parent, label);\n  }\n  /**\n   * Check if label is actually referencing the target control structure. If\n   * label is null, it always returns true.\n   */\n  private static boolean matchLabel(Node target, String label) {\n    if (label == null) {\n      return true;\n    }\n    while (target.isLabel()) {\n      if (target.getFirstChild().getString().equals(label)) {\n        return true;\n      }\n      target = target.getParent();\n    }\n    return false;\n  }\n\n  /**\n   * Determines if the subtree might throw an exception.\n   */\n  public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether the given node can be terminated with a BREAK node.\n   */\n  static boolean isBreakStructure(Node n, boolean labeled) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.SWITCH:\n        return true;\n      case Token.BLOCK:\n      case Token.IF:\n      case Token.TRY:\n        return labeled;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Determines whether the given node can be advanced with a CONTINUE node.\n   */\n  static boolean isContinueStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Get the TRY block with a CATCH that would be run if n throws an exception.\n   * @return The CATCH node or null if it there isn't a CATCH before the\n   *     the function terminates.\n   */\n  static Node getExceptionHandler(Node n) {\n    for (Node cur = n;\n        !cur.isScript() && !cur.isFunction();\n        cur = cur.getParent()) {\n      Node catchNode = getCatchHandlerForBlock(cur);\n      if (catchNode != null) {\n        return catchNode;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Locate the catch BLOCK given the first block in a TRY.\n   * @return The CATCH node or null there is no catch handler.\n   */\n  static Node getCatchHandlerForBlock(Node block) {\n    if (block.isBlock() &&\n        block.getParent().isTry() &&\n        block.getParent().getFirstChild() == block) {\n      for (Node s = block.getNext(); s != null; s = s.getNext()) {\n        if (NodeUtil.hasCatchHandler(s)) {\n          return s.getFirstChild();\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * A {@link ControlFlowGraph} which provides a node comparator based on the\n   * pre-order traversal of the AST.\n   */\n  private static class AstControlFlowGraph extends ControlFlowGraph<Node> {\n    private final Map<DiGraphNode<Node, Branch>, Integer> priorities;\n\n    /**\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     */\n    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities,\n        boolean edgeAnnotations) {\n      super(entry,\n          true /* node annotations */, edgeAnnotations);\n      this.priorities = priorities;\n    }\n\n    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }\n\n    /**\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     */\n    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }\n  }\n}\n"}}
{"bug_id": "Closure_14", "version": "fixed", "focal_method_signature": "boolean com.google.javascript.jscomp.ControlFlowAnalysis#shouldTraverse(NodeTraversal#nodeTraversal,Node#n,Node#parent)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_14/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "focal_method": "@Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }", "return_type": "boolean", "assertion_subject_candidates": ["boolean", "ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()"], "focal_class": {"name": "ControlFlowAnalysis", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_14/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "superclass": "", "interface": "implements Callback, CompilerPass", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.collect.HashMultimap;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Multimap;", "import com.google.javascript.jscomp.ControlFlowGraph.Branch;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.ArrayDeque;", "import java.util.Comparator;", "import java.util.Deque;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.PriorityQueue;"], "fields": ["private final AbstractCompiler compiler", "private ControlFlowGraph<Node> cfg", "private Map<Node, Integer> astPosition", "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "private int astPositionCounter", "private int priorityCounter", "private final boolean shouldTraverseFunctions", "private final boolean edgeAnnotations", "private Node root", "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"], "methods": ["ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()", "void com.google.javascript.jscomp.ControlFlowAnalysis#process(Node#externs,Node#root)", "void com.google.javascript.jscomp.ControlFlowAnalysis#prioritizeFromEntryNode(DiGraphNode<Node, Branch>#entry)", "void com.google.javascript.jscomp.ControlFlowAnalysis#visit(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleIf(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWhile(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDo(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFor(Node#forNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleSwitch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCase(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDefault(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWith(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmtList(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFunction(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleExpr(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleThrow(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleTry(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCatch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleBreak(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleContinue(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleReturn(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmt(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#node,ControlFlowAnalysis#cfa)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#fromNode,Node#node,ControlFlowAnalysis#cfa)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFallThrough(Node#n)", "void com.google.javascript.jscomp.ControlFlowAnalysis#createEdge(Node#fromNode,ControlFlowGraph.Branch#branch,Node#toNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#connectToPossibleExceptionHandler(Node#cfgNode,Node#target)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getNextSiblingOfType(Node#first,#int ... types)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakTarget(Node#target,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueTarget(Node#target,Node#parent,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#matchLabel(Node#target,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#mayThrowException(Node#n)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakStructure(Node#n,boolean#labeled)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueStructure(Node#n)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getExceptionHandler(Node#n)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getCatchHandlerForBlock(Node#block)"], "other_methods": ["@Override\n  public void process(Node externs,Node root);", "@Override\n  public void visit(NodeTraversal t,Node n,Node parent);", "public static boolean isBreakTarget(Node target,String label);", "public static boolean mayThrowException(Node n);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "ControlFlowGraph<Node>#cfg": "private ControlFlowGraph<Node> cfg", "Map<Node, Integer>#astPosition": "private Map<Node, Integer> astPosition", "Map<DiGraphNode<Node, Branch>, Integer>#nodePriorities": "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "Comparator<DiGraphNode<Node, Branch>>#priorityComparator": "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "int#astPositionCounter": "private int astPositionCounter", "int#priorityCounter": "private int priorityCounter", "boolean#shouldTraverseFunctions": "private final boolean shouldTraverseFunctions", "boolean#edgeAnnotations": "private final boolean edgeAnnotations", "Node#root": "private Node root", "Deque<Node>#exceptionHandler": "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "Multimap<Node, Node>#finallyMap": "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"}, "text": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.ArrayDeque;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\n/**\n * This is a compiler pass that computes a control flow graph.\n *\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n\n  /**\n   * Based roughly on the first few pages of\n   *\n   * \"Declarative Intraprocedural Flow Analysis of Java Source Code by\n   * Nilsson-Nyman, Hedin, Magnusson & Ekman\",\n   *\n   * this pass computes the control flow graph from the AST. However, a full\n   * attribute grammar is not necessary. We will compute the flow edges with a\n   * single post order traversal. The \"follow()\" of a given node will be\n   * computed recursively in a demand driven fashion.\n   *\n   * As of this moment, we are not performing any inter-procedural analysis\n   * within our framework.\n   */\n\n  private final AbstractCompiler compiler;\n\n  private ControlFlowGraph<Node> cfg;\n\n  private Map<Node, Integer> astPosition;\n\n  // TODO(nicksantos): should these be node annotations?\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n\n  // We order CFG nodes by by looking at the AST positions.\n  // CFG nodes that come first lexically should be visited first, because\n  // they will often be executed first in the source program.\n  private final Comparator<DiGraphNode<Node, Branch>> priorityComparator =\n      new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  };\n\n  private int astPositionCounter;\n  private int priorityCounter;\n\n  private final boolean shouldTraverseFunctions;\n  private final boolean edgeAnnotations;\n\n  // We need to store where we started, in case we aren't doing a flow analysis\n  // for the whole scope. This happens, for example, when running type inference\n  // on only the externs.\n  private Node root;\n\n  /*\n   * This stack captures the structure of nested TRY blocks. The top of the\n   * stack is the inner most TRY block. A FUNCTION node in this stack implies\n   * that the handler is determined by the caller of the function at runtime.\n   */\n  private final Deque<Node> exceptionHandler = new ArrayDeque<Node>();\n\n  /*\n   * This map is used to handle the follow of FINALLY. For example:\n   *\n   * while(x) {\n   *  try {\n   *    try {\n   *      break;\n   *    } catch (a) {\n   *    } finally {\n   *      foo();\n   *    }\n   *    fooFollow();\n   *  } catch (b) {\n   *  } finally {\n   *    bar();\n   *  }\n   *  barFollow();\n   * }\n   * END();\n   *\n   * In this case finallyMap will contain a map from:\n   *    first FINALLY -> bar()\n   *    second FINALLY -> END()\n   *\n   * When we are connecting foo() and bar() to to their respective follow, we\n   * must also look up this map and connect:\n   *   foo() -> bar()\n   *   bar() -> END\n   */\n  private final Multimap<Node, Node> finallyMap = HashMultimap.create();\n\n  /**\n   * Constructor.\n   *\n   * @param compiler Compiler instance.\n   * @param shouldTraverseFunctions Whether functions should be traversed (true\n   *    by default).\n   * @param edgeAnnotations Whether to allow edge annotations. By default,\n   *    only node annotations are allowed.\n   */\n  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n    this.edgeAnnotations = edgeAnnotations;\n  }\n\n  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.isFunction()) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }\n\n  /**\n   * Given an entry node, find all the nodes reachable from that node\n   * and prioritize them.\n   */\n  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }\n\n  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT_CASE:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }\n\n  private void handleIf(Node node) {\n    Node thenBlock = node.getFirstChild().getNext();\n    Node elseBlock = thenBlock.getNext();\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));\n\n    if (elseBlock == null) {\n      createEdge(node, Branch.ON_FALSE,\n          computeFollowNode(node, this)); // not taken branch\n    } else {\n      createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n    }\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleWhile(Node node) {\n    // Control goes to the first statement if the condition evaluates to true.\n    createEdge(node, Branch.ON_TRUE,\n        computeFallThrough(node.getFirstChild().getNext()));\n\n    // Control goes to the follow() if the condition evaluates to false.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleDo(Node node) {\n    // The first edge can be the initial iteration as well as the iterations\n    // after.\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild()));\n    // The edge that leaves the do loop if the condition fails.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleFor(Node forNode) {\n    if (forNode.getChildCount() == 4) {\n      // We have for (init; cond; iter) { body }\n      Node init = forNode.getFirstChild();\n      Node cond = init.getNext();\n      Node iter = cond.getNext();\n      Node body = iter.getNext();\n      // After initialization, we transfer to the FOR which is in charge of\n      // checking the condition (for the first time).\n      createEdge(init, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      // The end of the body will have a unconditional branch to our iter\n      // (handled by calling computeFollowNode of the last instruction of the\n      // body. Our iter will jump to the forNode again to another condition\n      // check.\n      createEdge(iter, Branch.UNCOND, forNode);\n      connectToPossibleExceptionHandler(init, init);\n      connectToPossibleExceptionHandler(forNode, cond);\n      connectToPossibleExceptionHandler(iter, iter);\n    } else {\n      // We have for (item in collection) { body }\n      Node item = forNode.getFirstChild();\n      Node collection = item.getNext();\n      Node body = collection.getNext();\n      // The collection behaves like init.\n      createEdge(collection, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      connectToPossibleExceptionHandler(forNode, collection);\n    }\n  }\n\n  private void handleSwitch(Node node) {\n    // Transfer to the first non-DEFAULT CASE. if there are none, transfer\n    // to the DEFAULT or the EMPTY node.\n    Node next = getNextSiblingOfType(\n        node.getFirstChild().getNext(), Token.CASE, Token.EMPTY);\n    if (next != null) { // Has at least one CASE or EMPTY\n      createEdge(node, Branch.UNCOND, next);\n    } else { // Has no CASE but possibly a DEFAULT\n      if (node.getFirstChild().getNext() != null) {\n        createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());\n      } else { // No CASE, no DEFAULT\n        createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleCase(Node node) {\n    // Case is a bit tricky....First it goes into the body if condition is true.\n    createEdge(node, Branch.ON_TRUE,\n        node.getFirstChild().getNext());\n    // Look for the next CASE, skipping over DEFAULT.\n    Node next = getNextSiblingOfType(node.getNext(), Token.CASE);\n    if (next != null) { // Found a CASE\n      Preconditions.checkState(next.isCase());\n      createEdge(node, Branch.ON_FALSE, next);\n    } else { // No more CASE found, go back and search for a DEFAULT.\n      Node parent = node.getParent();\n      Node deflt = getNextSiblingOfType(\n        parent.getFirstChild().getNext(), Token.DEFAULT_CASE);\n      if (deflt != null) { // Has a DEFAULT\n        createEdge(node, Branch.ON_FALSE, deflt);\n      } else { // No DEFAULT found, go to the follow of the SWITCH.\n        createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleDefault(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleWith(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.isBlock() && parent != null &&\n        parent.isTry() &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.isFunction()) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT_CASE:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.isBlock() && node.isSyntheticBlock()) {\n            createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n          }\n          break;\n      }\n    }\n  }\n\n  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }\n\n  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleThrow(Node node) {\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleTry(Node node) {\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleCatch(Node node) {\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n  }\n\n  private void handleBreak(Node node) {\n    String label = null;\n    // See if it is a break with label.\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n    Node parent = node.getParent();\n    /*\n     * Continuously look up the ancestor tree for the BREAK target or the target\n     * with the corresponding label and connect to it. If along the path we\n     * discover a FINALLY, we will connect the BREAK to that FINALLY. From then\n     * on, we will just record the control flow changes in the finallyMap. This\n     * is due to the fact that we need to connect any node that leaves its own\n     * FINALLY block to the outer FINALLY or the BREAK's target but those nodes\n     * are not known yet due to the way we traverse the nodes.\n     */\n    for (cur = node, lastJump = node;\n        !isBreakTarget(cur, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, computeFallThrough(\n              cur.getLastChild()));\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      if (parent == null) {\n        if (compiler.isIdeMode()) {\n          // In IDE mode, we expect that the data flow graph may\n          // not be well-formed.\n          return;\n        } else {\n          throw new IllegalStateException(\"Cannot find break target.\");\n        }\n      }\n      previous = cur;\n    }\n    if (lastJump == node) {\n      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur, this));\n    } else {\n      finallyMap.put(lastJump, computeFollowNode(cur, this));\n    }\n  }\n\n  private void handleContinue(Node node) {\n    String label = null;\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n\n    // Similar to handBreak's logic with a few minor variation.\n    Node parent = node.getParent();\n    for (cur = node, lastJump = node;\n        !isContinueTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, cur.getLastChild());\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find continue target.\");\n      previous = cur;\n    }\n    Node iter = cur;\n    if (cur.getChildCount() == 4) {\n      iter = cur.getFirstChild().getNext().getNext();\n    }\n\n    if (lastJump == node) {\n      createEdge(node, Branch.UNCOND, iter);\n    } else {\n      finallyMap.put(lastJump, iter);\n    }\n  }\n\n  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (curHandler.isFunction()) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }\n\n  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n    return computeFollowNode(node, node, cfa);\n  }\n\n  static Node computeFollowNode(Node node) {\n    return computeFollowNode(node, node, null);\n  }\n\n  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n\n  /**\n   * Computes the destination node of n when we want to fallthrough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   */\n  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n\n  /**\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   */\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n\n  /**\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   */\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (handler.isFunction()) {\n          return;\n        }\n        Preconditions.checkState(handler.isTry());\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n\n  /**\n   * Get the next sibling (including itself) of one of the given types.\n   */\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n    for (Node c = first; c != null; c = c.getNext()) {\n      for (int type : types) {\n        if (c.getType() == type) {\n          return c;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   */\n  public static boolean isBreakTarget(Node target, String label) {\n    return isBreakStructure(target, label != null) &&\n      matchLabel(target.getParent(), label);\n  }\n\n  /**\n   * Checks if target is actually the continue target of labeled continue. The\n   * label can be null if it is an unlabeled continue.\n   */\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n    return isContinueStructure(target) && matchLabel(parent, label);\n  }\n  /**\n   * Check if label is actually referencing the target control structure. If\n   * label is null, it always returns true.\n   */\n  private static boolean matchLabel(Node target, String label) {\n    if (label == null) {\n      return true;\n    }\n    while (target.isLabel()) {\n      if (target.getFirstChild().getString().equals(label)) {\n        return true;\n      }\n      target = target.getParent();\n    }\n    return false;\n  }\n\n  /**\n   * Determines if the subtree might throw an exception.\n   */\n  public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether the given node can be terminated with a BREAK node.\n   */\n  static boolean isBreakStructure(Node n, boolean labeled) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.SWITCH:\n        return true;\n      case Token.BLOCK:\n      case Token.IF:\n      case Token.TRY:\n        return labeled;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Determines whether the given node can be advanced with a CONTINUE node.\n   */\n  static boolean isContinueStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Get the TRY block with a CATCH that would be run if n throws an exception.\n   * @return The CATCH node or null if it there isn't a CATCH before the\n   *     the function terminates.\n   */\n  static Node getExceptionHandler(Node n) {\n    for (Node cur = n;\n        !cur.isScript() && !cur.isFunction();\n        cur = cur.getParent()) {\n      Node catchNode = getCatchHandlerForBlock(cur);\n      if (catchNode != null) {\n        return catchNode;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Locate the catch BLOCK given the first block in a TRY.\n   * @return The CATCH node or null there is no catch handler.\n   */\n  static Node getCatchHandlerForBlock(Node block) {\n    if (block.isBlock() &&\n        block.getParent().isTry() &&\n        block.getParent().getFirstChild() == block) {\n      for (Node s = block.getNext(); s != null; s = s.getNext()) {\n        if (NodeUtil.hasCatchHandler(s)) {\n          return s.getFirstChild();\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * A {@link ControlFlowGraph} which provides a node comparator based on the\n   * pre-order traversal of the AST.\n   */\n  private static class AstControlFlowGraph extends ControlFlowGraph<Node> {\n    private final Map<DiGraphNode<Node, Branch>, Integer> priorities;\n\n    /**\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     */\n    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities,\n        boolean edgeAnnotations) {\n      super(entry,\n          true /* node annotations */, edgeAnnotations);\n      this.priorities = priorities;\n    }\n\n    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }\n\n    /**\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     */\n    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }\n  }\n}\n"}}
{"bug_id": "Closure_14", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.ControlFlowAnalysis#visit(NodeTraversal#t,Node#n,Node#parent)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_14/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "focal_method": "@Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT_CASE:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }", "return_type": "void", "assertion_subject_candidates": ["ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()"], "focal_class": {"name": "ControlFlowAnalysis", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_14/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "superclass": "", "interface": "implements Callback, CompilerPass", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.collect.HashMultimap;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Multimap;", "import com.google.javascript.jscomp.ControlFlowGraph.Branch;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.ArrayDeque;", "import java.util.Comparator;", "import java.util.Deque;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.PriorityQueue;"], "fields": ["private final AbstractCompiler compiler", "private ControlFlowGraph<Node> cfg", "private Map<Node, Integer> astPosition", "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "private int astPositionCounter", "private int priorityCounter", "private final boolean shouldTraverseFunctions", "private final boolean edgeAnnotations", "private Node root", "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"], "methods": ["ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()", "void com.google.javascript.jscomp.ControlFlowAnalysis#process(Node#externs,Node#root)", "void com.google.javascript.jscomp.ControlFlowAnalysis#prioritizeFromEntryNode(DiGraphNode<Node, Branch>#entry)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#shouldTraverse(NodeTraversal#nodeTraversal,Node#n,Node#parent)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleIf(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWhile(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDo(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFor(Node#forNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleSwitch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCase(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDefault(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWith(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmtList(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFunction(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleExpr(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleThrow(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleTry(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCatch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleBreak(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleContinue(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleReturn(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmt(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#node,ControlFlowAnalysis#cfa)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#fromNode,Node#node,ControlFlowAnalysis#cfa)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFallThrough(Node#n)", "void com.google.javascript.jscomp.ControlFlowAnalysis#createEdge(Node#fromNode,ControlFlowGraph.Branch#branch,Node#toNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#connectToPossibleExceptionHandler(Node#cfgNode,Node#target)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getNextSiblingOfType(Node#first,#int ... types)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakTarget(Node#target,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueTarget(Node#target,Node#parent,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#matchLabel(Node#target,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#mayThrowException(Node#n)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakStructure(Node#n,boolean#labeled)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueStructure(Node#n)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getExceptionHandler(Node#n)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getCatchHandlerForBlock(Node#block)"], "other_methods": ["@Override\n  public void process(Node externs,Node root);", "@Override\n  public boolean shouldTraverse(NodeTraversal nodeTraversal,Node n,Node parent);", "public static boolean isBreakTarget(Node target,String label);", "public static boolean mayThrowException(Node n);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "ControlFlowGraph<Node>#cfg": "private ControlFlowGraph<Node> cfg", "Map<Node, Integer>#astPosition": "private Map<Node, Integer> astPosition", "Map<DiGraphNode<Node, Branch>, Integer>#nodePriorities": "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "Comparator<DiGraphNode<Node, Branch>>#priorityComparator": "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "int#astPositionCounter": "private int astPositionCounter", "int#priorityCounter": "private int priorityCounter", "boolean#shouldTraverseFunctions": "private final boolean shouldTraverseFunctions", "boolean#edgeAnnotations": "private final boolean edgeAnnotations", "Node#root": "private Node root", "Deque<Node>#exceptionHandler": "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "Multimap<Node, Node>#finallyMap": "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"}, "text": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.ArrayDeque;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\n/**\n * This is a compiler pass that computes a control flow graph.\n *\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n\n  /**\n   * Based roughly on the first few pages of\n   *\n   * \"Declarative Intraprocedural Flow Analysis of Java Source Code by\n   * Nilsson-Nyman, Hedin, Magnusson & Ekman\",\n   *\n   * this pass computes the control flow graph from the AST. However, a full\n   * attribute grammar is not necessary. We will compute the flow edges with a\n   * single post order traversal. The \"follow()\" of a given node will be\n   * computed recursively in a demand driven fashion.\n   *\n   * As of this moment, we are not performing any inter-procedural analysis\n   * within our framework.\n   */\n\n  private final AbstractCompiler compiler;\n\n  private ControlFlowGraph<Node> cfg;\n\n  private Map<Node, Integer> astPosition;\n\n  // TODO(nicksantos): should these be node annotations?\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n\n  // We order CFG nodes by by looking at the AST positions.\n  // CFG nodes that come first lexically should be visited first, because\n  // they will often be executed first in the source program.\n  private final Comparator<DiGraphNode<Node, Branch>> priorityComparator =\n      new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  };\n\n  private int astPositionCounter;\n  private int priorityCounter;\n\n  private final boolean shouldTraverseFunctions;\n  private final boolean edgeAnnotations;\n\n  // We need to store where we started, in case we aren't doing a flow analysis\n  // for the whole scope. This happens, for example, when running type inference\n  // on only the externs.\n  private Node root;\n\n  /*\n   * This stack captures the structure of nested TRY blocks. The top of the\n   * stack is the inner most TRY block. A FUNCTION node in this stack implies\n   * that the handler is determined by the caller of the function at runtime.\n   */\n  private final Deque<Node> exceptionHandler = new ArrayDeque<Node>();\n\n  /*\n   * This map is used to handle the follow of FINALLY. For example:\n   *\n   * while(x) {\n   *  try {\n   *    try {\n   *      break;\n   *    } catch (a) {\n   *    } finally {\n   *      foo();\n   *    }\n   *    fooFollow();\n   *  } catch (b) {\n   *  } finally {\n   *    bar();\n   *  }\n   *  barFollow();\n   * }\n   * END();\n   *\n   * In this case finallyMap will contain a map from:\n   *    first FINALLY -> bar()\n   *    second FINALLY -> END()\n   *\n   * When we are connecting foo() and bar() to to their respective follow, we\n   * must also look up this map and connect:\n   *   foo() -> bar()\n   *   bar() -> END\n   */\n  private final Multimap<Node, Node> finallyMap = HashMultimap.create();\n\n  /**\n   * Constructor.\n   *\n   * @param compiler Compiler instance.\n   * @param shouldTraverseFunctions Whether functions should be traversed (true\n   *    by default).\n   * @param edgeAnnotations Whether to allow edge annotations. By default,\n   *    only node annotations are allowed.\n   */\n  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n    this.edgeAnnotations = edgeAnnotations;\n  }\n\n  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.isFunction()) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }\n\n  /**\n   * Given an entry node, find all the nodes reachable from that node\n   * and prioritize them.\n   */\n  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }\n\n  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT_CASE:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }\n\n  private void handleIf(Node node) {\n    Node thenBlock = node.getFirstChild().getNext();\n    Node elseBlock = thenBlock.getNext();\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));\n\n    if (elseBlock == null) {\n      createEdge(node, Branch.ON_FALSE,\n          computeFollowNode(node, this)); // not taken branch\n    } else {\n      createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n    }\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleWhile(Node node) {\n    // Control goes to the first statement if the condition evaluates to true.\n    createEdge(node, Branch.ON_TRUE,\n        computeFallThrough(node.getFirstChild().getNext()));\n\n    // Control goes to the follow() if the condition evaluates to false.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleDo(Node node) {\n    // The first edge can be the initial iteration as well as the iterations\n    // after.\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild()));\n    // The edge that leaves the do loop if the condition fails.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleFor(Node forNode) {\n    if (forNode.getChildCount() == 4) {\n      // We have for (init; cond; iter) { body }\n      Node init = forNode.getFirstChild();\n      Node cond = init.getNext();\n      Node iter = cond.getNext();\n      Node body = iter.getNext();\n      // After initialization, we transfer to the FOR which is in charge of\n      // checking the condition (for the first time).\n      createEdge(init, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      // The end of the body will have a unconditional branch to our iter\n      // (handled by calling computeFollowNode of the last instruction of the\n      // body. Our iter will jump to the forNode again to another condition\n      // check.\n      createEdge(iter, Branch.UNCOND, forNode);\n      connectToPossibleExceptionHandler(init, init);\n      connectToPossibleExceptionHandler(forNode, cond);\n      connectToPossibleExceptionHandler(iter, iter);\n    } else {\n      // We have for (item in collection) { body }\n      Node item = forNode.getFirstChild();\n      Node collection = item.getNext();\n      Node body = collection.getNext();\n      // The collection behaves like init.\n      createEdge(collection, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      connectToPossibleExceptionHandler(forNode, collection);\n    }\n  }\n\n  private void handleSwitch(Node node) {\n    // Transfer to the first non-DEFAULT CASE. if there are none, transfer\n    // to the DEFAULT or the EMPTY node.\n    Node next = getNextSiblingOfType(\n        node.getFirstChild().getNext(), Token.CASE, Token.EMPTY);\n    if (next != null) { // Has at least one CASE or EMPTY\n      createEdge(node, Branch.UNCOND, next);\n    } else { // Has no CASE but possibly a DEFAULT\n      if (node.getFirstChild().getNext() != null) {\n        createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());\n      } else { // No CASE, no DEFAULT\n        createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleCase(Node node) {\n    // Case is a bit tricky....First it goes into the body if condition is true.\n    createEdge(node, Branch.ON_TRUE,\n        node.getFirstChild().getNext());\n    // Look for the next CASE, skipping over DEFAULT.\n    Node next = getNextSiblingOfType(node.getNext(), Token.CASE);\n    if (next != null) { // Found a CASE\n      Preconditions.checkState(next.isCase());\n      createEdge(node, Branch.ON_FALSE, next);\n    } else { // No more CASE found, go back and search for a DEFAULT.\n      Node parent = node.getParent();\n      Node deflt = getNextSiblingOfType(\n        parent.getFirstChild().getNext(), Token.DEFAULT_CASE);\n      if (deflt != null) { // Has a DEFAULT\n        createEdge(node, Branch.ON_FALSE, deflt);\n      } else { // No DEFAULT found, go to the follow of the SWITCH.\n        createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleDefault(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleWith(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.isBlock() && parent != null &&\n        parent.isTry() &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.isFunction()) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT_CASE:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.isBlock() && node.isSyntheticBlock()) {\n            createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n          }\n          break;\n      }\n    }\n  }\n\n  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }\n\n  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleThrow(Node node) {\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleTry(Node node) {\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleCatch(Node node) {\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n  }\n\n  private void handleBreak(Node node) {\n    String label = null;\n    // See if it is a break with label.\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n    Node parent = node.getParent();\n    /*\n     * Continuously look up the ancestor tree for the BREAK target or the target\n     * with the corresponding label and connect to it. If along the path we\n     * discover a FINALLY, we will connect the BREAK to that FINALLY. From then\n     * on, we will just record the control flow changes in the finallyMap. This\n     * is due to the fact that we need to connect any node that leaves its own\n     * FINALLY block to the outer FINALLY or the BREAK's target but those nodes\n     * are not known yet due to the way we traverse the nodes.\n     */\n    for (cur = node, lastJump = node;\n        !isBreakTarget(cur, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, computeFallThrough(\n              cur.getLastChild()));\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      if (parent == null) {\n        if (compiler.isIdeMode()) {\n          // In IDE mode, we expect that the data flow graph may\n          // not be well-formed.\n          return;\n        } else {\n          throw new IllegalStateException(\"Cannot find break target.\");\n        }\n      }\n      previous = cur;\n    }\n    if (lastJump == node) {\n      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur, this));\n    } else {\n      finallyMap.put(lastJump, computeFollowNode(cur, this));\n    }\n  }\n\n  private void handleContinue(Node node) {\n    String label = null;\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n\n    // Similar to handBreak's logic with a few minor variation.\n    Node parent = node.getParent();\n    for (cur = node, lastJump = node;\n        !isContinueTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, cur.getLastChild());\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find continue target.\");\n      previous = cur;\n    }\n    Node iter = cur;\n    if (cur.getChildCount() == 4) {\n      iter = cur.getFirstChild().getNext().getNext();\n    }\n\n    if (lastJump == node) {\n      createEdge(node, Branch.UNCOND, iter);\n    } else {\n      finallyMap.put(lastJump, iter);\n    }\n  }\n\n  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (curHandler.isFunction()) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }\n\n  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n    return computeFollowNode(node, node, cfa);\n  }\n\n  static Node computeFollowNode(Node node) {\n    return computeFollowNode(node, node, null);\n  }\n\n  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n\n  /**\n   * Computes the destination node of n when we want to fallthrough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   */\n  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n\n  /**\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   */\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n\n  /**\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   */\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (handler.isFunction()) {\n          return;\n        }\n        Preconditions.checkState(handler.isTry());\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n\n  /**\n   * Get the next sibling (including itself) of one of the given types.\n   */\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n    for (Node c = first; c != null; c = c.getNext()) {\n      for (int type : types) {\n        if (c.getType() == type) {\n          return c;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   */\n  public static boolean isBreakTarget(Node target, String label) {\n    return isBreakStructure(target, label != null) &&\n      matchLabel(target.getParent(), label);\n  }\n\n  /**\n   * Checks if target is actually the continue target of labeled continue. The\n   * label can be null if it is an unlabeled continue.\n   */\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n    return isContinueStructure(target) && matchLabel(parent, label);\n  }\n  /**\n   * Check if label is actually referencing the target control structure. If\n   * label is null, it always returns true.\n   */\n  private static boolean matchLabel(Node target, String label) {\n    if (label == null) {\n      return true;\n    }\n    while (target.isLabel()) {\n      if (target.getFirstChild().getString().equals(label)) {\n        return true;\n      }\n      target = target.getParent();\n    }\n    return false;\n  }\n\n  /**\n   * Determines if the subtree might throw an exception.\n   */\n  public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether the given node can be terminated with a BREAK node.\n   */\n  static boolean isBreakStructure(Node n, boolean labeled) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.SWITCH:\n        return true;\n      case Token.BLOCK:\n      case Token.IF:\n      case Token.TRY:\n        return labeled;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Determines whether the given node can be advanced with a CONTINUE node.\n   */\n  static boolean isContinueStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Get the TRY block with a CATCH that would be run if n throws an exception.\n   * @return The CATCH node or null if it there isn't a CATCH before the\n   *     the function terminates.\n   */\n  static Node getExceptionHandler(Node n) {\n    for (Node cur = n;\n        !cur.isScript() && !cur.isFunction();\n        cur = cur.getParent()) {\n      Node catchNode = getCatchHandlerForBlock(cur);\n      if (catchNode != null) {\n        return catchNode;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Locate the catch BLOCK given the first block in a TRY.\n   * @return The CATCH node or null there is no catch handler.\n   */\n  static Node getCatchHandlerForBlock(Node block) {\n    if (block.isBlock() &&\n        block.getParent().isTry() &&\n        block.getParent().getFirstChild() == block) {\n      for (Node s = block.getNext(); s != null; s = s.getNext()) {\n        if (NodeUtil.hasCatchHandler(s)) {\n          return s.getFirstChild();\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * A {@link ControlFlowGraph} which provides a node comparator based on the\n   * pre-order traversal of the AST.\n   */\n  private static class AstControlFlowGraph extends ControlFlowGraph<Node> {\n    private final Map<DiGraphNode<Node, Branch>, Integer> priorities;\n\n    /**\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     */\n    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities,\n        boolean edgeAnnotations) {\n      super(entry,\n          true /* node annotations */, edgeAnnotations);\n      this.priorities = priorities;\n    }\n\n    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }\n\n    /**\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     */\n    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }\n  }\n}\n"}}
{"bug_id": "Closure_14", "version": "fixed", "focal_method_signature": "boolean com.google.javascript.jscomp.ControlFlowAnalysis#mayThrowException(Node#n)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_14/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "focal_method": "public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }", "return_type": "boolean", "assertion_subject_candidates": ["boolean", "ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()"], "focal_class": {"name": "ControlFlowAnalysis", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_14/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "superclass": "", "interface": "implements Callback, CompilerPass", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.collect.HashMultimap;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Multimap;", "import com.google.javascript.jscomp.ControlFlowGraph.Branch;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.ArrayDeque;", "import java.util.Comparator;", "import java.util.Deque;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.PriorityQueue;"], "fields": ["private final AbstractCompiler compiler", "private ControlFlowGraph<Node> cfg", "private Map<Node, Integer> astPosition", "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "private int astPositionCounter", "private int priorityCounter", "private final boolean shouldTraverseFunctions", "private final boolean edgeAnnotations", "private Node root", "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"], "methods": ["ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()", "void com.google.javascript.jscomp.ControlFlowAnalysis#process(Node#externs,Node#root)", "void com.google.javascript.jscomp.ControlFlowAnalysis#prioritizeFromEntryNode(DiGraphNode<Node, Branch>#entry)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#shouldTraverse(NodeTraversal#nodeTraversal,Node#n,Node#parent)", "void com.google.javascript.jscomp.ControlFlowAnalysis#visit(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleIf(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWhile(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDo(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFor(Node#forNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleSwitch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCase(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDefault(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWith(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmtList(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFunction(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleExpr(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleThrow(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleTry(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCatch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleBreak(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleContinue(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleReturn(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmt(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#node,ControlFlowAnalysis#cfa)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#fromNode,Node#node,ControlFlowAnalysis#cfa)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFallThrough(Node#n)", "void com.google.javascript.jscomp.ControlFlowAnalysis#createEdge(Node#fromNode,ControlFlowGraph.Branch#branch,Node#toNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#connectToPossibleExceptionHandler(Node#cfgNode,Node#target)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getNextSiblingOfType(Node#first,#int ... types)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakTarget(Node#target,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueTarget(Node#target,Node#parent,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#matchLabel(Node#target,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakStructure(Node#n,boolean#labeled)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueStructure(Node#n)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getExceptionHandler(Node#n)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getCatchHandlerForBlock(Node#block)"], "other_methods": ["@Override\n  public void process(Node externs,Node root);", "@Override\n  public boolean shouldTraverse(NodeTraversal nodeTraversal,Node n,Node parent);", "@Override\n  public void visit(NodeTraversal t,Node n,Node parent);", "public static boolean isBreakTarget(Node target,String label);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "ControlFlowGraph<Node>#cfg": "private ControlFlowGraph<Node> cfg", "Map<Node, Integer>#astPosition": "private Map<Node, Integer> astPosition", "Map<DiGraphNode<Node, Branch>, Integer>#nodePriorities": "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "Comparator<DiGraphNode<Node, Branch>>#priorityComparator": "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "int#astPositionCounter": "private int astPositionCounter", "int#priorityCounter": "private int priorityCounter", "boolean#shouldTraverseFunctions": "private final boolean shouldTraverseFunctions", "boolean#edgeAnnotations": "private final boolean edgeAnnotations", "Node#root": "private Node root", "Deque<Node>#exceptionHandler": "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "Multimap<Node, Node>#finallyMap": "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"}, "text": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.ArrayDeque;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\n/**\n * This is a compiler pass that computes a control flow graph.\n *\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n\n  /**\n   * Based roughly on the first few pages of\n   *\n   * \"Declarative Intraprocedural Flow Analysis of Java Source Code by\n   * Nilsson-Nyman, Hedin, Magnusson & Ekman\",\n   *\n   * this pass computes the control flow graph from the AST. However, a full\n   * attribute grammar is not necessary. We will compute the flow edges with a\n   * single post order traversal. The \"follow()\" of a given node will be\n   * computed recursively in a demand driven fashion.\n   *\n   * As of this moment, we are not performing any inter-procedural analysis\n   * within our framework.\n   */\n\n  private final AbstractCompiler compiler;\n\n  private ControlFlowGraph<Node> cfg;\n\n  private Map<Node, Integer> astPosition;\n\n  // TODO(nicksantos): should these be node annotations?\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n\n  // We order CFG nodes by by looking at the AST positions.\n  // CFG nodes that come first lexically should be visited first, because\n  // they will often be executed first in the source program.\n  private final Comparator<DiGraphNode<Node, Branch>> priorityComparator =\n      new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  };\n\n  private int astPositionCounter;\n  private int priorityCounter;\n\n  private final boolean shouldTraverseFunctions;\n  private final boolean edgeAnnotations;\n\n  // We need to store where we started, in case we aren't doing a flow analysis\n  // for the whole scope. This happens, for example, when running type inference\n  // on only the externs.\n  private Node root;\n\n  /*\n   * This stack captures the structure of nested TRY blocks. The top of the\n   * stack is the inner most TRY block. A FUNCTION node in this stack implies\n   * that the handler is determined by the caller of the function at runtime.\n   */\n  private final Deque<Node> exceptionHandler = new ArrayDeque<Node>();\n\n  /*\n   * This map is used to handle the follow of FINALLY. For example:\n   *\n   * while(x) {\n   *  try {\n   *    try {\n   *      break;\n   *    } catch (a) {\n   *    } finally {\n   *      foo();\n   *    }\n   *    fooFollow();\n   *  } catch (b) {\n   *  } finally {\n   *    bar();\n   *  }\n   *  barFollow();\n   * }\n   * END();\n   *\n   * In this case finallyMap will contain a map from:\n   *    first FINALLY -> bar()\n   *    second FINALLY -> END()\n   *\n   * When we are connecting foo() and bar() to to their respective follow, we\n   * must also look up this map and connect:\n   *   foo() -> bar()\n   *   bar() -> END\n   */\n  private final Multimap<Node, Node> finallyMap = HashMultimap.create();\n\n  /**\n   * Constructor.\n   *\n   * @param compiler Compiler instance.\n   * @param shouldTraverseFunctions Whether functions should be traversed (true\n   *    by default).\n   * @param edgeAnnotations Whether to allow edge annotations. By default,\n   *    only node annotations are allowed.\n   */\n  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n    this.edgeAnnotations = edgeAnnotations;\n  }\n\n  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.isFunction()) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }\n\n  /**\n   * Given an entry node, find all the nodes reachable from that node\n   * and prioritize them.\n   */\n  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }\n\n  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT_CASE:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }\n\n  private void handleIf(Node node) {\n    Node thenBlock = node.getFirstChild().getNext();\n    Node elseBlock = thenBlock.getNext();\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));\n\n    if (elseBlock == null) {\n      createEdge(node, Branch.ON_FALSE,\n          computeFollowNode(node, this)); // not taken branch\n    } else {\n      createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n    }\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleWhile(Node node) {\n    // Control goes to the first statement if the condition evaluates to true.\n    createEdge(node, Branch.ON_TRUE,\n        computeFallThrough(node.getFirstChild().getNext()));\n\n    // Control goes to the follow() if the condition evaluates to false.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleDo(Node node) {\n    // The first edge can be the initial iteration as well as the iterations\n    // after.\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild()));\n    // The edge that leaves the do loop if the condition fails.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleFor(Node forNode) {\n    if (forNode.getChildCount() == 4) {\n      // We have for (init; cond; iter) { body }\n      Node init = forNode.getFirstChild();\n      Node cond = init.getNext();\n      Node iter = cond.getNext();\n      Node body = iter.getNext();\n      // After initialization, we transfer to the FOR which is in charge of\n      // checking the condition (for the first time).\n      createEdge(init, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      // The end of the body will have a unconditional branch to our iter\n      // (handled by calling computeFollowNode of the last instruction of the\n      // body. Our iter will jump to the forNode again to another condition\n      // check.\n      createEdge(iter, Branch.UNCOND, forNode);\n      connectToPossibleExceptionHandler(init, init);\n      connectToPossibleExceptionHandler(forNode, cond);\n      connectToPossibleExceptionHandler(iter, iter);\n    } else {\n      // We have for (item in collection) { body }\n      Node item = forNode.getFirstChild();\n      Node collection = item.getNext();\n      Node body = collection.getNext();\n      // The collection behaves like init.\n      createEdge(collection, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      connectToPossibleExceptionHandler(forNode, collection);\n    }\n  }\n\n  private void handleSwitch(Node node) {\n    // Transfer to the first non-DEFAULT CASE. if there are none, transfer\n    // to the DEFAULT or the EMPTY node.\n    Node next = getNextSiblingOfType(\n        node.getFirstChild().getNext(), Token.CASE, Token.EMPTY);\n    if (next != null) { // Has at least one CASE or EMPTY\n      createEdge(node, Branch.UNCOND, next);\n    } else { // Has no CASE but possibly a DEFAULT\n      if (node.getFirstChild().getNext() != null) {\n        createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());\n      } else { // No CASE, no DEFAULT\n        createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleCase(Node node) {\n    // Case is a bit tricky....First it goes into the body if condition is true.\n    createEdge(node, Branch.ON_TRUE,\n        node.getFirstChild().getNext());\n    // Look for the next CASE, skipping over DEFAULT.\n    Node next = getNextSiblingOfType(node.getNext(), Token.CASE);\n    if (next != null) { // Found a CASE\n      Preconditions.checkState(next.isCase());\n      createEdge(node, Branch.ON_FALSE, next);\n    } else { // No more CASE found, go back and search for a DEFAULT.\n      Node parent = node.getParent();\n      Node deflt = getNextSiblingOfType(\n        parent.getFirstChild().getNext(), Token.DEFAULT_CASE);\n      if (deflt != null) { // Has a DEFAULT\n        createEdge(node, Branch.ON_FALSE, deflt);\n      } else { // No DEFAULT found, go to the follow of the SWITCH.\n        createEdge(node, Branch.ON_FALSE, computeFollowNode(node, this));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleDefault(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleWith(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.isBlock() && parent != null &&\n        parent.isTry() &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.isFunction()) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT_CASE:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.isBlock() && node.isSyntheticBlock()) {\n            createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n          }\n          break;\n      }\n    }\n  }\n\n  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }\n\n  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleThrow(Node node) {\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleTry(Node node) {\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleCatch(Node node) {\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n  }\n\n  private void handleBreak(Node node) {\n    String label = null;\n    // See if it is a break with label.\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n    Node parent = node.getParent();\n    /*\n     * Continuously look up the ancestor tree for the BREAK target or the target\n     * with the corresponding label and connect to it. If along the path we\n     * discover a FINALLY, we will connect the BREAK to that FINALLY. From then\n     * on, we will just record the control flow changes in the finallyMap. This\n     * is due to the fact that we need to connect any node that leaves its own\n     * FINALLY block to the outer FINALLY or the BREAK's target but those nodes\n     * are not known yet due to the way we traverse the nodes.\n     */\n    for (cur = node, lastJump = node;\n        !isBreakTarget(cur, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, computeFallThrough(\n              cur.getLastChild()));\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      if (parent == null) {\n        if (compiler.isIdeMode()) {\n          // In IDE mode, we expect that the data flow graph may\n          // not be well-formed.\n          return;\n        } else {\n          throw new IllegalStateException(\"Cannot find break target.\");\n        }\n      }\n      previous = cur;\n    }\n    if (lastJump == node) {\n      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur, this));\n    } else {\n      finallyMap.put(lastJump, computeFollowNode(cur, this));\n    }\n  }\n\n  private void handleContinue(Node node) {\n    String label = null;\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node previous = null;\n    Node lastJump;\n\n    // Similar to handBreak's logic with a few minor variation.\n    Node parent = node.getParent();\n    for (cur = node, lastJump = node;\n        !isContinueTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.isTry() && NodeUtil.hasFinally(cur)\n          && cur.getLastChild() != previous) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, cur.getLastChild());\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find continue target.\");\n      previous = cur;\n    }\n    Node iter = cur;\n    if (cur.getChildCount() == 4) {\n      iter = cur.getFirstChild().getNext().getNext();\n    }\n\n    if (lastJump == node) {\n      createEdge(node, Branch.UNCOND, iter);\n    } else {\n      finallyMap.put(lastJump, iter);\n    }\n  }\n\n  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (curHandler.isFunction()) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }\n\n  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n    return computeFollowNode(node, node, cfa);\n  }\n\n  static Node computeFollowNode(Node node) {\n    return computeFollowNode(node, node, null);\n  }\n\n  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT_CASE:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().isCase()) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().isDefaultCase()) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transferred up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }\n\n  /**\n   * Computes the destination node of n when we want to fallthrough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   */\n  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n.getFirstChild().getNext();\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n\n  /**\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   */\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n\n  /**\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   */\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (handler.isFunction()) {\n          return;\n        }\n        Preconditions.checkState(handler.isTry());\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n\n  /**\n   * Get the next sibling (including itself) of one of the given types.\n   */\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n    for (Node c = first; c != null; c = c.getNext()) {\n      for (int type : types) {\n        if (c.getType() == type) {\n          return c;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   */\n  public static boolean isBreakTarget(Node target, String label) {\n    return isBreakStructure(target, label != null) &&\n      matchLabel(target.getParent(), label);\n  }\n\n  /**\n   * Checks if target is actually the continue target of labeled continue. The\n   * label can be null if it is an unlabeled continue.\n   */\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n    return isContinueStructure(target) && matchLabel(parent, label);\n  }\n  /**\n   * Check if label is actually referencing the target control structure. If\n   * label is null, it always returns true.\n   */\n  private static boolean matchLabel(Node target, String label) {\n    if (label == null) {\n      return true;\n    }\n    while (target.isLabel()) {\n      if (target.getFirstChild().getString().equals(label)) {\n        return true;\n      }\n      target = target.getParent();\n    }\n    return false;\n  }\n\n  /**\n   * Determines if the subtree might throw an exception.\n   */\n  public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether the given node can be terminated with a BREAK node.\n   */\n  static boolean isBreakStructure(Node n, boolean labeled) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.SWITCH:\n        return true;\n      case Token.BLOCK:\n      case Token.IF:\n      case Token.TRY:\n        return labeled;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Determines whether the given node can be advanced with a CONTINUE node.\n   */\n  static boolean isContinueStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Get the TRY block with a CATCH that would be run if n throws an exception.\n   * @return The CATCH node or null if it there isn't a CATCH before the\n   *     the function terminates.\n   */\n  static Node getExceptionHandler(Node n) {\n    for (Node cur = n;\n        !cur.isScript() && !cur.isFunction();\n        cur = cur.getParent()) {\n      Node catchNode = getCatchHandlerForBlock(cur);\n      if (catchNode != null) {\n        return catchNode;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Locate the catch BLOCK given the first block in a TRY.\n   * @return The CATCH node or null there is no catch handler.\n   */\n  static Node getCatchHandlerForBlock(Node block) {\n    if (block.isBlock() &&\n        block.getParent().isTry() &&\n        block.getParent().getFirstChild() == block) {\n      for (Node s = block.getNext(); s != null; s = s.getNext()) {\n        if (NodeUtil.hasCatchHandler(s)) {\n          return s.getFirstChild();\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * A {@link ControlFlowGraph} which provides a node comparator based on the\n   * pre-order traversal of the AST.\n   */\n  private static class AstControlFlowGraph extends ControlFlowGraph<Node> {\n    private final Map<DiGraphNode<Node, Branch>, Integer> priorities;\n\n    /**\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     */\n    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities,\n        boolean edgeAnnotations) {\n      super(entry,\n          true /* node annotations */, edgeAnnotations);\n      this.priorities = priorities;\n    }\n\n    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }\n\n    /**\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     */\n    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }\n  }\n}\n"}}
{"bug_id": "Closure_16", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.ScopedAliases#hotSwapScript(Node#root,Node#originalRoot)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_16/fixed/src/com/google/javascript/jscomp/ScopedAliases.java", "focal_method": "@Override\n  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n        aliasUsage.applyAlias();\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }", "return_type": "void", "assertion_subject_candidates": [], "focal_class": {"name": "ScopedAliases", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_16/fixed/src/com/google/javascript/jscomp/ScopedAliases.java", "superclass": "", "interface": "implements HotSwapCompilerPass", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Sets;", "import com.google.javascript.jscomp.CompilerOptions.AliasTransformation;", "import com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.SourcePosition;", "import com.google.javascript.rhino.Token;", "import java.util.Collection;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;", "import javax.annotation.Nullable;"], "fields": ["static final String SCOPING_METHOD_NAME = \"goog.scope\"", "private final AbstractCompiler compiler", "private final PreprocessorSymbolTable preprocessorSymbolTable", "private final AliasTransformationHandler transformationHandler", "static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USED_IMPROPERLY\",\n      \"The call to goog.scope must be alone in a single statement.\")", "static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error(\n          \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\",\n          \"The call to goog.scope must take only a single parameter.  It must\" +\n              \" be an anonymous function that itself takes no parameters.\")", "static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_REFERENCES_THIS\",\n      \"The body of a goog.scope function cannot reference 'this'.\")", "static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_RETURN\",\n      \"The body of a goog.scope function cannot use 'return'.\")", "static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_THROW\",\n      \"The body of a goog.scope function cannot use 'throw'.\")", "static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\",\n      \"The alias {0} is assigned a value more than once.\")", "static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\",\n      \"The local variable {0} is in a goog.scope and is not an alias.\")"], "methods": ["void com.google.javascript.jscomp.ScopedAliases#process(Node#externs,Node#root)"], "other_methods": ["@Override\n  public void process(Node externs,Node root);"], "fields_dict": {"String#SCOPING_METHOD_NAME": "static final String SCOPING_METHOD_NAME = \"goog.scope\"", "AbstractCompiler#compiler": "private final AbstractCompiler compiler", "PreprocessorSymbolTable#preprocessorSymbolTable": "private final PreprocessorSymbolTable preprocessorSymbolTable", "AliasTransformationHandler#transformationHandler": "private final AliasTransformationHandler transformationHandler", "DiagnosticType#GOOG_SCOPE_USED_IMPROPERLY": "static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USED_IMPROPERLY\",\n      \"The call to goog.scope must be alone in a single statement.\")", "DiagnosticType#GOOG_SCOPE_HAS_BAD_PARAMETERS": "static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS = DiagnosticType.error(\n          \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\",\n          \"The call to goog.scope must take only a single parameter.  It must\" +\n              \" be an anonymous function that itself takes no parameters.\")", "DiagnosticType#GOOG_SCOPE_REFERENCES_THIS": "static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_REFERENCES_THIS\",\n      \"The body of a goog.scope function cannot reference 'this'.\")", "DiagnosticType#GOOG_SCOPE_USES_RETURN": "static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_RETURN\",\n      \"The body of a goog.scope function cannot use 'return'.\")", "DiagnosticType#GOOG_SCOPE_USES_THROW": "static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_THROW\",\n      \"The body of a goog.scope function cannot use 'throw'.\")", "DiagnosticType#GOOG_SCOPE_ALIAS_REDEFINED": "static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\",\n      \"The alias {0} is assigned a value more than once.\")", "DiagnosticType#GOOG_SCOPE_NON_ALIAS_LOCAL": "static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\",\n      \"The local variable {0} is in a goog.scope and is not an alias.\")"}, "text": "/*\n * Copyright 2010 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.CompilerOptions.AliasTransformation;\nimport com.google.javascript.jscomp.CompilerOptions.AliasTransformationHandler;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.SourcePosition;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.annotation.Nullable;\n\n/**\n * Process aliases in goog.scope blocks.\n *\n * goog.scope(function() {\n *   var dom = goog.dom;\n *   var DIV = dom.TagName.DIV;\n *\n *   dom.createElement(DIV);\n * });\n *\n * should become\n *\n * goog.dom.createElement(goog.dom.TagName.DIV);\n *\n * @author robbyw@google.com (Robby Walker)\n */\nclass ScopedAliases implements HotSwapCompilerPass {\n  /** Name used to denote an scoped function block used for aliasing. */\n  static final String SCOPING_METHOD_NAME = \"goog.scope\";\n\n  private final AbstractCompiler compiler;\n  private final PreprocessorSymbolTable preprocessorSymbolTable;\n  private final AliasTransformationHandler transformationHandler;\n\n  // Errors\n  static final DiagnosticType GOOG_SCOPE_USED_IMPROPERLY = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USED_IMPROPERLY\",\n      \"The call to goog.scope must be alone in a single statement.\");\n\n  static final DiagnosticType GOOG_SCOPE_HAS_BAD_PARAMETERS =\n      DiagnosticType.error(\n          \"JSC_GOOG_SCOPE_HAS_BAD_PARAMETERS\",\n          \"The call to goog.scope must take only a single parameter.  It must\" +\n              \" be an anonymous function that itself takes no parameters.\");\n\n  static final DiagnosticType GOOG_SCOPE_REFERENCES_THIS = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_REFERENCES_THIS\",\n      \"The body of a goog.scope function cannot reference 'this'.\");\n\n  static final DiagnosticType GOOG_SCOPE_USES_RETURN = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_RETURN\",\n      \"The body of a goog.scope function cannot use 'return'.\");\n\n  static final DiagnosticType GOOG_SCOPE_USES_THROW = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_USES_THROW\",\n      \"The body of a goog.scope function cannot use 'throw'.\");\n\n  static final DiagnosticType GOOG_SCOPE_ALIAS_REDEFINED = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_ALIAS_REDEFINED\",\n      \"The alias {0} is assigned a value more than once.\");\n\n  static final DiagnosticType GOOG_SCOPE_NON_ALIAS_LOCAL = DiagnosticType.error(\n      \"JSC_GOOG_SCOPE_NON_ALIAS_LOCAL\",\n      \"The local variable {0} is in a goog.scope and is not an alias.\");\n\n  ScopedAliases(AbstractCompiler compiler,\n      @Nullable PreprocessorSymbolTable preprocessorSymbolTable,\n      AliasTransformationHandler transformationHandler) {\n    this.compiler = compiler;\n    this.preprocessorSymbolTable = preprocessorSymbolTable;\n    this.transformationHandler = transformationHandler;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    hotSwapScript(root, null);\n  }\n\n  @Override\n  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n        aliasUsage.applyAlias();\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }\n\n  private interface AliasUsage {\n    public void applyAlias();\n  }\n\n  private class AliasedNode implements AliasUsage {\n    private final Node aliasReference;\n\n    private final Node aliasDefinition;\n\n    AliasedNode(Node aliasReference, Node aliasDefinition) {\n      this.aliasReference = aliasReference;\n      this.aliasDefinition = aliasDefinition;\n    }\n\n    @Override\n    public void applyAlias() {\n      aliasReference.getParent().replaceChild(\n          aliasReference, aliasDefinition.cloneTree());\n    }\n  }\n\n  private class AliasedTypeNode implements AliasUsage {\n    private final Node typeReference;\n    private final Node aliasDefinition;\n    private final String aliasName;\n\n    AliasedTypeNode(Node typeReference, Node aliasDefinition,\n        String aliasName) {\n      this.typeReference = typeReference;\n      this.aliasDefinition = aliasDefinition;\n      this.aliasName = aliasName;\n    }\n\n    @Override\n    public void applyAlias() {\n      String typeName = typeReference.getString();\n      String aliasExpanded =\n          Preconditions.checkNotNull(aliasDefinition.getQualifiedName());\n      Preconditions.checkState(typeName.startsWith(aliasName));\n      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));\n    }\n  }\n\n\n  private class Traversal implements NodeTraversal.ScopedCallback {\n    // The job of this class is to collect these three data sets.\n\n    // The order of this list determines the order that aliases are applied.\n    private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList();\n\n    private final List<Node> scopeCalls = Lists.newArrayList();\n\n    private final List<AliasUsage> aliasUsages = Lists.newArrayList();\n\n    // This map is temporary and cleared for each scope.\n    private final Map<String, Var> aliases = Maps.newHashMap();\n\n    // Suppose you create an alias.\n    // var x = goog.x;\n    // As a side-effect, this means you can shadow the namespace 'goog'\n    // in inner scopes. When we inline the namespaces, we have to rename\n    // these shadows.\n    //\n    // Fortunately, we already have a name uniquifier that runs during tree\n    // normalization (before optimizations). We run it here on a limited\n    // set of variables, but only as a last resort (because this will screw\n    // up warning messages downstream).\n    private final Set<String> forbiddenLocals = Sets.newHashSet();\n    private boolean hasNamespaceShadows = false;\n\n    private boolean hasErrors = false;\n\n    private AliasTransformation transformation = null;\n\n    Collection<Node> getAliasDefinitionsInOrder() {\n      return aliasDefinitionsInOrder;\n    }\n\n    private List<AliasUsage> getAliasUsages() {\n      return aliasUsages;\n    }\n\n    List<Node> getScopeCalls() {\n      return scopeCalls;\n    }\n\n    boolean hasErrors() {\n      return hasErrors;\n    }\n\n    private boolean isCallToScopeMethod(Node n) {\n      return n.isCall() &&\n          SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName());\n    }\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n        findAliases(t);\n      }\n    }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n      if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n      }\n\n      if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n      }\n    }\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.isFunction() && t.inGlobalScope()) {\n        // Do not traverse in to functions except for goog.scope functions.\n        if (parent == null || !isCallToScopeMethod(parent)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private SourcePosition<AliasTransformation> getSourceRegion(Node n) {\n      Node testNode = n;\n      Node next = null;\n      for (; next != null || testNode.isScript();) {\n        next = testNode.getNext();\n        testNode = testNode.getParent();\n      }\n\n      int endLine = next == null ? Integer.MAX_VALUE : next.getLineno();\n      int endChar = next == null ? Integer.MAX_VALUE : next.getCharno();\n      SourcePosition<AliasTransformation> pos =\n          new SourcePosition<AliasTransformation>() {};\n      pos.setPositionInformation(\n          n.getLineno(), n.getCharno(), endLine, endChar);\n      return pos;\n    }\n\n    private void report(NodeTraversal t, Node n, DiagnosticType error,\n        String... arguments) {\n      compiler.report(t.makeError(n, error, arguments));\n      hasErrors = true;\n    }\n\n    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        int type = n.getType();\n        Node parent = n.getParent();\n        if (parent.isVar() &&\n            n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n          String name = n.getString();\n          Var aliasVar = scope.getVar(name);\n          aliases.put(name, aliasVar);\n\n          String qualifiedName =\n              aliasVar.getInitialValue().getQualifiedName();\n          transformation.addAlias(name, qualifiedName);\n\n          int rootIndex = qualifiedName.indexOf(\".\");\n          if (rootIndex != -1) {\n            String qNameRoot = qualifiedName.substring(0, rootIndex);\n            if (!aliases.containsKey(qNameRoot)) {\n              forbiddenLocals.add(qNameRoot);\n            }\n          }\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else {\n          // TODO(robbyw): Support using locals for private variables.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }\n\n    /** Find out if there are any local shadows of namespaces. */\n    private void findNamespaceShadows(NodeTraversal t) {\n      if (hasNamespaceShadows) {\n        return;\n      }\n\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        if (forbiddenLocals.contains(v.getName())) {\n          hasNamespaceShadows = true;\n          return;\n        }\n      }\n    }\n\n    /**\n     * Rename any local shadows of namespaces.\n     * This should be a very rare occurrence, so only do this traversal\n     * if we know that we need it.\n     */\n    private void renameNamespaceShadows(NodeTraversal t) {\n      if (hasNamespaceShadows) {\n        MakeDeclaredNamesUnique.Renamer renamer =\n            new MakeDeclaredNamesUnique.WhitelistedRenamer(\n                new MakeDeclaredNamesUnique.ContextualRenamer(),\n                forbiddenLocals);\n        for (String s : forbiddenLocals) {\n          renamer.addDeclaredName(s);\n        }\n        MakeDeclaredNamesUnique uniquifier =\n            new MakeDeclaredNamesUnique(renamer);\n        NodeTraversal.traverse(compiler, t.getScopeRoot(), uniquifier);\n      }\n    }\n\n    private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n      if (preprocessorSymbolTable != null) {\n        preprocessorSymbolTable.addReference(n.getFirstChild());\n      }\n      if (!parent.isExprResult()) {\n        report(t, n, GOOG_SCOPE_USED_IMPROPERLY);\n      }\n      if (n.getChildCount() != 2) {\n        // The goog.scope call should have exactly 1 parameter.  The first\n        // child is the \"goog.scope\" and the second should be the parameter.\n        report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n      } else {\n        Node anonymousFnNode = n.getChildAtIndex(1);\n        if (!anonymousFnNode.isFunction() ||\n            NodeUtil.getFunctionName(anonymousFnNode) != null ||\n            NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {\n          report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n        } else {\n          scopeCalls.add(n);\n        }\n      }\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n      if (t.getScopeDepth() < 2) {\n        return;\n      }\n\n      int type = n.getType();\n      Var aliasVar = null;\n      if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n          aliasVar = lexicalVar;\n        }\n      }\n\n      // Validate the top-level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n          if (aliasVar.getNode() == n) {\n            aliasDefinitionsInOrder.add(n);\n\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n          }\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedNode(n, aliasedNode));\n        }\n\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }\n\n    private void fixTypeNode(Node typeNode) {\n      if (typeNode.isString()) {\n        String name = typeNode.getString();\n        int endIndex = name.indexOf('.');\n        if (endIndex == -1) {\n          endIndex = name.length();\n        }\n        String baseName = name.substring(0, endIndex);\n        Var aliasVar = aliases.get(baseName);\n        if (aliasVar != null) {\n          Node aliasedNode = aliasVar.getInitialValue();\n          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));\n        }\n      }\n\n      for (Node child = typeNode.getFirstChild(); child != null;\n           child = child.getNext()) {\n        fixTypeNode(child);\n      }\n    }\n  }\n}\n"}}
{"bug_id": "Closure_103", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.ControlFlowAnalysis#process(Node#externs,Node#root)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_103/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "focal_method": "@Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.getType() == Token.FUNCTION) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }", "return_type": "void", "assertion_subject_candidates": ["ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()"], "focal_class": {"name": "ControlFlowAnalysis", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_103/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "superclass": "", "interface": "implements Callback, CompilerPass", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.collect.HashMultimap;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Multimap;", "import com.google.javascript.jscomp.ControlFlowGraph.Branch;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.ArrayDeque;", "import java.util.Comparator;", "import java.util.Deque;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.PriorityQueue;"], "fields": ["private final AbstractCompiler compiler", "private ControlFlowGraph<Node> cfg", "private Map<Node, Integer> astPosition", "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "private int astPositionCounter", "private int priorityCounter", "private final boolean shouldTraverseFunctions", "private Node root", "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"], "methods": ["ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()", "void com.google.javascript.jscomp.ControlFlowAnalysis#prioritizeFromEntryNode(DiGraphNode<Node, Branch>#entry)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#shouldTraverse(NodeTraversal#nodeTraversal,Node#n,Node#parent)", "void com.google.javascript.jscomp.ControlFlowAnalysis#visit(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleIf(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWhile(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDo(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFor(Node#forNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleSwitch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCase(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDefault(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWith(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmtList(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFunction(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleExpr(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleThrow(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleTry(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCatch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleBreak(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleContinue(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleReturn(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmt(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#fromNode,Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFallThrough(Node#n)", "void com.google.javascript.jscomp.ControlFlowAnalysis#createEdge(Node#fromNode,ControlFlowGraph.Branch#branch,Node#toNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#connectToPossibleExceptionHandler(Node#cfgNode,Node#target)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getNextSiblingOfType(Node#first,#int ... types)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakTarget(Node#target,Node#parent,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueTarget(Node#target,Node#parent,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#matchLabel(Node#target,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#mayThrowException(Node#n)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakStructure(Node#n,boolean#labeled)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueStructure(Node#n)"], "other_methods": ["@Override\n  public boolean shouldTraverse(NodeTraversal nodeTraversal,Node n,Node parent);", "@Override\n  public void visit(NodeTraversal t,Node n,Node parent);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "ControlFlowGraph<Node>#cfg": "private ControlFlowGraph<Node> cfg", "Map<Node, Integer>#astPosition": "private Map<Node, Integer> astPosition", "Map<DiGraphNode<Node, Branch>, Integer>#nodePriorities": "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "Comparator<DiGraphNode<Node, Branch>>#priorityComparator": "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "int#astPositionCounter": "private int astPositionCounter", "int#priorityCounter": "private int priorityCounter", "boolean#shouldTraverseFunctions": "private final boolean shouldTraverseFunctions", "Node#root": "private Node root", "Deque<Node>#exceptionHandler": "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "Multimap<Node, Node>#finallyMap": "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"}, "text": "/*\n * Copyright 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.ArrayDeque;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\n/**\n * This is a compiler pass that computes a control flow graph.\n *\n*\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n\n  /**\n   * Based roughly on the first few pages of\n   *\n   * \"Declarative Intraprocedural Flow Analysis of Java Source Code by\n   * Nilsson-Nyman, Hedin, Magnusson & Ekman\",\n   *\n   * this pass computes the control flow graph from the AST. However, a full\n   * attribute grammar is not necessary. We will compute the flow edges with a\n   * single post order traversal. The \"follow()\" of a given node will be\n   * computed recursively in a demand driven fashion.\n   *\n   * As of this moment, we are not performing any inter-procedural analysis\n   * within our framework.\n   */\n\n  private final AbstractCompiler compiler;\n\n  private ControlFlowGraph<Node> cfg;\n\n  private Map<Node, Integer> astPosition;\n\n  // TODO(nicksantos): should these be node annotations?\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n\n  // We order CFG nodes by by looking at the AST positions.\n  // CFG nodes that come first lexically should be visited first, because\n  // they will often be executed first in the source program.\n  private final Comparator<DiGraphNode<Node, Branch>> priorityComparator =\n      new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  };\n\n  private int astPositionCounter;\n  private int priorityCounter;\n\n  private final boolean shouldTraverseFunctions;\n\n  // We need to store where we started, in case we aren't doing a flow analysis\n  // for the whole scope. This happens, for example, when running type inference\n  // on only the externs.\n  private Node root;\n\n  /*\n   * This stack captures the structure of nested TRY blocks. The top of the\n   * stack is the inner most TRY block. A FUNCTION node in this stack implies\n   * that the handler is determined by the caller of the function at runtime.\n   */\n  private final Deque<Node> exceptionHandler = new ArrayDeque<Node>();\n\n  /*\n   * This map is used to handle the follow of FINALLY. For example:\n   *\n   * while(x) {\n   *  try {\n   *    try {\n   *      break;\n   *    } catch (a) {\n   *    } finally {\n   *      foo();\n   *    }\n   *    fooFollow();\n   *  } catch (b) {\n   *  } finally {\n   *    bar();\n   *  }\n   *  barFollow();\n   * }\n   * END();\n   *\n   * In this case finallyMap will contain a map from:\n   *    first FINALLY -> bar()\n   *    second FINALLY -> END()\n   *\n   * When we are connecting foo() and bar() to to their respective follow, we\n   * must also look up this map and connect:\n   *   foo() -> bar()\n   *   bar() -> END\n   */\n  private final Multimap<Node, Node> finallyMap = HashMultimap.create();\n\n  /**\n   * Constructor.\n   *\n   * @param compiler Compiler instance.\n   * @param shouldTraverseFunctions Whether functions should be traversed (true\n   *    by default).\n   */\n  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n  }\n\n  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.getType() == Token.FUNCTION) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }\n\n  /**\n   * Given an entry node, find all the nodes reachable from that node\n   * and prioritize them.\n   */\n  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }\n\n  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }\n\n  private void handleIf(Node node) {\n    Node thenBlock = node.getFirstChild().getNext();\n    Node elseBlock = thenBlock.getNext();\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));\n\n    if (elseBlock == null) {\n      createEdge(node, Branch.ON_FALSE,\n          computeFollowNode(node)); // not taken branch\n    } else {\n      createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n    }\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleWhile(Node node) {\n    // Control goes to the first statement if the condition evaluates to true.\n    createEdge(node, Branch.ON_TRUE,\n        computeFallThrough(node.getFirstChild().getNext()));\n\n    // Control goes to the follow() if the condition evaluates to false.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleDo(Node node) {\n    // The first edge can be the initial iteration as well as the iterations\n    // after.\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild()));\n    // The edge that leaves the do loop if the condition fails.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleFor(Node forNode) {\n    if (forNode.getChildCount() == 4) {\n      // We have for (init; cond; iter) { body }\n      Node init = forNode.getFirstChild();\n      Node cond = init.getNext();\n      Node iter = cond.getNext();\n      Node body = iter.getNext();\n      // After initialization, we transfer to the FOR which is in charge of\n      // checking the condition (for the first time).\n      createEdge(init, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode));\n      // The end of the body will have a unconditional branch to our iter\n      // (handled by calling computeFollowNode of the last instruction of the\n      // body. Our iter will jump to the forNode again to another condition\n      // check.\n      createEdge(iter, Branch.UNCOND, forNode);\n      connectToPossibleExceptionHandler(init, init);\n      connectToPossibleExceptionHandler(forNode, cond);\n      connectToPossibleExceptionHandler(iter, iter);\n    } else {\n      // We have for (item in collection) { body }\n      Node item = forNode.getFirstChild();\n      Node collection = item.getNext();\n      Node body = collection.getNext();\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode));\n      connectToPossibleExceptionHandler(forNode, collection);\n    }\n  }\n\n  private void handleSwitch(Node node) {\n    // Transfer to the first non-DEFAULT CASE. if there are none, transfer\n    // to the DEFAULT or the EMPTY node.\n    Node next = getNextSiblingOfType(\n        node.getFirstChild().getNext(), Token.CASE, Token.EMPTY);\n    if (next != null) { // Has at least one CASE or EMPTY\n      createEdge(node, Branch.UNCOND, next);\n    } else { // Has no CASE but possibly a DEFAULT\n      if (node.getFirstChild().getNext() != null) {\n        createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());\n      } else { // No CASE, no DEFAULT\n        createEdge(node, Branch.UNCOND, computeFollowNode(node));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleCase(Node node) {\n    // Case is a bit tricky....First it goes into the body if condition is true.\n    createEdge(node, Branch.ON_TRUE,\n        node.getFirstChild().getNext());\n    // Look for the next CASE, skipping over DEFAULT.\n    Node next = getNextSiblingOfType(node.getNext(), Token.CASE);\n    if (next != null) { // Found a CASE\n      Preconditions.checkState(next.getType() == Token.CASE);\n      createEdge(node, Branch.ON_FALSE, next);\n    } else { // No more CASE found, go back and search for a DEFAULT.\n      Node parent = node.getParent();\n      Node deflt = getNextSiblingOfType(\n        parent.getFirstChild().getNext(), Token.DEFAULT);\n      if (deflt != null) { // Has a DEFAULT\n        createEdge(node, Branch.ON_FALSE, deflt);\n      } else { // No DEFAULT found, go to the follow of the SWITCH.\n        createEdge(node, Branch.ON_FALSE, computeFollowNode(node));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleDefault(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleWith(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.getType() == Token.BLOCK && parent != null &&\n        parent.getType() == Token.TRY &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.getType() == Token.FUNCTION) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.getType() == Token.BLOCK && node.isSyntheticBlock()) {\n            Node next = node.getLastChild();\n            if (next != null) {\n              createEdge(node, Branch.SYN_BLOCK, computeFallThrough(next));\n            }\n          }\n          break;\n      }\n    }\n  }\n\n  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }\n\n  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleThrow(Node node) {\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleTry(Node node) {\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleCatch(Node node) {\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n  }\n\n  private void handleBreak(Node node) {\n    String label = null;\n    // See if it is a break with label.\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node lastJump;\n    Node parent = node.getParent();\n    /*\n     * Continuously look up the ancestor tree for the BREAK target or the target\n     * with the corresponding label and connect to it. If along the path we\n     * discover a FINALLY, we will connect the BREAK to that FINALLY. From then\n     * on, we will just record the control flow changes in the finallyMap. This\n     * is due to the fact that we need to connect any node that leaves its own\n     * FINALLY block to the outer FINALLY or the BREAK's target but those nodes\n     * are not known yet due to the way we traverse the nodes.\n     */\n    for (cur = node, lastJump = node;\n        !isBreakTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, computeFallThrough(\n              cur.getLastChild()));\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find break target.\");\n    }\n    if (lastJump == node) {\n      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur));\n    } else {\n      finallyMap.put(lastJump, computeFollowNode(cur));\n    }\n  }\n\n  private void handleContinue(Node node) {\n    String label = null;\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node lastJump;\n    // Similar to handBreak's logic with a few minor variation.\n    Node parent = node.getParent();\n    for (cur = node, lastJump = node;\n        !isContinueTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, cur.getLastChild());\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find continue target.\");\n    }\n    Node iter = cur;\n    if (cur.getChildCount() == 4) {\n      iter = cur.getFirstChild().getNext().getNext();\n    }\n\n    if (lastJump == node) {\n      createEdge(node, Branch.UNCOND, iter);\n    } else {\n      finallyMap.put(lastJump, iter);\n    }\n  }\n\n  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (NodeUtil.isFunction(curHandler)) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }\n\n  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private Node computeFollowNode(Node node) {\n    return computeFollowNode(node, node);\n  }\n\n  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private Node computeFollowNode(Node fromNode, Node node) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.getType() == Token.FUNCTION || node == root) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent);\n      case Token.CASE:\n      case Token.DEFAULT:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().getType() == Token.CASE) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().getType() == Token.DEFAULT) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          for (Node finallyNode : finallyMap.get(parent)) {\n            createEdge(fromNode, Branch.UNCOND, finallyNode);\n          }\n          return computeFollowNode(fromNode, parent);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.getType() == Token.FUNCTION) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transfered up the AST.\n      return computeFollowNode(fromNode, parent);\n    }\n  }\n\n  /**\n   * Computes the destination node of n when we want to fallthough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   */\n  private static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n;\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n\n  /**\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   */\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n\n  /**\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   */\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (NodeUtil.isFunction(handler)) {\n          return;\n        }\n        Preconditions.checkState(handler.getType() == Token.TRY);\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n\n  /**\n   * Get the next sibling (including itself) of one of the given types.\n   */\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n    for (Node c = first; c != null; c = c.getNext()) {\n      for (int type : types) {\n        if (c.getType() == type) {\n          return c;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   */\n  private static boolean isBreakTarget(\n      Node target, Node parent, String label) {\n    return isBreakStructure(target, label != null) && matchLabel(parent, label);\n  }\n\n  /**\n   * Checks if target is actually the continue target of labeled continue. The\n   * label can be null if it is an unlabeled continue.\n   */\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n    return isContinueStructure(target) && matchLabel(parent, label);\n  }\n  /**\n   * Check if label is actually referencing the target control structure. If\n   * label is null, it always returns true.\n   */\n  private static boolean matchLabel(Node target, String label) {\n    if (label == null) {\n      return true;\n    }\n    while (target.getType() == Token.LABEL) {\n      if (target.getFirstChild().getString().equals(label)) {\n        return true;\n      }\n      target = target.getParent();\n    }\n    return false;\n  }\n\n  /**\n   * Determines if the subtree might throw an exception.\n   */\n  private static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether the given node can be terminated with a BREAK node.\n   */\n  static boolean isBreakStructure(Node n, boolean labeled) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.SWITCH:\n        return true;\n      case Token.BLOCK:\n      case Token.IF:\n      case Token.TRY:\n        return labeled;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Determines whether the given node can be advanced with a CONTINUE node.\n   */\n  static boolean isContinueStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * A {@link ControlFlowGraph} which provides a node comparator based on the\n   * pre-order traversal of the AST.\n   */\n  private static class AstControlFlowGraph extends ControlFlowGraph<Node> {\n    private final Map<DiGraphNode<Node, Branch>, Integer> priorities;\n\n    /**\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     */\n    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities) {\n      super(entry);\n      this.priorities = priorities;\n    }\n\n    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }\n\n    /**\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     */\n    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }\n  }\n}\n"}}
{"bug_id": "Closure_103", "version": "fixed", "focal_method_signature": "boolean com.google.javascript.jscomp.ControlFlowAnalysis#shouldTraverse(NodeTraversal#nodeTraversal,Node#n,Node#parent)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_103/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "focal_method": "@Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }", "return_type": "boolean", "assertion_subject_candidates": ["boolean", "ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()"], "focal_class": {"name": "ControlFlowAnalysis", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_103/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "superclass": "", "interface": "implements Callback, CompilerPass", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.collect.HashMultimap;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Multimap;", "import com.google.javascript.jscomp.ControlFlowGraph.Branch;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.ArrayDeque;", "import java.util.Comparator;", "import java.util.Deque;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.PriorityQueue;"], "fields": ["private final AbstractCompiler compiler", "private ControlFlowGraph<Node> cfg", "private Map<Node, Integer> astPosition", "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "private int astPositionCounter", "private int priorityCounter", "private final boolean shouldTraverseFunctions", "private Node root", "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"], "methods": ["ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()", "void com.google.javascript.jscomp.ControlFlowAnalysis#process(Node#externs,Node#root)", "void com.google.javascript.jscomp.ControlFlowAnalysis#prioritizeFromEntryNode(DiGraphNode<Node, Branch>#entry)", "void com.google.javascript.jscomp.ControlFlowAnalysis#visit(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleIf(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWhile(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDo(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFor(Node#forNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleSwitch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCase(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDefault(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWith(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmtList(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFunction(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleExpr(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleThrow(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleTry(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCatch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleBreak(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleContinue(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleReturn(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmt(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#fromNode,Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFallThrough(Node#n)", "void com.google.javascript.jscomp.ControlFlowAnalysis#createEdge(Node#fromNode,ControlFlowGraph.Branch#branch,Node#toNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#connectToPossibleExceptionHandler(Node#cfgNode,Node#target)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getNextSiblingOfType(Node#first,#int ... types)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakTarget(Node#target,Node#parent,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueTarget(Node#target,Node#parent,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#matchLabel(Node#target,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#mayThrowException(Node#n)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakStructure(Node#n,boolean#labeled)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueStructure(Node#n)"], "other_methods": ["@Override\n  public void process(Node externs,Node root);", "@Override\n  public void visit(NodeTraversal t,Node n,Node parent);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "ControlFlowGraph<Node>#cfg": "private ControlFlowGraph<Node> cfg", "Map<Node, Integer>#astPosition": "private Map<Node, Integer> astPosition", "Map<DiGraphNode<Node, Branch>, Integer>#nodePriorities": "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "Comparator<DiGraphNode<Node, Branch>>#priorityComparator": "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "int#astPositionCounter": "private int astPositionCounter", "int#priorityCounter": "private int priorityCounter", "boolean#shouldTraverseFunctions": "private final boolean shouldTraverseFunctions", "Node#root": "private Node root", "Deque<Node>#exceptionHandler": "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "Multimap<Node, Node>#finallyMap": "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"}, "text": "/*\n * Copyright 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.ArrayDeque;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\n/**\n * This is a compiler pass that computes a control flow graph.\n *\n*\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n\n  /**\n   * Based roughly on the first few pages of\n   *\n   * \"Declarative Intraprocedural Flow Analysis of Java Source Code by\n   * Nilsson-Nyman, Hedin, Magnusson & Ekman\",\n   *\n   * this pass computes the control flow graph from the AST. However, a full\n   * attribute grammar is not necessary. We will compute the flow edges with a\n   * single post order traversal. The \"follow()\" of a given node will be\n   * computed recursively in a demand driven fashion.\n   *\n   * As of this moment, we are not performing any inter-procedural analysis\n   * within our framework.\n   */\n\n  private final AbstractCompiler compiler;\n\n  private ControlFlowGraph<Node> cfg;\n\n  private Map<Node, Integer> astPosition;\n\n  // TODO(nicksantos): should these be node annotations?\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n\n  // We order CFG nodes by by looking at the AST positions.\n  // CFG nodes that come first lexically should be visited first, because\n  // they will often be executed first in the source program.\n  private final Comparator<DiGraphNode<Node, Branch>> priorityComparator =\n      new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  };\n\n  private int astPositionCounter;\n  private int priorityCounter;\n\n  private final boolean shouldTraverseFunctions;\n\n  // We need to store where we started, in case we aren't doing a flow analysis\n  // for the whole scope. This happens, for example, when running type inference\n  // on only the externs.\n  private Node root;\n\n  /*\n   * This stack captures the structure of nested TRY blocks. The top of the\n   * stack is the inner most TRY block. A FUNCTION node in this stack implies\n   * that the handler is determined by the caller of the function at runtime.\n   */\n  private final Deque<Node> exceptionHandler = new ArrayDeque<Node>();\n\n  /*\n   * This map is used to handle the follow of FINALLY. For example:\n   *\n   * while(x) {\n   *  try {\n   *    try {\n   *      break;\n   *    } catch (a) {\n   *    } finally {\n   *      foo();\n   *    }\n   *    fooFollow();\n   *  } catch (b) {\n   *  } finally {\n   *    bar();\n   *  }\n   *  barFollow();\n   * }\n   * END();\n   *\n   * In this case finallyMap will contain a map from:\n   *    first FINALLY -> bar()\n   *    second FINALLY -> END()\n   *\n   * When we are connecting foo() and bar() to to their respective follow, we\n   * must also look up this map and connect:\n   *   foo() -> bar()\n   *   bar() -> END\n   */\n  private final Multimap<Node, Node> finallyMap = HashMultimap.create();\n\n  /**\n   * Constructor.\n   *\n   * @param compiler Compiler instance.\n   * @param shouldTraverseFunctions Whether functions should be traversed (true\n   *    by default).\n   */\n  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n  }\n\n  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.getType() == Token.FUNCTION) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }\n\n  /**\n   * Given an entry node, find all the nodes reachable from that node\n   * and prioritize them.\n   */\n  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }\n\n  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }\n\n  private void handleIf(Node node) {\n    Node thenBlock = node.getFirstChild().getNext();\n    Node elseBlock = thenBlock.getNext();\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));\n\n    if (elseBlock == null) {\n      createEdge(node, Branch.ON_FALSE,\n          computeFollowNode(node)); // not taken branch\n    } else {\n      createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n    }\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleWhile(Node node) {\n    // Control goes to the first statement if the condition evaluates to true.\n    createEdge(node, Branch.ON_TRUE,\n        computeFallThrough(node.getFirstChild().getNext()));\n\n    // Control goes to the follow() if the condition evaluates to false.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleDo(Node node) {\n    // The first edge can be the initial iteration as well as the iterations\n    // after.\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild()));\n    // The edge that leaves the do loop if the condition fails.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleFor(Node forNode) {\n    if (forNode.getChildCount() == 4) {\n      // We have for (init; cond; iter) { body }\n      Node init = forNode.getFirstChild();\n      Node cond = init.getNext();\n      Node iter = cond.getNext();\n      Node body = iter.getNext();\n      // After initialization, we transfer to the FOR which is in charge of\n      // checking the condition (for the first time).\n      createEdge(init, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode));\n      // The end of the body will have a unconditional branch to our iter\n      // (handled by calling computeFollowNode of the last instruction of the\n      // body. Our iter will jump to the forNode again to another condition\n      // check.\n      createEdge(iter, Branch.UNCOND, forNode);\n      connectToPossibleExceptionHandler(init, init);\n      connectToPossibleExceptionHandler(forNode, cond);\n      connectToPossibleExceptionHandler(iter, iter);\n    } else {\n      // We have for (item in collection) { body }\n      Node item = forNode.getFirstChild();\n      Node collection = item.getNext();\n      Node body = collection.getNext();\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode));\n      connectToPossibleExceptionHandler(forNode, collection);\n    }\n  }\n\n  private void handleSwitch(Node node) {\n    // Transfer to the first non-DEFAULT CASE. if there are none, transfer\n    // to the DEFAULT or the EMPTY node.\n    Node next = getNextSiblingOfType(\n        node.getFirstChild().getNext(), Token.CASE, Token.EMPTY);\n    if (next != null) { // Has at least one CASE or EMPTY\n      createEdge(node, Branch.UNCOND, next);\n    } else { // Has no CASE but possibly a DEFAULT\n      if (node.getFirstChild().getNext() != null) {\n        createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());\n      } else { // No CASE, no DEFAULT\n        createEdge(node, Branch.UNCOND, computeFollowNode(node));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleCase(Node node) {\n    // Case is a bit tricky....First it goes into the body if condition is true.\n    createEdge(node, Branch.ON_TRUE,\n        node.getFirstChild().getNext());\n    // Look for the next CASE, skipping over DEFAULT.\n    Node next = getNextSiblingOfType(node.getNext(), Token.CASE);\n    if (next != null) { // Found a CASE\n      Preconditions.checkState(next.getType() == Token.CASE);\n      createEdge(node, Branch.ON_FALSE, next);\n    } else { // No more CASE found, go back and search for a DEFAULT.\n      Node parent = node.getParent();\n      Node deflt = getNextSiblingOfType(\n        parent.getFirstChild().getNext(), Token.DEFAULT);\n      if (deflt != null) { // Has a DEFAULT\n        createEdge(node, Branch.ON_FALSE, deflt);\n      } else { // No DEFAULT found, go to the follow of the SWITCH.\n        createEdge(node, Branch.ON_FALSE, computeFollowNode(node));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleDefault(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleWith(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.getType() == Token.BLOCK && parent != null &&\n        parent.getType() == Token.TRY &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.getType() == Token.FUNCTION) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.getType() == Token.BLOCK && node.isSyntheticBlock()) {\n            Node next = node.getLastChild();\n            if (next != null) {\n              createEdge(node, Branch.SYN_BLOCK, computeFallThrough(next));\n            }\n          }\n          break;\n      }\n    }\n  }\n\n  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }\n\n  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleThrow(Node node) {\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleTry(Node node) {\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleCatch(Node node) {\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n  }\n\n  private void handleBreak(Node node) {\n    String label = null;\n    // See if it is a break with label.\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node lastJump;\n    Node parent = node.getParent();\n    /*\n     * Continuously look up the ancestor tree for the BREAK target or the target\n     * with the corresponding label and connect to it. If along the path we\n     * discover a FINALLY, we will connect the BREAK to that FINALLY. From then\n     * on, we will just record the control flow changes in the finallyMap. This\n     * is due to the fact that we need to connect any node that leaves its own\n     * FINALLY block to the outer FINALLY or the BREAK's target but those nodes\n     * are not known yet due to the way we traverse the nodes.\n     */\n    for (cur = node, lastJump = node;\n        !isBreakTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, computeFallThrough(\n              cur.getLastChild()));\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find break target.\");\n    }\n    if (lastJump == node) {\n      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur));\n    } else {\n      finallyMap.put(lastJump, computeFollowNode(cur));\n    }\n  }\n\n  private void handleContinue(Node node) {\n    String label = null;\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node lastJump;\n    // Similar to handBreak's logic with a few minor variation.\n    Node parent = node.getParent();\n    for (cur = node, lastJump = node;\n        !isContinueTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, cur.getLastChild());\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find continue target.\");\n    }\n    Node iter = cur;\n    if (cur.getChildCount() == 4) {\n      iter = cur.getFirstChild().getNext().getNext();\n    }\n\n    if (lastJump == node) {\n      createEdge(node, Branch.UNCOND, iter);\n    } else {\n      finallyMap.put(lastJump, iter);\n    }\n  }\n\n  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (NodeUtil.isFunction(curHandler)) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }\n\n  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private Node computeFollowNode(Node node) {\n    return computeFollowNode(node, node);\n  }\n\n  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private Node computeFollowNode(Node fromNode, Node node) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.getType() == Token.FUNCTION || node == root) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent);\n      case Token.CASE:\n      case Token.DEFAULT:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().getType() == Token.CASE) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().getType() == Token.DEFAULT) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          for (Node finallyNode : finallyMap.get(parent)) {\n            createEdge(fromNode, Branch.UNCOND, finallyNode);\n          }\n          return computeFollowNode(fromNode, parent);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.getType() == Token.FUNCTION) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transfered up the AST.\n      return computeFollowNode(fromNode, parent);\n    }\n  }\n\n  /**\n   * Computes the destination node of n when we want to fallthough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   */\n  private static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n;\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n\n  /**\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   */\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n\n  /**\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   */\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (NodeUtil.isFunction(handler)) {\n          return;\n        }\n        Preconditions.checkState(handler.getType() == Token.TRY);\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n\n  /**\n   * Get the next sibling (including itself) of one of the given types.\n   */\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n    for (Node c = first; c != null; c = c.getNext()) {\n      for (int type : types) {\n        if (c.getType() == type) {\n          return c;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   */\n  private static boolean isBreakTarget(\n      Node target, Node parent, String label) {\n    return isBreakStructure(target, label != null) && matchLabel(parent, label);\n  }\n\n  /**\n   * Checks if target is actually the continue target of labeled continue. The\n   * label can be null if it is an unlabeled continue.\n   */\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n    return isContinueStructure(target) && matchLabel(parent, label);\n  }\n  /**\n   * Check if label is actually referencing the target control structure. If\n   * label is null, it always returns true.\n   */\n  private static boolean matchLabel(Node target, String label) {\n    if (label == null) {\n      return true;\n    }\n    while (target.getType() == Token.LABEL) {\n      if (target.getFirstChild().getString().equals(label)) {\n        return true;\n      }\n      target = target.getParent();\n    }\n    return false;\n  }\n\n  /**\n   * Determines if the subtree might throw an exception.\n   */\n  private static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether the given node can be terminated with a BREAK node.\n   */\n  static boolean isBreakStructure(Node n, boolean labeled) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.SWITCH:\n        return true;\n      case Token.BLOCK:\n      case Token.IF:\n      case Token.TRY:\n        return labeled;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Determines whether the given node can be advanced with a CONTINUE node.\n   */\n  static boolean isContinueStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * A {@link ControlFlowGraph} which provides a node comparator based on the\n   * pre-order traversal of the AST.\n   */\n  private static class AstControlFlowGraph extends ControlFlowGraph<Node> {\n    private final Map<DiGraphNode<Node, Branch>, Integer> priorities;\n\n    /**\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     */\n    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities) {\n      super(entry);\n      this.priorities = priorities;\n    }\n\n    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }\n\n    /**\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     */\n    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }\n  }\n}\n"}}
{"bug_id": "Closure_103", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.ControlFlowAnalysis#visit(NodeTraversal#t,Node#n,Node#parent)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_103/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "focal_method": "@Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }", "return_type": "void", "assertion_subject_candidates": ["ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()"], "focal_class": {"name": "ControlFlowAnalysis", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_103/fixed/src/com/google/javascript/jscomp/ControlFlowAnalysis.java", "superclass": "", "interface": "implements Callback, CompilerPass", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.collect.HashMultimap;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Multimap;", "import com.google.javascript.jscomp.ControlFlowGraph.Branch;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.ArrayDeque;", "import java.util.Comparator;", "import java.util.Deque;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.PriorityQueue;"], "fields": ["private final AbstractCompiler compiler", "private ControlFlowGraph<Node> cfg", "private Map<Node, Integer> astPosition", "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "private int astPositionCounter", "private int priorityCounter", "private final boolean shouldTraverseFunctions", "private Node root", "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"], "methods": ["ControlFlowGraph<Node> com.google.javascript.jscomp.ControlFlowAnalysis#getCfg()", "void com.google.javascript.jscomp.ControlFlowAnalysis#process(Node#externs,Node#root)", "void com.google.javascript.jscomp.ControlFlowAnalysis#prioritizeFromEntryNode(DiGraphNode<Node, Branch>#entry)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#shouldTraverse(NodeTraversal#nodeTraversal,Node#n,Node#parent)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleIf(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWhile(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDo(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFor(Node#forNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleSwitch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCase(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleDefault(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleWith(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmtList(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleFunction(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleExpr(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleThrow(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleTry(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleCatch(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleBreak(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleContinue(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleReturn(Node#node)", "void com.google.javascript.jscomp.ControlFlowAnalysis#handleStmt(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFollowNode(Node#fromNode,Node#node)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#computeFallThrough(Node#n)", "void com.google.javascript.jscomp.ControlFlowAnalysis#createEdge(Node#fromNode,ControlFlowGraph.Branch#branch,Node#toNode)", "void com.google.javascript.jscomp.ControlFlowAnalysis#connectToPossibleExceptionHandler(Node#cfgNode,Node#target)", "Node com.google.javascript.jscomp.ControlFlowAnalysis#getNextSiblingOfType(Node#first,#int ... types)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakTarget(Node#target,Node#parent,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueTarget(Node#target,Node#parent,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#matchLabel(Node#target,String#label)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#mayThrowException(Node#n)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isBreakStructure(Node#n,boolean#labeled)", "boolean com.google.javascript.jscomp.ControlFlowAnalysis#isContinueStructure(Node#n)"], "other_methods": ["@Override\n  public void process(Node externs,Node root);", "@Override\n  public boolean shouldTraverse(NodeTraversal nodeTraversal,Node n,Node parent);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "ControlFlowGraph<Node>#cfg": "private ControlFlowGraph<Node> cfg", "Map<Node, Integer>#astPosition": "private Map<Node, Integer> astPosition", "Map<DiGraphNode<Node, Branch>, Integer>#nodePriorities": "private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities", "Comparator<DiGraphNode<Node, Branch>>#priorityComparator": "private final Comparator<DiGraphNode<Node, Branch>> priorityComparator = new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  }", "int#astPositionCounter": "private int astPositionCounter", "int#priorityCounter": "private int priorityCounter", "boolean#shouldTraverseFunctions": "private final boolean shouldTraverseFunctions", "Node#root": "private Node root", "Deque<Node>#exceptionHandler": "private final Deque<Node> exceptionHandler = new ArrayDeque<Node>()", "Multimap<Node, Node>#finallyMap": "private final Multimap<Node, Node> finallyMap = HashMultimap.create()"}, "text": "/*\n * Copyright 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.javascript.jscomp.ControlFlowGraph.Branch;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.ArrayDeque;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\n\n/**\n * This is a compiler pass that computes a control flow graph.\n *\n*\n */\nfinal class ControlFlowAnalysis implements Callback, CompilerPass {\n\n  /**\n   * Based roughly on the first few pages of\n   *\n   * \"Declarative Intraprocedural Flow Analysis of Java Source Code by\n   * Nilsson-Nyman, Hedin, Magnusson & Ekman\",\n   *\n   * this pass computes the control flow graph from the AST. However, a full\n   * attribute grammar is not necessary. We will compute the flow edges with a\n   * single post order traversal. The \"follow()\" of a given node will be\n   * computed recursively in a demand driven fashion.\n   *\n   * As of this moment, we are not performing any inter-procedural analysis\n   * within our framework.\n   */\n\n  private final AbstractCompiler compiler;\n\n  private ControlFlowGraph<Node> cfg;\n\n  private Map<Node, Integer> astPosition;\n\n  // TODO(nicksantos): should these be node annotations?\n  private Map<DiGraphNode<Node, Branch>, Integer> nodePriorities;\n\n  // We order CFG nodes by by looking at the AST positions.\n  // CFG nodes that come first lexically should be visited first, because\n  // they will often be executed first in the source program.\n  private final Comparator<DiGraphNode<Node, Branch>> priorityComparator =\n      new Comparator<DiGraphNode<Node, Branch>>() {\n    @Override\n    public int compare(\n        DiGraphNode<Node, Branch> a, DiGraphNode<Node, Branch> b) {\n      return astPosition.get(a.getValue()) - astPosition.get(b.getValue());\n    }\n  };\n\n  private int astPositionCounter;\n  private int priorityCounter;\n\n  private final boolean shouldTraverseFunctions;\n\n  // We need to store where we started, in case we aren't doing a flow analysis\n  // for the whole scope. This happens, for example, when running type inference\n  // on only the externs.\n  private Node root;\n\n  /*\n   * This stack captures the structure of nested TRY blocks. The top of the\n   * stack is the inner most TRY block. A FUNCTION node in this stack implies\n   * that the handler is determined by the caller of the function at runtime.\n   */\n  private final Deque<Node> exceptionHandler = new ArrayDeque<Node>();\n\n  /*\n   * This map is used to handle the follow of FINALLY. For example:\n   *\n   * while(x) {\n   *  try {\n   *    try {\n   *      break;\n   *    } catch (a) {\n   *    } finally {\n   *      foo();\n   *    }\n   *    fooFollow();\n   *  } catch (b) {\n   *  } finally {\n   *    bar();\n   *  }\n   *  barFollow();\n   * }\n   * END();\n   *\n   * In this case finallyMap will contain a map from:\n   *    first FINALLY -> bar()\n   *    second FINALLY -> END()\n   *\n   * When we are connecting foo() and bar() to to their respective follow, we\n   * must also look up this map and connect:\n   *   foo() -> bar()\n   *   bar() -> END\n   */\n  private final Multimap<Node, Node> finallyMap = HashMultimap.create();\n\n  /**\n   * Constructor.\n   *\n   * @param compiler Compiler instance.\n   * @param shouldTraverseFunctions Whether functions should be traversed (true\n   *    by default).\n   */\n  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n  }\n\n  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.getType() == Token.FUNCTION) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }\n\n  /**\n   * Given an entry node, find all the nodes reachable from that node\n   * and prioritize them.\n   */\n  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }\n\n  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }\n\n  private void handleIf(Node node) {\n    Node thenBlock = node.getFirstChild().getNext();\n    Node elseBlock = thenBlock.getNext();\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));\n\n    if (elseBlock == null) {\n      createEdge(node, Branch.ON_FALSE,\n          computeFollowNode(node)); // not taken branch\n    } else {\n      createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n    }\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleWhile(Node node) {\n    // Control goes to the first statement if the condition evaluates to true.\n    createEdge(node, Branch.ON_TRUE,\n        computeFallThrough(node.getFirstChild().getNext()));\n\n    // Control goes to the follow() if the condition evaluates to false.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleDo(Node node) {\n    // The first edge can be the initial iteration as well as the iterations\n    // after.\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(node.getFirstChild()));\n    // The edge that leaves the do loop if the condition fails.\n    createEdge(node, Branch.ON_FALSE,\n        computeFollowNode(node));\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }\n\n  private void handleFor(Node forNode) {\n    if (forNode.getChildCount() == 4) {\n      // We have for (init; cond; iter) { body }\n      Node init = forNode.getFirstChild();\n      Node cond = init.getNext();\n      Node iter = cond.getNext();\n      Node body = iter.getNext();\n      // After initialization, we transfer to the FOR which is in charge of\n      // checking the condition (for the first time).\n      createEdge(init, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode));\n      // The end of the body will have a unconditional branch to our iter\n      // (handled by calling computeFollowNode of the last instruction of the\n      // body. Our iter will jump to the forNode again to another condition\n      // check.\n      createEdge(iter, Branch.UNCOND, forNode);\n      connectToPossibleExceptionHandler(init, init);\n      connectToPossibleExceptionHandler(forNode, cond);\n      connectToPossibleExceptionHandler(iter, iter);\n    } else {\n      // We have for (item in collection) { body }\n      Node item = forNode.getFirstChild();\n      Node collection = item.getNext();\n      Node body = collection.getNext();\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode));\n      connectToPossibleExceptionHandler(forNode, collection);\n    }\n  }\n\n  private void handleSwitch(Node node) {\n    // Transfer to the first non-DEFAULT CASE. if there are none, transfer\n    // to the DEFAULT or the EMPTY node.\n    Node next = getNextSiblingOfType(\n        node.getFirstChild().getNext(), Token.CASE, Token.EMPTY);\n    if (next != null) { // Has at least one CASE or EMPTY\n      createEdge(node, Branch.UNCOND, next);\n    } else { // Has no CASE but possibly a DEFAULT\n      if (node.getFirstChild().getNext() != null) {\n        createEdge(node, Branch.UNCOND, node.getFirstChild().getNext());\n      } else { // No CASE, no DEFAULT\n        createEdge(node, Branch.UNCOND, computeFollowNode(node));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleCase(Node node) {\n    // Case is a bit tricky....First it goes into the body if condition is true.\n    createEdge(node, Branch.ON_TRUE,\n        node.getFirstChild().getNext());\n    // Look for the next CASE, skipping over DEFAULT.\n    Node next = getNextSiblingOfType(node.getNext(), Token.CASE);\n    if (next != null) { // Found a CASE\n      Preconditions.checkState(next.getType() == Token.CASE);\n      createEdge(node, Branch.ON_FALSE, next);\n    } else { // No more CASE found, go back and search for a DEFAULT.\n      Node parent = node.getParent();\n      Node deflt = getNextSiblingOfType(\n        parent.getFirstChild().getNext(), Token.DEFAULT);\n      if (deflt != null) { // Has a DEFAULT\n        createEdge(node, Branch.ON_FALSE, deflt);\n      } else { // No DEFAULT found, go to the follow of the SWITCH.\n        createEdge(node, Branch.ON_FALSE, computeFollowNode(node));\n      }\n    }\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleDefault(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleWith(Node node) {\n    // Directly goes to the body. It should not transfer to the next case.\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n    connectToPossibleExceptionHandler(node, node.getFirstChild());\n  }\n\n  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.getType() == Token.BLOCK && parent != null &&\n        parent.getType() == Token.TRY &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.getType() == Token.FUNCTION) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.getType() == Token.BLOCK && node.isSyntheticBlock()) {\n            Node next = node.getLastChild();\n            if (next != null) {\n              createEdge(node, Branch.SYN_BLOCK, computeFallThrough(next));\n            }\n          }\n          break;\n      }\n    }\n  }\n\n  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }\n\n  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleThrow(Node node) {\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private void handleTry(Node node) {\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }\n\n  private void handleCatch(Node node) {\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n  }\n\n  private void handleBreak(Node node) {\n    String label = null;\n    // See if it is a break with label.\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node lastJump;\n    Node parent = node.getParent();\n    /*\n     * Continuously look up the ancestor tree for the BREAK target or the target\n     * with the corresponding label and connect to it. If along the path we\n     * discover a FINALLY, we will connect the BREAK to that FINALLY. From then\n     * on, we will just record the control flow changes in the finallyMap. This\n     * is due to the fact that we need to connect any node that leaves its own\n     * FINALLY block to the outer FINALLY or the BREAK's target but those nodes\n     * are not known yet due to the way we traverse the nodes.\n     */\n    for (cur = node, lastJump = node;\n        !isBreakTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, computeFallThrough(\n              cur.getLastChild()));\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find break target.\");\n    }\n    if (lastJump == node) {\n      createEdge(lastJump, Branch.UNCOND, computeFollowNode(cur));\n    } else {\n      finallyMap.put(lastJump, computeFollowNode(cur));\n    }\n  }\n\n  private void handleContinue(Node node) {\n    String label = null;\n    if (node.hasChildren()) {\n      label = node.getFirstChild().getString();\n    }\n    Node cur;\n    Node lastJump;\n    // Similar to handBreak's logic with a few minor variation.\n    Node parent = node.getParent();\n    for (cur = node, lastJump = node;\n        !isContinueTarget(cur, parent, label);\n        cur = parent, parent = parent.getParent()) {\n      if (cur.getType() == Token.TRY && NodeUtil.hasFinally(cur)) {\n        if (lastJump == node) {\n          createEdge(lastJump, Branch.UNCOND, cur.getLastChild());\n        } else {\n          finallyMap.put(lastJump, computeFallThrough(cur.getLastChild()));\n        }\n        lastJump = cur;\n      }\n      Preconditions.checkState(parent != null, \"Cannot find continue target.\");\n    }\n    Node iter = cur;\n    if (cur.getChildCount() == 4) {\n      iter = cur.getFirstChild().getNext().getNext();\n    }\n\n    if (lastJump == node) {\n      createEdge(node, Branch.UNCOND, iter);\n    } else {\n      finallyMap.put(lastJump, iter);\n    }\n  }\n\n  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (NodeUtil.isFunction(curHandler)) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }\n\n  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    connectToPossibleExceptionHandler(node, node);\n  }\n\n  private Node computeFollowNode(Node node) {\n    return computeFollowNode(node, node);\n  }\n\n  /**\n   * Computes the follow() node of a given node and its parent. There is a side\n   * effect when calling this function. If this function computed an edge that\n   * exists a FINALLY, it'll attempt to connect the fromNode to the outer\n   * FINALLY according to the finallyMap.\n   *\n   * @param fromNode The original source node since {@code node} is changed\n   *        during recursion.\n   * @param node The node that follow() should compute.\n   */\n  private Node computeFollowNode(Node fromNode, Node node) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.getType() == Token.FUNCTION || node == root) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent);\n      case Token.CASE:\n      case Token.DEFAULT:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().getType() == Token.CASE) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().getType() == Token.DEFAULT) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          for (Node finallyNode : finallyMap.get(parent)) {\n            createEdge(fromNode, Branch.UNCOND, finallyNode);\n          }\n          return computeFollowNode(fromNode, parent);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.getType() == Token.FUNCTION) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transfered up the AST.\n      return computeFollowNode(fromNode, parent);\n    }\n  }\n\n  /**\n   * Computes the destination node of n when we want to fallthough into the\n   * subtree of n. We don't always create a CFG edge into n itself because of\n   * DOs and FORs.\n   */\n  private static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n;\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }\n\n  /**\n   * Connects the two nodes in the control flow graph.\n   *\n   * @param fromNode Source.\n   * @param toNode Destination.\n   */\n  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }\n\n  /**\n   * Connects cfgNode to the proper CATCH block if target subtree might throw\n   * an exception. If there are FINALLY blocks reached before a CATCH, it will\n   * make the corresponding entry in finallyMap.\n   */\n  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (NodeUtil.isFunction(handler)) {\n          return;\n        }\n        Preconditions.checkState(handler.getType() == Token.TRY);\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }\n\n  /**\n   * Get the next sibling (including itself) of one of the given types.\n   */\n  private static Node getNextSiblingOfType(Node first, int ... types) {\n    for (Node c = first; c != null; c = c.getNext()) {\n      for (int type : types) {\n        if (c.getType() == type) {\n          return c;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Checks if target is actually the break target of labeled continue. The\n   * label can be null if it is an unlabeled break.\n   */\n  private static boolean isBreakTarget(\n      Node target, Node parent, String label) {\n    return isBreakStructure(target, label != null) && matchLabel(parent, label);\n  }\n\n  /**\n   * Checks if target is actually the continue target of labeled continue. The\n   * label can be null if it is an unlabeled continue.\n   */\n  private static boolean isContinueTarget(\n      Node target, Node parent, String label) {\n    return isContinueStructure(target) && matchLabel(parent, label);\n  }\n  /**\n   * Check if label is actually referencing the target control structure. If\n   * label is null, it always returns true.\n   */\n  private static boolean matchLabel(Node target, String label) {\n    if (label == null) {\n      return true;\n    }\n    while (target.getType() == Token.LABEL) {\n      if (target.getFirstChild().getString().equals(label)) {\n        return true;\n      }\n      target = target.getParent();\n    }\n    return false;\n  }\n\n  /**\n   * Determines if the subtree might throw an exception.\n   */\n  private static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Determines whether the given node can be terminated with a BREAK node.\n   */\n  static boolean isBreakStructure(Node n, boolean labeled) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.SWITCH:\n        return true;\n      case Token.BLOCK:\n      case Token.IF:\n      case Token.TRY:\n        return labeled;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Determines whether the given node can be advanced with a CONTINUE node.\n   */\n  static boolean isContinueStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * A {@link ControlFlowGraph} which provides a node comparator based on the\n   * pre-order traversal of the AST.\n   */\n  private static class AstControlFlowGraph extends ControlFlowGraph<Node> {\n    private final Map<DiGraphNode<Node, Branch>, Integer> priorities;\n\n    /**\n     * Constructor.\n     * @param entry The entry node.\n     * @param priorities The map from nodes to position in the AST (to be\n     *    filled by the {@link ControlFlowAnalysis#shouldTraverse}).\n     */\n    private AstControlFlowGraph(Node entry,\n        Map<DiGraphNode<Node, Branch>, Integer> priorities) {\n      super(entry);\n      this.priorities = priorities;\n    }\n\n    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }\n\n    /**\n     * Gets the pre-order traversal position of the given node.\n     * @return An arbitrary counter used for comparing positions.\n     */\n    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }\n  }\n}\n"}}
{"bug_id": "Closure_103", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.DisambiguateProperties#process(Node#externs,Node#root)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_103/fixed/src/com/google/javascript/jscomp/DisambiguateProperties.java", "focal_method": "public void process(Node externs, Node root) {\n    for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n      addInvalidatingType(mis.typeA);\n      addInvalidatingType(mis.typeB);\n    }\n\n    StaticScope<T> scope = typeSystem.getRootScope();\n    NodeTraversal.traverse(compiler, externs, new FindExternProperties());\n    NodeTraversal.traverse(compiler, root, new FindRenameableProperties());\n    renameProperties();\n  }", "return_type": "void", "assertion_subject_candidates": ["T com.google.javascript.jscomp.DisambiguateProperties#getTypeWithProperty(String#field,T#type)"], "focal_class": {"name": "DisambiguateProperties", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_103/fixed/src/com/google/javascript/jscomp/DisambiguateProperties.java", "superclass": "", "interface": "implements CompilerPass", "imports": ["import static com.google.common.base.Preconditions.checkState;", "import com.google.common.collect.HashMultimap;", "import com.google.common.collect.ImmutableSet;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.common.collect.Multimap;", "import com.google.common.collect.Sets;", "import com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType;", "import com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType;", "import com.google.javascript.jscomp.ConcreteType.ConcreteUnionType;", "import com.google.javascript.jscomp.ConcreteType.ConcreteUniqueType;", "import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;", "import com.google.javascript.jscomp.TypeValidator.TypeMismatch;", "import com.google.javascript.jscomp.graph.StandardUnionFind;", "import com.google.javascript.jscomp.graph.UnionFind;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import com.google.javascript.rhino.jstype.FunctionPrototypeType;", "import com.google.javascript.rhino.jstype.FunctionType;", "import com.google.javascript.rhino.jstype.JSType;", "import com.google.javascript.rhino.jstype.JSTypeNative;", "import com.google.javascript.rhino.jstype.JSTypeRegistry;", "import com.google.javascript.rhino.jstype.ObjectType;", "import com.google.javascript.rhino.jstype.StaticScope;", "import com.google.javascript.rhino.jstype.UnionType;", "import java.util.Collection;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;", "import java.util.Stack;", "import java.util.logging.Logger;"], "fields": ["private static final Logger logger = Logger.getLogger(\n      DisambiguateProperties.class.getName())", "static final DiagnosticType INVALIDATION = DiagnosticType.warning(\n      \"JSC_INVALIDATION\",\n      \"Property disambiguator skipping all instances of property {0} \"\n      + \"because of type {1} node {2}\")", "private final boolean showInvalidationWarnings = false", "private final AbstractCompiler compiler", "private final TypeSystem<T> typeSystem", "private Map<String, Property> properties = Maps.newHashMap()"], "methods": ["DisambiguateProperties<JSType> com.google.javascript.jscomp.DisambiguateProperties#forJSTypeSystem(AbstractCompiler#compiler)", "DisambiguateProperties<ConcreteType> com.google.javascript.jscomp.DisambiguateProperties#forConcreteTypeSystem(AbstractCompiler#compiler,TightenTypes#tt)", "void com.google.javascript.jscomp.DisambiguateProperties#addInvalidatingType(JSType#type)", "Property com.google.javascript.jscomp.DisambiguateProperties#getProperty(String#name)", "T com.google.javascript.jscomp.DisambiguateProperties#getTypeWithProperty(String#field,T#type)", "void com.google.javascript.jscomp.DisambiguateProperties#renameProperties()", "Map<T, String> com.google.javascript.jscomp.DisambiguateProperties#buildPropNames(UnionFind<T>#types,String#name)", "Multimap<String, Collection<T>> com.google.javascript.jscomp.DisambiguateProperties#getRenamedTypesForTesting()"], "other_methods": [], "fields_dict": {"Logger#logger": "private static final Logger logger = Logger.getLogger(\n      DisambiguateProperties.class.getName())", "DiagnosticType#INVALIDATION": "static final DiagnosticType INVALIDATION = DiagnosticType.warning(\n      \"JSC_INVALIDATION\",\n      \"Property disambiguator skipping all instances of property {0} \"\n      + \"because of type {1} node {2}\")", "boolean#showInvalidationWarnings": "private final boolean showInvalidationWarnings = false", "AbstractCompiler#compiler": "private final AbstractCompiler compiler", "TypeSystem<T>#typeSystem": "private final TypeSystem<T> typeSystem", "Map<String, Property>#properties": "private Map<String, Property> properties = Maps.newHashMap()"}, "text": "/*\n * Copyright 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport static com.google.common.base.Preconditions.checkState;\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.ConcreteType.ConcreteFunctionType;\nimport com.google.javascript.jscomp.ConcreteType.ConcreteInstanceType;\nimport com.google.javascript.jscomp.ConcreteType.ConcreteUnionType;\nimport com.google.javascript.jscomp.ConcreteType.ConcreteUniqueType;\nimport com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\nimport com.google.javascript.jscomp.TypeValidator.TypeMismatch;\nimport com.google.javascript.jscomp.graph.StandardUnionFind;\nimport com.google.javascript.jscomp.graph.UnionFind;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.jstype.FunctionPrototypeType;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.JSTypeNative;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\nimport com.google.javascript.rhino.jstype.ObjectType;\nimport com.google.javascript.rhino.jstype.StaticScope;\nimport com.google.javascript.rhino.jstype.UnionType;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.logging.Logger;\n\n/**\n * DisambiguateProperties renames properties to disambiguate between unrelated\n * fields with the same name. Two properties are considered related if they\n * share a definition on their prototype chains, or if they are potentially\n * referenced together via union types.\n *\n * <p> Renamimg only occurs if there are two or more distinct properties with\n * the same name.\n *\n * <p> This pass allows other passes, such as inlining and code removal to take\n * advantage of type information implicitly.\n *\n * <pre>\n *   Foo.a;\n *   Bar.a;\n * </pre>\n *\n * <p> will become\n *\n * <pre>\n *   Foo.a$Foo;\n *   Bar.a$Bar;\n * </pre>\n *\n*\n */\nclass DisambiguateProperties<T> implements CompilerPass {\n  private static final Logger logger = Logger.getLogger(\n      DisambiguateProperties.class.getName());\n\n  // TODO(user): add a flag to allow enabling of this once apps start\n  // using it.\n  static final DiagnosticType INVALIDATION = DiagnosticType.warning(\n      \"JSC_INVALIDATION\",\n      \"Property disambiguator skipping all instances of property {0} \"\n      + \"because of type {1} node {2}\");\n  private final boolean showInvalidationWarnings = false;\n\n  private final AbstractCompiler compiler;\n  private final TypeSystem<T> typeSystem;\n\n  private class Property {\n    /** The name of the property. */\n    final String name;\n\n    /** All types on which the field exists, grouped together if related. */\n    private UnionFind<T> types;\n\n    /**\n     * A set of types for which renaming this field should be skipped. This\n     * list is first filled by fields defined in the externs file.\n     */\n    Set<T> typesToSkip = Sets.newHashSet();\n\n    /**\n     * If true, do not rename any instance of this field, as it has been\n     * referenced from an unknown type.\n     */\n    boolean skipRenaming;\n\n    /** Set of nodes for this field that need renaming. */\n    Set<Node> renameNodes = Sets.newHashSet();\n\n    /**\n     * Map from node to the highest type in the prototype chain containing the\n     * field for that node. In the case of a union, the type is the highest type\n     * of one of the types in the union.\n     */\n    final Map<Node, T> rootTypes = Maps.newHashMap();\n\n    Property(String name) {\n      this.name = name;\n    }\n\n    /** Returns the types on which this field is referenced. */\n    UnionFind<T> getTypes() {\n      if (types == null) {\n        types = new StandardUnionFind<T>();\n      }\n      return types;\n    }\n\n    /**\n     * Record that this property is referenced from this type.\n     * @return true if the type was recorded for this property, else false,\n     *     which would happen if the type was invalidating.\n     */\n    boolean addType(T type, T top, T relatedType) {\n      checkState(!skipRenaming, \"Attempt to record skipped property: %s\", name);\n      if (typeSystem.isInvalidatingType(top)) {\n        invalidate();\n        return false;\n      } else {\n        if (typeSystem.isTypeToSkip(top)) {\n          addTypeToSkip(top);\n        }\n\n        if (relatedType == null) {\n          getTypes().add(top);\n        } else {\n          getTypes().union(top, relatedType);\n        }\n        typeSystem.recordInterfaces(type, top, this);\n        return true;\n      }\n    }\n\n    /** Records the given type as one to skip for this property. */\n    void addTypeToSkip(T type) {\n      for (T skipType : typeSystem.getTypesToSkipForType(type)) {\n        typesToSkip.add(skipType);\n        getTypes().union(skipType, type);\n      }\n    }\n\n    /** Invalidates any types related to invalid types. */\n    void expandTypesToSkip() {\n      // If we are not going to rename any properties, then we do not need to\n      // update the list of invalid types, as they are all invalid.\n      if (shouldRename()) {\n        int count = 0;\n        while (true) {\n          // It should usually only take one time through this do-while.\n          checkState(++count < 10, \"Stuck in loop expanding types to skip.\");\n\n          // Make sure that the representative type for each type to skip is\n          // marked as being skipped.\n          Set<T> rootTypesToSkip = Sets.newHashSet();\n          for (T subType : typesToSkip) {\n            rootTypesToSkip.add(types.find(subType));\n          }\n          typesToSkip.addAll(rootTypesToSkip);\n\n          Set<T> newTypesToSkip = Sets.newHashSet();\n          Set<T> allTypes = types.elements();\n          int originalTypesSize = allTypes.size();\n          for (T subType : allTypes) {\n            if (!typesToSkip.contains(subType)\n                && typesToSkip.contains(types.find(subType))) {\n              newTypesToSkip.add(subType);\n            }\n          }\n\n          for (T newType : newTypesToSkip) {\n            addTypeToSkip(newType);\n          }\n\n          // If there were not any new types added, we are done here.\n          if (types.elements().size() == originalTypesSize) {\n            break;\n          }\n        }\n      }\n    }\n\n    /** Returns true if any instance of this property should be renamed. */\n    boolean shouldRename() {\n      return !skipRenaming && types != null\n          && types.allEquivalenceClasses().size() > 1;\n    }\n\n    /**\n     * Returns true if this property should be renamed on this type.\n     * expandTypesToSkip() should be called before this, if anything has been\n     * added to the typesToSkip list.\n     */\n    boolean shouldRename(T type) {\n      return !skipRenaming && !typesToSkip.contains(type);\n    }\n\n    /**\n     * Invalidates a field from renaming.  Used for field references on an\n     * object with unknown type.\n     */\n    boolean invalidate() {\n      boolean changed = !skipRenaming;\n      skipRenaming = true;\n      types = null;\n      return changed;\n    }\n\n    /**\n     * Schedule the node to potentially be renamed.\n     * @param node the node to rename\n     * @param type the highest type in the prototype chain for which the\n     *     property is defined\n     * @return True if type was accepted without invalidation or if the property\n     *     was already invalidated.  False if this property was invalidated this\n     *     time.\n     */\n    boolean scheduleRenaming(Node node, T type) {\n      if (!skipRenaming) {\n        if (typeSystem.isInvalidatingType(type)) {\n          invalidate();\n          return false;\n        }\n        renameNodes.add(node);\n        rootTypes.put(node, type);\n      }\n      return true;\n    }\n  }\n\n  private Map<String, Property> properties = Maps.newHashMap();\n\n  static DisambiguateProperties<JSType> forJSTypeSystem(\n      AbstractCompiler compiler) {\n    return new DisambiguateProperties<JSType>(\n        compiler, new JSTypeSystem(compiler));\n  }\n\n  static DisambiguateProperties<ConcreteType> forConcreteTypeSystem(\n      AbstractCompiler compiler, TightenTypes tt) {\n    return new DisambiguateProperties<ConcreteType>(\n        compiler, new ConcreteTypeSystem(tt, compiler.getCodingConvention()));\n  }\n\n  /**\n   * This constructor should only be called by one of the helper functions\n   * above for either the JSType system, or the concrete type system.\n   */\n  private DisambiguateProperties(AbstractCompiler compiler,\n                                 TypeSystem<T> typeSystem) {\n    this.compiler = compiler;\n    this.typeSystem = typeSystem;\n  }\n\n  public void process(Node externs, Node root) {\n    for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n      addInvalidatingType(mis.typeA);\n      addInvalidatingType(mis.typeB);\n    }\n\n    StaticScope<T> scope = typeSystem.getRootScope();\n    NodeTraversal.traverse(compiler, externs, new FindExternProperties());\n    NodeTraversal.traverse(compiler, root, new FindRenameableProperties());\n    renameProperties();\n  }\n\n  /**\n   * Invalidates the given type, so that no properties on it will be renamed.\n   */\n  private void addInvalidatingType(JSType type) {\n    type = type.restrictByNotNullOrUndefined();\n    if (type instanceof UnionType) {\n      for (JSType alt : ((UnionType) type).getAlternates()) {\n        addInvalidatingType(alt);\n      }\n      return;\n    }\n\n    typeSystem.addInvalidatingType(type);\n    ObjectType objType = ObjectType.cast(type);\n    if (objType != null && objType.getImplicitPrototype() != null) {\n      typeSystem.addInvalidatingType(objType.getImplicitPrototype());\n    }\n  }\n\n\n  /** Returns the property for the given name, creating it if necessary. */\n  protected Property getProperty(String name) {\n    if (!properties.containsKey(name)) {\n      properties.put(name, new Property(name));\n    }\n    return properties.get(name);\n  }\n\n  /** Public for testing. */\n  T getTypeWithProperty(String field, T type) {\n    return typeSystem.getTypeWithProperty(field, type);\n  }\n\n  /** Tracks the current type system scope while traversing. */\n  private abstract class AbstractScopingCallback implements ScopedCallback {\n    protected final Stack<StaticScope<T>> scopes =\n        new Stack<StaticScope<T>>();\n\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      return true;\n    }\n\n    public void enterScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        scopes.push(typeSystem.getRootScope());\n      } else {\n        scopes.push(typeSystem.getFunctionScope(t.getScopeRoot()));\n      }\n    }\n\n    public void exitScope(NodeTraversal t) {\n      scopes.pop();\n    }\n\n    /** Returns the current scope at this point in the file. */\n    protected StaticScope<T> getScope() {\n      return scopes.peek();\n    }\n  }\n\n  /**\n   * Finds all properties defined in the externs file and sets them as\n   * ineligible for renaming from the type on which they are defined.\n   */\n  private class FindExternProperties extends AbstractScopingCallback {\n    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.GETPROP) {\n        String field = n.getLastChild().getString();\n        T type = typeSystem.getType(getScope(), n.getFirstChild(), field);\n        Property prop = getProperty(field);\n        if (typeSystem.isInvalidatingType(type)) {\n          prop.invalidate();\n        } else {\n          prop.addTypeToSkip(type);\n\n          // If this is a prototype property, then we want to skip assignments\n          // to the instance type as well.  These assignments are not usually\n          // seen in the extern code itself, so we must handle them here.\n          if ((type = typeSystem.getInstanceFromPrototype(type)) != null) {\n            prop.getTypes().add(type);\n            prop.typesToSkip.add(type);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Traverses the tree, building a map from field names to Nodes for all\n   * fields that can be renamed.\n   */\n  private class FindRenameableProperties extends AbstractScopingCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.GETPROP) {\n        handleGetProp(t, n);\n      } else if (n.getType() == Token.OBJECTLIT) {\n        handleObjectLit(t, n);\n      }\n    }\n\n    /**\n     * Processes a GETPROP node.\n     */\n    private void handleGetProp(NodeTraversal t, Node n) {\n      String name = n.getLastChild().getString();\n      T type = typeSystem.getType(getScope(), n.getFirstChild(), name);\n\n      Property prop = getProperty(name);\n      if (!prop.scheduleRenaming(n.getLastChild(),\n                                 processProperty(t, prop, type, null))) {\n        if (showInvalidationWarnings) {\n          compiler.report(JSError.make(\n              t.getSourceName(), n, INVALIDATION, name,\n              (type == null ? \"null\" : type.toString()), n.toString()));\n        }\n      }\n    }\n\n    /**\n     * Processes a OBJECTLIT node.\n     */\n    private void handleObjectLit(NodeTraversal t, Node n) {\n      Node child = n.getFirstChild();\n      while (child != null) {\n        if (child.getType() == Token.STRING) {\n          // We should never see a mix of numbers and strings.\n          String name = child.getString();\n          T type = typeSystem.getType(getScope(), n, name);\n\n          Property prop = getProperty(name);\n          if (!prop.scheduleRenaming(child,\n                                     processProperty(t, prop, type, null))) {\n            if (showInvalidationWarnings) {\n              compiler.report(JSError.make(\n                  t.getSourceName(), child, INVALIDATION, name,\n                  (type == null ? \"null\" : type.toString()), n.toString()));\n            }\n          }\n        }\n\n        child = child.getNext().getNext();\n      }\n    }\n\n    /**\n     * Processes a property, adding it to the list of properties to rename.\n     * @return a representative type for the property reference, which will be\n     *   the highest type on the prototype chain of the provided type.  In the\n     *   case of a union type, it will be the highest type on the prototype\n     *   chain of one of the members of the union.\n     */\n    private T processProperty(\n        NodeTraversal t, Property prop, T type, T relatedType) {\n      type = typeSystem.restrictByNotNullOrUndefined(type);\n      if (prop.skipRenaming || typeSystem.isInvalidatingType(type)) {\n        return null;\n      }\n\n      Iterable<T> alternatives = typeSystem.getTypeAlternatives(type);\n      if (alternatives != null) {\n        T firstType = null;\n        for (T subType : alternatives) {\n          T lastType = processProperty(t, prop, subType, firstType);\n          if (lastType != null) {\n            firstType = firstType == null ? lastType : firstType;\n          }\n        }\n        return firstType;\n      } else {\n        T topType = typeSystem.getTypeWithProperty(prop.name, type);\n        if (typeSystem.isInvalidatingType(topType)) {\n          return null;\n        }\n        prop.addType(type, topType, relatedType);\n        return topType;\n      }\n    }\n  }\n\n  /** Renames all properties with references on more than one type. */\n  void renameProperties() {\n    int propsRenamed = 0, propsSkipped = 0, instancesRenamed = 0,\n        instancesSkipped = 0, singleTypeProps = 0;\n\n    for (Property prop : properties.values()) {\n      if (prop.shouldRename()) {\n        Map<T, String> propNames = buildPropNames(prop.getTypes(), prop.name);\n\n        ++propsRenamed;\n        prop.expandTypesToSkip();\n        UnionFind<T> types = prop.getTypes();\n        for (Node node : prop.renameNodes) {\n          T rootType = prop.rootTypes.get(node);\n          if (prop.shouldRename(rootType)) {\n            String newName = propNames.get(rootType);\n            node.setString(newName);\n            compiler.reportCodeChange();\n            ++instancesRenamed;\n          } else {\n            ++instancesSkipped;\n          }\n        }\n      } else {\n        if (prop.skipRenaming) {\n          ++propsSkipped;\n        } else {\n          ++singleTypeProps;\n        }\n      }\n    }\n    logger.info(\"Renamed \" + instancesRenamed + \" instances of \"\n                + propsRenamed + \" properties.\");\n    logger.info(\"Skipped renaming \" + instancesSkipped + \" invalidated \"\n                + \"properties, \" + propsSkipped + \" instances of properties \"\n                + \"that were skipped for specific types and \" + singleTypeProps\n                + \" properties that were referenced from only one type.\");\n  }\n\n  /**\n   * Chooses a name to use for renaming in each equivalence class and maps\n   * each type in that class to it.\n   */\n  private Map<T, String> buildPropNames(UnionFind<T> types, String name) {\n    Map<T, String> names = Maps.newHashMap();\n    for (Set<T> set : types.allEquivalenceClasses()) {\n      checkState(!set.isEmpty());\n\n      String typeName = null;\n      for (T type : set) {\n        if (typeName == null || type.toString().compareTo(typeName) < 0) {\n          typeName = type.toString();\n        }\n      }\n\n      String newName;\n      if (\"{...}\".equals(typeName)) {\n        newName = name;\n      } else {\n        newName = typeName.replaceAll(\"[^\\\\w$]\", \"_\") + \"$\" + name;\n      }\n\n      for (T type : set) {\n        names.put(type, newName);\n      }\n    }\n    return names;\n  }\n\n  /** Returns a map from field name to types for which it will be renamed. */\n  Multimap<String, Collection<T>> getRenamedTypesForTesting() {\n    Multimap<String, Collection<T>> ret = HashMultimap.create();\n    for (Map.Entry<String, Property> entry: properties.entrySet()) {\n      Property prop = entry.getValue();\n      if (!prop.skipRenaming) {\n        for (Collection<T> c : prop.getTypes().allEquivalenceClasses()) {\n          if (!c.isEmpty() && !prop.typesToSkip.contains(c.iterator().next())) {\n            ret.put(entry.getKey(), c);\n          }\n        }\n      }\n    }\n    return ret;\n  }\n\n  /** Interface for providing the type information needed by this pass. */\n  private interface TypeSystem<T> {\n    // TODO(user): add a getUniqueName(T type) method that is guaranteed\n    // to be unique, performant and human-readable.\n\n    /** Returns the top-most scope used by the type system (if any). */\n    StaticScope<T> getRootScope();\n\n    /** Returns the new scope started at the given function node. */\n    StaticScope<T> getFunctionScope(Node node);\n\n    /**\n     * Returns the type of the given node.\n     * @param prop Only types with this property need to be returned. In general\n     *     with type tightening, this will require no special processing, but in\n     *     the case of an unknown JSType, we might need to add in the native\n     *     types since we don't track them, but only if they have the given\n     *     property.\n     */\n    T getType(StaticScope<T> scope, Node node, String prop);\n\n    /**\n     * Returns true if a field reference on this type will invalidiate all\n     * references to that field as candidates for renaming. This is true if the\n     * type is unknown or all-inclusive, as variables with such a type could be\n     * references to any object.\n     */\n    boolean isInvalidatingType(T type);\n\n    /**\n     * Informs the given type system that a type is invalidating due to a type\n     * mismatch found during type checking.\n     */\n    void addInvalidatingType(JSType type);\n\n    /**\n     * Returns a set of types that should be skipped given the given type.\n     * This is necessary for interfaces when using JSTypes, as all super\n     * interfaces must also be skipped.\n     */\n    ImmutableSet<T> getTypesToSkipForType(T type);\n\n    /**\n     * Determines whether the given type is one whose properties should not be\n     * considered for renaming.\n     */\n    boolean isTypeToSkip(T type);\n\n    /** Remove null and undefined from the options in the given type. */\n    T restrictByNotNullOrUndefined(T type);\n\n    /**\n     * Returns the alternatives if this is a type that represents multiple\n     * types, and null if not. Union and interface types can correspond to\n     * multiple other types.\n     */\n    Iterable<T> getTypeAlternatives(T type);\n\n    /**\n     * Returns the type in the chain from the given type that contains the given\n     * field or null if it is not found anywhere.\n     */\n    T getTypeWithProperty(String field, T type);\n\n    /**\n     * Returns the type of the instance of which this is the prototype or null\n     * if this is not a function prototype.\n     */\n    T getInstanceFromPrototype(T type);\n\n    /**\n     * Records that this property could be referenced from any interface that\n     * this type, or any type in its superclass chain, implements.\n     */\n    void recordInterfaces(T type, T relatedType,\n                          DisambiguateProperties<T>.Property p);\n  }\n\n  /** Implementation of TypeSystem using JSTypes. */\n  private static class JSTypeSystem implements TypeSystem<JSType> {\n    private final Set<JSType> invalidatingTypes;\n    private JSTypeRegistry registry;\n\n    public JSTypeSystem(AbstractCompiler compiler) {\n      registry = compiler.getTypeRegistry();\n      invalidatingTypes = Sets.newHashSet(\n          registry.getNativeType(JSTypeNative.ALL_TYPE),\n          registry.getNativeType(JSTypeNative.NO_OBJECT_TYPE),\n          registry.getNativeType(JSTypeNative.NO_TYPE),\n          registry.getNativeType(JSTypeNative.FUNCTION_PROTOTYPE),\n          registry.getNativeType(JSTypeNative.OBJECT_PROTOTYPE),\n          registry.getNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE),\n          registry.getNativeType(JSTypeNative.UNKNOWN_TYPE));\n\n    }\n\n    @Override public void addInvalidatingType(JSType type) {\n      checkState(!type.isUnionType());\n      invalidatingTypes.add(type);\n    }\n\n    @Override public StaticScope<JSType> getRootScope() { return null; }\n\n    @Override public StaticScope<JSType> getFunctionScope(Node node) {\n      return null;\n    }\n\n    @Override public JSType getType(\n        StaticScope<JSType> scope, Node node, String prop) {\n      if (node.getJSType() == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return node.getJSType();\n    }\n\n    @Override public boolean isInvalidatingType(JSType type) {\n      if (type == null || invalidatingTypes.contains(type) ||\n          (type.isNamedType() && type.isUnknownType())) {\n        return true;\n      }\n\n      ObjectType objType = ObjectType.cast(type);\n      return objType != null && !objType.hasReferenceName();\n    }\n\n    @Override public ImmutableSet<JSType> getTypesToSkipForType(JSType type) {\n      type = type.restrictByNotNullOrUndefined();\n      if (type instanceof UnionType) {\n        Set<JSType> types = Sets.newHashSet(type);\n        for (JSType alt : ((UnionType) type).getAlternates()) {\n          types.addAll(getTypesToSkipForTypeNonUnion(type));\n        }\n        return ImmutableSet.copyOf(types);\n      }\n      return ImmutableSet.copyOf(getTypesToSkipForTypeNonUnion(type));\n    }\n\n    private Set<JSType> getTypesToSkipForTypeNonUnion(JSType type) {\n      Set<JSType> types = Sets.newHashSet();\n      JSType skipType = type;\n      while (skipType != null) {\n        types.add(skipType);\n\n        ObjectType objSkipType = skipType.toObjectType();\n        if (objSkipType != null) {\n          skipType = objSkipType.getImplicitPrototype();\n        } else {\n          break;\n        }\n      }\n      return types;\n    }\n\n    @Override public boolean isTypeToSkip(JSType type) {\n      return type.isEnumType() || (type.autoboxesTo() != null);\n    }\n\n    @Override public JSType restrictByNotNullOrUndefined(JSType type) {\n      return type.restrictByNotNullOrUndefined();\n    }\n\n    @Override public Iterable<JSType> getTypeAlternatives(JSType type) {\n      if (type.isUnionType()) {\n        return ((UnionType) type).getAlternates();\n      } else {\n        ObjectType objType = type.toObjectType();\n        if (objType != null &&\n            objType.getConstructor() != null &&\n            objType.getConstructor().isInterface()) {\n          List<JSType> list = Lists.newArrayList();\n          for (FunctionType impl\n                   : registry.getDirectImplementors(objType)) {\n            list.add(impl.getInstanceType());\n          }\n          return list;\n        } else {\n          return null;\n        }\n      }\n    }\n\n    @Override public ObjectType getTypeWithProperty(String field, JSType type) {\n      if (!(type instanceof ObjectType)) {\n        if (type.autoboxesTo() != null) {\n          type = type.autoboxesTo();\n        } else {\n          return null;\n        }\n      }\n\n      // Ignore the prototype itself at all times.\n      if (\"prototype\".equals(field)) {\n        return null;\n      }\n\n      // We look up the prototype chain to find the highest place (if any) that\n      // this appears.  This will make references to overriden properties look\n      // like references to the initial property, so they are renamed alike.\n      ObjectType foundType = null;\n      ObjectType objType = ObjectType.cast(type);\n      while (objType != null && objType.getImplicitPrototype() != objType) {\n        if (objType.hasOwnProperty(field)) {\n          foundType = objType;\n        }\n        objType = objType.getImplicitPrototype();\n      }\n      // If the property does not exist on the referenced type but the original\n      // type is an object type, see if any subtype has the property.\n      if (foundType == null) {\n        ObjectType maybeType = ObjectType.cast(\n            registry.getGreatestSubtypeWithProperty(type, field));\n        // getGreatestSubtypeWithProperty does not guarantee that the property\n        // is defined on the returned type, it just indicates that it might be,\n        // so we have to double check.\n        if (maybeType != null && maybeType.hasOwnProperty(field)) {\n          foundType = maybeType;\n        }\n      }\n      return foundType;\n    }\n\n    @Override public JSType getInstanceFromPrototype(JSType type) {\n      if (type.isFunctionPrototypeType()) {\n        FunctionPrototypeType prototype = (FunctionPrototypeType) type;\n        FunctionType owner = prototype.getOwnerFunction();\n        if (owner.isConstructor() || owner.isInterface()) {\n          return ((FunctionPrototypeType) type).getOwnerFunction()\n              .getInstanceType();\n        }\n      }\n      return null;\n    }\n\n    @Override\n    public void recordInterfaces(JSType type, JSType relatedType,\n                                 DisambiguateProperties<JSType>.Property p) {\n      ObjectType objType = ObjectType.cast(type);\n      if (objType != null) {\n        FunctionType constructor;\n        if (objType instanceof FunctionType) {\n          constructor = (FunctionType) objType;\n        } else if (objType instanceof FunctionPrototypeType) {\n          constructor = ((FunctionPrototypeType) objType).getOwnerFunction();\n        } else {\n          constructor = objType.getConstructor();\n        }\n        while (constructor != null) {\n          for (ObjectType itype : constructor.getImplementedInterfaces()) {\n            JSType top = getTypeWithProperty(p.name, itype);\n            if (top != null) {\n              p.addType(itype, top, relatedType);\n            } else {\n              recordInterfaces(itype, relatedType, p);\n            }\n\n            // If this interface invalidated this property, return now.\n            if (p.skipRenaming) return;\n          }\n          if (constructor.isInterface() || constructor.isConstructor()) {\n            constructor = constructor.getSuperClassConstructor();\n          } else {\n            constructor = null;\n          }\n        }\n      }\n    }\n  }\n\n  /** Implementation of TypeSystem using concrete types. */\n  private static class ConcreteTypeSystem implements TypeSystem<ConcreteType> {\n    private final TightenTypes tt;\n    private int nextUniqueId;\n    private CodingConvention codingConvention;\n    private final Set<JSType> invalidatingTypes = Sets.newHashSet();\n\n    // An array of native types that are not tracked by type tightening, and\n    // thus need to be added in if an unknown type is encountered.\n    private static final JSTypeNative [] nativeTypes = new JSTypeNative[] {\n        JSTypeNative.BOOLEAN_OBJECT_TYPE,\n        JSTypeNative.NUMBER_OBJECT_TYPE,\n        JSTypeNative.STRING_OBJECT_TYPE\n    };\n\n    public ConcreteTypeSystem(TightenTypes tt, CodingConvention convention) {\n      this.tt = tt;\n      this.codingConvention = convention;\n    }\n\n    @Override public void addInvalidatingType(JSType type) {\n      checkState(!type.isUnionType());\n      invalidatingTypes.add(type);\n    }\n\n    @Override public StaticScope<ConcreteType> getRootScope() {\n      return tt.getTopScope();\n    }\n\n    @Override public StaticScope<ConcreteType> getFunctionScope(Node decl) {\n      ConcreteFunctionType func = tt.getConcreteFunction(decl);\n      return (func != null) ?\n          func.getScope() : (StaticScope<ConcreteType>) null;\n    }\n\n    @Override\n    public ConcreteType getType(\n        StaticScope<ConcreteType> scope, Node node, String prop) {\n      if (scope != null) {\n        ConcreteType c = tt.inferConcreteType(\n            (TightenTypes.ConcreteScope) scope, node);\n        return maybeAddAutoboxes(c, node, prop);\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Add concrete types for autoboxing types if necessary. The concrete type\n     * system does not track native types, like string, so add them if they are\n     * present in the JSType for the node.\n     */\n    private ConcreteType maybeAddAutoboxes(\n        ConcreteType cType, Node node, String prop) {\n      JSType jsType = node.getJSType();\n      if (jsType == null) {\n        return cType;\n      } else if (jsType.isUnknownType()) {\n        for (JSTypeNative nativeType : nativeTypes) {\n          ConcreteType concrete = tt.getConcreteInstance(\n              tt.getTypeRegistry().getNativeObjectType(nativeType));\n          if (concrete != null && !concrete.getPropertyType(prop).isNone()) {\n            cType = cType.unionWith(concrete);\n          }\n        }\n        return cType;\n      }\n\n      return maybeAddAutoboxes(cType, jsType, prop);\n    }\n\n    private ConcreteType maybeAddAutoboxes(\n        ConcreteType cType, JSType jsType, String prop) {\n      jsType = jsType.restrictByNotNullOrUndefined();\n      if (jsType instanceof UnionType) {\n        for (JSType alt : ((UnionType) jsType).getAlternates()) {\n          return maybeAddAutoboxes(cType, alt, prop);\n        }\n      }\n\n      if (jsType.autoboxesTo() != null) {\n        JSType autoboxed = jsType.autoboxesTo();\n        return cType.unionWith(tt.getConcreteInstance((ObjectType) autoboxed));\n      } else if (jsType.unboxesTo() != null) {\n        return cType.unionWith(tt.getConcreteInstance((ObjectType) jsType));\n      }\n\n      return cType;\n    }\n\n    @Override public boolean isInvalidatingType(ConcreteType type) {\n      // We will disallow types on functions so that 'prototype' is not renamed.\n      // TODO(user): Support properties on functions as well.\n      return (type == null) || type.isAll() || type.isFunction()\n        || (type.isInstance()\n            && invalidatingTypes.contains(type.toInstance().instanceType));\n    }\n\n    @Override\n    public ImmutableSet<ConcreteType> getTypesToSkipForType(ConcreteType type) {\n      return ImmutableSet.of(type);\n    }\n\n    @Override public boolean isTypeToSkip(ConcreteType type) {\n      // Skip anonymous object literals and enum types.\n      return type.isInstance()\n        && !(type.toInstance().isFunctionPrototype()\n             || type.toInstance().instanceType.isInstanceType());\n    }\n\n    @Override\n    public ConcreteType restrictByNotNullOrUndefined(ConcreteType type) {\n      // These are not represented in concrete types.\n      return type;\n    }\n\n    @Override\n    public Iterable<ConcreteType> getTypeAlternatives(ConcreteType type) {\n      if (type.isUnion()) {\n        return ((ConcreteUnionType) type).getAlternatives();\n      } else {\n        return null;\n      }\n    }\n\n    @Override public ConcreteType getTypeWithProperty(String field,\n                                                      ConcreteType type) {\n      if (type.isInstance()) {\n        ConcreteInstanceType instanceType = (ConcreteInstanceType) type;\n        return instanceType.getInstanceTypeWithProperty(field);\n      } else if (type.isFunction()) {\n        if (\"prototype\".equals(field)\n            || codingConvention.isSuperClassReference(field)) {\n          return type;\n        }\n      } else if (type.isNone()) {\n        // If the receiver is none, then this code is never reached.  We will\n        // return a new fake type to ensure that this access is renamed\n        // differently from any other, so it can be easily removed.\n        return new ConcreteUniqueType(++nextUniqueId);\n      } else if (type.isUnion()) {\n        // If only one has the property, return that.\n        for (ConcreteType t : ((ConcreteUnionType) type).getAlternatives()) {\n          ConcreteType ret = getTypeWithProperty(field, t);\n          if (ret != null) {\n            return ret;\n          }\n        }\n      }\n      return null;\n    }\n\n    @Override public ConcreteType getInstanceFromPrototype(ConcreteType type) {\n      if (type.isInstance()) {\n        ConcreteInstanceType instanceType = (ConcreteInstanceType) type;\n        if (instanceType.isFunctionPrototype()) {\n          return instanceType.getConstructorType().getInstanceType();\n        }\n      }\n      return null;\n    }\n\n    @Override\n    public void recordInterfaces(ConcreteType type, ConcreteType relatedType,\n        DisambiguateProperties<ConcreteType>.Property p) {\n      // No need to record interfaces when using concrete types.\n    }\n  }\n}\n"}}
{"bug_id": "Closure_116", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.FunctionInjector#setKnownConstants(Set<String>#knownConstants)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_116/fixed/src/com/google/javascript/jscomp/FunctionInjector.java", "focal_method": "public void setKnownConstants(Set<String> knownConstants) {\n    // This is only expected to be set once. The same set should be used\n    // when evaluating call-sites and inlining calls.\n    Preconditions.checkState(this.knownConstants.isEmpty());\n    this.knownConstants = knownConstants;\n  }", "return_type": "void", "assertion_subject_candidates": ["ExpressionDecomposer com.google.javascript.jscomp.FunctionInjector#getDecomposer()"], "focal_class": {"name": "FunctionInjector", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_116/fixed/src/com/google/javascript/jscomp/FunctionInjector.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.base.Predicate;", "import com.google.common.base.Predicates;", "import com.google.common.base.Supplier;", "import com.google.common.collect.Sets;", "import com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.Collection;", "import java.util.Map;", "import java.util.Set;"], "fields": ["private final AbstractCompiler compiler", "private final Supplier<String> safeNameIdSupplier", "private final boolean allowDecomposition", "private Set<String> knownConstants = Sets.newHashSet()", "private final boolean assumeStrictThis", "private final boolean assumeMinimumCapture", "private static final int NAME_COST_ESTIMATE = InlineCostEstimator.ESTIMATED_IDENTIFIER_COST", "private static final int COMMA_COST = 1", "private static final int PAREN_COST = 2"], "methods": ["boolean com.google.javascript.jscomp.FunctionInjector#doesFunctionMeetMinimumRequirements(String#fnName,Node#fnNode)", "CanInlineResult com.google.javascript.jscomp.FunctionInjector#canInlineReferenceToFunction(NodeTraversal#t,Node#callNode,Node#fnNode,Set<String>#needAliases,InliningMode#mode,boolean#referencesThis,boolean#containsFunctions)", "boolean com.google.javascript.jscomp.FunctionInjector#isSupportedCallType(Node#callNode)", "Node com.google.javascript.jscomp.FunctionInjector#inline(Node#callNode,String#fnName,Node#fnNode,InliningMode#mode)", "Node com.google.javascript.jscomp.FunctionInjector#inlineReturnValue(Node#callNode,Node#fnNode)", "CallSiteType com.google.javascript.jscomp.FunctionInjector#classifyCallSite(Node#callNode)", "ExpressionDecomposer com.google.javascript.jscomp.FunctionInjector#getDecomposer()", "void com.google.javascript.jscomp.FunctionInjector#maybePrepareCall(Node#callNode)", "Node com.google.javascript.jscomp.FunctionInjector#inlineFunction(Node#callNode,Node#fnNode,String#fnName)", "boolean com.google.javascript.jscomp.FunctionInjector#isDirectCallNodeReplacementPossible(Node#fnNode)", "CanInlineResult com.google.javascript.jscomp.FunctionInjector#canInlineReferenceAsStatementBlock(NodeTraversal#t,Node#callNode,Node#fnNode,Set<String>#namesToAlias)", "boolean com.google.javascript.jscomp.FunctionInjector#callMeetsBlockInliningRequirements(NodeTraversal#t,Node#callNode,Node#fnNode,Set<String>#namesToAlias)", "CanInlineResult com.google.javascript.jscomp.FunctionInjector#canInlineReferenceDirectly(Node#callNode,Node#fnNode)", "boolean com.google.javascript.jscomp.FunctionInjector#inliningLowersCost(JSModule#fnModule,Node#fnNode,Collection<? extends Reference>#refs,Set<String>#namesToAlias,boolean#isRemovable,boolean#referencesThis)", "boolean com.google.javascript.jscomp.FunctionInjector#doesLowerCost(Node#fnNode,int#callCost,int#directInlines,int#costDeltaDirect,int#blockInlines,int#costDeltaBlock,boolean#removable)", "int com.google.javascript.jscomp.FunctionInjector#estimateCallCost(Node#fnNode,boolean#referencesThis)", "int com.google.javascript.jscomp.FunctionInjector#inlineCostDelta(Node#fnNode,Set<String>#namesToAlias,InliningMode#mode)"], "other_methods": [], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "Supplier<String>#safeNameIdSupplier": "private final Supplier<String> safeNameIdSupplier", "boolean#allowDecomposition": "private final boolean allowDecomposition", "Set<String>#knownConstants": "private Set<String> knownConstants = Sets.newHashSet()", "boolean#assumeStrictThis": "private final boolean assumeStrictThis", "boolean#assumeMinimumCapture": "private final boolean assumeMinimumCapture", "int#NAME_COST_ESTIMATE": "private static final int NAME_COST_ESTIMATE = InlineCostEstimator.ESTIMATED_IDENTIFIER_COST", "int#COMMA_COST": "private static final int COMMA_COST = 1", "int#PAREN_COST": "private static final int PAREN_COST = 2"}, "text": "/*\n * Copyright 2008 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.Sets;\nimport com.google.javascript.jscomp.ExpressionDecomposer.DecompositionType;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A set of utility functions that replaces CALL with a specified\n * FUNCTION body, replacing and aliasing function parameters as\n * necessary.\n *\n * @author johnlenz@google.com (John Lenz)\n */\nclass FunctionInjector {\n\n  private final AbstractCompiler compiler;\n  private final Supplier<String> safeNameIdSupplier;\n  private final boolean allowDecomposition;\n  private Set<String> knownConstants = Sets.newHashSet();\n  private final boolean assumeStrictThis;\n  private final boolean assumeMinimumCapture;\n\n  /**\n   * @param allowDecomposition Whether an effort should be made to break down\n   * expressions into simpler expressions to allow functions to be injected\n   * where they would otherwise be disallowed.\n   */\n  public FunctionInjector(\n      AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean allowDecomposition,\n      boolean assumeStrictThis,\n      boolean assumeMinimumCapture) {\n    Preconditions.checkNotNull(compiler);\n    Preconditions.checkNotNull(safeNameIdSupplier);\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n    this.allowDecomposition = allowDecomposition;\n    this.assumeStrictThis = assumeStrictThis;\n    this.assumeMinimumCapture = assumeMinimumCapture;\n  }\n\n  /** The type of inlining to perform. */\n  enum InliningMode {\n    /**\n     * Directly replace the call expression. Only functions of meeting\n     * strict preconditions can be inlined.\n     */\n    DIRECT,\n\n    /**\n     * Replaces the call expression with a block of statements. Conditions\n     * on the function are looser in mode, but stricter on the call site.\n     */\n    BLOCK\n  }\n\n  /** Holds a reference to the call node of a function call */\n  static class Reference {\n    final Node callNode;\n    final JSModule module;\n    final InliningMode mode;\n\n    Reference(Node callNode, JSModule module, InliningMode mode){\n      this.callNode = callNode;\n      this.module = module;\n      this.mode = mode;\n    }\n  }\n\n  /**\n   * In order to estimate the cost of lining, we make the assumption that\n   * Identifiers are reduced 2 characters. For the call arguments, the important\n   * thing is that the cost is assumed to be the same in the call and the\n   * function, so the actual length doesn't matter in most cases.\n   */\n  private static final int NAME_COST_ESTIMATE =\n      InlineCostEstimator.ESTIMATED_IDENTIFIER_COST;\n\n  /** The cost of a argument separator (a comma). */\n  private static final int COMMA_COST = 1;\n\n  /** The cost of the parentheses needed to make a call.*/\n  private static final int PAREN_COST = 2;\n\n\n  /**\n   * @param fnName The name of this function. This either the name of the\n   *  variable to which the function is assigned or the name from the FUNCTION\n   *  node.\n   * @param fnNode The FUNCTION node of the function to inspect.\n   * @return Whether the function node meets the minimum requirements for\n   * inlining.\n   */\n  boolean doesFunctionMeetMinimumRequirements(\n      final String fnName, Node fnNode) {\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Basic restrictions on functions that can be inlined:\n    // 0) The function is inlinable by convention\n    // 1) It contains a reference to itself.\n    // 2) It uses its parameters indirectly using \"arguments\" (it isn't\n    //    handled yet.\n    // 3) It references \"eval\". Inline a function containing eval can have\n    //    large performance implications.\n\n    if (!compiler.getCodingConvention().isInlinableFunction(fnNode)) {\n      return false;\n    }\n\n    final String fnRecursionName = fnNode.getFirstChild().getString();\n    Preconditions.checkState(fnRecursionName != null);\n\n    // If the function references \"arguments\" directly in the function\n    boolean referencesArguments = NodeUtil.isNameReferenced(\n        block, \"arguments\", NodeUtil.MATCH_NOT_FUNCTION);\n\n    // or it references \"eval\" or one of its names anywhere.\n    Predicate<Node> p = new Predicate<Node>(){\n      @Override\n      public boolean apply(Node n) {\n        if (n.isName()) {\n          return n.getString().equals(\"eval\")\n            || (!fnName.isEmpty()\n                && n.getString().equals(fnName))\n            || (!fnRecursionName.isEmpty()\n                && n.getString().equals(fnRecursionName));\n        }\n        return false;\n      }\n    };\n\n    return !referencesArguments\n        && !NodeUtil.has(block, p, Predicates.<Node>alwaysTrue());\n  }\n\n  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n        // TODO(johnlenz): Allow inlining into any scope without local names or\n        // inner functions.\n        return CanInlineResult.NO;\n      } else if (NodeUtil.isWithinLoop(callNode)) {\n        // An inner closure maybe relying on a local value holding a value for a\n        // single iteration through a loop.\n        return CanInlineResult.NO;\n      }\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }\n\n  /**\n   * Only \".call\" calls and direct calls to functions are supported.\n   * @param callNode The call evaluate.\n   * @return Whether the call is of a type that is supported.\n   */\n  private boolean isSupportedCallType(Node callNode) {\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        if (!assumeStrictThis) {\n          Node thisValue = callNode.getFirstChild().getNext();\n          if (thisValue == null || !thisValue.isThis()) {\n            return false;\n          }\n        }\n      } else if (NodeUtil.isFunctionObjectApply(callNode)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Inline a function into the call site.\n   */\n  Node inline(\n      Node callNode, String fnName, Node fnNode, InliningMode mode) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    if (mode == InliningMode.DIRECT) {\n      return inlineReturnValue(callNode, fnNode);\n    } else {\n      return inlineFunction(callNode, fnNode, fnName);\n    }\n  }\n\n  /**\n   * Inline a function that fulfills the requirements of\n   * canInlineReferenceDirectly into the call site, replacing only the CALL\n   * node.\n   */\n  private Node inlineReturnValue(Node callNode, Node fnNode) {\n    Node block = fnNode.getLastChild();\n    Node callParentNode = callNode.getParent();\n\n    // NOTE: As the normalize pass guarantees globals aren't being\n    // shadowed and an expression can't introduce new names, there is\n    // no need to check for conflicts.\n\n    // Create an argName -> expression map, checking for side effects.\n    Map<String, Node> argMap =\n        FunctionArgumentInjector.getFunctionCallParameterMap(\n            fnNode, callNode, this.safeNameIdSupplier);\n\n    Node newExpression;\n    if (!block.hasChildren()) {\n      Node srcLocation = block;\n      newExpression = NodeUtil.newUndefinedNode(srcLocation);\n    } else {\n      Node returnNode = block.getFirstChild();\n      Preconditions.checkArgument(returnNode.isReturn());\n\n      // Clone the return node first.\n      Node safeReturnNode = returnNode.cloneTree();\n      Node inlineResult = FunctionArgumentInjector.inject(\n          null, safeReturnNode, null, argMap);\n      Preconditions.checkArgument(safeReturnNode == inlineResult);\n      newExpression = safeReturnNode.removeFirstChild();\n    }\n\n    callParentNode.replaceChild(callNode, newExpression);\n    return newExpression;\n  }\n\n  /**\n   * Supported call site types.\n   */\n  private enum CallSiteType {\n\n    /**\n     * Used for a call site for which there does not exist a method\n     * to inline it.\n     */\n    UNSUPPORTED() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        throw new IllegalStateException(\"unexpected\");\n      }\n    },\n\n    /**\n     * A call as a statement. For example: \"foo();\".\n     *   EXPR_RESULT\n     *     CALL\n     */\n    SIMPLE_CALL() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        // Nothing to do.\n      }\n    },\n\n    /**\n     * An assignment, where the result of the call is assigned to a simple\n     * name. For example: \"a = foo();\".\n     *   EXPR_RESULT\n     *     NAME A\n     *     CALL\n     *       FOO\n     */\n    SIMPLE_ASSIGNMENT() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        // Nothing to do.\n      }\n    },\n    /**\n     * An var declaration and initialization, where the result of the call is\n     * assigned to the declared name\n     * name. For example: \"a = foo();\".\n     *   VAR\n     *     NAME A\n     *       CALL\n     *         FOO\n     */\n    VAR_DECL_SIMPLE_ASSIGNMENT() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        // Nothing to do.\n      }\n    },\n    /**\n     * An arbitrary expression, the root of which is a EXPR_RESULT, IF,\n     * RETURN, SWITCH or VAR.  The call must be the first side-effect in\n     * the expression.\n     *\n     * Examples include:\n     *   \"if (foo()) {...\"\n     *   \"return foo();\"\n     *   \"var a = 1 + foo();\"\n     *   \"a = 1 + foo()\"\n     *   \"foo() ? 1:0\"\n     *   \"foo() && x\"\n     */\n    EXPRESSION() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        injector.getDecomposer().moveExpression(callNode);\n\n        // Reclassify after move\n        CallSiteType callSiteType = injector.classifyCallSite(callNode);\n        Preconditions.checkState(this != callSiteType);\n        callSiteType.prepare(injector, callNode);\n      }\n    },\n\n    /**\n     * An arbitrary expression, the root of which is a EXPR_RESULT, IF,\n     * RETURN, SWITCH or VAR.  Where the call is not the first side-effect in\n     * the expression.\n     */\n    DECOMPOSABLE_EXPRESSION() {\n      @Override\n      public void prepare(FunctionInjector injector, Node callNode) {\n        injector.getDecomposer().maybeExposeExpression(callNode);\n\n        // Reclassify after decomposition\n        CallSiteType callSiteType = injector.classifyCallSite(callNode);\n        Preconditions.checkState(this != callSiteType);\n        callSiteType.prepare(injector, callNode);\n      }\n    };\n\n    public abstract void prepare(FunctionInjector injector, Node callNode);\n  }\n\n  /**\n   * Determine which, if any, of the supported types the call site is.\n   */\n  private CallSiteType classifyCallSite(Node callNode) {\n    Node parent = callNode.getParent();\n    Node grandParent = parent.getParent();\n\n    // Verify the call site:\n    if (NodeUtil.isExprCall(parent)) {\n      // This is a simple call?  Example: \"foo();\".\n      return CallSiteType.SIMPLE_CALL;\n    } else if (NodeUtil.isExprAssign(grandParent)\n        && !NodeUtil.isVarOrSimpleAssignLhs(callNode, parent)\n        && parent.getFirstChild().isName()\n        && !NodeUtil.isConstantName(parent.getFirstChild())) {\n      // This is a simple assignment.  Example: \"x = foo();\"\n      return CallSiteType.SIMPLE_ASSIGNMENT;\n    } else if (parent.isName()\n        && !NodeUtil.isConstantName(parent)\n        && grandParent.isVar()\n        && grandParent.hasOneChild()) {\n      // This is a var declaration.  Example: \"var x = foo();\"\n      // TODO(johnlenz): Should we be checking for constants on the\n      // left-hand-side of the assignments and handling them as EXPRESSION?\n      return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;\n    } else {\n      Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode);\n      if (expressionRoot != null) {\n        ExpressionDecomposer decomposer = new ExpressionDecomposer(\n            compiler, safeNameIdSupplier, knownConstants);\n        DecompositionType type = decomposer.canExposeExpression(\n            callNode);\n        if (type == DecompositionType.MOVABLE) {\n          return CallSiteType.EXPRESSION;\n        } else if (type == DecompositionType.DECOMPOSABLE) {\n          return CallSiteType.DECOMPOSABLE_EXPRESSION;\n        } else {\n          Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE);\n        }\n      }\n    }\n\n    return CallSiteType.UNSUPPORTED;\n  }\n\n  private ExpressionDecomposer getDecomposer() {\n    return new ExpressionDecomposer(\n        compiler, safeNameIdSupplier, knownConstants);\n  }\n\n  /**\n   * If required, rewrite the statement containing the call expression.\n   * @see ExpressionDecomposer#canExposeExpression\n   */\n  void maybePrepareCall(Node callNode) {\n    CallSiteType callSiteType = classifyCallSite(callNode);\n    callSiteType.prepare(this, callNode);\n  }\n\n  /**\n   * Inline a function which fulfills the requirements of\n   * canInlineReferenceAsStatementBlock into the call site, replacing the\n   * parent expression.\n   */\n  private Node inlineFunction(\n      Node callNode, Node fnNode, String fnName) {\n    Node parent = callNode.getParent();\n    Node grandParent = parent.getParent();\n\n    // TODO(johnlenz): Consider storing the callSite classification in the\n    // reference object and passing it in here.\n    CallSiteType callSiteType = classifyCallSite(callNode);\n    Preconditions.checkArgument(callSiteType != CallSiteType.UNSUPPORTED);\n\n    boolean isCallInLoop = NodeUtil.isWithinLoop(callNode);\n\n    // Store the name for the result. This will be used to\n    // replace \"return expr\" statements with \"resultName = expr\"\n    // to replace\n    String resultName = null;\n    boolean needsDefaultReturnResult = true;\n    switch (callSiteType) {\n      case SIMPLE_ASSIGNMENT:\n        resultName = parent.getFirstChild().getString();\n        break;\n\n      case VAR_DECL_SIMPLE_ASSIGNMENT:\n        resultName = parent.getString();\n        break;\n\n      case SIMPLE_CALL:\n        resultName = null;  // \"foo()\" doesn't need a result.\n        needsDefaultReturnResult = false;\n        break;\n\n      case EXPRESSION:\n        throw new IllegalStateException(\n            \"Movable expressions must be moved before inlining.\");\n\n      case DECOMPOSABLE_EXPRESSION:\n        throw new IllegalStateException(\n            \"Decomposable expressions must be decomposed before inlining.\");\n\n      default:\n        throw new IllegalStateException(\"Unexpected call site type.\");\n    }\n\n    FunctionToBlockMutator mutator = new FunctionToBlockMutator(\n        compiler, this.safeNameIdSupplier);\n\n    Node newBlock = mutator.mutate(\n        fnName, fnNode, callNode, resultName,\n        needsDefaultReturnResult, isCallInLoop);\n\n    // TODO(nicksantos): Create a common mutation function that\n    // can replace either a VAR name assignment, assignment expression or\n    // a EXPR_RESULT.\n    Node greatGrandParent = grandParent.getParent();\n    switch (callSiteType) {\n      case VAR_DECL_SIMPLE_ASSIGNMENT:\n        // Remove the call from the name node.\n        parent.removeChild(parent.getFirstChild());\n        Preconditions.checkState(parent.getFirstChild() == null);\n        // Add the call, after the VAR.\n        greatGrandParent.addChildAfter(newBlock, grandParent);\n        break;\n\n      case SIMPLE_ASSIGNMENT:\n        // The assignment is now part of the inline function so\n        // replace it completely.\n        Preconditions.checkState(grandParent.isExprResult());\n        greatGrandParent.replaceChild(grandParent, newBlock);\n        break;\n\n      case SIMPLE_CALL:\n        // If nothing is looking at the result just replace the call.\n        Preconditions.checkState(parent.isExprResult());\n        grandParent.replaceChild(parent, newBlock);\n        break;\n\n      default:\n        throw new IllegalStateException(\"Unexpected call site type.\");\n    }\n\n    return newBlock;\n  }\n\n  /**\n   * Checks if the given function matches the criteria for an inlinable\n   * function, and if so, adds it to our set of inlinable functions.\n   */\n  boolean isDirectCallNodeReplacementPossible(Node fnNode) {\n    // Only inline single-statement functions\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Check if this function is suitable for direct replacement of a CALL node:\n    // a function that consists of single return that returns an expression.\n    if (!block.hasChildren()) {\n      // special case empty functions.\n      return true;\n    } else if (block.hasOneChild()) {\n      // Only inline functions that return something.\n      if (block.getFirstChild().isReturn()\n          && block.getFirstChild().getFirstChild() != null) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  enum CanInlineResult {\n    YES,\n    AFTER_PREPARATION,\n    NO\n  }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * - It must be a simple call, or assignment, or var initialization.\n   * <pre>\n   *    f();\n   *    a = foo();\n   *    var a = foo();\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceAsStatementBlock(\n      NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias) {\n    CallSiteType callSiteType = classifyCallSite(callNode);\n    if (callSiteType == CallSiteType.UNSUPPORTED) {\n      return CanInlineResult.NO;\n    }\n\n    if (!allowDecomposition\n        && (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION\n            || callSiteType == CallSiteType.EXPRESSION)) {\n      return CanInlineResult.NO;\n    }\n\n    if (!callMeetsBlockInliningRequirements(\n            t, callNode, fnNode, namesToAlias)) {\n      return CanInlineResult.NO;\n    }\n\n    if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION\n        || callSiteType == CallSiteType.EXPRESSION) {\n      return CanInlineResult.AFTER_PREPARATION;\n    } else {\n      return CanInlineResult.YES;\n    }\n  }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * - Don't inline if the calling function contains an inner function and\n   * inlining would introduce new globals.\n   */\n  private boolean callMeetsBlockInliningRequirements(\n      NodeTraversal t, Node callNode, final Node fnNode,\n      Set<String> namesToAlias) {\n    final boolean assumeMinimumCapture = this.assumeMinimumCapture;\n\n    // Note: functions that contain function definitions are filtered out\n    // in isCandidateFunction.\n\n    // TODO(johnlenz): Determining if the called function contains VARs\n    // or if the caller contains inner functions accounts for 20% of the\n    // run-time cost of this pass.\n\n    // Don't inline functions with var declarations into a scope with inner\n    // functions as the new vars would leak into the inner function and\n    // cause memory leaks.\n    boolean fnContainsVars = NodeUtil.has(\n        NodeUtil.getFunctionBody(fnNode),\n        new NodeUtil.MatchDeclaration(),\n        new NodeUtil.MatchShallowStatement());\n    boolean forbidTemps = false;\n    if (!t.inGlobalScope()) {\n      Node fnCaller = t.getScopeRoot();\n      Node fnCallerBody = fnCaller.getLastChild();\n\n      // Don't allow any new vars into a scope that contains eval or one\n      // that contains functions (excluding the function being inlined).\n      Predicate<Node> match = new Predicate<Node>(){\n        @Override\n        public boolean apply(Node n) {\n          if (n.isName()) {\n            return n.getString().equals(\"eval\");\n          }\n          if (!assumeMinimumCapture && n.isFunction()) {\n            return n != fnNode;\n          }\n          return false;\n        }\n      };\n      forbidTemps = NodeUtil.has(fnCallerBody,\n          match, NodeUtil.MATCH_NOT_FUNCTION);\n    }\n\n    if (fnContainsVars && forbidTemps) {\n      return false;\n    }\n\n    // If the caller contains functions or evals, verify we aren't adding any\n    // additional VAR declarations because aliasing is needed.\n    if (forbidTemps) {\n      Map<String, Node> args =\n          FunctionArgumentInjector.getFunctionCallParameterMap(\n              fnNode, callNode, this.safeNameIdSupplier);\n      boolean hasArgs = !args.isEmpty();\n      if (hasArgs) {\n        // Limit the inlining\n        Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias);\n        FunctionArgumentInjector.maybeAddTempsForCallArguments(\n            fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n        if (!allNamesToAlias.isEmpty()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    boolean hasSideEffects = false;  // empty function case\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(\n            stmt.getFirstChild(), compiler);\n      }\n    }\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }\n\n  /**\n   * Determine if inlining the function is likely to reduce the code size.\n   * @param namesToAlias\n   */\n  boolean inliningLowersCost(\n      JSModule fnModule, Node fnNode, Collection<? extends Reference> refs,\n      Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {\n    int referenceCount = refs.size();\n    if (referenceCount == 0) {\n      return true;\n    }\n\n    int referencesUsingBlockInlining = 0;\n\n    boolean checkModules = isRemovable && fnModule != null;\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n\n    for (Reference ref : refs) {\n      if (ref.mode == InliningMode.BLOCK) {\n        referencesUsingBlockInlining++;\n      }\n\n      // Check if any of the references cross the module boundaries.\n      if (checkModules && ref.module != null) {\n        if (ref.module != fnModule &&\n            !moduleGraph.dependsOn(ref.module, fnModule)) {\n          // Calculate the cost as if the function were non-removable,\n          // if it still lowers the cost inline it.\n          isRemovable = false;\n          checkModules = false;  // no need to check additional modules.\n        }\n      }\n    }\n\n    int referencesUsingDirectInlining = referenceCount -\n        referencesUsingBlockInlining;\n\n    // Don't bother calculating the cost of function for simple functions where\n    // possible.\n    // However, when inlining a complex function, even a single reference may be\n    // larger than the original function if there are many returns (resulting\n    // in additional assignments) or many parameters that need to be aliased\n    // so use the cost estimating.\n    if (referenceCount == 1 && isRemovable &&\n        referencesUsingDirectInlining == 1) {\n      return true;\n    }\n\n    int callCost = estimateCallCost(fnNode, referencesThis);\n    int overallCallCost = callCost * referenceCount;\n\n    int costDeltaDirect = inlineCostDelta(\n        fnNode, namesToAlias, InliningMode.DIRECT);\n    int costDeltaBlock = inlineCostDelta(\n        fnNode, namesToAlias, InliningMode.BLOCK);\n\n    return doesLowerCost(fnNode, overallCallCost,\n        referencesUsingDirectInlining, costDeltaDirect,\n        referencesUsingBlockInlining, costDeltaBlock,\n        isRemovable);\n  }\n\n  /**\n   * @return Whether inlining will lower cost.\n   */\n  private boolean doesLowerCost(\n      Node fnNode, int callCost,\n      int directInlines, int costDeltaDirect,\n      int blockInlines, int costDeltaBlock,\n      boolean removable) {\n\n    // Determine the threshold value for this inequality:\n    //     inline_cost < call_cost\n    // But solve it for the function declaration size so the size of it\n    // is only calculated once and terminated early if possible.\n\n    int fnInstanceCount = directInlines + blockInlines - (removable ? 1 : 0);\n    // Prevent division by zero.\n    if (fnInstanceCount == 0) {\n      // Special case single reference function that are being block inlined:\n      // If the cost of the inline is greater than the function definition size,\n      // don't inline.\n      if (blockInlines > 0 && costDeltaBlock > 0) {\n        return false;\n      }\n      return true;\n    }\n\n    int costDelta = (directInlines * costDeltaDirect) +\n        (blockInlines * costDeltaBlock);\n    int threshold = (callCost - costDelta) / fnInstanceCount;\n\n    return InlineCostEstimator.getCost(fnNode, threshold + 1) <= threshold;\n  }\n\n  /**\n   * Gets an estimate of the cost in characters of making the function call:\n   * the sum of the identifiers and the separators.\n   * @param referencesThis\n   */\n  private static int estimateCallCost(Node fnNode, boolean referencesThis) {\n    Node argsNode = NodeUtil.getFunctionParameters(fnNode);\n    int numArgs = argsNode.getChildCount();\n\n    int callCost = NAME_COST_ESTIMATE + PAREN_COST;\n    if (numArgs > 0) {\n      callCost += (numArgs * NAME_COST_ESTIMATE) + ((numArgs - 1) * COMMA_COST);\n    }\n\n    if (referencesThis) {\n      // TODO(johnlenz): Update this if we start supporting inlining\n      // other functions that reference this.\n      // The only functions that reference this that are currently inlined\n      // are those that are called via \".call\" with an explicit \"this\".\n      callCost += 5 + 5;  // \".call\" + \"this,\"\n    }\n\n    return callCost;\n  }\n\n  /**\n   * @return The difference between the function definition cost and\n   *     inline cost.\n   */\n  private static int inlineCostDelta(\n      Node fnNode, Set<String> namesToAlias, InliningMode mode) {\n    // The part of the function that is never inlined:\n    //    \"function xx(xx,xx){}\" (15 + (param count * 3) -1;\n    int paramCount = NodeUtil.getFunctionParameters(fnNode).getChildCount();\n    int commaCount = (paramCount > 1) ? paramCount - 1 : 0;\n    int costDeltaFunctionOverhead = 15 + commaCount +\n        (paramCount * InlineCostEstimator.ESTIMATED_IDENTIFIER_COST);\n\n    Node block = fnNode.getLastChild();\n    if (!block.hasChildren()) {\n      // Assume the inline cost is zero for empty functions.\n      return -costDeltaFunctionOverhead;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      // The part of the function that is inlined using direct inlining:\n      //    \"return \" (7)\n      return -(costDeltaFunctionOverhead + 7);\n    } else {\n      int aliasCount = namesToAlias.size();\n\n      // Originally, we estimated purely base on the function code size, relying\n      // on later optimizations. But that did not produce good results, so here\n      // we try to estimate the something closer to the actual inlined coded.\n\n      // NOTE 1: Result overhead is only if there is an assignment, but\n      // getting that information would require some refactoring.\n      // NOTE 2: The aliasing overhead is currently an under-estimate,\n      // as some parameters are aliased because of the parameters used.\n      // Perhaps we should just assume all parameters will be aliased?\n      final int inlineBlockOverhead = 4; // \"X:{}\"\n      final int perReturnOverhead = 2;   // \"return\" --> \"break X\"\n      final int perReturnResultOverhead = 3; // \"XX=\"\n      final int perAliasOverhead = 3; // \"XX=\"\n\n      // TODO(johnlenz): Counting the number of returns is relatively expensive\n      //   this information should be determined during the traversal and\n      //   cached.\n      int returnCount = NodeUtil.getNodeTypeReferenceCount(\n          block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n      int resultCount = (returnCount > 0) ? returnCount - 1 : 0;\n      int baseOverhead = (returnCount > 0) ? inlineBlockOverhead : 0;\n\n      int overhead = baseOverhead\n          + returnCount * perReturnOverhead\n          + resultCount * perReturnResultOverhead\n          + aliasCount * perAliasOverhead;\n\n      return (overhead - costDeltaFunctionOverhead);\n    }\n  }\n\n  /**\n   * Store the names of known constants to be used when classifying call-sites\n   * in expressions.\n   */\n  public void setKnownConstants(Set<String> knownConstants) {\n    // This is only expected to be set once. The same set should be used\n    // when evaluating call-sites and inlining calls.\n    Preconditions.checkState(this.knownConstants.isEmpty());\n    this.knownConstants = knownConstants;\n  }\n}\n"}}
{"bug_id": "Closure_102", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.Normalize#process(Node#externs,Node#root)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_102/fixed/src/com/google/javascript/jscomp/Normalize.java", "focal_method": "@Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }", "return_type": "void", "assertion_subject_candidates": [], "focal_class": {"name": "Normalize", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_102/fixed/src/com/google/javascript/jscomp/Normalize.java", "superclass": "", "interface": "implements CompilerPass, Callback", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.Map;"], "fields": ["private final AbstractCompiler compiler", "private final boolean assertOnChange", "private static final boolean CONVERT_WHILE_TO_FOR = true", "static final boolean MAKE_LOCAL_NAMES_UNIQUE = true"], "methods": ["void com.google.javascript.jscomp.Normalize#reportCodeChange(String#changeDescription)", "boolean com.google.javascript.jscomp.Normalize#shouldTraverse(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.Normalize#visit(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.Normalize#doStatementNormalizations(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.Normalize#normalizeLabels(Node#n)", "void com.google.javascript.jscomp.Normalize#extractForInitializer(Node#n,Node#before,Node#beforeParent)", "void com.google.javascript.jscomp.Normalize#splitVarDeclarations(Node#n)", "void com.google.javascript.jscomp.Normalize#moveNamedFunctions(Node#functionBody)", "Node com.google.javascript.jscomp.Normalize#addToFront(Node#parent,Node#newChild,Node#after)", "void com.google.javascript.jscomp.Normalize#removeDuplicateDeclarations(Node#root)"], "other_methods": ["@Override\n  public boolean shouldTraverse(NodeTraversal t,Node n,Node parent);", "@Override\n  public void visit(NodeTraversal t,Node n,Node parent);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "boolean#assertOnChange": "private final boolean assertOnChange", "boolean#CONVERT_WHILE_TO_FOR": "private static final boolean CONVERT_WHILE_TO_FOR = true", "boolean#MAKE_LOCAL_NAMES_UNIQUE": "static final boolean MAKE_LOCAL_NAMES_UNIQUE = true"}, "text": "/*\n * Copyright 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Map;\n\n\n/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Splits var statements contains multiple declarations into individual\n * statements.\n * 2) Splits chained assign statements such as \"a = b = c = 0\" into individual\n * statements.  These are split as follows \"c = 0; b = c; a = b\". Unfortunately,\n * not all such statements can be broken up, for instance:\n *   \"a[next()] = a[next()] = 0\"\n * can not be made into\n *   \"a[next()] = 0; a[next()] = a[next()];\n * 3) init expressions in FOR statements are extracted and placed before the\n * statement. For example: \"for(var a=0;;);\" becomes \"var a=0;for(;;);\"\n * 4) WHILE statements are converted to FOR statements. For example:\n * \"while(true);\" becomes \"for(;true;);\"\n * 5) Renames constant variables, as marked with an IS_CONSTANT_NAME annotation,\n *   to include a suffix of NodeUtil.CONSTANT_MARKER which is used by constant\n *   inlining.\n *\n*\n */\n// public for ReplaceDebugStringsTest\nclass Normalize implements CompilerPass, Callback {\n\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  static final boolean MAKE_LOCAL_NAMES_UNIQUE = true;\n\n  Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n    this.compiler = compiler;\n    this.assertOnChange = assertOnChange;\n  }\n\n  private void reportCodeChange(String changeDescription) {\n    if (assertOnChange) {\n      throw new IllegalStateException(\n          \"Normalize constraints violated:\\n\" + changeDescription);\n    }\n    compiler.reportCodeChange();\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }\n\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    doStatementNormalizations(t, n, parent);\n\n    return true;\n  }\n\n  public static class PropogateConstantAnnotations\n      extends AbstractPostOrderCallback\n      implements CompilerPass {\n    private final AbstractCompiler compiler;\n    private final boolean assertOnChange;\n\n    public PropogateConstantAnnotations(\n        AbstractCompiler compiler, boolean forbidChanges) {\n      this.compiler = compiler;\n      this.assertOnChange = forbidChanges;\n    }\n\n    @Override\n    public void process(Node externs, Node root) {\n      new NodeTraversal(compiler, this).traverseRoots(externs, root);\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Note: Constant properties annotations are not propagated.\n      if (n.getType() == Token.NAME) {\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        JSDocInfo info = null;\n        // Find the JSDocInfo for a top level variable.\n        Var var = t.getScope().getVar(n.getString());\n        if (var != null) {\n          info = var.getJSDocInfo();\n        }\n\n        if ((info != null && info.isConstant()) &&\n            !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  gramps:\" + n.getParent().getParent().toStringTree());\n          }\n          // Even though the AST has changed (an annotation was added),\n          // the annotations are not compared so don't report the change.\n          // reportCodeChange(\"constant annotation\");\n        }\n      }\n    }\n  }\n\n  /**\n   * Walk the AST tree and verify that constant names are used consistently.\n   */\n  static class VerifyConstants extends AbstractPostOrderCallback\n      implements CompilerPass {\n\n    final private AbstractCompiler compiler;\n    final private boolean checkUserDeclarations;\n\n    VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) {\n      this.compiler = compiler;\n      this.checkUserDeclarations = checkUserDeclarations;\n    }\n\n    @Override\n    public void process(Node externs, Node root) {\n      Node externsAndJs = root.getParent();\n      Preconditions.checkState(externsAndJs != null);\n      Preconditions.checkState(externsAndJs.hasChild(externs));\n\n      NodeTraversal.traverseRoots(\n          compiler, Lists.newArrayList(externs, root), this);\n    }\n\n    private Map<String,Boolean> constantMap = Maps.newHashMap();\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.NAME) {\n        String name = n.getString();\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (checkUserDeclarations) {\n          boolean expectedConst = false;\n          if (NodeUtil.isConstantName(n)\n              || compiler.getCodingConvention().isConstant(n.getString())) {\n            expectedConst = true;\n          } else {\n            expectedConst = false;\n\n            JSDocInfo info = null;\n            Var var = t.getScope().getVar(n.getString());\n            if (var != null) {\n              info = var.getJSDocInfo();\n            }\n\n            if (info != null && info.isConstant()) {\n              expectedConst = true;\n            } else {\n              expectedConst = false;\n            }\n          }\n\n          if (expectedConst) {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name \" + name + \" is not annotated as constant.\");\n          } else {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name \" + name + \" should not be annotated as constant.\");\n          }\n        }\n\n        Boolean value = constantMap.get(name);\n        if (value == null) {\n          constantMap.put(name, isConst);\n        } else {\n          Preconditions.checkState(value.booleanValue() == isConst,\n              \"The name \" + name + \" is not consistently annotated as \" +\n              \"constant.\");\n        }\n      }\n    }\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.WHILE:\n        if (CONVERT_WHILE_TO_FOR) {\n          Node expr = n.getFirstChild();\n          n.setType(Token.FOR);\n          n.addChildBefore(new Node(Token.EMPTY), expr);\n          n.addChildAfter(new Node(Token.EMPTY), expr);\n          reportCodeChange(\"WHILE node\");\n        }\n        break;\n    }\n  }\n\n  /**\n   * Do normalizations that introduce new siblings or parents.\n   */\n  private void doStatementNormalizations(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.LABEL) {\n      normalizeLabels(n);\n    }\n\n    // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n    // are the only legal place for VARs and FOR statements.\n    if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n      extractForInitializer(n, null, null);\n    }\n\n    // Only inspect the children of SCRIPTs, BLOCKs, as all these\n    // are the only legal place for VARs.\n    if (NodeUtil.isStatementBlock(n)) {\n      splitVarDeclarations(n);\n    }\n\n    if (n.getType() == Token.FUNCTION) {\n      moveNamedFunctions(n.getLastChild());\n    }\n  }\n\n  // TODO(johnlenz): Move this to NodeTypeNormalizer once the unit tests are\n  // fixed.\n  /**\n   * Limit the number of special cases where LABELs need to be handled. Only\n   * BLOCK and loops are allowed to be labeled.  Loop labels must remain in\n   * place as the named continues are not allowed for labeled blocks.\n   */\n  private void normalizeLabels(Node n) {\n    Preconditions.checkArgument(n.getType() == Token.LABEL);\n\n    Node last = n.getLastChild();\n    switch (last.getType()) {\n      case Token.LABEL:\n      case Token.BLOCK:\n      case Token.FOR:\n      case Token.WHILE:\n      case Token.DO:\n        return;\n      default:\n        Node block = new Node(Token.BLOCK);\n        n.replaceChild(last, block);\n        block.addChildToFront(last);\n        reportCodeChange(\"LABEL normalization\");\n        return;\n    }\n  }\n\n  /**\n   * Bring the initializers out of FOR loops.  These need to be placed\n   * before any associated LABEL nodes. This needs to be done from the top\n   * level label first so this is called as a pre-order callback (from\n   * shouldTraverse).\n   *\n   * @param n The node to inspect.\n   * @param before The node to insert the initializer before.\n   * @param beforeParent The parent of the node before which the initializer\n   *     will be inserted.\n   */\n  private void extractForInitializer(\n      Node n, Node before, Node beforeParent) {\n\n    for (Node next, c = n.getFirstChild(); c != null; c = next) {\n      next = c.getNext();\n      Node insertBefore = (before == null) ? c : before;\n      Node insertBeforeParent = (before == null) ? n : beforeParent;\n      switch (c.getType()) {\n        case Token.LABEL:\n          extractForInitializer(c, insertBefore, insertBeforeParent);\n          break;\n        case Token.FOR:\n          if (!NodeUtil.isForIn(c)\n              && c.getFirstChild().getType() != Token.EMPTY) {\n            Node init = c.getFirstChild();\n            c.replaceChild(init, new Node(Token.EMPTY));\n\n            Node newStatement;\n            // Only VAR statements, and expressions are allowed,\n            // but are handled differently.\n            if (init.getType() == Token.VAR) {\n              newStatement = init;\n            } else {\n              newStatement = NodeUtil.newExpr(init);\n            }\n\n            insertBeforeParent.addChildBefore(newStatement, insertBefore);\n            reportCodeChange(\"FOR initializer\");\n          }\n          break;\n      }\n    }\n  }\n\n\n  /**\n   * Split a var node such as:\n   *   var a, b;\n   * into individual statements:\n   *   var a;\n   *   var b;\n   * @param n The whose children we should inspect.\n   */\n  private void splitVarDeclarations(Node n) {\n    for (Node next, c = n.getFirstChild(); c != null; c = next) {\n      next = c.getNext();\n      if (c.getType() == Token.VAR) {\n        if (assertOnChange && !c.hasChildren()) {\n          throw new IllegalStateException(\"Empty VAR node.\");\n        }\n\n        while (c.getFirstChild() != c.getLastChild()) {\n          Node name = c.getFirstChild();\n          c.removeChild(name);\n          Node newVar = new Node(Token.VAR, name, n.getLineno(), n.getCharno());\n          n.addChildBefore(newVar, c);\n          reportCodeChange(\"VAR with multiple children\");\n        }\n      }\n    }\n  }\n\n  /**\n   * Move all the functions that are valid at the execution of the first\n   * statement of the function to the beginning of the function definition.\n   */\n  private void moveNamedFunctions(Node functionBody) {\n    Preconditions.checkState(\n        functionBody.getParent().getType() == Token.FUNCTION);\n    Node previous = null;\n    Node current = functionBody.getFirstChild();\n    // Skip any declarations at the beginning of the function body, they\n    // are already in the right place.\n    while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n      previous = current;\n      current = current.getNext();\n    }\n\n    // Find any remaining declarations and move them.\n    Node insertAfter = previous;\n    while (current != null) {\n      // Save off the next node as the current node maybe removed.\n      Node next = current.getNext();\n      if (NodeUtil.isFunctionDeclaration(current)) {\n        // Remove the declaration from the body.\n        Preconditions.checkNotNull(previous);\n        functionBody.removeChildAfter(previous);\n\n        // Readd the function at the top of the function body (after any\n        // previous declarations).\n        insertAfter = addToFront(functionBody, current, insertAfter);\n        compiler.reportCodeChange();\n      } else {\n        // Update the previous only if the current node hasn't been moved.\n        previous = current;\n      }\n      current = next;\n    }\n  }\n\n  /**\n   * @param after The child node to insert the newChild after, or null if\n   *     newChild should be added to the front of parent's child list.\n   * @return The inserted child node.\n   */\n  private Node addToFront(Node parent, Node newChild, Node after) {\n    if (after == null) {\n      parent.addChildToFront(newChild);\n    } else {\n      parent.addChildAfter(newChild, after);\n    }\n    return newChild;\n  }\n\n  /**\n   * Remove duplicate VAR declarations.\n   */\n  private void removeDuplicateDeclarations(Node root) {\n    Callback tickler = new ScopeTicklingCallback();\n    ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n        compiler, new DuplicateDeclarationHandler());\n    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n    t.traverse(root);\n  }\n\n  /**\n   * ScopeCreator duplicate declaration handler.\n   */\n  private final class DuplicateDeclarationHandler implements\n      SyntacticScopeCreator.RedeclarationHandler {\n\n    /**\n     * Remove duplicate VAR declarations encountered discovered during\n     * scope creation.\n     */\n    @Override\n    public void onRedeclaration(\n        Scope s, String name, Node n, Node parent, Node gramps,\n        Node nodeWithLineNumber) {\n      Preconditions.checkState(n.getType() == Token.NAME);\n      if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n\n        //\n        // Remove the parent VAR. There are three cases that need to be handled:\n        //  1) \"var a = b;\" which is replaced with \"a = b\"\n        //  2) \"label:var a;\" which is replaced with \"label:;\".  Ideally, the\n        //     label itself would be removed but that is not possible in the\n        //     context in which \"onRedeclaration\" is called.\n        //  3) \"for (var a in b) ...\" which is replaced with \"for (a in b)...\"\n        // Cases we don't need to handle are VARs with multiple children,\n        // which have already been split into separate declarations, so there\n        // is no need to handle that here, and \"for (var a;;);\", which has\n        // been moved out of the loop.\n        //\n        // The result of this is that in each case the parent node is replaced\n        // which is generally dangerous in a traversal but is fine here with\n        // the scope creator, as the next node of interest is the parent's\n        // next sibling.\n        //\n        if (n.hasChildren()) {\n          // The var is being initialize, preserve the new value.\n          parent.removeChild(n);\n          // Convert \"var name = value\" to \"name = value\"\n          Node value = n.getFirstChild();\n          n.removeChild(value);\n          Node replacement = new Node(Token.ASSIGN, n, value);\n          gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement));\n        } else {\n          // It is an empty reference remove it.\n          if (NodeUtil.isStatementBlock(gramps)) {\n            gramps.removeChild(parent);\n          } else if (gramps.getType() == Token.FOR) {\n            // This is the \"for (var a in b)...\" case.  We don't need to worry\n            // about initializers in \"for (var a;;)...\" as those are moved out\n            // as part of the other normalizations.\n            parent.removeChild(n);\n            gramps.replaceChild(parent, n);\n          } else {\n            Preconditions.checkState(gramps.getType() == Token.LABEL);\n            gramps.replaceChild(parent, new Node(Token.EMPTY));\n          }\n        }\n        reportCodeChange(\"Duplicate VAR declaration\");\n      }\n    }\n\n  }\n\n  /**\n   * A simple class that causes scope to be created.\n   */\n  private final class ScopeTicklingCallback\n      implements NodeTraversal.ScopedCallback {\n    @Override\n    public void enterScope(NodeTraversal t) {\n      // Cause the scope to be created, which will cause duplicate\n      // to be found.\n      t.getScope();\n    }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n      // Nothing to do.\n    }\n\n    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      return true;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Nothing to do.\n    }\n  }\n\n}\n"}}
{"bug_id": "Closure_102", "version": "fixed", "focal_method_signature": "boolean com.google.javascript.jscomp.Normalize#shouldTraverse(NodeTraversal#t,Node#n,Node#parent)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_102/fixed/src/com/google/javascript/jscomp/Normalize.java", "focal_method": "@Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    doStatementNormalizations(t, n, parent);\n\n    return true;\n  }", "return_type": "boolean", "assertion_subject_candidates": ["boolean"], "focal_class": {"name": "Normalize", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_102/fixed/src/com/google/javascript/jscomp/Normalize.java", "superclass": "", "interface": "implements CompilerPass, Callback", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.Map;"], "fields": ["private final AbstractCompiler compiler", "private final boolean assertOnChange", "private static final boolean CONVERT_WHILE_TO_FOR = true", "static final boolean MAKE_LOCAL_NAMES_UNIQUE = true"], "methods": ["void com.google.javascript.jscomp.Normalize#reportCodeChange(String#changeDescription)", "void com.google.javascript.jscomp.Normalize#process(Node#externs,Node#root)", "void com.google.javascript.jscomp.Normalize#visit(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.Normalize#doStatementNormalizations(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.Normalize#normalizeLabels(Node#n)", "void com.google.javascript.jscomp.Normalize#extractForInitializer(Node#n,Node#before,Node#beforeParent)", "void com.google.javascript.jscomp.Normalize#splitVarDeclarations(Node#n)", "void com.google.javascript.jscomp.Normalize#moveNamedFunctions(Node#functionBody)", "Node com.google.javascript.jscomp.Normalize#addToFront(Node#parent,Node#newChild,Node#after)", "void com.google.javascript.jscomp.Normalize#removeDuplicateDeclarations(Node#root)"], "other_methods": ["@Override\n  public void process(Node externs,Node root);", "@Override\n  public void visit(NodeTraversal t,Node n,Node parent);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "boolean#assertOnChange": "private final boolean assertOnChange", "boolean#CONVERT_WHILE_TO_FOR": "private static final boolean CONVERT_WHILE_TO_FOR = true", "boolean#MAKE_LOCAL_NAMES_UNIQUE": "static final boolean MAKE_LOCAL_NAMES_UNIQUE = true"}, "text": "/*\n * Copyright 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Map;\n\n\n/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Splits var statements contains multiple declarations into individual\n * statements.\n * 2) Splits chained assign statements such as \"a = b = c = 0\" into individual\n * statements.  These are split as follows \"c = 0; b = c; a = b\". Unfortunately,\n * not all such statements can be broken up, for instance:\n *   \"a[next()] = a[next()] = 0\"\n * can not be made into\n *   \"a[next()] = 0; a[next()] = a[next()];\n * 3) init expressions in FOR statements are extracted and placed before the\n * statement. For example: \"for(var a=0;;);\" becomes \"var a=0;for(;;);\"\n * 4) WHILE statements are converted to FOR statements. For example:\n * \"while(true);\" becomes \"for(;true;);\"\n * 5) Renames constant variables, as marked with an IS_CONSTANT_NAME annotation,\n *   to include a suffix of NodeUtil.CONSTANT_MARKER which is used by constant\n *   inlining.\n *\n*\n */\n// public for ReplaceDebugStringsTest\nclass Normalize implements CompilerPass, Callback {\n\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  static final boolean MAKE_LOCAL_NAMES_UNIQUE = true;\n\n  Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n    this.compiler = compiler;\n    this.assertOnChange = assertOnChange;\n  }\n\n  private void reportCodeChange(String changeDescription) {\n    if (assertOnChange) {\n      throw new IllegalStateException(\n          \"Normalize constraints violated:\\n\" + changeDescription);\n    }\n    compiler.reportCodeChange();\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }\n\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    doStatementNormalizations(t, n, parent);\n\n    return true;\n  }\n\n  public static class PropogateConstantAnnotations\n      extends AbstractPostOrderCallback\n      implements CompilerPass {\n    private final AbstractCompiler compiler;\n    private final boolean assertOnChange;\n\n    public PropogateConstantAnnotations(\n        AbstractCompiler compiler, boolean forbidChanges) {\n      this.compiler = compiler;\n      this.assertOnChange = forbidChanges;\n    }\n\n    @Override\n    public void process(Node externs, Node root) {\n      new NodeTraversal(compiler, this).traverseRoots(externs, root);\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Note: Constant properties annotations are not propagated.\n      if (n.getType() == Token.NAME) {\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        JSDocInfo info = null;\n        // Find the JSDocInfo for a top level variable.\n        Var var = t.getScope().getVar(n.getString());\n        if (var != null) {\n          info = var.getJSDocInfo();\n        }\n\n        if ((info != null && info.isConstant()) &&\n            !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  gramps:\" + n.getParent().getParent().toStringTree());\n          }\n          // Even though the AST has changed (an annotation was added),\n          // the annotations are not compared so don't report the change.\n          // reportCodeChange(\"constant annotation\");\n        }\n      }\n    }\n  }\n\n  /**\n   * Walk the AST tree and verify that constant names are used consistently.\n   */\n  static class VerifyConstants extends AbstractPostOrderCallback\n      implements CompilerPass {\n\n    final private AbstractCompiler compiler;\n    final private boolean checkUserDeclarations;\n\n    VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) {\n      this.compiler = compiler;\n      this.checkUserDeclarations = checkUserDeclarations;\n    }\n\n    @Override\n    public void process(Node externs, Node root) {\n      Node externsAndJs = root.getParent();\n      Preconditions.checkState(externsAndJs != null);\n      Preconditions.checkState(externsAndJs.hasChild(externs));\n\n      NodeTraversal.traverseRoots(\n          compiler, Lists.newArrayList(externs, root), this);\n    }\n\n    private Map<String,Boolean> constantMap = Maps.newHashMap();\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.NAME) {\n        String name = n.getString();\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (checkUserDeclarations) {\n          boolean expectedConst = false;\n          if (NodeUtil.isConstantName(n)\n              || compiler.getCodingConvention().isConstant(n.getString())) {\n            expectedConst = true;\n          } else {\n            expectedConst = false;\n\n            JSDocInfo info = null;\n            Var var = t.getScope().getVar(n.getString());\n            if (var != null) {\n              info = var.getJSDocInfo();\n            }\n\n            if (info != null && info.isConstant()) {\n              expectedConst = true;\n            } else {\n              expectedConst = false;\n            }\n          }\n\n          if (expectedConst) {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name \" + name + \" is not annotated as constant.\");\n          } else {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name \" + name + \" should not be annotated as constant.\");\n          }\n        }\n\n        Boolean value = constantMap.get(name);\n        if (value == null) {\n          constantMap.put(name, isConst);\n        } else {\n          Preconditions.checkState(value.booleanValue() == isConst,\n              \"The name \" + name + \" is not consistently annotated as \" +\n              \"constant.\");\n        }\n      }\n    }\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.WHILE:\n        if (CONVERT_WHILE_TO_FOR) {\n          Node expr = n.getFirstChild();\n          n.setType(Token.FOR);\n          n.addChildBefore(new Node(Token.EMPTY), expr);\n          n.addChildAfter(new Node(Token.EMPTY), expr);\n          reportCodeChange(\"WHILE node\");\n        }\n        break;\n    }\n  }\n\n  /**\n   * Do normalizations that introduce new siblings or parents.\n   */\n  private void doStatementNormalizations(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.LABEL) {\n      normalizeLabels(n);\n    }\n\n    // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n    // are the only legal place for VARs and FOR statements.\n    if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n      extractForInitializer(n, null, null);\n    }\n\n    // Only inspect the children of SCRIPTs, BLOCKs, as all these\n    // are the only legal place for VARs.\n    if (NodeUtil.isStatementBlock(n)) {\n      splitVarDeclarations(n);\n    }\n\n    if (n.getType() == Token.FUNCTION) {\n      moveNamedFunctions(n.getLastChild());\n    }\n  }\n\n  // TODO(johnlenz): Move this to NodeTypeNormalizer once the unit tests are\n  // fixed.\n  /**\n   * Limit the number of special cases where LABELs need to be handled. Only\n   * BLOCK and loops are allowed to be labeled.  Loop labels must remain in\n   * place as the named continues are not allowed for labeled blocks.\n   */\n  private void normalizeLabels(Node n) {\n    Preconditions.checkArgument(n.getType() == Token.LABEL);\n\n    Node last = n.getLastChild();\n    switch (last.getType()) {\n      case Token.LABEL:\n      case Token.BLOCK:\n      case Token.FOR:\n      case Token.WHILE:\n      case Token.DO:\n        return;\n      default:\n        Node block = new Node(Token.BLOCK);\n        n.replaceChild(last, block);\n        block.addChildToFront(last);\n        reportCodeChange(\"LABEL normalization\");\n        return;\n    }\n  }\n\n  /**\n   * Bring the initializers out of FOR loops.  These need to be placed\n   * before any associated LABEL nodes. This needs to be done from the top\n   * level label first so this is called as a pre-order callback (from\n   * shouldTraverse).\n   *\n   * @param n The node to inspect.\n   * @param before The node to insert the initializer before.\n   * @param beforeParent The parent of the node before which the initializer\n   *     will be inserted.\n   */\n  private void extractForInitializer(\n      Node n, Node before, Node beforeParent) {\n\n    for (Node next, c = n.getFirstChild(); c != null; c = next) {\n      next = c.getNext();\n      Node insertBefore = (before == null) ? c : before;\n      Node insertBeforeParent = (before == null) ? n : beforeParent;\n      switch (c.getType()) {\n        case Token.LABEL:\n          extractForInitializer(c, insertBefore, insertBeforeParent);\n          break;\n        case Token.FOR:\n          if (!NodeUtil.isForIn(c)\n              && c.getFirstChild().getType() != Token.EMPTY) {\n            Node init = c.getFirstChild();\n            c.replaceChild(init, new Node(Token.EMPTY));\n\n            Node newStatement;\n            // Only VAR statements, and expressions are allowed,\n            // but are handled differently.\n            if (init.getType() == Token.VAR) {\n              newStatement = init;\n            } else {\n              newStatement = NodeUtil.newExpr(init);\n            }\n\n            insertBeforeParent.addChildBefore(newStatement, insertBefore);\n            reportCodeChange(\"FOR initializer\");\n          }\n          break;\n      }\n    }\n  }\n\n\n  /**\n   * Split a var node such as:\n   *   var a, b;\n   * into individual statements:\n   *   var a;\n   *   var b;\n   * @param n The whose children we should inspect.\n   */\n  private void splitVarDeclarations(Node n) {\n    for (Node next, c = n.getFirstChild(); c != null; c = next) {\n      next = c.getNext();\n      if (c.getType() == Token.VAR) {\n        if (assertOnChange && !c.hasChildren()) {\n          throw new IllegalStateException(\"Empty VAR node.\");\n        }\n\n        while (c.getFirstChild() != c.getLastChild()) {\n          Node name = c.getFirstChild();\n          c.removeChild(name);\n          Node newVar = new Node(Token.VAR, name, n.getLineno(), n.getCharno());\n          n.addChildBefore(newVar, c);\n          reportCodeChange(\"VAR with multiple children\");\n        }\n      }\n    }\n  }\n\n  /**\n   * Move all the functions that are valid at the execution of the first\n   * statement of the function to the beginning of the function definition.\n   */\n  private void moveNamedFunctions(Node functionBody) {\n    Preconditions.checkState(\n        functionBody.getParent().getType() == Token.FUNCTION);\n    Node previous = null;\n    Node current = functionBody.getFirstChild();\n    // Skip any declarations at the beginning of the function body, they\n    // are already in the right place.\n    while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n      previous = current;\n      current = current.getNext();\n    }\n\n    // Find any remaining declarations and move them.\n    Node insertAfter = previous;\n    while (current != null) {\n      // Save off the next node as the current node maybe removed.\n      Node next = current.getNext();\n      if (NodeUtil.isFunctionDeclaration(current)) {\n        // Remove the declaration from the body.\n        Preconditions.checkNotNull(previous);\n        functionBody.removeChildAfter(previous);\n\n        // Readd the function at the top of the function body (after any\n        // previous declarations).\n        insertAfter = addToFront(functionBody, current, insertAfter);\n        compiler.reportCodeChange();\n      } else {\n        // Update the previous only if the current node hasn't been moved.\n        previous = current;\n      }\n      current = next;\n    }\n  }\n\n  /**\n   * @param after The child node to insert the newChild after, or null if\n   *     newChild should be added to the front of parent's child list.\n   * @return The inserted child node.\n   */\n  private Node addToFront(Node parent, Node newChild, Node after) {\n    if (after == null) {\n      parent.addChildToFront(newChild);\n    } else {\n      parent.addChildAfter(newChild, after);\n    }\n    return newChild;\n  }\n\n  /**\n   * Remove duplicate VAR declarations.\n   */\n  private void removeDuplicateDeclarations(Node root) {\n    Callback tickler = new ScopeTicklingCallback();\n    ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n        compiler, new DuplicateDeclarationHandler());\n    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n    t.traverse(root);\n  }\n\n  /**\n   * ScopeCreator duplicate declaration handler.\n   */\n  private final class DuplicateDeclarationHandler implements\n      SyntacticScopeCreator.RedeclarationHandler {\n\n    /**\n     * Remove duplicate VAR declarations encountered discovered during\n     * scope creation.\n     */\n    @Override\n    public void onRedeclaration(\n        Scope s, String name, Node n, Node parent, Node gramps,\n        Node nodeWithLineNumber) {\n      Preconditions.checkState(n.getType() == Token.NAME);\n      if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n\n        //\n        // Remove the parent VAR. There are three cases that need to be handled:\n        //  1) \"var a = b;\" which is replaced with \"a = b\"\n        //  2) \"label:var a;\" which is replaced with \"label:;\".  Ideally, the\n        //     label itself would be removed but that is not possible in the\n        //     context in which \"onRedeclaration\" is called.\n        //  3) \"for (var a in b) ...\" which is replaced with \"for (a in b)...\"\n        // Cases we don't need to handle are VARs with multiple children,\n        // which have already been split into separate declarations, so there\n        // is no need to handle that here, and \"for (var a;;);\", which has\n        // been moved out of the loop.\n        //\n        // The result of this is that in each case the parent node is replaced\n        // which is generally dangerous in a traversal but is fine here with\n        // the scope creator, as the next node of interest is the parent's\n        // next sibling.\n        //\n        if (n.hasChildren()) {\n          // The var is being initialize, preserve the new value.\n          parent.removeChild(n);\n          // Convert \"var name = value\" to \"name = value\"\n          Node value = n.getFirstChild();\n          n.removeChild(value);\n          Node replacement = new Node(Token.ASSIGN, n, value);\n          gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement));\n        } else {\n          // It is an empty reference remove it.\n          if (NodeUtil.isStatementBlock(gramps)) {\n            gramps.removeChild(parent);\n          } else if (gramps.getType() == Token.FOR) {\n            // This is the \"for (var a in b)...\" case.  We don't need to worry\n            // about initializers in \"for (var a;;)...\" as those are moved out\n            // as part of the other normalizations.\n            parent.removeChild(n);\n            gramps.replaceChild(parent, n);\n          } else {\n            Preconditions.checkState(gramps.getType() == Token.LABEL);\n            gramps.replaceChild(parent, new Node(Token.EMPTY));\n          }\n        }\n        reportCodeChange(\"Duplicate VAR declaration\");\n      }\n    }\n\n  }\n\n  /**\n   * A simple class that causes scope to be created.\n   */\n  private final class ScopeTicklingCallback\n      implements NodeTraversal.ScopedCallback {\n    @Override\n    public void enterScope(NodeTraversal t) {\n      // Cause the scope to be created, which will cause duplicate\n      // to be found.\n      t.getScope();\n    }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n      // Nothing to do.\n    }\n\n    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      return true;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Nothing to do.\n    }\n  }\n\n}\n"}}
{"bug_id": "Closure_102", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.Normalize#visit(NodeTraversal#t,Node#n,Node#parent)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_102/fixed/src/com/google/javascript/jscomp/Normalize.java", "focal_method": "@Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.WHILE:\n        if (CONVERT_WHILE_TO_FOR) {\n          Node expr = n.getFirstChild();\n          n.setType(Token.FOR);\n          n.addChildBefore(new Node(Token.EMPTY), expr);\n          n.addChildAfter(new Node(Token.EMPTY), expr);\n          reportCodeChange(\"WHILE node\");\n        }\n        break;\n    }\n  }", "return_type": "void", "assertion_subject_candidates": [], "focal_class": {"name": "Normalize", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_102/fixed/src/com/google/javascript/jscomp/Normalize.java", "superclass": "", "interface": "implements CompilerPass, Callback", "imports": ["import com.google.common.base.Preconditions;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;", "import com.google.javascript.jscomp.NodeTraversal.Callback;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import java.util.Map;"], "fields": ["private final AbstractCompiler compiler", "private final boolean assertOnChange", "private static final boolean CONVERT_WHILE_TO_FOR = true", "static final boolean MAKE_LOCAL_NAMES_UNIQUE = true"], "methods": ["void com.google.javascript.jscomp.Normalize#reportCodeChange(String#changeDescription)", "void com.google.javascript.jscomp.Normalize#process(Node#externs,Node#root)", "boolean com.google.javascript.jscomp.Normalize#shouldTraverse(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.Normalize#doStatementNormalizations(NodeTraversal#t,Node#n,Node#parent)", "void com.google.javascript.jscomp.Normalize#normalizeLabels(Node#n)", "void com.google.javascript.jscomp.Normalize#extractForInitializer(Node#n,Node#before,Node#beforeParent)", "void com.google.javascript.jscomp.Normalize#splitVarDeclarations(Node#n)", "void com.google.javascript.jscomp.Normalize#moveNamedFunctions(Node#functionBody)", "Node com.google.javascript.jscomp.Normalize#addToFront(Node#parent,Node#newChild,Node#after)", "void com.google.javascript.jscomp.Normalize#removeDuplicateDeclarations(Node#root)"], "other_methods": ["@Override\n  public void process(Node externs,Node root);", "@Override\n  public boolean shouldTraverse(NodeTraversal t,Node n,Node parent);"], "fields_dict": {"AbstractCompiler#compiler": "private final AbstractCompiler compiler", "boolean#assertOnChange": "private final boolean assertOnChange", "boolean#CONVERT_WHILE_TO_FOR": "private static final boolean CONVERT_WHILE_TO_FOR = true", "boolean#MAKE_LOCAL_NAMES_UNIQUE": "static final boolean MAKE_LOCAL_NAMES_UNIQUE = true"}, "text": "/*\n * Copyright 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.Map;\n\n\n/**\n * The goal with this pass is to simplify the other passes,\n * by making less complex statements.\n *\n * Starting with statements like:\n *   var a = 0, b = foo();\n *\n * Which become:\n *   var a = 0;\n *   var b = foo();\n *\n * The key here is only to break down things that help the other passes\n * and can be put back together in a form that is at least as small when\n * all is said and done.\n *\n * This pass currently does the following:\n * 1) Splits var statements contains multiple declarations into individual\n * statements.\n * 2) Splits chained assign statements such as \"a = b = c = 0\" into individual\n * statements.  These are split as follows \"c = 0; b = c; a = b\". Unfortunately,\n * not all such statements can be broken up, for instance:\n *   \"a[next()] = a[next()] = 0\"\n * can not be made into\n *   \"a[next()] = 0; a[next()] = a[next()];\n * 3) init expressions in FOR statements are extracted and placed before the\n * statement. For example: \"for(var a=0;;);\" becomes \"var a=0;for(;;);\"\n * 4) WHILE statements are converted to FOR statements. For example:\n * \"while(true);\" becomes \"for(;true;);\"\n * 5) Renames constant variables, as marked with an IS_CONSTANT_NAME annotation,\n *   to include a suffix of NodeUtil.CONSTANT_MARKER which is used by constant\n *   inlining.\n *\n*\n */\n// public for ReplaceDebugStringsTest\nclass Normalize implements CompilerPass, Callback {\n\n  private final AbstractCompiler compiler;\n  private final boolean assertOnChange;\n  private static final boolean CONVERT_WHILE_TO_FOR = true;\n  static final boolean MAKE_LOCAL_NAMES_UNIQUE = true;\n\n  Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n    this.compiler = compiler;\n    this.assertOnChange = assertOnChange;\n  }\n\n  private void reportCodeChange(String changeDescription) {\n    if (assertOnChange) {\n      throw new IllegalStateException(\n          \"Normalize constraints violated:\\n\" + changeDescription);\n    }\n    compiler.reportCodeChange();\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n    removeDuplicateDeclarations(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }\n\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    doStatementNormalizations(t, n, parent);\n\n    return true;\n  }\n\n  public static class PropogateConstantAnnotations\n      extends AbstractPostOrderCallback\n      implements CompilerPass {\n    private final AbstractCompiler compiler;\n    private final boolean assertOnChange;\n\n    public PropogateConstantAnnotations(\n        AbstractCompiler compiler, boolean forbidChanges) {\n      this.compiler = compiler;\n      this.assertOnChange = forbidChanges;\n    }\n\n    @Override\n    public void process(Node externs, Node root) {\n      new NodeTraversal(compiler, this).traverseRoots(externs, root);\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Note: Constant properties annotations are not propagated.\n      if (n.getType() == Token.NAME) {\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        JSDocInfo info = null;\n        // Find the JSDocInfo for a top level variable.\n        Var var = t.getScope().getVar(n.getString());\n        if (var != null) {\n          info = var.getJSDocInfo();\n        }\n\n        if ((info != null && info.isConstant()) &&\n            !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  gramps:\" + n.getParent().getParent().toStringTree());\n          }\n          // Even though the AST has changed (an annotation was added),\n          // the annotations are not compared so don't report the change.\n          // reportCodeChange(\"constant annotation\");\n        }\n      }\n    }\n  }\n\n  /**\n   * Walk the AST tree and verify that constant names are used consistently.\n   */\n  static class VerifyConstants extends AbstractPostOrderCallback\n      implements CompilerPass {\n\n    final private AbstractCompiler compiler;\n    final private boolean checkUserDeclarations;\n\n    VerifyConstants(AbstractCompiler compiler, boolean checkUserDeclarations) {\n      this.compiler = compiler;\n      this.checkUserDeclarations = checkUserDeclarations;\n    }\n\n    @Override\n    public void process(Node externs, Node root) {\n      Node externsAndJs = root.getParent();\n      Preconditions.checkState(externsAndJs != null);\n      Preconditions.checkState(externsAndJs.hasChild(externs));\n\n      NodeTraversal.traverseRoots(\n          compiler, Lists.newArrayList(externs, root), this);\n    }\n\n    private Map<String,Boolean> constantMap = Maps.newHashMap();\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.NAME) {\n        String name = n.getString();\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (checkUserDeclarations) {\n          boolean expectedConst = false;\n          if (NodeUtil.isConstantName(n)\n              || compiler.getCodingConvention().isConstant(n.getString())) {\n            expectedConst = true;\n          } else {\n            expectedConst = false;\n\n            JSDocInfo info = null;\n            Var var = t.getScope().getVar(n.getString());\n            if (var != null) {\n              info = var.getJSDocInfo();\n            }\n\n            if (info != null && info.isConstant()) {\n              expectedConst = true;\n            } else {\n              expectedConst = false;\n            }\n          }\n\n          if (expectedConst) {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name \" + name + \" is not annotated as constant.\");\n          } else {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name \" + name + \" should not be annotated as constant.\");\n          }\n        }\n\n        Boolean value = constantMap.get(name);\n        if (value == null) {\n          constantMap.put(name, isConst);\n        } else {\n          Preconditions.checkState(value.booleanValue() == isConst,\n              \"The name \" + name + \" is not consistently annotated as \" +\n              \"constant.\");\n        }\n      }\n    }\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.WHILE:\n        if (CONVERT_WHILE_TO_FOR) {\n          Node expr = n.getFirstChild();\n          n.setType(Token.FOR);\n          n.addChildBefore(new Node(Token.EMPTY), expr);\n          n.addChildAfter(new Node(Token.EMPTY), expr);\n          reportCodeChange(\"WHILE node\");\n        }\n        break;\n    }\n  }\n\n  /**\n   * Do normalizations that introduce new siblings or parents.\n   */\n  private void doStatementNormalizations(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.LABEL) {\n      normalizeLabels(n);\n    }\n\n    // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n    // are the only legal place for VARs and FOR statements.\n    if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n      extractForInitializer(n, null, null);\n    }\n\n    // Only inspect the children of SCRIPTs, BLOCKs, as all these\n    // are the only legal place for VARs.\n    if (NodeUtil.isStatementBlock(n)) {\n      splitVarDeclarations(n);\n    }\n\n    if (n.getType() == Token.FUNCTION) {\n      moveNamedFunctions(n.getLastChild());\n    }\n  }\n\n  // TODO(johnlenz): Move this to NodeTypeNormalizer once the unit tests are\n  // fixed.\n  /**\n   * Limit the number of special cases where LABELs need to be handled. Only\n   * BLOCK and loops are allowed to be labeled.  Loop labels must remain in\n   * place as the named continues are not allowed for labeled blocks.\n   */\n  private void normalizeLabels(Node n) {\n    Preconditions.checkArgument(n.getType() == Token.LABEL);\n\n    Node last = n.getLastChild();\n    switch (last.getType()) {\n      case Token.LABEL:\n      case Token.BLOCK:\n      case Token.FOR:\n      case Token.WHILE:\n      case Token.DO:\n        return;\n      default:\n        Node block = new Node(Token.BLOCK);\n        n.replaceChild(last, block);\n        block.addChildToFront(last);\n        reportCodeChange(\"LABEL normalization\");\n        return;\n    }\n  }\n\n  /**\n   * Bring the initializers out of FOR loops.  These need to be placed\n   * before any associated LABEL nodes. This needs to be done from the top\n   * level label first so this is called as a pre-order callback (from\n   * shouldTraverse).\n   *\n   * @param n The node to inspect.\n   * @param before The node to insert the initializer before.\n   * @param beforeParent The parent of the node before which the initializer\n   *     will be inserted.\n   */\n  private void extractForInitializer(\n      Node n, Node before, Node beforeParent) {\n\n    for (Node next, c = n.getFirstChild(); c != null; c = next) {\n      next = c.getNext();\n      Node insertBefore = (before == null) ? c : before;\n      Node insertBeforeParent = (before == null) ? n : beforeParent;\n      switch (c.getType()) {\n        case Token.LABEL:\n          extractForInitializer(c, insertBefore, insertBeforeParent);\n          break;\n        case Token.FOR:\n          if (!NodeUtil.isForIn(c)\n              && c.getFirstChild().getType() != Token.EMPTY) {\n            Node init = c.getFirstChild();\n            c.replaceChild(init, new Node(Token.EMPTY));\n\n            Node newStatement;\n            // Only VAR statements, and expressions are allowed,\n            // but are handled differently.\n            if (init.getType() == Token.VAR) {\n              newStatement = init;\n            } else {\n              newStatement = NodeUtil.newExpr(init);\n            }\n\n            insertBeforeParent.addChildBefore(newStatement, insertBefore);\n            reportCodeChange(\"FOR initializer\");\n          }\n          break;\n      }\n    }\n  }\n\n\n  /**\n   * Split a var node such as:\n   *   var a, b;\n   * into individual statements:\n   *   var a;\n   *   var b;\n   * @param n The whose children we should inspect.\n   */\n  private void splitVarDeclarations(Node n) {\n    for (Node next, c = n.getFirstChild(); c != null; c = next) {\n      next = c.getNext();\n      if (c.getType() == Token.VAR) {\n        if (assertOnChange && !c.hasChildren()) {\n          throw new IllegalStateException(\"Empty VAR node.\");\n        }\n\n        while (c.getFirstChild() != c.getLastChild()) {\n          Node name = c.getFirstChild();\n          c.removeChild(name);\n          Node newVar = new Node(Token.VAR, name, n.getLineno(), n.getCharno());\n          n.addChildBefore(newVar, c);\n          reportCodeChange(\"VAR with multiple children\");\n        }\n      }\n    }\n  }\n\n  /**\n   * Move all the functions that are valid at the execution of the first\n   * statement of the function to the beginning of the function definition.\n   */\n  private void moveNamedFunctions(Node functionBody) {\n    Preconditions.checkState(\n        functionBody.getParent().getType() == Token.FUNCTION);\n    Node previous = null;\n    Node current = functionBody.getFirstChild();\n    // Skip any declarations at the beginning of the function body, they\n    // are already in the right place.\n    while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n      previous = current;\n      current = current.getNext();\n    }\n\n    // Find any remaining declarations and move them.\n    Node insertAfter = previous;\n    while (current != null) {\n      // Save off the next node as the current node maybe removed.\n      Node next = current.getNext();\n      if (NodeUtil.isFunctionDeclaration(current)) {\n        // Remove the declaration from the body.\n        Preconditions.checkNotNull(previous);\n        functionBody.removeChildAfter(previous);\n\n        // Readd the function at the top of the function body (after any\n        // previous declarations).\n        insertAfter = addToFront(functionBody, current, insertAfter);\n        compiler.reportCodeChange();\n      } else {\n        // Update the previous only if the current node hasn't been moved.\n        previous = current;\n      }\n      current = next;\n    }\n  }\n\n  /**\n   * @param after The child node to insert the newChild after, or null if\n   *     newChild should be added to the front of parent's child list.\n   * @return The inserted child node.\n   */\n  private Node addToFront(Node parent, Node newChild, Node after) {\n    if (after == null) {\n      parent.addChildToFront(newChild);\n    } else {\n      parent.addChildAfter(newChild, after);\n    }\n    return newChild;\n  }\n\n  /**\n   * Remove duplicate VAR declarations.\n   */\n  private void removeDuplicateDeclarations(Node root) {\n    Callback tickler = new ScopeTicklingCallback();\n    ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n        compiler, new DuplicateDeclarationHandler());\n    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n    t.traverse(root);\n  }\n\n  /**\n   * ScopeCreator duplicate declaration handler.\n   */\n  private final class DuplicateDeclarationHandler implements\n      SyntacticScopeCreator.RedeclarationHandler {\n\n    /**\n     * Remove duplicate VAR declarations encountered discovered during\n     * scope creation.\n     */\n    @Override\n    public void onRedeclaration(\n        Scope s, String name, Node n, Node parent, Node gramps,\n        Node nodeWithLineNumber) {\n      Preconditions.checkState(n.getType() == Token.NAME);\n      if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n\n        //\n        // Remove the parent VAR. There are three cases that need to be handled:\n        //  1) \"var a = b;\" which is replaced with \"a = b\"\n        //  2) \"label:var a;\" which is replaced with \"label:;\".  Ideally, the\n        //     label itself would be removed but that is not possible in the\n        //     context in which \"onRedeclaration\" is called.\n        //  3) \"for (var a in b) ...\" which is replaced with \"for (a in b)...\"\n        // Cases we don't need to handle are VARs with multiple children,\n        // which have already been split into separate declarations, so there\n        // is no need to handle that here, and \"for (var a;;);\", which has\n        // been moved out of the loop.\n        //\n        // The result of this is that in each case the parent node is replaced\n        // which is generally dangerous in a traversal but is fine here with\n        // the scope creator, as the next node of interest is the parent's\n        // next sibling.\n        //\n        if (n.hasChildren()) {\n          // The var is being initialize, preserve the new value.\n          parent.removeChild(n);\n          // Convert \"var name = value\" to \"name = value\"\n          Node value = n.getFirstChild();\n          n.removeChild(value);\n          Node replacement = new Node(Token.ASSIGN, n, value);\n          gramps.replaceChild(parent, new Node(Token.EXPR_RESULT, replacement));\n        } else {\n          // It is an empty reference remove it.\n          if (NodeUtil.isStatementBlock(gramps)) {\n            gramps.removeChild(parent);\n          } else if (gramps.getType() == Token.FOR) {\n            // This is the \"for (var a in b)...\" case.  We don't need to worry\n            // about initializers in \"for (var a;;)...\" as those are moved out\n            // as part of the other normalizations.\n            parent.removeChild(n);\n            gramps.replaceChild(parent, n);\n          } else {\n            Preconditions.checkState(gramps.getType() == Token.LABEL);\n            gramps.replaceChild(parent, new Node(Token.EMPTY));\n          }\n        }\n        reportCodeChange(\"Duplicate VAR declaration\");\n      }\n    }\n\n  }\n\n  /**\n   * A simple class that causes scope to be created.\n   */\n  private final class ScopeTicklingCallback\n      implements NodeTraversal.ScopedCallback {\n    @Override\n    public void enterScope(NodeTraversal t) {\n      // Cause the scope to be created, which will cause duplicate\n      // to be found.\n      t.getScope();\n    }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n      // Nothing to do.\n    }\n\n    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      return true;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Nothing to do.\n    }\n  }\n\n}\n"}}
