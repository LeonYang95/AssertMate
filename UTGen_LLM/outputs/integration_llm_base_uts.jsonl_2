{"bug_id": "JacksonCore_22", "version": "fixed", "focal_method_signature": "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTokenId(int#id)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "focal_method": "@Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }", "return_type": "boolean", "assertion_subject_candidates": ["boolean", "TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()"], "focal_class": {"name": "FilteringParserDelegate", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "superclass": "extends JsonParserDelegate", "interface": "", "imports": ["import java.io.IOException;", "import java.io.OutputStream;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.util.JsonParserDelegate;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected TokenFilter rootFilter", "protected boolean _allowMultipleMatches", "protected boolean _includePath", "@Deprecated\n    protected boolean _includeImmediateParent", "protected JsonToken _currToken", "protected JsonToken _lastClearedToken", "protected TokenFilterContext _headContext", "protected TokenFilterContext _exposedContext", "protected TokenFilter _itemFilter", "protected int _matchCount"], "methods": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentToken()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentTokenId()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentTokenId()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasCurrentToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasToken(JsonToken#t)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartArrayToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartObjectToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentName()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#clearCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#overrideCurrentName(String#name)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextToken2()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextTokenWithBuffering(TokenFilterContext#buffRoot)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextBuffered(TokenFilterContext#buffRoot)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#_verifyAllowedMatches()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextValue()", "JsonParser com.fasterxml.jackson.core.filter.FilteringParserDelegate#skipChildren()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTextCharacters()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#_filterContext()"], "other_methods": ["public TokenFilter getFilter();", "public int getMatchCount();", "@Override public JsonToken getCurrentToken();", "@Override public JsonToken currentToken();", "@Override public final int getCurrentTokenId();", "@Override public final int currentTokenId();", "@Override public boolean hasCurrentToken();", "@Override public final boolean hasToken(JsonToken t);", "@Override public boolean isExpectedStartArrayToken();", "@Override public boolean isExpectedStartObjectToken();", "@Override public JsonLocation getCurrentLocation();", "@Override\n    public JsonStreamContext getParsingContext();", "@Override\n    public String getCurrentName();", "@Override\n    public void clearCurrentToken();", "@Override\n    public JsonToken getLastClearedToken();", "@Override\n    public void overrideCurrentName(String name);", "@Override\n    public JsonToken nextToken();", "@Override\n    public JsonToken nextValue();", "@Override\n    public JsonParser skipChildren();", "@Override public String getText();", "@Override public boolean hasTextCharacters();", "@Override public char[] getTextCharacters();", "@Override public int getTextLength();", "@Override public int getTextOffset();", "@Override\n    public BigInteger getBigIntegerValue();", "@Override\n    public boolean getBooleanValue();", "@Override\n    public byte getByteValue();", "@Override\n    public short getShortValue();", "@Override\n    public BigDecimal getDecimalValue();", "@Override\n    public double getDoubleValue();", "@Override\n    public float getFloatValue();", "@Override\n    public int getIntValue();", "@Override\n    public long getLongValue();", "@Override\n    public NumberType getNumberType();", "@Override\n    public Number getNumberValue();", "@Override public int getValueAsInt();", "@Override public int getValueAsInt(int defaultValue);", "@Override public long getValueAsLong();", "@Override public long getValueAsLong(long defaultValue);", "@Override public double getValueAsDouble();", "@Override public double getValueAsDouble(double defaultValue);", "@Override public boolean getValueAsBoolean();", "@Override public boolean getValueAsBoolean(boolean defaultValue);", "@Override public String getValueAsString();", "@Override public String getValueAsString(String defaultValue);", "@Override public Object getEmbeddedObject();", "@Override public byte[] getBinaryValue(Base64Variant b64variant);", "@Override public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override public JsonLocation getTokenLocation();"], "fields_dict": {"TokenFilter#rootFilter": "protected TokenFilter rootFilter", "boolean#_allowMultipleMatches": "protected boolean _allowMultipleMatches", "boolean#_includePath": "protected boolean _includePath", "boolean#_includeImmediateParent": "@Deprecated\n    protected boolean _includeImmediateParent", "JsonToken#_currToken": "protected JsonToken _currToken", "JsonToken#_lastClearedToken": "protected JsonToken _lastClearedToken", "TokenFilterContext#_headContext": "protected TokenFilterContext _headContext", "TokenFilterContext#_exposedContext": "protected TokenFilterContext _exposedContext", "TokenFilter#_itemFilter": "protected TokenFilter _itemFilter", "int#_matchCount": "protected int _matchCount"}, "text": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    @Override public final int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n            // matched once, return null\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_verifyAllowedMatches() && _includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    if (_verifyAllowedMatches()) {\n                        return (_currToken = t);\n                    }\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                _currToken = t;\n                return t;\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_verifyAllowedMatches() && _includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return (_currToken = t);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return _nextBuffered(buffRoot);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n\n    private final boolean _verifyAllowedMatches() throws IOException {\n        if (_matchCount == 0 || _allowMultipleMatches) {\n            ++_matchCount;\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `hasTokenId(int id)` method of the `FilteringParserDelegate` class. These tests aim to maximize both branch and line coverage.\n\nFirst, ensure you have the necessary imports and a test class setup:\n\n```java\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.core.JsonTokenId;\n\npublic class FilteringParserDelegateTest {\n\n    private FilteringParserDelegate delegate;\n\n    @Before\n    public void setUp() {\n        delegate = new FilteringParserDelegate(null, null, false, false);\n    }\n}\n```\n\nNow, let's write the tests for the `hasTokenId(int id)` method:\n\n```java\npublic class FilteringParserDelegateTest {\n\n    private FilteringParserDelegate delegate;\n\n    @Before\n    public void setUp() {\n        delegate = new FilteringParserDelegate(null, null, false, false);\n    }\n\n    @Test\n    public void testHasTokenId_NoCurrentToken_IdNoToken() {\n        // Given\n        delegate._currToken = null;\n\n        // When\n        boolean result = delegate.hasTokenId(JsonTokenId.ID_NO_TOKEN);\n\n        // Then\n        assertTrue(result);\n    }\n\n    @Test\n    public void testHasTokenId_NoCurrentToken_OtherId() {\n        // Given\n        delegate._currToken = null;\n\n        // When\n        boolean result = delegate.hasTokenId(JsonTokenId.ID_NUMBER_INT);\n\n        // Then\n        assertFalse(result);\n    }\n\n    @Test\n    public void testHasTokenId_CurrentToken_MatchingId() {\n        // Given\n        delegate._currToken = JsonToken.START_ARRAY;\n\n        // When\n        boolean result = delegate.hasTokenId(JsonTokenId.ID_START_ARRAY);\n\n        // Then\n        assertTrue(result);\n    }\n\n    @Test\n    public void testHasTokenId_CurrentToken_NonMatchingId() {\n        // Given\n        delegate._currToken = JsonToken.START_ARRAY;\n\n        // When\n        boolean result = delegate.hasTokenId(JsonTokenId.ID_NUMBER_INT);\n\n        // Then\n        assertFalse(result);\n    }\n\n    @Test\n    public void testHasTokenId_CurrentToken_IdNoToken() {\n        // Given\n        delegate._currToken = JsonToken.START_ARRAY;\n\n        // When\n        boolean result = delegate.hasTokenId(JsonTokenId.ID_NO_TOKEN);\n\n        // Then\n        assertFalse(result);\n    }\n}\n```\n\n### Explanation of Test Cases:\n\n1. **testHasTokenId_NoCurrentToken_IdNoToken**: This test verifies that when `_currToken` is `null` and the provided `id` is `JsonTokenId.ID_NO_TOKEN`, the method returns `true`.\n   \n2. **testHasTokenId_NoCurrentToken_OtherId**: This test verifies that when `_currToken` is `null` and the provided `id` is anything other than `JsonTokenId.ID_NO_TOKEN`, the method returns `false`.\n\n3. **testHasTokenId_CurrentToken_MatchingId**: This test verifies that when `_currToken` is set to a specific token (e.g., `JsonToken.START_ARRAY`) and the provided `id` matches the `_currToken`'s id, the method returns `true`.\n\n4. **testHasTokenId_CurrentToken_NonMatchingId**: This test verifies that when `_currToken` is set to a specific token (e.g., `JsonToken.START_ARRAY`) and the provided `id` does not match the `_currToken`'s id, the method returns `false`.\n\n5. **testHasTokenId_CurrentToken_IdNoToken**: This test verifies that when `_currToken` is set to a specific token (e.g., `JsonToken.START_ARRAY`) and the provided `id` is `JsonTokenId.ID_NO_TOKEN`, the method returns `false`.\n\nThese tests ensure that all branches of the `hasTokenId(int id)` method are covered and increase line coverage as well."}
{"bug_id": "JacksonCore_22", "version": "fixed", "focal_method_signature": "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentName()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "focal_method": "@Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }", "return_type": "String", "assertion_subject_candidates": ["String", "TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()"], "focal_class": {"name": "FilteringParserDelegate", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "superclass": "extends JsonParserDelegate", "interface": "", "imports": ["import java.io.IOException;", "import java.io.OutputStream;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.util.JsonParserDelegate;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected TokenFilter rootFilter", "protected boolean _allowMultipleMatches", "protected boolean _includePath", "@Deprecated\n    protected boolean _includeImmediateParent", "protected JsonToken _currToken", "protected JsonToken _lastClearedToken", "protected TokenFilterContext _headContext", "protected TokenFilterContext _exposedContext", "protected TokenFilter _itemFilter", "protected int _matchCount"], "methods": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentToken()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentTokenId()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentTokenId()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasCurrentToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTokenId(int#id)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasToken(JsonToken#t)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartArrayToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartObjectToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#clearCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#overrideCurrentName(String#name)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextToken2()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextTokenWithBuffering(TokenFilterContext#buffRoot)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextBuffered(TokenFilterContext#buffRoot)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#_verifyAllowedMatches()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextValue()", "JsonParser com.fasterxml.jackson.core.filter.FilteringParserDelegate#skipChildren()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTextCharacters()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#_filterContext()"], "other_methods": ["public TokenFilter getFilter();", "public int getMatchCount();", "@Override public JsonToken getCurrentToken();", "@Override public JsonToken currentToken();", "@Override public final int getCurrentTokenId();", "@Override public final int currentTokenId();", "@Override public boolean hasCurrentToken();", "@Override public boolean hasTokenId(int id);", "@Override public final boolean hasToken(JsonToken t);", "@Override public boolean isExpectedStartArrayToken();", "@Override public boolean isExpectedStartObjectToken();", "@Override public JsonLocation getCurrentLocation();", "@Override\n    public JsonStreamContext getParsingContext();", "@Override\n    public void clearCurrentToken();", "@Override\n    public JsonToken getLastClearedToken();", "@Override\n    public void overrideCurrentName(String name);", "@Override\n    public JsonToken nextToken();", "@Override\n    public JsonToken nextValue();", "@Override\n    public JsonParser skipChildren();", "@Override public String getText();", "@Override public boolean hasTextCharacters();", "@Override public char[] getTextCharacters();", "@Override public int getTextLength();", "@Override public int getTextOffset();", "@Override\n    public BigInteger getBigIntegerValue();", "@Override\n    public boolean getBooleanValue();", "@Override\n    public byte getByteValue();", "@Override\n    public short getShortValue();", "@Override\n    public BigDecimal getDecimalValue();", "@Override\n    public double getDoubleValue();", "@Override\n    public float getFloatValue();", "@Override\n    public int getIntValue();", "@Override\n    public long getLongValue();", "@Override\n    public NumberType getNumberType();", "@Override\n    public Number getNumberValue();", "@Override public int getValueAsInt();", "@Override public int getValueAsInt(int defaultValue);", "@Override public long getValueAsLong();", "@Override public long getValueAsLong(long defaultValue);", "@Override public double getValueAsDouble();", "@Override public double getValueAsDouble(double defaultValue);", "@Override public boolean getValueAsBoolean();", "@Override public boolean getValueAsBoolean(boolean defaultValue);", "@Override public String getValueAsString();", "@Override public String getValueAsString(String defaultValue);", "@Override public Object getEmbeddedObject();", "@Override public byte[] getBinaryValue(Base64Variant b64variant);", "@Override public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override public JsonLocation getTokenLocation();"], "fields_dict": {"TokenFilter#rootFilter": "protected TokenFilter rootFilter", "boolean#_allowMultipleMatches": "protected boolean _allowMultipleMatches", "boolean#_includePath": "protected boolean _includePath", "boolean#_includeImmediateParent": "@Deprecated\n    protected boolean _includeImmediateParent", "JsonToken#_currToken": "protected JsonToken _currToken", "JsonToken#_lastClearedToken": "protected JsonToken _lastClearedToken", "TokenFilterContext#_headContext": "protected TokenFilterContext _headContext", "TokenFilterContext#_exposedContext": "protected TokenFilterContext _exposedContext", "TokenFilter#_itemFilter": "protected TokenFilter _itemFilter", "int#_matchCount": "protected int _matchCount"}, "text": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    @Override public final int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n            // matched once, return null\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_verifyAllowedMatches() && _includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    if (_verifyAllowedMatches()) {\n                        return (_currToken = t);\n                    }\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                _currToken = t;\n                return t;\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_verifyAllowedMatches() && _includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return (_currToken = t);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return _nextBuffered(buffRoot);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n\n    private final boolean _verifyAllowedMatches() throws IOException {\n        if (_matchCount == 0 || _allowMultipleMatches) {\n            ++_matchCount;\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n"}, "generated_test_class": "Sure, I'll provide some unit tests for the `getCurrentName` method in the `FilteringParserDelegate` class. Since we don't have the actual implementation of the `JsonParserDelegate` class and some methods like `_filterContext()`, we will need to mock these dependencies to test `getCurrentName`.\n\nFirst, ensure you have JUnit 4 and a mocking library like Mockito in your classpath.\n\nHere's how you can write the tests:\n\n### Maven Dependency\nIf you're using Maven, add the following dependencies to your `pom.xml`:\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n</dependency>\n<dependency>\n    <groupId>org.mockito</groupId>\n    <artifactId>mockito-core</artifactId>\n    <version>2.28.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\n### Unit Tests\n\n```java\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.core.JsonStreamContext;\nimport com.fasterxml.jackson.core.JsonToken;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\nimport java.io.IOException;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.mockito.Mockito.*;\n\npublic class FilteringParserDelegateTest {\n\n    @Mock\n    private JsonParserDelegate mockDelegate;\n    @Mock\n    private TokenFilterContext mockTokenFilterContext;\n    @Mock\n    private JsonStreamContext mockContext;\n    @Mock\n    private JsonStreamContext mockParentContext;\n\n    private FilteringParserDelegate delegate;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        delegate = new FilteringParserDelegate(mockDelegate);\n        // Mocking fields\n        delegate._currToken = JsonToken.FIELD_NAME;\n        delegate._headContext = mockTokenFilterContext;\n    }\n\n    @Test\n    public void testGetCurrentNameForFieldName() throws IOException {\n        when(mockTokenFilterContext.getCurrentName()).thenReturn(\"fieldName\");\n        \n        String currentName = delegate.getCurrentName();\n        assertEquals(\"fieldName\", currentName);\n        \n        verify(mockTokenFilterContext).getCurrentName();\n    }\n\n    @Test\n    public void testGetCurrentNameForStartObject() throws IOException {\n        delegate._currToken = JsonToken.START_OBJECT;\n        when(mockTokenFilterContext.getParent()).thenReturn(mockParentContext);\n        when(mockParentContext.getCurrentName()).thenReturn(\"parentObjectName\");\n        \n        String currentName = delegate.getCurrentName();\n        assertEquals(\"parentObjectName\", currentName);\n        \n        verify(mockTokenFilterContext).getParent();\n        verify(mockParentContext).getCurrentName();\n    }\n\n    @Test\n    public void testGetCurrentNameForStartArray() throws IOException {\n        delegate._currToken = JsonToken.START_ARRAY;\n        when(mockTokenFilterContext.getParent()).thenReturn(mockParentContext);\n        when(mockParentContext.getCurrentName()).thenReturn(\"parentArrayName\");\n        \n        String currentName = delegate.getCurrentName();\n        assertEquals(\"parentArrayName\", currentName);\n        \n        verify(mockTokenFilterContext).getParent();\n        verify(mockParentContext).getCurrentName();\n    }\n\n    @Test\n    public void testGetCurrentNameForStartObjectWithNullParent() throws IOException {\n        delegate._currToken = JsonToken.START_OBJECT;\n        when(mockTokenFilterContext.getParent()).thenReturn(null);\n        \n        String currentName = delegate.getCurrentName();\n        assertNull(currentName);\n        \n        verify(mockTokenFilterContext).getParent();\n    }\n\n    @Test\n    public void testGetCurrentNameForStartArrayWithNullParent() throws IOException {\n        delegate._currToken = JsonToken.START_ARRAY;\n        when(mockTokenFilterContext.getParent()).thenReturn(null);\n        \n        String currentName = delegate.getCurrentName();\n        assertNull(currentName);\n        \n        verify(mockTokenFilterContext).getParent();\n    }\n\n    @Test\n    public void testGetCurrentNameForUnknownToken() throws IOException {\n        delegate._currToken = JsonToken.END_OBJECT;\n        when(mockTokenFilterContext.getCurrentName()).thenReturn(\"fieldName\");\n        \n        String currentName = delegate.getCurrentName();\n        assertEquals(\"fieldName\", currentName);\n        \n        verify(mockTokenFilterContext).getCurrentName();\n    }\n}\n```\n\n### Explanation:\n\n- **Setup:** We use Mockito to mock the dependencies like `JsonParserDelegate`, `TokenFilterContext`, `JsonStreamContext`, etc.\n- **Test Cases:**\n  - `testGetCurrentNameForFieldName`: Tests that if the current token is a `FIELD_NAME`, the method returns the current name from the context.\n  - `testGetCurrentNameForStartObject`: Tests that if the current token is `START_OBJECT`, the method returns the name of the parent context.\n  - `testGetCurrentNameForStartArray`: Tests that if the current token is `START_ARRAY`, the method returns the name of the parent context.\n  - `testGetCurrentNameForStartObjectWithNullParent` and `testGetCurrentNameForStartArrayWithNullParent`: Tests that if the parent context is null, the method returns null.\n  - `testGetCurrentNameForUnknownToken`: Tests that if the current token is not `START_OBJECT` or `START_ARRAY`, the method returns the current name from the context.\n\nThese tests should cover both branch and line coverage for the `getCurrentName` method."}
{"bug_id": "JacksonCore_22", "version": "fixed", "focal_method_signature": "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#clearCurrentToken()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "focal_method": "@Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }", "return_type": "void", "assertion_subject_candidates": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()"], "focal_class": {"name": "FilteringParserDelegate", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "superclass": "extends JsonParserDelegate", "interface": "", "imports": ["import java.io.IOException;", "import java.io.OutputStream;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.util.JsonParserDelegate;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected TokenFilter rootFilter", "protected boolean _allowMultipleMatches", "protected boolean _includePath", "@Deprecated\n    protected boolean _includeImmediateParent", "protected JsonToken _currToken", "protected JsonToken _lastClearedToken", "protected TokenFilterContext _headContext", "protected TokenFilterContext _exposedContext", "protected TokenFilter _itemFilter", "protected int _matchCount"], "methods": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentToken()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentTokenId()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentTokenId()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasCurrentToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTokenId(int#id)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasToken(JsonToken#t)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartArrayToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartObjectToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentName()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#overrideCurrentName(String#name)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextToken2()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextTokenWithBuffering(TokenFilterContext#buffRoot)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextBuffered(TokenFilterContext#buffRoot)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#_verifyAllowedMatches()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextValue()", "JsonParser com.fasterxml.jackson.core.filter.FilteringParserDelegate#skipChildren()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTextCharacters()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#_filterContext()"], "other_methods": ["public TokenFilter getFilter();", "public int getMatchCount();", "@Override public JsonToken getCurrentToken();", "@Override public JsonToken currentToken();", "@Override public final int getCurrentTokenId();", "@Override public final int currentTokenId();", "@Override public boolean hasCurrentToken();", "@Override public boolean hasTokenId(int id);", "@Override public final boolean hasToken(JsonToken t);", "@Override public boolean isExpectedStartArrayToken();", "@Override public boolean isExpectedStartObjectToken();", "@Override public JsonLocation getCurrentLocation();", "@Override\n    public JsonStreamContext getParsingContext();", "@Override\n    public String getCurrentName();", "@Override\n    public JsonToken getLastClearedToken();", "@Override\n    public void overrideCurrentName(String name);", "@Override\n    public JsonToken nextToken();", "@Override\n    public JsonToken nextValue();", "@Override\n    public JsonParser skipChildren();", "@Override public String getText();", "@Override public boolean hasTextCharacters();", "@Override public char[] getTextCharacters();", "@Override public int getTextLength();", "@Override public int getTextOffset();", "@Override\n    public BigInteger getBigIntegerValue();", "@Override\n    public boolean getBooleanValue();", "@Override\n    public byte getByteValue();", "@Override\n    public short getShortValue();", "@Override\n    public BigDecimal getDecimalValue();", "@Override\n    public double getDoubleValue();", "@Override\n    public float getFloatValue();", "@Override\n    public int getIntValue();", "@Override\n    public long getLongValue();", "@Override\n    public NumberType getNumberType();", "@Override\n    public Number getNumberValue();", "@Override public int getValueAsInt();", "@Override public int getValueAsInt(int defaultValue);", "@Override public long getValueAsLong();", "@Override public long getValueAsLong(long defaultValue);", "@Override public double getValueAsDouble();", "@Override public double getValueAsDouble(double defaultValue);", "@Override public boolean getValueAsBoolean();", "@Override public boolean getValueAsBoolean(boolean defaultValue);", "@Override public String getValueAsString();", "@Override public String getValueAsString(String defaultValue);", "@Override public Object getEmbeddedObject();", "@Override public byte[] getBinaryValue(Base64Variant b64variant);", "@Override public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override public JsonLocation getTokenLocation();"], "fields_dict": {"TokenFilter#rootFilter": "protected TokenFilter rootFilter", "boolean#_allowMultipleMatches": "protected boolean _allowMultipleMatches", "boolean#_includePath": "protected boolean _includePath", "boolean#_includeImmediateParent": "@Deprecated\n    protected boolean _includeImmediateParent", "JsonToken#_currToken": "protected JsonToken _currToken", "JsonToken#_lastClearedToken": "protected JsonToken _lastClearedToken", "TokenFilterContext#_headContext": "protected TokenFilterContext _headContext", "TokenFilterContext#_exposedContext": "protected TokenFilterContext _exposedContext", "TokenFilter#_itemFilter": "protected TokenFilter _itemFilter", "int#_matchCount": "protected int _matchCount"}, "text": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    @Override public final int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n            // matched once, return null\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_verifyAllowedMatches() && _includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    if (_verifyAllowedMatches()) {\n                        return (_currToken = t);\n                    }\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                _currToken = t;\n                return t;\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_verifyAllowedMatches() && _includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return (_currToken = t);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return _nextBuffered(buffRoot);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n\n    private final boolean _verifyAllowedMatches() throws IOException {\n        if (_matchCount == 0 || _allowMultipleMatches) {\n            ++_matchCount;\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n"}, "generated_test_class": "Sure, I'll write some unit tests for the `clearCurrentToken` method in the `FilteringParserDelegate` class. To maximize branch and line coverage, we'll need to test scenarios where `_currToken` is `null` and where it is not `null`.\n\nHere's the unit test class:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\n\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\npublic class FilteringParserDelegateTest {\n\n    private FilteringParserDelegate filteringParserDelegate;\n    private JsonToken mockJsonToken;\n\n    @Before\n    public void setUp() {\n        filteringParserDelegate = new FilteringParserDelegate(mock(JsonParser.class), mock(TokenFilter.class), false, false);\n        mockJsonToken = mock(JsonToken.class);\n    }\n\n    @Test\n    public void testClearCurrentToken_WhenCurrTokenIsNotNull() {\n        // Arrange\n        filteringParserDelegate._currToken = mockJsonToken;\n\n        // Act\n        filteringParserDelegate.clearCurrentToken();\n\n        // Assert\n        assertNull(\"Current token should be null after clearing\", filteringParserDelegate._currToken);\n        assertSame(\"Last cleared token should be the previous current token\", mockJsonToken, filteringParserDelegate._lastClearedToken);\n    }\n\n    @Test\n    public void testClearCurrentToken_WhenCurrTokenIsNull() {\n        // Arrange\n        filteringParserDelegate._currToken = null;\n\n        // Act\n        filteringParserDelegate.clearCurrentToken();\n\n        // Assert\n        assertNull(\"Current token should remain null after clearing\", filteringParserDelegate._currToken);\n        assertNull(\"Last cleared token should also be null\", filteringParserDelegate._lastClearedToken);\n    }\n\n    @Test\n    public void testClearCurrentToken_WhenCurrTokenIsAlreadyCleared() {\n        // Arrange\n        filteringParserDelegate._currToken = mockJsonToken;\n        filteringParserDelegate.clearCurrentToken(); // First clear to set _lastClearedToken\n\n        // Act\n        filteringParserDelegate.clearCurrentToken();\n\n        // Assert\n        assertNull(\"Current token should be null after clearing\", filteringParserDelegate._currToken);\n        assertSame(\"Last cleared token should remain the same\", mockJsonToken, filteringParserDelegate._lastClearedToken);\n    }\n}\n```\n\n### Explanation:\n1. **Setup**:\n    - We create a mock `JsonParser` and `TokenFilter` to instantiate the `FilteringParserDelegate`.\n    - We also create a mock `JsonToken` to use in the tests.\n\n2. **Test Cases**:\n    - **testClearCurrentToken_WhenCurrTokenIsNotNull**:\n        - We set `_currToken` to a non-null value.\n        - We call `clearCurrentToken`.\n        - We assert that `_currToken` is null and `_lastClearedToken` is the previous `_currToken`.\n    \n    - **testClearCurrentToken_WhenCurrTokenIsNull**:\n        - We set `_currToken` to null.\n        - We call `clearCurrentToken`.\n        - We assert that both `_currToken` and `_lastClearedToken` remain null.\n\n    - **testClearCurrentToken_WhenCurrTokenIsAlreadyCleared**:\n        - We first clear `_currToken` to set `_lastClearedToken`.\n        - We call `clearCurrentToken` again.\n        - We assert that `_currToken` remains null and `_lastClearedToken` remains the same.\n\nThese tests ensure that all branches of the `clearCurrentToken` method are covered, thus maximizing branch and line coverage."}
{"bug_id": "JacksonCore_22", "version": "fixed", "focal_method_signature": "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#overrideCurrentName(String#name)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "focal_method": "@Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }", "return_type": "void", "assertion_subject_candidates": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()"], "focal_class": {"name": "FilteringParserDelegate", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "superclass": "extends JsonParserDelegate", "interface": "", "imports": ["import java.io.IOException;", "import java.io.OutputStream;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.util.JsonParserDelegate;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected TokenFilter rootFilter", "protected boolean _allowMultipleMatches", "protected boolean _includePath", "@Deprecated\n    protected boolean _includeImmediateParent", "protected JsonToken _currToken", "protected JsonToken _lastClearedToken", "protected TokenFilterContext _headContext", "protected TokenFilterContext _exposedContext", "protected TokenFilter _itemFilter", "protected int _matchCount"], "methods": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentToken()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentTokenId()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentTokenId()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasCurrentToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTokenId(int#id)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasToken(JsonToken#t)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartArrayToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartObjectToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentName()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#clearCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextToken2()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextTokenWithBuffering(TokenFilterContext#buffRoot)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextBuffered(TokenFilterContext#buffRoot)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#_verifyAllowedMatches()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextValue()", "JsonParser com.fasterxml.jackson.core.filter.FilteringParserDelegate#skipChildren()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTextCharacters()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#_filterContext()"], "other_methods": ["public TokenFilter getFilter();", "public int getMatchCount();", "@Override public JsonToken getCurrentToken();", "@Override public JsonToken currentToken();", "@Override public final int getCurrentTokenId();", "@Override public final int currentTokenId();", "@Override public boolean hasCurrentToken();", "@Override public boolean hasTokenId(int id);", "@Override public final boolean hasToken(JsonToken t);", "@Override public boolean isExpectedStartArrayToken();", "@Override public boolean isExpectedStartObjectToken();", "@Override public JsonLocation getCurrentLocation();", "@Override\n    public JsonStreamContext getParsingContext();", "@Override\n    public String getCurrentName();", "@Override\n    public void clearCurrentToken();", "@Override\n    public JsonToken getLastClearedToken();", "@Override\n    public JsonToken nextToken();", "@Override\n    public JsonToken nextValue();", "@Override\n    public JsonParser skipChildren();", "@Override public String getText();", "@Override public boolean hasTextCharacters();", "@Override public char[] getTextCharacters();", "@Override public int getTextLength();", "@Override public int getTextOffset();", "@Override\n    public BigInteger getBigIntegerValue();", "@Override\n    public boolean getBooleanValue();", "@Override\n    public byte getByteValue();", "@Override\n    public short getShortValue();", "@Override\n    public BigDecimal getDecimalValue();", "@Override\n    public double getDoubleValue();", "@Override\n    public float getFloatValue();", "@Override\n    public int getIntValue();", "@Override\n    public long getLongValue();", "@Override\n    public NumberType getNumberType();", "@Override\n    public Number getNumberValue();", "@Override public int getValueAsInt();", "@Override public int getValueAsInt(int defaultValue);", "@Override public long getValueAsLong();", "@Override public long getValueAsLong(long defaultValue);", "@Override public double getValueAsDouble();", "@Override public double getValueAsDouble(double defaultValue);", "@Override public boolean getValueAsBoolean();", "@Override public boolean getValueAsBoolean(boolean defaultValue);", "@Override public String getValueAsString();", "@Override public String getValueAsString(String defaultValue);", "@Override public Object getEmbeddedObject();", "@Override public byte[] getBinaryValue(Base64Variant b64variant);", "@Override public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override public JsonLocation getTokenLocation();"], "fields_dict": {"TokenFilter#rootFilter": "protected TokenFilter rootFilter", "boolean#_allowMultipleMatches": "protected boolean _allowMultipleMatches", "boolean#_includePath": "protected boolean _includePath", "boolean#_includeImmediateParent": "@Deprecated\n    protected boolean _includeImmediateParent", "JsonToken#_currToken": "protected JsonToken _currToken", "JsonToken#_lastClearedToken": "protected JsonToken _lastClearedToken", "TokenFilterContext#_headContext": "protected TokenFilterContext _headContext", "TokenFilterContext#_exposedContext": "protected TokenFilterContext _exposedContext", "TokenFilter#_itemFilter": "protected TokenFilter _itemFilter", "int#_matchCount": "protected int _matchCount"}, "text": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    @Override public final int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n            // matched once, return null\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_verifyAllowedMatches() && _includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    if (_verifyAllowedMatches()) {\n                        return (_currToken = t);\n                    }\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                _currToken = t;\n                return t;\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_verifyAllowedMatches() && _includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return (_currToken = t);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return _nextBuffered(buffRoot);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n\n    private final boolean _verifyAllowedMatches() throws IOException {\n        if (_matchCount == 0 || _allowMultipleMatches) {\n            ++_matchCount;\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n"}, "generated_test_class": "Sure, let's write some unit tests for the `overrideCurrentName` method of the `FilteringParserDelegate` class. Since the method simply throws an `UnsupportedOperationException`, our tests will focus on ensuring that the exception is thrown correctly.\n\nFirst, we need to ensure that we have the necessary imports and setup for the JUnit test.\n\n```java\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\n\nimport static org.junit.Assert.fail;\n\npublic class FilteringParserDelegateTest {\n\n    private FilteringParserDelegate filteringParserDelegate;\n\n    @Rule\n    public ExpectedException exception = ExpectedException.none();\n\n    @Before\n    public void setUp() {\n        // Since FilteringParserDelegate extends JsonParserDelegate,\n        // we need a JsonParser instance to pass to the constructor.\n        // For testing purposes, we can use a mock or a simple stub.\n        JsonParser mockJsonParser = new JsonParser() {\n            @Override\n            public JsonToken nextToken() throws IOException, JsonProcessingException {\n                return null;\n            }\n\n            @Override\n            public JsonToken getCurrentToken() {\n                return null;\n            }\n\n            @Override\n            public int getCurrentTokenId() {\n                return 0;\n            }\n\n            @Override\n            public boolean hasCurrentToken() {\n                return false;\n            }\n\n            @Override\n            public boolean hasTokenId(int id) {\n                return false;\n            }\n\n            @Override\n            public boolean hasToken(JsonToken t) {\n                return false;\n            }\n\n            @Override\n            public void clearCurrentToken() {\n            }\n\n            @Override\n            public JsonToken getLastClearedToken() {\n                return null;\n            }\n\n            @Override\n            public String getCurrentName() throws IOException, JsonProcessingException {\n                return null;\n            }\n\n            @Override\n            public void overrideCurrentName(String name) {\n            }\n\n            @Override\n            public void close() throws IOException {\n            }\n\n            @Override\n            public boolean isClosed() {\n                return false;\n            }\n\n            @Override\n            public JsonStreamContext getParsingContext() {\n                return null;\n            }\n\n            @Override\n            public JsonLocation getTokenLocation() {\n                return null;\n            }\n\n            @Override\n            public JsonLocation getCurrentLocation() {\n                return null;\n            }\n\n            @Override\n            public String getText() throws IOException, JsonProcessingException {\n                return null;\n            }\n\n            @Override\n            public boolean hasTextCharacters() {\n                return false;\n            }\n\n            @Override\n            public char[] getTextCharacters() throws IOException, JsonProcessingException {\n                return new char[0];\n            }\n\n            @Override\n            public int getTextLength() throws IOException, JsonProcessingException {\n                return 0;\n            }\n\n            @Override\n            public int getTextOffset() throws IOException, JsonProcessingException {\n                return 0;\n            }\n\n            @Override\n            public boolean isTextWhitespace() throws IOException, JsonProcessingException {\n                return false;\n            }\n\n            @Override\n            public Number getNumberValue() throws IOException, JsonProcessingException {\n                return null;\n            }\n\n            @Override\n            public NumberType getNumberType() throws IOException, JsonProcessingException {\n                return null;\n            }\n\n            @Override\n            public int getIntValue() throws IOException, JsonProcessingException, JsonParseException {\n                return 0;\n            }\n\n            @Override\n            public long getLongValue() throws IOException, JsonProcessingException, JsonParseException {\n                return 0;\n            }\n\n            @Override\n            public BigInteger getBigIntegerValue() throws IOException, JsonProcessingException, JsonParseException {\n                return null;\n            }\n\n            @Override\n            public float getFloatValue() throws IOException, JsonProcessingException, JsonParseException {\n                return 0;\n            }\n\n            @Override\n            public double getDoubleValue() throws IOException, JsonProcessingException, JsonParseException {\n                return 0;\n            }\n\n            @Override\n            public BigDecimal getDecimalValue() throws IOException, JsonProcessingException, JsonParseException {\n                return null;\n            }\n\n            @Override\n            public boolean getBooleanValue() throws IOException, JsonProcessingException, JsonParseException {\n                return false;\n            }\n\n            @Override\n            public byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonProcessingException {\n                return new byte[0];\n            }\n\n            @Override\n            public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonProcessingException {\n                return 0;\n            }\n\n            @Override\n            public JsonParser skipChildren() throws IOException, JsonProcessingException {\n                return null;\n            }\n\n            @Override\n            public Version version() {\n                return null;\n            }\n        };\n\n        filteringParserDelegate = new FilteringParserDelegate(mockJsonParser, null, false, false);\n    }\n\n    @Test\n    public void testOverrideCurrentNameThrowsUnsupportedOperationException() {\n        exception.expect(UnsupportedOperationException.class);\n        exception.expectMessage(\"Can not currently override name during filtering read\");\n\n        filteringParserDelegate.overrideCurrentName(\"newName\");\n    }\n\n    @Test\n    public void testOverrideCurrentNameWithNullNameThrowsUnsupportedOperationException() {\n        exception.expect(UnsupportedOperationException.class);\n        exception.expectMessage(\"Can not currently override name during filtering read\");\n\n        filteringParserDelegate.overrideCurrentName(null);\n    }\n\n    @Test\n    public void testOverrideCurrentNameWithEmptyStringThrowsUnsupportedOperationException() {\n        exception.expect(UnsupportedOperationException.class);\n        exception.expectMessage(\"Can not currently override name during filtering read\");\n\n        filteringParserDelegate.overrideCurrentName(\"\");\n    }\n}\n```\n\n### Explanation:\n1. **Setup**: We create a minimal implementation of `JsonParser` that throws the necessary exceptions and returns default values. This is necessary because `FilteringParserDelegate` extends `JsonParserDelegate`, which requires a `JsonParser` instance in its constructor.\n2. **Test Cases**:\n   - **testOverrideCurrentNameThrowsUnsupportedOperationException**: This test checks that calling `overrideCurrentName` with a non-null, non-empty string throws the expected `UnsupportedOperationException` with the correct message.\n   - **testOverrideCurrentNameWithNullNameThrowsUnsupportedOperationException**: This test ensures that passing a `null` name also results in the same exception.\n   - **testOverrideCurrentNameWithEmptyStringThrowsUnsupportedOperationException**: This test verifies that passing an empty string also results in the same exception.\n\nThese tests aim to maximize line and branch coverage for the `overrideCurrentName` method by ensuring that the exception is thrown correctly under different conditions."}
{"bug_id": "JacksonCore_22", "version": "fixed", "focal_method_signature": "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextToken()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "focal_method": "@Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n            // matched once, return null\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_verifyAllowedMatches() && _includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    if (_verifyAllowedMatches()) {\n                        return (_currToken = t);\n                    }\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }", "return_type": "JsonToken", "assertion_subject_candidates": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()"], "focal_class": {"name": "FilteringParserDelegate", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "superclass": "extends JsonParserDelegate", "interface": "", "imports": ["import java.io.IOException;", "import java.io.OutputStream;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.util.JsonParserDelegate;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected TokenFilter rootFilter", "protected boolean _allowMultipleMatches", "protected boolean _includePath", "@Deprecated\n    protected boolean _includeImmediateParent", "protected JsonToken _currToken", "protected JsonToken _lastClearedToken", "protected TokenFilterContext _headContext", "protected TokenFilterContext _exposedContext", "protected TokenFilter _itemFilter", "protected int _matchCount"], "methods": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentToken()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentTokenId()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentTokenId()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasCurrentToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTokenId(int#id)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasToken(JsonToken#t)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartArrayToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartObjectToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentName()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#clearCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#overrideCurrentName(String#name)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextToken2()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextTokenWithBuffering(TokenFilterContext#buffRoot)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextBuffered(TokenFilterContext#buffRoot)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#_verifyAllowedMatches()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextValue()", "JsonParser com.fasterxml.jackson.core.filter.FilteringParserDelegate#skipChildren()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTextCharacters()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#_filterContext()"], "other_methods": ["public TokenFilter getFilter();", "public int getMatchCount();", "@Override public JsonToken getCurrentToken();", "@Override public JsonToken currentToken();", "@Override public final int getCurrentTokenId();", "@Override public final int currentTokenId();", "@Override public boolean hasCurrentToken();", "@Override public boolean hasTokenId(int id);", "@Override public final boolean hasToken(JsonToken t);", "@Override public boolean isExpectedStartArrayToken();", "@Override public boolean isExpectedStartObjectToken();", "@Override public JsonLocation getCurrentLocation();", "@Override\n    public JsonStreamContext getParsingContext();", "@Override\n    public String getCurrentName();", "@Override\n    public void clearCurrentToken();", "@Override\n    public JsonToken getLastClearedToken();", "@Override\n    public void overrideCurrentName(String name);", "@Override\n    public JsonToken nextValue();", "@Override\n    public JsonParser skipChildren();", "@Override public String getText();", "@Override public boolean hasTextCharacters();", "@Override public char[] getTextCharacters();", "@Override public int getTextLength();", "@Override public int getTextOffset();", "@Override\n    public BigInteger getBigIntegerValue();", "@Override\n    public boolean getBooleanValue();", "@Override\n    public byte getByteValue();", "@Override\n    public short getShortValue();", "@Override\n    public BigDecimal getDecimalValue();", "@Override\n    public double getDoubleValue();", "@Override\n    public float getFloatValue();", "@Override\n    public int getIntValue();", "@Override\n    public long getLongValue();", "@Override\n    public NumberType getNumberType();", "@Override\n    public Number getNumberValue();", "@Override public int getValueAsInt();", "@Override public int getValueAsInt(int defaultValue);", "@Override public long getValueAsLong();", "@Override public long getValueAsLong(long defaultValue);", "@Override public double getValueAsDouble();", "@Override public double getValueAsDouble(double defaultValue);", "@Override public boolean getValueAsBoolean();", "@Override public boolean getValueAsBoolean(boolean defaultValue);", "@Override public String getValueAsString();", "@Override public String getValueAsString(String defaultValue);", "@Override public Object getEmbeddedObject();", "@Override public byte[] getBinaryValue(Base64Variant b64variant);", "@Override public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override public JsonLocation getTokenLocation();"], "fields_dict": {"TokenFilter#rootFilter": "protected TokenFilter rootFilter", "boolean#_allowMultipleMatches": "protected boolean _allowMultipleMatches", "boolean#_includePath": "protected boolean _includePath", "boolean#_includeImmediateParent": "@Deprecated\n    protected boolean _includeImmediateParent", "JsonToken#_currToken": "protected JsonToken _currToken", "JsonToken#_lastClearedToken": "protected JsonToken _lastClearedToken", "TokenFilterContext#_headContext": "protected TokenFilterContext _headContext", "TokenFilterContext#_exposedContext": "protected TokenFilterContext _exposedContext", "TokenFilter#_itemFilter": "protected TokenFilter _itemFilter", "int#_matchCount": "protected int _matchCount"}, "text": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    @Override public final int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n            // matched once, return null\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_verifyAllowedMatches() && _includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    if (_verifyAllowedMatches()) {\n                        return (_currToken = t);\n                    }\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                _currToken = t;\n                return t;\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_verifyAllowedMatches() && _includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return (_currToken = t);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return _nextBuffered(buffRoot);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n\n    private final boolean _verifyAllowedMatches() throws IOException {\n        if (_matchCount == 0 || _allowMultipleMatches) {\n            ++_matchCount;\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n"}, "generated_test_class": "Certainly! To write comprehensive unit tests for the `nextToken` method in the `FilteringParserDelegate` class, we'll need to simulate different scenarios based on the conditions and branches in the method. Given that we are using Java 1.7 and JUnit 4, here are some test cases designed to cover various branches and lines:\n\n```java\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.core.JsonStreamContext;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.core.Base64Variant;\nimport com.fasterxml.jackson.core.filter.TokenFilter;\nimport com.fasterxml.jackson.core.filter.TokenFilterContext;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Collection;\n\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\nimport static org.mockito.ArgumentMatchers.*;\n\n@RunWith(Parameterized.class)\npublic class FilteringParserDelegateTest {\n    private FilteringParserDelegate filteringParserDelegate;\n    private JsonParser mockDelegate;\n    private TokenFilter mockRootFilter;\n    private TokenFilter mockItemFilter;\n    private TokenFilterContext mockHeadContext;\n    private TokenFilterContext mockExposedContext;\n\n    @Parameterized.Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(new Object[][] {\n                { JsonToken.START_OBJECT, JsonToken.START_OBJECT, TokenFilter.INCLUDE_ALL, true, true },\n                { JsonToken.START_ARRAY, JsonToken.START_ARRAY, TokenFilter.INCLUDE_ALL, true, true },\n                { JsonToken.FIELD_NAME, JsonToken.FIELD_NAME, TokenFilter.INCLUDE_ALL, true, true },\n                { JsonToken.VALUE_STRING, JsonToken.VALUE_STRING, TokenFilter.INCLUDE_ALL, true, true },\n                { JsonToken.END_OBJECT, JsonToken.END_OBJECT, TokenFilter.INCLUDE_ALL, true, true },\n                { JsonToken.END_ARRAY, JsonToken.END_ARRAY, TokenFilter.INCLUDE_ALL, true, true },\n                { JsonToken.START_OBJECT, null, null, false, true },\n                { JsonToken.START_ARRAY, null, null, false, true },\n                { JsonToken.FIELD_NAME, null, null, false, true },\n                { JsonToken.VALUE_STRING, null, null, false, true },\n                { JsonToken.END_OBJECT, null, null, false, true },\n                { JsonToken.END_ARRAY, null, null, false, true },\n                { JsonToken.START_OBJECT, JsonToken.START_OBJECT, TokenFilter.INCLUDE_ALL, true, false },\n                { JsonToken.START_ARRAY, JsonToken.START_ARRAY, TokenFilter.INCLUDE_ALL, true, false },\n                { JsonToken.FIELD_NAME, JsonToken.FIELD_NAME, TokenFilter.INCLUDE_ALL, true, false },\n                { JsonToken.VALUE_STRING, JsonToken.VALUE_STRING, TokenFilter.INCLUDE_ALL, true, false },\n                { JsonToken.END_OBJECT, JsonToken.END_OBJECT, TokenFilter.INCLUDE_ALL, true, false },\n                { JsonToken.END_ARRAY, JsonToken.END_ARRAY, TokenFilter.INCLUDE_ALL, true, false },\n                { JsonToken.START_OBJECT, null, null, false, false },\n                { JsonToken.START_ARRAY, null, null, false, false },\n                { JsonToken.FIELD_NAME, null, null, false, false },\n                { JsonToken.VALUE_STRING, null, null, false, false },\n                { JsonToken.END_OBJECT, null, null, false, false },\n                { JsonToken.END_ARRAY, null, null, false, false },\n        });\n    }\n\n    @Parameterized.Parameter(0)\n    public JsonToken delegateToken;\n\n    @Parameterized.Parameter(1)\n    public JsonToken expectedToken;\n\n    @Parameterized.Parameter(2)\n    public TokenFilter itemFilter;\n\n    @Parameterized.Parameter(3)\n    public boolean allowMultipleMatches;\n\n    @Parameterized.Parameter(4)\n    public boolean includePath;\n\n    @Before\n    public void setUp() throws Exception {\n        mockDelegate = mock(JsonParser.class);\n        when(mockDelegate.nextToken()).thenReturn(delegateToken);\n\n        mockRootFilter = mock(TokenFilter.class);\n        mockItemFilter = itemFilter;\n\n        mockHeadContext = mock(TokenFilterContext.class);\n        mockExposedContext = mock(TokenFilterContext.class);\n\n        filteringParserDelegate = new FilteringParserDelegate(mockDelegate, mockRootFilter, allowMultipleMatches, includePath) {\n            @Override\n            protected TokenFilterContext _headContext() {\n                return mockHeadContext;\n            }\n\n            @Override\n            protected TokenFilterContext _exposedContext() {\n                return mockExposedContext;\n            }\n\n            @Override\n            protected TokenFilter _itemFilter() {\n                return mockItemFilter;\n            }\n        };\n    }\n\n    @Test\n    public void testNextToken() throws IOException {\n        JsonToken result = filteringParserDelegate.nextToken();\n\n        if (expectedToken != null) {\n            assertNotNull(result);\n            assertEquals(expectedToken, result);\n        } else {\n            assertNull(result);\n        }\n    }\n\n    @Test\n    public void testNextTokenScalarValue() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.VALUE_STRING);\n        when(mockItemFilter.includeValue(mockDelegate)).thenReturn(true);\n        when(mockHeadContext.checkValue(mockItemFilter)).thenReturn(mockItemFilter);\n\n        filteringParserDelegate.nextToken();\n\n        assertEquals(JsonToken.VALUE_STRING, filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testNextTokenScalarValueExcluded() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.VALUE_STRING);\n        when(mockItemFilter.includeValue(mockDelegate)).thenReturn(false);\n        when(mockHeadContext.checkValue(mockItemFilter)).thenReturn(mockItemFilter);\n\n        filteringParserDelegate.nextToken();\n\n        assertNull(filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testNextTokenFieldName() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.FIELD_NAME);\n        when(mockDelegate.getCurrentName()).thenReturn(\"testField\");\n        when(mockHeadContext.setFieldName(\"testField\")).thenReturn(mockItemFilter);\n        when(mockItemFilter.includeProperty(\"testField\")).thenReturn(true);\n\n        filteringParserDelegate.nextToken();\n\n        assertEquals(JsonToken.FIELD_NAME, filteringParserDelegate.getCurrentToken());\n        assertEquals(\"testField\", filteringParserDelegate.getCurrentName());\n    }\n\n    @Test\n    public void testNextTokenFieldNameExcluded() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.FIELD_NAME);\n        when(mockDelegate.getCurrentName()).thenReturn(\"testField\");\n        when(mockHeadContext.setFieldName(\"testField\")).thenReturn(mockItemFilter);\n        when(mockItemFilter.includeProperty(\"testField\")).thenReturn(false);\n\n        filteringParserDelegate.nextToken();\n\n        assertNull(filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testNextTokenArrayStartIncluded() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.START_ARRAY);\n        when(mockItemFilter.filterStartArray()).thenReturn(mockItemFilter);\n\n        filteringParserDelegate.nextToken();\n\n        assertEquals(JsonToken.START_ARRAY, filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testNextTokenArrayStartExcluded() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.START_ARRAY);\n        when(mockItemFilter.filterStartArray()).thenReturn(null);\n\n        filteringParserDelegate.nextToken();\n\n        assertNull(filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testNextTokenObjectStartIncluded() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.START_OBJECT);\n        when(mockItemFilter.filterStartObject()).thenReturn(mockItemFilter);\n\n        filteringParserDelegate.nextToken();\n\n        assertEquals(JsonToken.START_OBJECT, filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testNextTokenObjectStartExcluded() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.START_OBJECT);\n        when(mockItemFilter.filterStartObject()).thenReturn(null);\n\n        filteringParserDelegate.nextToken();\n\n        assertNull(filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testNextTokenEndObjectIncluded() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.END_OBJECT);\n        when(mockHeadContext.isStartHandled()).thenReturn(true);\n\n        filteringParserDelegate.nextToken();\n\n        assertEquals(JsonToken.END_OBJECT, filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testNextTokenEndObjectExcluded() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.END_OBJECT);\n        when(mockHeadContext.isStartHandled()).thenReturn(false);\n\n        filteringParserDelegate.nextToken();\n\n        assertNull(filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testNextTokenEndArrayIncluded() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.END_ARRAY);\n        when(mockHeadContext.isStartHandled()).thenReturn(true);\n\n        filteringParserDelegate.nextToken();\n\n        assertEquals(JsonToken.END_ARRAY, filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testNextTokenEndArrayExcluded() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.END_ARRAY);\n        when(mockHeadContext.isStartHandled()).thenReturn(false);\n\n        filteringParserDelegate.nextToken();\n\n        assertNull(filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testNextTokenWithBuffering() throws IOException {\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.FIELD_NAME);\n        when(mockDelegate.getCurrentName()).thenReturn(\"testField\");\n        when(mockHeadContext.setFieldName(\"testField\")).thenReturn(mockItemFilter);\n        when(mockItemFilter.includeProperty(\"testField\")).thenReturn(true);\n\n        filteringParserDelegate.nextToken();\n\n        assertEquals(JsonToken.FIELD_NAME, filteringParserDelegate.getCurrentToken());\n        assertEquals(\"testField\", filteringParserDelegate.getCurrentName());\n    }\n\n    @Test\n    public void testMultipleMatches() throws IOException {\n        filteringParserDelegate._allowMultipleMatches = true;\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.VALUE_STRING);\n        when(mockItemFilter.includeValue(mockDelegate)).thenReturn(true);\n        when(mockHeadContext.checkValue(mockItemFilter)).thenReturn(mockItemFilter);\n\n        filteringParserDelegate.nextToken();\n\n        assertEquals(JsonToken.VALUE_STRING, filteringParserDelegate.getCurrentToken());\n    }\n\n    @Test\n    public void testIncludePath() throws IOException {\n        filteringParserDelegate._includePath = true;\n        when(mockDelegate.nextToken()).thenReturn(JsonToken.VALUE_STRING);\n        when(mockItemFilter.includeValue(mockDelegate)).thenReturn(true);\n        when(mockHeadContext.checkValue(mockItemFilter)).thenReturn(mockItemFilter);\n\n        filteringParserDelegate.nextToken();\n\n        assertEquals(JsonToken.VALUE_STRING, filteringParserDelegate.getCurrentToken());\n    }\n}\n```\n\n### Explanation of the Tests:\n1. **Parameterized Tests**: These tests cover different combinations of input tokens, expected tokens, item filters, `allowMultipleMatches`, and `includePath`. This helps in covering a wide range of scenarios.\n   \n2. **Scalar Values**: Tests cases for scalar values (e.g., `VALUE_STRING`) with both included and excluded scenarios.\n   \n3. **Field Names**: Test cases for `FIELD_NAME` to ensure that field names are correctly filtered.\n   \n4. **Array and Object Start**: Tests cases for `START_ARRAY` and `START_OBJECT` to ensure that arrays and objects are correctly started and handled.\n   \n5. **End Array and Object**: Test cases for `END_ARRAY` and `END_OBJECT` to ensure that these tokens are correctly handled based on their inclusion.\n   \n6. **Buffering**: Test case to simulate `_nextTokenWithBuffering` functionality.\n   \n7. **Multiple Matches and Include Path**: Tests to cover scenarios where multiple matches are allowed or paths are included.\n\nThese tests should help in achieving high branch and line coverage for the `nextToken` method in the `FilteringParserDelegate` class."}
{"bug_id": "JacksonCore_22", "version": "fixed", "focal_method_signature": "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextValue()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "focal_method": "@Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }", "return_type": "JsonToken", "assertion_subject_candidates": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()"], "focal_class": {"name": "FilteringParserDelegate", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "superclass": "extends JsonParserDelegate", "interface": "", "imports": ["import java.io.IOException;", "import java.io.OutputStream;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.util.JsonParserDelegate;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected TokenFilter rootFilter", "protected boolean _allowMultipleMatches", "protected boolean _includePath", "@Deprecated\n    protected boolean _includeImmediateParent", "protected JsonToken _currToken", "protected JsonToken _lastClearedToken", "protected TokenFilterContext _headContext", "protected TokenFilterContext _exposedContext", "protected TokenFilter _itemFilter", "protected int _matchCount"], "methods": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentToken()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentTokenId()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentTokenId()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasCurrentToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTokenId(int#id)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasToken(JsonToken#t)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartArrayToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartObjectToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentName()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#clearCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#overrideCurrentName(String#name)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextToken2()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextTokenWithBuffering(TokenFilterContext#buffRoot)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextBuffered(TokenFilterContext#buffRoot)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#_verifyAllowedMatches()", "JsonParser com.fasterxml.jackson.core.filter.FilteringParserDelegate#skipChildren()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTextCharacters()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#_filterContext()"], "other_methods": ["public TokenFilter getFilter();", "public int getMatchCount();", "@Override public JsonToken getCurrentToken();", "@Override public JsonToken currentToken();", "@Override public final int getCurrentTokenId();", "@Override public final int currentTokenId();", "@Override public boolean hasCurrentToken();", "@Override public boolean hasTokenId(int id);", "@Override public final boolean hasToken(JsonToken t);", "@Override public boolean isExpectedStartArrayToken();", "@Override public boolean isExpectedStartObjectToken();", "@Override public JsonLocation getCurrentLocation();", "@Override\n    public JsonStreamContext getParsingContext();", "@Override\n    public String getCurrentName();", "@Override\n    public void clearCurrentToken();", "@Override\n    public JsonToken getLastClearedToken();", "@Override\n    public void overrideCurrentName(String name);", "@Override\n    public JsonToken nextToken();", "@Override\n    public JsonParser skipChildren();", "@Override public String getText();", "@Override public boolean hasTextCharacters();", "@Override public char[] getTextCharacters();", "@Override public int getTextLength();", "@Override public int getTextOffset();", "@Override\n    public BigInteger getBigIntegerValue();", "@Override\n    public boolean getBooleanValue();", "@Override\n    public byte getByteValue();", "@Override\n    public short getShortValue();", "@Override\n    public BigDecimal getDecimalValue();", "@Override\n    public double getDoubleValue();", "@Override\n    public float getFloatValue();", "@Override\n    public int getIntValue();", "@Override\n    public long getLongValue();", "@Override\n    public NumberType getNumberType();", "@Override\n    public Number getNumberValue();", "@Override public int getValueAsInt();", "@Override public int getValueAsInt(int defaultValue);", "@Override public long getValueAsLong();", "@Override public long getValueAsLong(long defaultValue);", "@Override public double getValueAsDouble();", "@Override public double getValueAsDouble(double defaultValue);", "@Override public boolean getValueAsBoolean();", "@Override public boolean getValueAsBoolean(boolean defaultValue);", "@Override public String getValueAsString();", "@Override public String getValueAsString(String defaultValue);", "@Override public Object getEmbeddedObject();", "@Override public byte[] getBinaryValue(Base64Variant b64variant);", "@Override public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override public JsonLocation getTokenLocation();"], "fields_dict": {"TokenFilter#rootFilter": "protected TokenFilter rootFilter", "boolean#_allowMultipleMatches": "protected boolean _allowMultipleMatches", "boolean#_includePath": "protected boolean _includePath", "boolean#_includeImmediateParent": "@Deprecated\n    protected boolean _includeImmediateParent", "JsonToken#_currToken": "protected JsonToken _currToken", "JsonToken#_lastClearedToken": "protected JsonToken _lastClearedToken", "TokenFilterContext#_headContext": "protected TokenFilterContext _headContext", "TokenFilterContext#_exposedContext": "protected TokenFilterContext _exposedContext", "TokenFilter#_itemFilter": "protected TokenFilter _itemFilter", "int#_matchCount": "protected int _matchCount"}, "text": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    @Override public final int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n            // matched once, return null\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_verifyAllowedMatches() && _includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    if (_verifyAllowedMatches()) {\n                        return (_currToken = t);\n                    }\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                _currToken = t;\n                return t;\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_verifyAllowedMatches() && _includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return (_currToken = t);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return _nextBuffered(buffRoot);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n\n    private final boolean _verifyAllowedMatches() throws IOException {\n        if (_matchCount == 0 || _allowMultipleMatches) {\n            ++_matchCount;\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n"}, "generated_test_class": "Sure, I will provide a set of unit tests for the `nextValue()` method of the `FilteringParserDelegate` class. These tests will aim to maximize both branch and line coverage.\n\nTo write the tests, we need to mock the `FilteringParserDelegate` class and its `nextToken()` method using a mocking framework such as Mockito. Below is the code for the unit tests:\n\n```java\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonStreamContext;\nimport com.fasterxml.jackson.core.JsonToken;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.mockito.junit.MockitoJUnitRunner;\n\nimport java.io.IOException;\n\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class FilteringParserDelegateTest {\n\n    private FilteringParserDelegate parserDelegate;\n\n    @Mock\n    private JsonParser mockedParser;\n\n    @Mock\n    private JsonToken mockedJsonToken;\n\n    @Mock\n    private JsonLocation mockedJsonLocation;\n\n    @Mock\n    private JsonStreamContext mockedJsonStreamContext;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        parserDelegate = spy(new FilteringParserDelegate(mockedParser, null, false, false));\n    }\n\n    @Test\n    public void testNextValue_returnsNullWhenNextTokenIsNull() throws IOException {\n        // Arrange\n        when(parserDelegate.nextToken()).thenReturn(null);\n\n        // Act\n        JsonToken result = parserDelegate.nextValue();\n\n        // Assert\n        assertNull(result);\n        verify(parserDelegate, times(1)).nextToken();\n    }\n\n    @Test\n    public void testNextValue_returnsTokenWhenNextTokenIsNotFieldName() throws IOException {\n        // Arrange\n        when(parserDelegate.nextToken()).thenReturn(mockedJsonToken);\n\n        // Act\n        JsonToken result = parserDelegate.nextValue();\n\n        // Assert\n        assertSame(mockedJsonToken, result);\n        verify(parserDelegate, times(1)).nextToken();\n    }\n\n    @Test\n    public void testNextValue_skipsFieldNameAndReturnsNextToken() throws IOException {\n        // Arrange\n        when(parserDelegate.nextToken())\n                .thenReturn(JsonToken.FIELD_NAME)\n                .thenReturn(mockedJsonToken);\n\n        // Act\n        JsonToken result = parserDelegate.nextValue();\n\n        // Assert\n        assertSame(mockedJsonToken, result);\n        verify(parserDelegate, times(2)).nextToken();\n    }\n\n    @Test\n    public void testNextValue_returnsNullAfterFieldNameWhenNextTokenIsNull() throws IOException {\n        // Arrange\n        when(parserDelegate.nextToken())\n                .thenReturn(JsonToken.FIELD_NAME)\n                .thenReturn(null);\n\n        // Act\n        JsonToken result = parserDelegate.nextValue();\n\n        // Assert\n        assertNull(result);\n        verify(parserDelegate, times(2)).nextToken();\n    }\n\n    @Test\n    public void testNextValue_handlesMultipleFieldNamesCorrectly() throws IOException {\n        // Arrange\n        JsonToken fieldNameToken1 = JsonToken.FIELD_NAME;\n        JsonToken fieldNameToken2 = JsonToken.FIELD_NAME;\n        JsonToken valueToken = JsonToken.VALUE_STRING;\n\n        when(parserDelegate.nextToken())\n                .thenReturn(fieldNameToken1)\n                .thenReturn(fieldNameToken2)\n                .thenReturn(valueToken);\n\n        // Act\n        JsonToken result = parserDelegate.nextValue();\n\n        // Assert\n        assertSame(valueToken, result);\n        verify(parserDelegate, times(3)).nextToken();\n    }\n\n    @Test\n    public void testNextValue_throwsIOExceptionWhenNextTokenThrowsIOException() throws IOException {\n        // Arrange\n        when(parserDelegate.nextToken()).thenThrow(new IOException(\"Test exception\"));\n\n        // Act & Assert\n        try {\n            parserDelegate.nextValue();\n            fail(\"Expected IOException to be thrown\");\n        } catch (IOException e) {\n            assertEquals(\"Test exception\", e.getMessage());\n        }\n        verify(parserDelegate, times(1)).nextToken();\n    }\n}\n```\n\n### Explanation:\n\n1. **Test Case 1: `testNextValue_returnsNullWhenNextTokenIsNull()`**\n   - This test checks the scenario where `nextToken()` returns `null`. The expected result is that `nextValue()` should also return `null`.\n\n2. **Test Case 2: `testNextValue_returnsTokenWhenNextTokenIsNotFieldName()`**\n   - This test checks the scenario where `nextToken()` returns a token that is not `FIELD_NAME`. The expected result is that `nextValue()` should return the same token.\n\n3. **Test Case 3: `testNextValue_skipsFieldNameAndReturnsNextToken()`**\n   - This test checks the scenario where `nextToken()` returns `FIELD_NAME` initially, and then returns a valid token on the second call. The expected result is that `nextValue()` should skip the `FIELD_NAME` and return the subsequent token.\n\n4. **Test Case 4: `testNextValue_returnsNullAfterFieldNameWhenNextTokenIsNull()`**\n   - This test checks the scenario where `nextToken()` returns `FIELD_NAME` initially, and then returns `null` on the second call. The expected result is that `nextValue()` should return `null`.\n\n5. **Test Case 5: `testNextValue_handlesMultipleFieldNamesCorrectly()`**\n   - This test checks the scenario where multiple `FIELD_NAME` tokens are encountered before a valid token. The expected result is that `nextValue()` should skip all `FIELD_NAME` tokens and return the subsequent valid token.\n\n6. **Test Case 6: `testNextValue_throwsIOExceptionWhenNextTokenThrowsIOException()`**\n   - This test checks the scenario where `nextToken()` throws an `IOException`. The expected result is that `nextValue()` should also throw an `IOException` with the same message.\n\nThese tests should provide comprehensive coverage for the `nextValue()` method, ensuring that it behaves correctly across various scenarios."}
{"bug_id": "JacksonCore_22", "version": "fixed", "focal_method_signature": "JsonParser com.fasterxml.jackson.core.filter.FilteringParserDelegate#skipChildren()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "focal_method": "@Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }", "return_type": "JsonParser", "assertion_subject_candidates": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()"], "focal_class": {"name": "FilteringParserDelegate", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_22/fixed/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java", "superclass": "extends JsonParserDelegate", "interface": "", "imports": ["import java.io.IOException;", "import java.io.OutputStream;", "import java.math.BigDecimal;", "import java.math.BigInteger;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.util.JsonParserDelegate;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected TokenFilter rootFilter", "protected boolean _allowMultipleMatches", "protected boolean _includePath", "@Deprecated\n    protected boolean _includeImmediateParent", "protected JsonToken _currToken", "protected JsonToken _lastClearedToken", "protected TokenFilterContext _headContext", "protected TokenFilterContext _exposedContext", "protected TokenFilter _itemFilter", "protected int _matchCount"], "methods": ["TokenFilter com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFilter()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getMatchCount()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentToken()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentTokenId()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#currentTokenId()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasCurrentToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTokenId(int#id)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasToken(JsonToken#t)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartArrayToken()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#isExpectedStartObjectToken()", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#getParsingContext()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getCurrentName()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#clearCurrentToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLastClearedToken()", "void com.fasterxml.jackson.core.filter.FilteringParserDelegate#overrideCurrentName(String#name)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextToken()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextToken2()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextTokenWithBuffering(TokenFilterContext#buffRoot)", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#_nextBuffered(TokenFilterContext#buffRoot)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#_verifyAllowedMatches()", "JsonToken com.fasterxml.jackson.core.filter.FilteringParserDelegate#nextValue()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getText()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#hasTextCharacters()", "char[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextCharacters()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextLength()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTextOffset()", "BigInteger com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBigIntegerValue()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBooleanValue()", "byte com.fasterxml.jackson.core.filter.FilteringParserDelegate#getByteValue()", "short com.fasterxml.jackson.core.filter.FilteringParserDelegate#getShortValue()", "BigDecimal com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDecimalValue()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getDoubleValue()", "float com.fasterxml.jackson.core.filter.FilteringParserDelegate#getFloatValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getIntValue()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getLongValue()", "NumberType com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberType()", "Number com.fasterxml.jackson.core.filter.FilteringParserDelegate#getNumberValue()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt()", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsInt(int#defaultValue)", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong()", "long com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsLong(long#defaultValue)", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble()", "double com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsDouble(double#defaultValue)", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean()", "boolean com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsBoolean(boolean#defaultValue)", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString()", "String com.fasterxml.jackson.core.filter.FilteringParserDelegate#getValueAsString(String#defaultValue)", "Object com.fasterxml.jackson.core.filter.FilteringParserDelegate#getEmbeddedObject()", "byte[] com.fasterxml.jackson.core.filter.FilteringParserDelegate#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.filter.FilteringParserDelegate#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "JsonLocation com.fasterxml.jackson.core.filter.FilteringParserDelegate#getTokenLocation()", "JsonStreamContext com.fasterxml.jackson.core.filter.FilteringParserDelegate#_filterContext()"], "other_methods": ["public TokenFilter getFilter();", "public int getMatchCount();", "@Override public JsonToken getCurrentToken();", "@Override public JsonToken currentToken();", "@Override public final int getCurrentTokenId();", "@Override public final int currentTokenId();", "@Override public boolean hasCurrentToken();", "@Override public boolean hasTokenId(int id);", "@Override public final boolean hasToken(JsonToken t);", "@Override public boolean isExpectedStartArrayToken();", "@Override public boolean isExpectedStartObjectToken();", "@Override public JsonLocation getCurrentLocation();", "@Override\n    public JsonStreamContext getParsingContext();", "@Override\n    public String getCurrentName();", "@Override\n    public void clearCurrentToken();", "@Override\n    public JsonToken getLastClearedToken();", "@Override\n    public void overrideCurrentName(String name);", "@Override\n    public JsonToken nextToken();", "@Override\n    public JsonToken nextValue();", "@Override public String getText();", "@Override public boolean hasTextCharacters();", "@Override public char[] getTextCharacters();", "@Override public int getTextLength();", "@Override public int getTextOffset();", "@Override\n    public BigInteger getBigIntegerValue();", "@Override\n    public boolean getBooleanValue();", "@Override\n    public byte getByteValue();", "@Override\n    public short getShortValue();", "@Override\n    public BigDecimal getDecimalValue();", "@Override\n    public double getDoubleValue();", "@Override\n    public float getFloatValue();", "@Override\n    public int getIntValue();", "@Override\n    public long getLongValue();", "@Override\n    public NumberType getNumberType();", "@Override\n    public Number getNumberValue();", "@Override public int getValueAsInt();", "@Override public int getValueAsInt(int defaultValue);", "@Override public long getValueAsLong();", "@Override public long getValueAsLong(long defaultValue);", "@Override public double getValueAsDouble();", "@Override public double getValueAsDouble(double defaultValue);", "@Override public boolean getValueAsBoolean();", "@Override public boolean getValueAsBoolean(boolean defaultValue);", "@Override public String getValueAsString();", "@Override public String getValueAsString(String defaultValue);", "@Override public Object getEmbeddedObject();", "@Override public byte[] getBinaryValue(Base64Variant b64variant);", "@Override public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override public JsonLocation getTokenLocation();"], "fields_dict": {"TokenFilter#rootFilter": "protected TokenFilter rootFilter", "boolean#_allowMultipleMatches": "protected boolean _allowMultipleMatches", "boolean#_includePath": "protected boolean _includePath", "boolean#_includeImmediateParent": "@Deprecated\n    protected boolean _includeImmediateParent", "JsonToken#_currToken": "protected JsonToken _currToken", "JsonToken#_lastClearedToken": "protected JsonToken _lastClearedToken", "TokenFilterContext#_headContext": "protected TokenFilterContext _headContext", "TokenFilterContext#_exposedContext": "protected TokenFilterContext _exposedContext", "TokenFilter#_itemFilter": "protected TokenFilter _itemFilter", "int#_matchCount": "protected int _matchCount"}, "text": "package com.fasterxml.jackson.core.filter;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * Specialized {@link JsonParserDelegate} that allows use of\n * {@link TokenFilter} for outputting a subset of content that\n * is visible to caller\n * \n * @since 2.6\n */\npublic class FilteringParserDelegate extends JsonParserDelegate\n{\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n    \n    /**\n     * Object consulted to determine whether to write parts of content generator\n     * is asked to write or not.\n     */\n    protected TokenFilter rootFilter;\n\n    /**\n     * Flag that determines whether filtering will continue after the first\n     * match is indicated or not: if `false`, output is based on just the first\n     * full match (returning {@link TokenFilter#INCLUDE_ALL}) and no more\n     * checks are made; if `true` then filtering will be applied as necessary\n     * until end of content.\n     */\n    protected boolean _allowMultipleMatches;\n\n    /**\n     * Flag that determines whether path leading up to included content should\n     * also be automatically included or not. If `false`, no path inclusion is\n     * done and only explicitly included entries are output; if `true` then\n     * path from main level down to match is also included as necessary.\n     */\n    protected boolean _includePath;\n\n    /* NOTE: this feature is included in the first version (2.6), but\n     * there is no public API to enable it, yet, since there isn't an\n     * actual use case. But it seemed possible need could arise, which\n     * is feature has not yet been removed. If no use is found within\n     * first version or two, just remove.\n     * \n     * Marked as deprecated since its status is uncertain.\n     */\n    @Deprecated\n    protected boolean _includeImmediateParent;\n    \n    /*\n    /**********************************************************\n    /* State\n    /**********************************************************\n     */\n\n    /**\n     * Last token retrieved via {@link #nextToken}, if any.\n     * Null before the first call to <code>nextToken()</code>,\n     * as well as if token has been explicitly cleared\n     */\n    protected JsonToken _currToken;\n\n    /**\n     * Last cleared token, if any: that is, value that was in\n     * effect when {@link #clearCurrentToken} was called.\n     */\n    protected JsonToken _lastClearedToken;\n    \n    /**\n     * During traversal this is the actual \"open\" parse tree, which sometimes\n     * is the same as {@link #_exposedContext}, and at other times is ahead\n     * of it. Note that this context is never null.\n     */\n    protected TokenFilterContext _headContext;\n\n    /**\n     * In cases where {@link #_headContext} is \"ahead\" of context exposed to\n     * caller, this context points to what is currently exposed to caller.\n     * When the two are in sync, this context reference will be <code>null</code>.\n     */\n    protected TokenFilterContext _exposedContext;\n\n    /**\n     * State that applies to the item within container, used where applicable.\n     * Specifically used to pass inclusion state between property name and\n     * property, and also used for array elements.\n     */\n    protected TokenFilter _itemFilter;\n    \n    /**\n     * Number of tokens for which {@link TokenFilter#INCLUDE_ALL}\n     * has been returned.\n     */\n    protected int _matchCount;\n\n    /*\n    /**********************************************************\n    /* Construction, initialization\n    /**********************************************************\n     */\n\n    public FilteringParserDelegate(JsonParser p, TokenFilter f,\n            boolean includePath, boolean allowMultipleMatches)\n    {\n        super(p);\n        rootFilter = f;\n        // and this is the currently active filter for root values\n        _itemFilter = f;\n        _headContext = TokenFilterContext.createRootContext(f);\n        _includePath = includePath;\n        _allowMultipleMatches = allowMultipleMatches;\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    public TokenFilter getFilter() { return rootFilter; }\n\n    /**\n     * Accessor for finding number of matches, where specific token and sub-tree\n     * starting (if structured type) are passed.\n     */\n    public int getMatchCount() {\n        return _matchCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token accessors\n    /**********************************************************\n     */\n\n    @Override public JsonToken getCurrentToken() { return _currToken; }\n    @Override public JsonToken currentToken() { return _currToken; }\n\n    @Override public final int getCurrentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n    @Override public final int currentTokenId() {\n        final JsonToken t = _currToken;\n        return (t == null) ? JsonTokenId.ID_NO_TOKEN : t.id();\n    }\n\n    @Override public boolean hasCurrentToken() { return _currToken != null; }\n    @Override public boolean hasTokenId(int id) {\n        final JsonToken t = _currToken;\n        if (t == null) {\n            return (JsonTokenId.ID_NO_TOKEN == id);\n        }\n        return t.id() == id;\n    }\n\n    @Override public final boolean hasToken(JsonToken t) {\n        return (_currToken == t);\n    }\n    \n    @Override public boolean isExpectedStartArrayToken() { return _currToken == JsonToken.START_ARRAY; }\n    @Override public boolean isExpectedStartObjectToken() { return _currToken == JsonToken.START_OBJECT; }\n\n    @Override public JsonLocation getCurrentLocation() { return delegate.getCurrentLocation(); }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return _filterContext();\n    }\n    \n    // !!! TODO: Verify it works as expected: copied from standard JSON parser impl\n    @Override\n    public String getCurrentName() throws IOException {\n        JsonStreamContext ctxt = _filterContext();\n        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n            JsonStreamContext parent = ctxt.getParent();\n            return (parent == null) ? null : parent.getCurrentName();\n        }\n        return ctxt.getCurrentName();\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, token state overrides\n    /**********************************************************\n     */\n\n    @Override\n    public void clearCurrentToken() {\n        if (_currToken != null) {\n            _lastClearedToken = _currToken;\n            _currToken = null;\n        }\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() { return _lastClearedToken; }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        /* 14-Apr-2015, tatu: Not sure whether this can be supported, and if so,\n         *    what to do with it... Delegation won't work for sure, so let's for\n         *    now throw an exception\n         */\n        throw new UnsupportedOperationException(\"Can not currently override name during filtering read\");\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n        //    conditionals; and it seems odd to return `null` but NOT considering input\n        //    as closed... would love a rewrite to simplify/clear up logic here.\n        \n        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n        // check for no buffered context _exposedContext - null\n        // If all the conditions matches then check for scalar / non-scalar property\n\n        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n            // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n            // matched once, return null\n            if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n                    && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n                return (_currToken = null);\n            }\n        }\n        // Anything buffered?\n        TokenFilterContext ctxt = _exposedContext;\n\n        if (ctxt != null) {\n            while (true) {\n                JsonToken t = ctxt.nextTokenToRead();\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n                // all done with buffered stuff?\n                if (ctxt == _headContext) {\n                    _exposedContext = null;\n                    if (ctxt.inArray()) {\n                        t = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n                        _currToken = t;\n                        return t;\n                    }\n\n                    // Almost! Most likely still have the current token;\n                    // with the sole exception of \n                    /*\n                    t = delegate.getCurrentToken();\n                    if (t != JsonToken.FIELD_NAME) {\n                        _currToken = t;\n                        return t;\n                    }\n                    */\n                    break;\n                }\n                // If not, traverse down the context chain\n                ctxt = _headContext.findChildOf(ctxt);\n                _exposedContext = ctxt;\n                if (ctxt == null) { // should never occur\n                    throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n                }\n            }\n        }\n\n        // If not, need to read more. If we got any:\n        JsonToken t = delegate.nextToken();\n        if (t == null) {\n            // no strict need to close, since we have no state here\n            _currToken = t;\n            return t;\n        }\n\n        // otherwise... to include or not?\n        TokenFilter f;\n        \n        switch (t.id()) {\n        case ID_START_ARRAY:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartArray();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildArrayContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildArrayContext(f, false);\n            \n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            break;\n\n        case ID_START_OBJECT:\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            if (f == null) { // does this occur?\n                delegate.skipChildren();\n                break;\n            }\n            // Otherwise still iffy, need to check\n            f = _headContext.checkValue(f);\n            if (f == null) {\n                delegate.skipChildren();\n                break;\n            }\n            if (f != TokenFilter.INCLUDE_ALL) {\n                f = f.filterStartObject();\n            }\n            _itemFilter = f;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                _headContext = _headContext.createChildObjectContext(f, true);\n                return (_currToken = t);\n            }\n            _headContext = _headContext.createChildObjectContext(f, false);\n            // Also: only need buffering if parent path to be included\n            if (_includePath) {\n                t = _nextTokenWithBuffering(_headContext);\n                if (t != null) {\n                    _currToken = t;\n                    return t;\n                }\n            }\n            // note: inclusion of surrounding Object handled separately via\n            // FIELD_NAME\n            break;\n\n        case ID_END_ARRAY:\n        case ID_END_OBJECT:\n            {\n                boolean returnEnd = _headContext.isStartHandled();\n                f = _headContext.getFilter();\n                if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                    f.filterFinishArray();\n                }\n                _headContext = _headContext.getParent();\n                _itemFilter = _headContext.getFilter();\n                if (returnEnd) {\n                    return (_currToken = t);\n                }\n            }\n            break;\n\n        case ID_FIELD_NAME:\n            {\n                final String name = delegate.getCurrentName();\n                // note: this will also set 'needToHandleName'\n                f = _headContext.setFieldName(name);\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _itemFilter = f;\n                    if (!_includePath) {\n                        // Minor twist here: if parent NOT included, may need to induce output of\n                        // surrounding START_OBJECT/END_OBJECT\n                        if (_includeImmediateParent && !_headContext.isStartHandled()) {\n                            t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n                            _exposedContext = _headContext;\n                        }\n                    }\n                    return (_currToken = t);\n                }\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                f = f.includeProperty(name);\n                if (f == null) {\n                    delegate.nextToken();\n                    delegate.skipChildren();\n                    break;\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    if (_verifyAllowedMatches() && _includePath) {\n                        return (_currToken = t);\n                    }\n                }\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                break;\n            }\n\n        default: // scalar value\n            f = _itemFilter;\n            if (f == TokenFilter.INCLUDE_ALL) {\n                return (_currToken = t);\n            }\n            if (f != null) {\n                f = _headContext.checkValue(f);\n                if ((f == TokenFilter.INCLUDE_ALL)\n                        || ((f != null) && f.includeValue(delegate))) {\n                    if (_verifyAllowedMatches()) {\n                        return (_currToken = t);\n                    }\n                }\n            }\n            // Otherwise not included (leaves must be explicitly included)\n            break;\n        }\n\n        // We get here if token was not yet found; offlined handling\n        return _nextToken2();\n    }\n\n    /**\n     * Offlined handling for cases where there was no buffered token to\n     * return, and the token read next could not be returned as-is,\n     * at least not yet, but where we have not yet established that\n     * buffering is needed.\n     */\n    protected final JsonToken _nextToken2() throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                _currToken = t;\n                return t;\n            }\n            TokenFilter f;\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                // but if we didn't figure it out yet, need to buffer possible events\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return (_currToken = t);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                if (_includePath) {\n                    t = _nextTokenWithBuffering(_headContext);\n                    if (t != null) {\n                        _currToken = t;\n                        return t;\n                    }\n                }\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    boolean returnEnd = _headContext.isStartHandled();\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n                    if (returnEnd) {\n                        return (_currToken = t);\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return (_currToken = t);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        if (_verifyAllowedMatches() && _includePath) {\n                            return (_currToken = t);\n                        }\n//                        if (_includeImmediateParent) { ...\n                        continue main_loop;\n                    }\n                    if (_includePath) {\n                        t = _nextTokenWithBuffering(_headContext);\n                        if (t != null) {\n                            _currToken = t;\n                            return t;\n                        }\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return (_currToken = t);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return (_currToken = t);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                break;\n            }\n        }\n    }\n\n    /**\n     * Method called when a new potentially included context is found.\n     */\n    protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\n        throws IOException\n    {\n        main_loop:\n        while (true) {\n            JsonToken t = delegate.nextToken();\n            if (t == null) { // is this even legal?\n                return t;\n            }\n            TokenFilter f;\n\n            // One simplification here: we know for a fact that the item filter is\n            // neither null nor 'include all', for most cases; the only exception\n            // being FIELD_NAME handling\n\n            switch (t.id()) {\n            case ID_START_ARRAY:\n                f = _headContext.checkValue(_itemFilter);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartArray();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildArrayContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildArrayContext(f, false);\n                continue main_loop;\n\n            case ID_START_OBJECT:\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return t;\n                }\n                if (f == null) { // does this occur?\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                // Otherwise still iffy, need to check\n                f = _headContext.checkValue(f);\n                if (f == null) {\n                    delegate.skipChildren();\n                    continue main_loop;\n                }\n                if (f != TokenFilter.INCLUDE_ALL) {\n                    f = f.filterStartObject();\n                }\n                _itemFilter = f;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    _headContext = _headContext.createChildObjectContext(f, true);\n                    return _nextBuffered(buffRoot);\n                }\n                _headContext = _headContext.createChildObjectContext(f, false);\n                continue main_loop;\n\n            case ID_END_ARRAY:\n            case ID_END_OBJECT:\n                {\n                    // Unlike with other loops, here we know that content was NOT\n                    // included (won't get this far otherwise)\n                    f = _headContext.getFilter();\n                    if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n                        f.filterFinishArray();\n                    }\n                    boolean gotEnd = (_headContext == buffRoot);\n                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n                    _headContext = _headContext.getParent();\n                    _itemFilter = _headContext.getFilter();\n\n                    if (returnEnd) {\n                        return t;\n                    }\n                    // Hmmh. Do we need both checks, or should above suffice?\n                    if (gotEnd || (_headContext == buffRoot)) {\n                        return null;\n                    }\n                }\n                continue main_loop;\n\n            case ID_FIELD_NAME:\n                {\n                    final String name = delegate.getCurrentName();\n                    f = _headContext.setFieldName(name);\n                    if (f == TokenFilter.INCLUDE_ALL) {\n                        _itemFilter = f;\n                        return _nextBuffered(buffRoot);\n                    }\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    f = f.includeProperty(name);\n                    if (f == null) { // filter out the value\n                        delegate.nextToken();\n                        delegate.skipChildren();\n                        continue main_loop;\n                    }\n                    _itemFilter = f;\n                    if (f == TokenFilter.INCLUDE_ALL && _verifyAllowedMatches()) {\n                        return _nextBuffered(buffRoot);\n                    }\n                }\n                continue main_loop;\n\n            default: // scalar value\n                f = _itemFilter;\n                if (f == TokenFilter.INCLUDE_ALL) {\n                    return _nextBuffered(buffRoot);\n                }\n                if (f != null) {\n                    f = _headContext.checkValue(f);\n                    if ((f == TokenFilter.INCLUDE_ALL)\n                            || ((f != null) && f.includeValue(delegate))) {\n                        if (_verifyAllowedMatches()) {\n                            return _nextBuffered(buffRoot);\n                        }\n                    }\n                }\n                // Otherwise not included (leaves must be explicitly included)\n                continue main_loop;\n            }\n        }\n    }\n\n    private JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n    {\n        _exposedContext = buffRoot;\n        TokenFilterContext ctxt = buffRoot;\n        JsonToken t = ctxt.nextTokenToRead();\n        if (t != null) {\n            return t;\n        }\n        while (true) {\n            // all done with buffered stuff?\n            if (ctxt == _headContext) {\n                throw _constructError(\"Internal error: failed to locate expected buffered tokens\");\n                /*\n                _exposedContext = null;\n                break;\n                */\n            }\n            // If not, traverse down the context chain\n            ctxt = _exposedContext.findChildOf(ctxt);\n            _exposedContext = ctxt;\n            if (ctxt == null) { // should never occur\n                throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n            }\n            t = _exposedContext.nextTokenToRead();\n            if (t != null) {\n                return t;\n            }\n        }\n    }\n\n    private final boolean _verifyAllowedMatches() throws IOException {\n        if (_matchCount == 0 || _allowMultipleMatches) {\n            ++_matchCount;\n            return true;\n        }\n        return false;\n    }\n\n    @Override\n    public JsonToken nextValue() throws IOException {\n        // Re-implemented same as ParserMinimalBase:\n        JsonToken t = nextToken();\n        if (t == JsonToken.FIELD_NAME) {\n            t = nextToken();\n        }\n        return t;\n    }\n\n    /**\n     * Need to override, re-implement similar to how method defined in\n     * {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n     * state correct here.\n     */\n    @Override\n    public JsonParser skipChildren() throws IOException\n    {\n        if ((_currToken != JsonToken.START_OBJECT)\n            && (_currToken != JsonToken.START_ARRAY)) {\n            return this;\n        }\n        int open = 1;\n\n        // Since proper matching of start/end markers is handled\n        // by nextToken(), we'll just count nesting levels here\n        while (true) {\n            JsonToken t = nextToken();\n            if (t == null) { // not ideal but for now, just return\n                return this;\n            }\n            if (t.isStructStart()) {\n                ++open;\n            } else if (t.isStructEnd()) {\n                if (--open == 0) {\n                    return this;\n                }\n            }\n        }\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token information, text\n    /**********************************************************\n     */\n\n    @Override public String getText() throws IOException { return delegate.getText();  }\n    @Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n    @Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n    @Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n    @Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, numeric\n    /**********************************************************\n     */\n    \n    @Override\n    public BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n    @Override\n    public boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n    \n    @Override\n    public byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n    @Override\n    public short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n    @Override\n    public double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n    @Override\n    public float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n    @Override\n    public int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n    @Override\n    public long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n    @Override\n    public NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n    @Override\n    public Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n    /*\n    /**********************************************************\n    /* Public API, access to token information, coercion/conversion\n    /**********************************************************\n     */\n    \n    @Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n    @Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n    @Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n    @Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n    @Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n    @Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n    @Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n    @Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n    @Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n    @Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n    \n    /*\n    /**********************************************************\n    /* Public API, access to token values, other\n    /**********************************************************\n     */\n\n    @Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n    @Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n    @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n    @Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n    /*\n    /**********************************************************\n    /* Internal helper methods\n    /**********************************************************\n     */\n\n    protected JsonStreamContext _filterContext() {\n        if (_exposedContext != null) {\n            return _exposedContext;\n        }\n        return _headContext;\n    }\n  \n}\n"}, "generated_test_class": "To write unit tests for the `skipChildren` method in the `FilteringParserDelegate` class, we need to simulate various scenarios that the method handles. These scenarios include:\n\n1. When the current token is not a `START_OBJECT` or `START_ARRAY`.\n2. When the current token is a `START_OBJECT` or `START_ARRAY` and the method needs to skip over nested structures.\n\nBelow is a set of unit tests that aim to cover these scenarios:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.Mockito;\nimport org.mockito.MockitoAnnotations;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.junit.MockitoJUnitRunner;\n\nimport com.fasterxml.jackson.core.Base64Variant;\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonStreamContext;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.core.ObjectCodec;\nimport com.fasterxml.jackson.core.io.JsonEOFException;\nimport com.fasterxml.jackson.core.json.JsonParserDelegate;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Iterator;\n\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class FilteringParserDelegateTest {\n\n    @Mock\n    private JsonParser mockParser;\n\n    private FilteringParserDelegate parserDelegate;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        parserDelegate = new FilteringParserDelegate(mockParser) {\n            @Override\n            public TokenFilter getFilter() {\n                return null;\n            }\n\n            @Override\n            public int getMatchCount() {\n                return 0;\n            }\n        };\n    }\n\n    @Test\n    public void testSkipChildrenWhenCurrentTokenIsNotStartObjectOrArray() throws IOException {\n        // Given\n        when(mockParser.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME);\n\n        // When\n        JsonParser result = parserDelegate.skipChildren();\n\n        // Then\n        assertEquals(parserDelegate, result);\n        verify(mockParser, times(0)).nextToken();\n    }\n\n    @Test\n    public void testSkipChildrenWhenCurrentTokenIsStartObject() throws IOException {\n        // Given\n        when(mockParser.getCurrentToken()).thenReturn(JsonToken.START_OBJECT);\n        mockNextTokenForSkipChildren(mockParser, new JsonToken[]{\n                JsonToken.FIELD_NAME,\n                JsonToken.VALUE_STRING,\n                JsonToken.START_OBJECT,\n                JsonToken.END_OBJECT,\n                JsonToken.END_OBJECT\n        });\n\n        // When\n        JsonParser result = parserDelegate.skipChildren();\n\n        // Then\n        assertEquals(parserDelegate, result);\n        verify(mockParser, times(5)).nextToken();\n    }\n\n    @Test\n    public void testSkipChildrenWhenCurrentTokenIsStartArray() throws IOException {\n        // Given\n        when(mockParser.getCurrentToken()).thenReturn(JsonToken.START_ARRAY);\n        mockNextTokenForSkipChildren(mockParser, new JsonToken[]{\n                JsonToken.START_ARRAY,\n                JsonToken.START_OBJECT,\n                JsonToken.END_OBJECT,\n                JsonToken.END_ARRAY,\n                JsonToken.END_ARRAY\n        });\n\n        // When\n        JsonParser result = parserDelegate.skipChildren();\n\n        // Then\n        assertEquals(parserDelegate, result);\n        verify(mockParser, times(5)).nextToken();\n    }\n\n    @Test\n    public void testSkipChildrenWhenEncountersNullToken() throws IOException {\n        // Given\n        when(mockParser.getCurrentToken()).thenReturn(JsonToken.START_OBJECT);\n        mockNextTokenForSkipChildren(mockParser, new JsonToken[]{\n                JsonToken.START_OBJECT,\n                null\n        });\n\n        // When\n        JsonParser result = parserDelegate.skipChildren();\n\n        // Then\n        assertEquals(parserDelegate, result);\n        verify(mockParser, times(2)).nextToken();\n    }\n\n    private void mockNextTokenForSkipChildren(JsonParser mockParser, JsonToken[] tokens) throws IOException {\n        when(mockParser.nextToken()).thenAnswer(new Answer<JsonToken>() {\n            private final Iterator<JsonToken> iterator = java.util.Arrays.asList(tokens).iterator();\n\n            @Override\n            public JsonToken answer(InvocationOnMock invocation) throws Throwable {\n                if (iterator.hasNext()) {\n                    return iterator.next();\n                }\n                return null;\n            }\n        });\n    }\n\n    // Other required methods (mock implementation)\n    @Override\n    protected TokenFilterContext _findFilterContext(TokenFilter filter) {\n        return null;\n    }\n\n    @Override\n    protected void _handleEOF() throws IOException {\n        throw new JsonEOFException(null, null, null);\n    }\n\n    @Override\n    public void close() throws IOException {\n        mockParser.close();\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        mockParser.finishToken();\n    }\n\n    @Override\n    public JsonToken nextFieldName() throws IOException {\n        return mockParser.nextFieldName();\n    }\n\n    @Override\n    public String nextTextValue() throws IOException {\n        return mockParser.nextTextValue();\n    }\n\n    @Override\n    public int nextIntValue(int defaultValue) throws IOException {\n        return mockParser.nextIntValue(defaultValue);\n    }\n\n    @Override\n    public long nextLongValue(long defaultValue) throws IOException {\n        return mockParser.nextLongValue(defaultValue);\n    }\n\n    @Override\n    public Boolean nextBooleanValue() throws IOException {\n        return mockParser.nextBooleanValue();\n    }\n\n    @Override\n    public void overrideCurrentName(String name) {\n        mockParser.overrideCurrentName(name);\n    }\n\n    @Override\n    public void setCurrentValue(Object v) {\n        mockParser.setCurrentValue(v);\n    }\n\n    @Override\n    public Object currentValue() {\n        return mockParser.currentValue();\n    }\n\n    @Override\n    public ObjectCodec getCodec() {\n        return mockParser.getCodec();\n    }\n\n    @Override\n    public void setCodec(ObjectCodec c) {\n        mockParser.setCodec(c);\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException {\n        return mockParser.readBinaryValue(b64variant, out);\n    }\n\n    @Override\n    public JsonLocation getTokenLocation() {\n        return mockParser.getTokenLocation();\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        return mockParser.getCurrentLocation();\n    }\n\n    @Override\n    public boolean isClosed() {\n        return mockParser.isClosed();\n    }\n\n    @Override\n    public JsonStreamContext getParsingContext() {\n        return mockParser.getParsingContext();\n    }\n\n    @Override\n    public boolean canReadObjectId() {\n        return mockParser.canReadObjectId();\n    }\n\n    @Override\n    public boolean canReadTypeId() {\n        return mockParser.canReadTypeId();\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException {\n        return mockParser.getBinaryValue(b64variant);\n    }\n\n    @Override\n    public Object getEmbeddedObject() {\n        return mockParser.getEmbeddedObject();\n    }\n\n    @Override\n    public String getValueAsString() {\n        return mockParser.getValueAsString();\n    }\n\n    @Override\n    public String getValueAsString(String defaultValue) {\n        return mockParser.getValueAsString(defaultValue);\n    }\n\n    @Override\n    public char[] getTextCharacters() throws IOException {\n        return mockParser.getTextCharacters();\n    }\n\n    @Override\n    public boolean hasTextCharacters() {\n        return mockParser.hasTextCharacters();\n    }\n\n    @Override\n    public int getTextLength() throws IOException {\n        return mockParser.getTextLength();\n    }\n\n    @Override\n    public int getTextOffset() throws IOException {\n        return mockParser.getTextOffset();\n    }\n\n    @Override\n    public int getValueAsInt() {\n        return mockParser.getValueAsInt();\n    }\n\n    @Override\n    public int getValueAsInt(int defaultValue) {\n        return mockParser.getValueAsInt(defaultValue);\n    }\n\n    @Override\n    public long getValueAsLong() {\n        return mockParser.getValueAsLong();\n    }\n\n    @Override\n    public long getValueAsLong(long defaultValue) {\n        return mockParser.getValueAsLong(defaultValue);\n    }\n\n    @Override\n    public double getValueAsDouble() {\n        return mockParser.getValueAsDouble();\n    }\n\n    @Override\n    public double getValueAsDouble(double defaultValue) {\n        return mockParser.getValueAsDouble(defaultValue);\n    }\n\n    @Override\n    public boolean getValueAsBoolean() {\n        return mockParser.getValueAsBoolean();\n    }\n\n    @Override\n    public boolean getValueAsBoolean(boolean defaultValue) {\n        return mockParser.getValueAsBoolean(defaultValue);\n    }\n\n    @Override\n    public String getCurrentName() {\n        return mockParser.getCurrentName();\n    }\n\n    @Override\n    public NumberType getNumberType() {\n        return mockParser.getNumberType();\n    }\n\n    @Override\n    public Number getNumberValue() throws IOException {\n        return mockParser.getNumberValue();\n    }\n\n    @Override\n    public BigInteger getBigIntegerValue() throws IOException {\n        return mockParser.getBigIntegerValue();\n    }\n\n    @Override\n    public BigDecimal getDecimalValue() throws IOException {\n        return mockParser.getDecimalValue();\n    }\n\n    @Override\n    public double getDoubleValue() throws IOException {\n        return mockParser.getDoubleValue();\n    }\n\n    @Override\n    public float getFloatValue() throws IOException {\n        return mockParser.getFloatValue();\n    }\n\n    @Override\n    public int getIntValue() throws IOException {\n        return mockParser.getIntValue();\n    }\n\n    @Override\n    public long getLongValue() throws IOException {\n        return mockParser.getLongValue();\n    }\n\n    @Override\n    public byte getByteValue() throws IOException {\n        return mockParser.getByteValue();\n    }\n\n    @Override\n    public short getShortValue() throws IOException {\n        return mockParser.getShortValue();\n    }\n\n    @Override\n    public boolean getBooleanValue() throws IOException {\n        return mockParser.getBooleanValue();\n    }\n\n    @Override\n    public JsonToken nextToken() throws IOException {\n        return mockParser.nextToken();\n    }\n\n    @Override\n    public JsonToken nextValue() throws IOException {\n        return mockParser.nextValue();\n    }\n\n    @Override\n    public void clearCurrentToken() {\n        mockParser.clearCurrentToken();\n    }\n\n    @Override\n    public JsonToken getCurrentToken() {\n        return mockParser.getCurrentToken();\n    }\n\n    @Override\n    public boolean hasCurrentToken() {\n        return mockParser.hasCurrentToken();\n    }\n\n    @Override\n    public boolean hasTokenId(int id) {\n        return mockParser.hasTokenId(id);\n    }\n\n    @Override\n    public boolean hasToken(JsonToken t) {\n        return mockParser.hasToken(t);\n    }\n\n    @Override\n    public boolean isExpectedStartArrayToken() {\n        return mockParser.isExpectedStartArrayToken();\n    }\n\n    @Override\n    public boolean isExpectedStartObjectToken() {\n        return mockParser.isExpectedStartObjectToken();\n    }\n\n    @Override\n    public String getText() {\n        return mockParser.getText();\n    }\n\n    @Override\n    public JsonToken currentToken() {\n        return mockParser.currentToken();\n    }\n\n    @Override\n    public int getCurrentTokenId() {\n        return mockParser.getCurrentTokenId();\n    }\n\n    @Override\n    public int currentTokenId() {\n        return mockParser.currentTokenId();\n    }\n\n    @Override\n    public JsonToken getLastClearedToken() {\n        return mockParser.getLastClearedToken();\n    }\n}\n```\n\n### Explanation\n\n1. **Test `testSkipChildrenWhenCurrentTokenIsNotStartObjectOrArray`**:\n   - Ensures that when the current token is not a `START_OBJECT` or `START_ARRAY`, the method returns immediately without calling `nextToken`.\n\n2. **Test `testSkipChildrenWhenCurrentTokenIsStartObject`**:\n   - Simulates a scenario where the current token is a `START_OBJECT` and the nested structure includes an object inside another object. It verifies that the method correctly skips over all nested structures.\n\n3. **Test `testSkipChildrenWhenCurrentTokenIsStartArray`**:\n   - Similar to the previous test, but with arrays instead of objects, ensuring that nested arrays are also skipped correctly.\n\n4. **Test `testSkipChildrenWhenEncountersNullToken`**:\n   - Simulates encountering a `null` token, which indicates the end of the input. The method should return immediately in this case.\n\nThe `mockNextTokenForSkipChildren` method is used to provide a sequence of tokens that `nextToken()` should return during the test. This allows us to simulate the parser's behavior in various scenarios."}
{"bug_id": "JacksonCore_26", "version": "fixed", "focal_method_signature": "void com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#feedInput(byte[]#buf,int#start,int#end)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_26/fixed/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java", "focal_method": "@Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _currBufferStart = start;\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }", "return_type": "void", "assertion_subject_candidates": ["ByteArrayFeeder com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#getNonBlockingInputFeeder()"], "focal_class": {"name": "NonBlockingJsonParser", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_26/fixed/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java", "superclass": "extends NonBlockingJsonParserBase", "interface": "implements ByteArrayFeeder", "imports": ["import java.io.IOException;", "import java.io.OutputStream;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.async.ByteArrayFeeder;", "import com.fasterxml.jackson.core.async.NonBlockingInputFeeder;", "import com.fasterxml.jackson.core.io.CharTypes;", "import com.fasterxml.jackson.core.io.IOContext;", "import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;", "import com.fasterxml.jackson.core.util.VersionUtil;"], "fields": ["@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask()", "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask()", "private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask()", "private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask()", "private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask()", "private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask()", "private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8()", "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "protected byte[] _inputBuffer = NO_BYTES", "protected int _origBufferLen"], "methods": ["ByteArrayFeeder com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#getNonBlockingInputFeeder()", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#needMoreInput()", "void com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#endOfInput()", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#releaseBuffered(OutputStream#out)", "char com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeEscaped()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#nextToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishTokenWithEOF()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startDocument(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishBOM(int#bytesHandled)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFieldName(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFieldNameAfterComma(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValue(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValueExpectComma(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValueExpectColon(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValueAfterComma(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startUnexpectedValue(boolean#leadingComma,int#ch)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_skipWS(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startSlashComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishHashComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishCppComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishCComment(int#fromMinorState,boolean#gotStar)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startAfterComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFalseToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startTrueToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startNullToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishKeywordToken(String#expToken,int#matched,JsonToken#result)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishKeywordTokenWithEOF(String#expToken,int#matched,JsonToken#result)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNonStdToken(int#type,int#matched)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNonStdTokenWithEOF(int#type,int#matched)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishErrorToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishErrorTokenWithEOF()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_reportErrorToken(String#actualToken)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startPositiveNumber(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startNegativeNumber()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startNumberLeadingZero()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberMinus(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberLeadingZeroes()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberLeadingNegZeroes()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberIntegralPart(char[]#outBuf,int#outPtr)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFloat(char[]#outBuf,int#outPtr,int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishFloatFraction()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishFloatExponent(boolean#checkSign,int#ch)", "String com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_fastParseName()", "String com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_parseMediumName(int#ptr,int#q2)", "String com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_parseMediumName2(int#ptr,int#q3,int#q2)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_parseEscapedName(int#qlen,int#currQuad,int#currQuadBytes)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_handleOddName(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishUnquotedName(int#qlen,int#currQuad,int#currQuadBytes)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishAposName(int#qlen,int#currQuad,int#currQuadBytes)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishFieldWithEscape()", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitEscaped(int#value,int#bytesRead)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startString()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishRegularString()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startAposString()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishAposString()", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitMultiByte(int#c,int#type,boolean#gotNext)", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitUTF8_3(int#prev,int#prevCount,int#next)", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitUTF8_4(int#prev,int#prevCount,int#next)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeCharEscape()", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeFastCharEscape()", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeUTF8_2(int#c,int#d)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeUTF8_3(int#c,int#d,int#e)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeUTF8_4(int#c,int#d,int#e,int#f)"], "other_methods": ["@Override\n    public ByteArrayFeeder getNonBlockingInputFeeder();", "@Override\n    public final boolean needMoreInput();", "@Override\n    public void endOfInput();", "@Override\n    public int releaseBuffered(OutputStream out);", "@Override\n    public JsonToken nextToken();"], "fields_dict": {"int#FEAT_MASK_TRAILING_COMMA": "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "int#FEAT_MASK_LEADING_ZEROS": "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask()", "int#FEAT_MASK_ALLOW_MISSING": "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask()", "int#FEAT_MASK_ALLOW_SINGLE_QUOTES": "private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask()", "int#FEAT_MASK_ALLOW_UNQUOTED_NAMES": "private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask()", "int#FEAT_MASK_ALLOW_JAVA_COMMENTS": "private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask()", "int#FEAT_MASK_ALLOW_YAML_COMMENTS": "private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask()", "int[]#_icUTF8": "private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8()", "int[]#_icLatin1": "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "byte[]#_inputBuffer": "protected byte[] _inputBuffer = NO_BYTES", "int#_origBufferLen": "protected int _origBufferLen"}, "text": "package com.fasterxml.jackson.core.json.async;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.async.ByteArrayFeeder;\nimport com.fasterxml.jackson.core.async.NonBlockingInputFeeder;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\npublic class NonBlockingJsonParser\n    extends NonBlockingJsonParserBase\n    implements ByteArrayFeeder\n{\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask();\n    private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask();\n    private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask();\n    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask();\n    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask();\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************************\n    /* Input source config\n    /**********************************************************************\n     */\n\n    /**\n     * This buffer is actually provided via {@link NonBlockingInputFeeder}\n     */\n    protected byte[] _inputBuffer = NO_BYTES;\n\n    /**\n     * In addition to current buffer pointer, and end pointer,\n     * we will also need to know number of bytes originally\n     * contained. This is needed to correctly update location\n     * information when the block has been completed.\n     */\n    protected int _origBufferLen;\n\n    // And from ParserBase:\n//  protected int _inputPtr;\n//  protected int _inputEnd;\n\n    /*\n    /**********************************************************************\n    /* Life-cycle\n    /**********************************************************************\n     */\n\n    public NonBlockingJsonParser(IOContext ctxt, int parserFeatures,\n            ByteQuadsCanonicalizer sym)\n    {\n        super(ctxt, parserFeatures, sym);\n    }\n\n    /*\n    /**********************************************************************\n    /* AsyncInputFeeder impl\n    /**********************************************************************\n     */\n\n    @Override\n    public ByteArrayFeeder getNonBlockingInputFeeder() {\n        return this;\n    }\n\n    @Override\n    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _currBufferStart = start;\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n\n    @Override\n    public void endOfInput() {\n        _endOfInput = true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Abstract methods/overrides from JsonParser\n    /**********************************************************************\n     */\n\n    /* Implementing these methods efficiently for non-blocking cases would\n     * be complicated; so for now let's just use the default non-optimized\n     * implementation\n     */\n\n//    public boolean nextFieldName(SerializableString str) throws IOException\n//    public String nextTextValue() throws IOException\n//    public int nextIntValue(int defaultValue) throws IOException\n//    public long nextLongValue(long defaultValue) throws IOException\n//    public Boolean nextBooleanValue() throws IOException\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int avail = _inputEnd - _inputPtr;\n        if (avail > 0) {\n            out.write(_inputBuffer, _inputPtr, avail);\n        }\n        return avail;\n    }\n\n    // Should never be called: can not be implemented quite as expected\n    // due to non-blocking behavior\n    @Override\n    protected char _decodeEscaped() throws IOException {\n        VersionUtil.throwInternal();\n        return ' ';\n    }\n\n    /*\n    /**********************************************************************\n    /* Main-level decoding\n    /**********************************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // First: regardless of where we really are, need at least one more byte;\n        // can simplify some of the checks by short-circuiting right away\n        if (_inputPtr >= _inputEnd) {\n            if (_closed) {\n                return null;\n            }\n            // note: if so, do not even bother changing state\n            if (_endOfInput) { // except for this special case\n                // End-of-input within (possibly...) started token is bit complicated,\n                // so offline\n                if (_currToken == JsonToken.NOT_AVAILABLE) {\n                    return _finishTokenWithEOF();\n                }\n                return _eofAsNextToken();\n            }\n            return JsonToken.NOT_AVAILABLE;\n        }\n        // in the middle of tokenization?\n        if (_currToken == JsonToken.NOT_AVAILABLE) {\n            return _finishToken();\n        }\n\n        // No: fresh new token; may or may not have existing one\n        _numTypesValid = NR_UNKNOWN;\n        _tokenInputTotal = _currInputProcessed + _inputPtr;\n        // also: clear any data retained so far\n        _binaryValue = null;\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n\n        switch (_majorState) {\n        case MAJOR_INITIAL:\n            return _startDocument(ch);\n\n        case MAJOR_ROOT:\n            return _startValue(ch);\n\n        case MAJOR_OBJECT_FIELD_FIRST: // expect field-name or end-object\n            return _startFieldName(ch);\n        case MAJOR_OBJECT_FIELD_NEXT: // expect comma + field-name or end-object\n            return _startFieldNameAfterComma(ch);\n\n        case MAJOR_OBJECT_VALUE: // expect colon, followed by value\n            return _startValueExpectColon(ch);\n\n        case MAJOR_ARRAY_ELEMENT_FIRST: // expect value or end-array\n            return _startValue(ch);\n\n        case MAJOR_ARRAY_ELEMENT_NEXT: // expect leading comma + value or end-array\n            return _startValueExpectComma(ch);\n\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method called when decoding of a token has been started, but not yet completed due\n     * to missing input; method is to continue decoding due to at least one more byte\n     * being made available to decode.\n     */\n    protected final JsonToken _finishToken() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        switch (_minorState) {\n        case MINOR_ROOT_BOM:\n            return _finishBOM(_pending32);\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n\n        // Field name states\n        case MINOR_FIELD_NAME:\n            return _parseEscapedName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_NAME_ESCAPE:\n            return _finishFieldWithEscape();\n        case MINOR_FIELD_APOS_NAME:\n            return _finishAposName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_UNQUOTED_NAME:\n            return _finishUnquotedName(_quadLength,  _pending32, _pendingBytes);\n\n        // Value states\n\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(_inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordToken(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordToken(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordToken(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdToken(_nonStdTokenType, _pending32);\n\n        case MINOR_NUMBER_MINUS:\n            return _finishNumberMinus(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_ZERO:\n            return _finishNumberLeadingZeroes();\n        case MINOR_NUMBER_MINUSZERO:\n            return _finishNumberLeadingNegZeroes();\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            return _finishNumberIntegralPart(_textBuffer.getBufferWithoutReset(),\n                    _textBuffer.getCurrentSegmentSize());\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            return _finishFloatFraction();\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _finishFloatExponent(false, _inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_STRING:\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_2:\n            _textBuffer.append((char) _decodeUTF8_2(_pending32, _inputBuffer[_inputPtr++]));\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_3:\n            if (!_decodeSplitUTF8_3(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_4:\n            if (!_decodeSplitUTF8_4(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_STRING_ESCAPE:\n            {\n                int c = _decodeSplitEscaped(_quoted32, _quotedDigits);\n                if (c < 0) {\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                _textBuffer.append((char) c);\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_APOS_STRING:\n            return _finishAposString();\n\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorToken();\n\n        // Comments\n            \n        case MINOR_COMMENT_LEADING_SLASH:\n            return _startSlashComment(_pending32);\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n            return _finishCComment(_pending32, true);\n        case MINOR_COMMENT_C:\n            return _finishCComment(_pending32, false);\n        case MINOR_COMMENT_CPP:\n            return _finishCppComment(_pending32);\n        case MINOR_COMMENT_YAML:\n            return _finishHashComment(_pending32);\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method similar to {@link #_finishToken}, but called when no more input is\n     * available, and end-of-input has been detected. This is usually problem\n     * case, but not always: root-level values may be properly terminated by\n     * this, and similarly trailing white-space may have been skipped.\n     */\n    protected final JsonToken _finishTokenWithEOF() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        JsonToken t = _currToken;\n        switch (_minorState) {\n        case MINOR_ROOT_GOT_SEPARATOR: // fine, just skip some trailing space\n            return _eofAsNextToken();\n        case MINOR_VALUE_LEADING_WS: // finished at token boundary; probably fine\n            return _eofAsNextToken();\n//        case MINOR_VALUE_EXPECTING_COMMA: // not fine\n//        case MINOR_VALUE_EXPECTING_COLON: // not fine\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordTokenWithEOF(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordTokenWithEOF(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordTokenWithEOF(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdTokenWithEOF(_nonStdTokenType, _pending32);\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorTokenWithEOF();\n\n        // Number-parsing states; valid stopping points, more explicit errors\n        case MINOR_NUMBER_ZERO:\n        case MINOR_NUMBER_MINUSZERO:\n            // NOTE: does NOT retain possible leading minus-sign (can change if\n            // absolutely needs be)\n            return _valueCompleteInt(0, \"0\");\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            // Fine: just need to ensure we have value fully defined\n            {\n                int len = _textBuffer.getCurrentSegmentSize();\n                if (_numberNegative) {\n                    --len;\n                }\n                _intLength = len;\n            }\n            return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            _expLength = 0;\n            // fall through\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            _reportInvalidEOF(\": was expecting fraction after exponent marker\", JsonToken.VALUE_NUMBER_FLOAT);\n\n            // How about comments? \n            // Inside C-comments; not legal\n\n//        case MINOR_COMMENT_LEADING_SLASH: // not legal, but use default error\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n        case MINOR_COMMENT_C:\n            _reportInvalidEOF(\": was expecting closing '*/' for comment\", JsonToken.NOT_AVAILABLE);\n\n        case MINOR_COMMENT_CPP:\n        case MINOR_COMMENT_YAML:\n            // within C++/YAML comments, ok, as long as major state agrees...\n            return _eofAsNextToken();\n            \n        default:\n        }\n        _reportInvalidEOF(\": was expecting rest of token (internal state: \"+_minorState+\")\", _currToken);\n        return t; // never gets here\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, root level\n    /**********************************************************************\n     */\n\n    private final JsonToken _startDocument(int ch) throws IOException\n    {\n        ch &= 0xFF;\n\n        // Very first byte: could be BOM\n        if ((ch == 0xEF) && (_minorState != MINOR_ROOT_BOM)) {\n            return _finishBOM(1);\n        }\n\n        // If not BOM (or we got past it), could be whitespace or comment to skip\n        while (ch <= 0x020) {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_ROOT_GOT_SEPARATOR;\n                if (_closed) {\n                    return null;\n                }\n                // note: if so, do not even bother changing state\n                if (_endOfInput) { // except for this special case\n                    return _eofAsNextToken();\n                }\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        return _startValue(ch);\n    }\n\n    private final JsonToken _finishBOM(int bytesHandled) throws IOException\n    {\n        // public final static byte UTF8_BOM_1 = (byte) 0xEF;\n        // public final static byte UTF8_BOM_2 = (byte) 0xBB;\n        // public final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n        while (_inputPtr < _inputEnd) {\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (bytesHandled) {\n            case 3:\n                // got it all; go back to \"start document\" handling, without changing\n                // minor state (to let it know we've done BOM)\n                _currInputProcessed -= 3;\n                return _startDocument(ch);\n            case 2:\n                if (ch != 0xBF) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF 0xBB; should get 0xBF as third byte of UTF-8 BOM\", ch);\n                }\n                break;\n            case 1:\n                if (ch != 0xBB) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF; should get 0xBB as second byte UTF-8 BOM\", ch);\n                }\n                break;\n            }\n            ++bytesHandled;\n        }\n        _pending32 = bytesHandled;\n        _minorState = MINOR_ROOT_BOM;\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, primary field name decoding\n    /**********************************************************************\n     */\n\n    /**\n     * Method that handles initial token type recognition for token\n     * that has to be either FIELD_NAME or END_OBJECT.\n     */\n    private final JsonToken _startFieldName(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    private final JsonToken _startFieldNameAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) { // either comma, separating entries, or closing right curly\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_FIELD_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                    return _closeObjectScope();\n                }\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, value decoding\n    /**********************************************************************\n     */\n    \n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value may be preceded by leading white-space, but no separator (comma).\n     */\n    private final JsonToken _startValue(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/': // c/c++ comments\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n            \n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            return _closeArrayScope();\n        case '{':\n            return _startObjectScope();\n        case '}':\n            return _closeObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /**\n     * Helper method called to parse token that is either a value token in array\n     * or end-array marker\n     */\n    private final JsonToken _startValueExpectComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) {\n            if (ch == INT_RBRACKET) {\n                return _closeArrayScope();\n            }\n            if (ch == INT_RCURLY){\n                return _closeObjectScope();\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value MUST be preceded by a semi-colon (which may be surrounded by white-space)\n     */\n    private final JsonToken _startValueExpectColon(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COLON;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COLON) {\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            // can not omit colon here\n            _reportUnexpectedChar(ch, \"was expecting a colon to separate field name and value\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case '{':\n            return _startObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /* Method called when we have already gotten a comma (i.e. not the first value)\n     */\n    private final JsonToken _startValueAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException\n    {\n        switch (ch) {\n        case ']':\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n            //   we may allow \"missing values\", that is, encountering a trailing\n            //   comma or closing marker where value would be expected\n            if ((_features & FEAT_MASK_ALLOW_MISSING) != 0) {\n                --_inputPtr;\n                return _valueComplete(JsonToken.VALUE_NULL);\n            }\n            // fall through\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }\n        // !!! TODO: maybe try to collect more information for better diagnostics\n        _reportUnexpectedChar(ch, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, skipping white-space, comments\n    /**********************************************************************\n     */\n    \n    private final int _skipWS(int ch) throws IOException\n    {\n        do {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _currToken = JsonToken.NOT_AVAILABLE;\n                return 0;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        } while (ch <= 0x0020);\n        return ch;\n    }\n\n    private final JsonToken _startSlashComment(int fromMinorState) throws IOException\n    {\n        if ((_features & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n\n        // After that, need to verify if we have c/c++ comment\n        if (_inputPtr >= _inputEnd) {\n            _pending32 = fromMinorState;\n            _minorState = MINOR_COMMENT_LEADING_SLASH;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++];\n        if (ch == INT_ASTERISK) { // c-style\n            return _finishCComment(fromMinorState, false);\n        }\n        if (ch == INT_SLASH) { // c++-style\n            return _finishCppComment(fromMinorState);\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"was expecting either '*' or '/' for a comment\");\n        return null;\n    }\n\n    private final JsonToken _finishHashComment(int fromMinorState) throws IOException\n    {\n        // Could by-pass this check by refactoring, but for now simplest way...\n        if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {\n            _reportUnexpectedChar('#', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_YAML_COMMENTS' not enabled for parser)\");\n        }\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_YAML;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCppComment(int fromMinorState) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_CPP;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCComment(int fromMinorState, boolean gotStar) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = gotStar ? MINOR_COMMENT_CLOSING_ASTERISK : MINOR_COMMENT_C;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            } else if (ch == INT_ASTERISK) {\n                gotStar = true;\n                continue;\n            } else if (ch == INT_SLASH) {\n                if (gotStar) {\n                    break;\n                }\n            }\n            gotStar = false;\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _startAfterComment(int fromMinorState) throws IOException\n    {\n        // Ok, then, need one more character...\n        if (_inputPtr >= _inputEnd) {\n            _minorState = fromMinorState;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        switch (fromMinorState) {\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(ch);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(ch);\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(ch);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(ch);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(ch);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(ch);\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Tertiary decoding, simple tokens\n    /**********************************************************************\n     */\n\n    protected JsonToken _startFalseToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'a') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 's')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_FALSE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_FALSE;\n        return _finishKeywordToken(\"false\", 1, JsonToken.VALUE_FALSE);\n    }\n\n    protected JsonToken _startTrueToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'r') \n                   && (buf[ptr++] == 'u')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_TRUE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_TRUE;\n        return _finishKeywordToken(\"true\", 1, JsonToken.VALUE_TRUE);\n    }\n\n    protected JsonToken _startNullToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'u') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 'l')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_NULL);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_NULL;\n        return _finishKeywordToken(\"null\", 1, JsonToken.VALUE_NULL);\n    }\n\n    protected JsonToken _finishKeywordToken(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _pending32 = matched;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueComplete(result);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishKeywordTokenWithEOF(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        if (matched == expToken.length()) {\n            return (_currToken = result);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishNonStdToken(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _nonStdTokenType = type;\n                _pending32 = matched;\n                _minorState = MINOR_VALUE_TOKEN_NON_STD;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueNonStdNumberComplete(type);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishNonStdTokenWithEOF(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        if (matched == expToken.length()) {\n            return _valueNonStdNumberComplete(type);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishErrorToken() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = (int) _inputBuffer[_inputPtr++];\n\n// !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(i);\n\n            char ch = (char) i;\n            if (Character.isJavaIdentifierPart(ch)) {\n                // 11-Jan-2016, tatu: note: we will fully consume the character,\n                // included or not, so if recovery was possible, it'd be off-by-one...\n                _textBuffer.append(ch);\n                if (_textBuffer.size() < MAX_ERROR_TOKEN_LENGTH) {\n                    continue;\n                }\n            }\n            return _reportErrorToken(_textBuffer.contentsAsString());\n        }\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    protected JsonToken _finishErrorTokenWithEOF() throws IOException\n    {\n        return _reportErrorToken(_textBuffer.contentsAsString());\n    }\n\n    protected JsonToken _reportErrorToken(String actualToken) throws IOException\n    {\n        // !!! TODO: Include non-standard ones if enabled\n        _reportError(\"Unrecognized token '%s': was expecting %s\", _textBuffer.contentsAsString(),\n                \"'null', 'true' or 'false'\");\n        return JsonToken.NOT_AVAILABLE; // never gets here\n    }\n    \n    /*\n    /**********************************************************************\n    /* Second-level decoding, Number decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startPositiveNumber(int ch) throws IOException\n    {\n        _numberNegative = false;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = (char) ch;\n        // in unlikely event of not having more input, denote location\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(1);\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        int outPtr = 1;\n\n        ch = _inputBuffer[_inputPtr] & 0xFF;\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNegativeNumber() throws IOException\n    {\n        _numberNegative = true;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_MINUS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            // One special case: if first char is 0, must not be followed by a digit\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(2);\n            _intLength = 1;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[_inputPtr];\n        int outPtr = 2;\n\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand, to ensure contiguous buffer, outPtr is the length\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr-1;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNumberLeadingZero() throws IOException\n    {\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_ZERO;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        // While we could call `_finishNumberLeadingZeroes()`, let's try checking\n        // the very first char after first zero since the most common case is that\n        // there is a separator\n\n        int ch = _inputBuffer[ptr++] & 0xFF;\n        // one early check: leading zeroes may or may not be allowed\n        if (ch < INT_0) {\n            if (ch == INT_PERIOD) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n        } else if (ch > INT_9) {\n            if (ch == INT_e || ch == INT_E) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n            // Ok; unfortunately we have closing bracket/curly that are valid so need\n            // (colon not possible since this is within value, not after key)\n            // \n            if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                reportUnexpectedNumberChar(ch,\n                        \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n            }\n        } else { // leading zero case (zero followed by a digit)\n            // leave inputPtr as is (i.e. \"push back\" digit)\n            return _finishNumberLeadingZeroes();\n        }\n        // leave _inputPtr as-is, to push back byte we checked\n        return _valueCompleteInt(0, \"0\");\n    }\n\n    protected JsonToken _finishNumberMinus(int ch) throws IOException\n    {\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        _intLength = 1;\n        return _finishNumberIntegralPart(outBuf, 2);\n    }\n\n    protected JsonToken _finishNumberLeadingZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_ZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 0 and 9\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 1);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberLeadingNegZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_MINUSZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 1 and 9; go integral\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = '-';\n                outBuf[1] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 2);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws IOException\n    {\n        int negMod = _numberNegative ? -1 : 0;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            ++_inputPtr;\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n        }\n        _intLength = outPtr+negMod;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException\n    {\n        int fractLen = 0;\n        if (ch == INT_PERIOD) {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = '.';\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_FRACTION_DIGITS;\n                    _fractLength = fractLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n                if (ch < INT_0 || ch > INT_9) {\n                    ch &= 0xFF; // but here we'll want to mask it to unsigned 8-bit\n                    // must be followed by sequence of ints, one minimum\n                    if (fractLen == 0) {\n                        reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                    }\n                    break;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                ++fractLen;\n            }\n        }\n        _fractLength = fractLen;\n        int expLen = 0;\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                _expLength = 0;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            while (ch >= INT_0 && ch <= INT_9) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = expLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            ch &= 0xFF;\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatFraction() throws IOException\n    {\n        int fractLen = _fractLength;\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        // caller guarantees at least one char; also, sign-extension not needed here\n        int ch;\n        while (((ch = _inputBuffer[_inputPtr++]) >= INT_0) && (ch <= INT_9)) {\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _fractLength = fractLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n        }\n        \n        // Ok, fraction done; what have we got next?\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n        }\n        _fractLength = fractLen;\n        _textBuffer.setCurrentLength(outPtr);\n\n        // Ok: end of floating point number or exponent?\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            _textBuffer.append((char) ch);\n            _expLength = 0;\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = 0;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws IOException\n    {\n        if (checkSign) {\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                _textBuffer.append((char) ch);\n                if (_inputPtr >= _inputEnd) {\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n        }\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int expLen = _expLength;\n\n        while (ch >= INT_0 && ch <= INT_9) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _expLength = expLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        ch &= 0xFF;\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    /*\n    /**********************************************************************\n    /* Name-decoding, tertiary decoding\n    /**********************************************************************\n     */\n\n    private final String _fastParseName() throws IOException\n    {\n        // If so, can also unroll loops nicely\n        // This may seem weird, but here we do NOT want to worry about UTF-8\n        // decoding. Rather, we'll assume that part is ok (if not it will be\n        // caught later on), and just handle quotes and backslashes here.\n\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int ptr = _inputPtr;\n\n        int q0 = input[ptr++] & 0xFF;\n        if (codes[q0] == 0) {\n            int i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                int q = (q0 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[ptr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return _parseMediumName(ptr, i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            _inputPtr = ptr;\n                            return _findName(q, 4);\n                        }\n                        return null;\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        _inputPtr = ptr;\n                        return _findName(q, 3);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    _inputPtr = ptr;\n                    return _findName(q, 2);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                _inputPtr = ptr;\n                return _findName(q0, 1);\n            }\n            return null;\n        }\n        if (q0 == INT_QUOTE) {\n            _inputPtr = ptr;\n            return \"\";\n        }\n        return null;\n    }\n\n    private final String _parseMediumName(int ptr, int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] == 0) {\n            q2 = (q2 << 8) | i;\n            i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                q2 = (q2 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q2 = (q2 << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        return _parseMediumName2(ptr, i, q2);\n                    }\n                    if (i == INT_QUOTE) { // 8 bytes\n                        _inputPtr = ptr;\n                        return _findName(_quad1, q2, 4);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 7 bytes\n                    _inputPtr = ptr;\n                    return _findName(_quad1, q2, 3);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // 6 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, 2);\n            }\n            return null;\n        }\n        if (i == INT_QUOTE) { // 5 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, 1);\n        }\n        return null;\n    }\n\n    private final String _parseMediumName2(int ptr, int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 1);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 2);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 3);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (i == INT_QUOTE) { // 12 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, q3, 4);\n        }\n        // Could continue\n        return null;\n    }\n\n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hence is offlined to a separate method.\n     */\n    private final JsonToken _parseEscapedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        // This may seem weird, but here we do not want to worry about\n        // UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n        // caught later on), and just handle quotes and backslashes here.\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[ch] == 0) {\n                if (currQuadBytes < 4) {\n                    ++currQuadBytes;\n                    currQuad = (currQuad << 8) | ch;\n                    continue;\n                }\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n                continue;\n            }\n\n            // Otherwise bit longer handling\n            if (ch == INT_QUOTE) { // we are done\n                break;\n            }\n            // Unquoted white space?\n            if (ch != INT_BACKSLASH) {\n                // Call can actually now return (if unquoted linefeeds allowed)\n                _throwUnquotedSpace(ch, \"name\");\n            } else {\n                // Nope, escape sequence\n                ch = _decodeCharEscape();\n                if (ch < 0) { // method has set up state about escape sequence\n                    _minorState = MINOR_FIELD_NAME_ESCAPE;\n                    _minorStateAfterSplit = MINOR_FIELD_NAME;\n                    _quadLength = qlen;\n                    _pending32 = currQuad;\n                    _pendingBytes = currQuadBytes;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n            }\n\n            // May need to UTF-8 (re-)encode it, if it's beyond\n            // 7-bit ASCII. Gets pretty messy. If this happens often, may\n            // want to use different name canonicalization to avoid these hits.\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            if (ch > 127) {\n                // Ok, we'll need room for first byte right away\n                if (currQuadBytes >= 4) {\n                    quads[qlen++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                if (ch < 0x800) { // 2-byte\n                    currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                    ++currQuadBytes;\n                    // Second byte gets output below:\n                } else { // 3 bytes; no need to worry about surrogates here\n                    currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                    ++currQuadBytes;\n                    // need room for middle byte?\n                    if (currQuadBytes >= 4) {\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                    ++currQuadBytes;\n                }\n                // And same last byte in both cases, gets output below:\n                ch = 0x80 | (ch & 0x3f);\n            }\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n                continue;\n            }\n            quads[qlen++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare, but may happen\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an exception; but\n     * in non-standard modes may be able to parse name.\n     */\n    private JsonToken _handleOddName(int ch) throws IOException\n    {\n        // First: may allow single quotes\n        switch (ch) {\n        case '#':\n            // Careful, since this may alternatively be leading char of\n            // unquoted name...\n            if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) != 0) {\n                return _finishHashComment(MINOR_FIELD_LEADING_WS);\n            }\n            break;\n        case '/':\n            return _startSlashComment(MINOR_FIELD_LEADING_WS);\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _finishAposName(0, 0, 0);\n            }\n            break;\n        case ']': // for better error reporting...\n            return _closeArrayScope();\n        }\n        // allow unquoted names if feature enabled:\n        if ((_features & FEAT_MASK_ALLOW_UNQUOTED_NAMES) == 0) {\n         // !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(ch);\n            char c = (char) ch;\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        // Also: note that although we use a different table here, it does NOT handle UTF-8\n        // decoding. It'll just pass those high-bit codes as acceptable for later decoding.\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        return _finishUnquotedName(0, ch, 1);\n    }\n\n    /**\n     * Parsing of optionally supported non-standard \"unquoted\" names: names without\n     * either double-quotes or apostrophes surrounding them.\n     * Unlike other \n     */\n    private JsonToken _finishUnquotedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n\n        // Ok, now; instead of ultra-optimizing parsing here (as with regular JSON names),\n        // let's just use the generic \"slow\" variant. Can measure its impact later on if need be.\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_UNQUOTED_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    private JsonToken _finishAposName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_APOS_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch == INT_APOS) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeCharEscape();\n                    if (ch < 0) { // method has set up state about escape sequence\n                        _minorState = MINOR_FIELD_NAME_ESCAPE;\n                        _minorStateAfterSplit = MINOR_FIELD_APOS_NAME;\n                        _quadLength = qlen;\n                        _pending32 = currQuad;\n                        _pendingBytes = currQuadBytes;\n                        return (_currToken = JsonToken.NOT_AVAILABLE);\n                    }\n                }\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare case but possible\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    protected final JsonToken _finishFieldWithEscape() throws IOException\n    {\n        // First: try finishing what wasn't yet:\n        int ch = _decodeSplitEscaped(_quoted32, _quotedDigits);\n        if (ch < 0) { // ... if possible\n            _minorState = MINOR_FIELD_NAME_ESCAPE;\n            return JsonToken.NOT_AVAILABLE;\n        }\n        if (_quadLength >= _quadBuffer.length) {\n            _quadBuffer = growArrayBy(_quadBuffer, 32);\n        }\n        int currQuad = _pending32;\n        int currQuadBytes = _pendingBytes;\n        if (ch > 127) {\n            // Ok, we'll need room for first byte right away\n            if (currQuadBytes >= 4) {\n                _quadBuffer[_quadLength++] = currQuad;\n                currQuad = 0;\n                currQuadBytes = 0;\n            }\n            if (ch < 0x800) { // 2-byte\n                currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                ++currQuadBytes;\n                // Second byte gets output below:\n            } else { // 3 bytes; no need to worry about surrogates here\n                currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                // need room for middle byte?\n                if (++currQuadBytes >= 4) {\n                    _quadBuffer[_quadLength++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                ++currQuadBytes;\n            }\n            // And same last byte in both cases, gets output below:\n            ch = 0x80 | (ch & 0x3f);\n        }\n        if (currQuadBytes < 4) {\n            ++currQuadBytes;\n            currQuad = (currQuad << 8) | ch;\n        } else {\n            _quadBuffer[_quadLength++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n        if (_minorStateAfterSplit == MINOR_FIELD_APOS_NAME) {\n            return _finishAposName(_quadLength, currQuad, currQuadBytes);\n        }\n        return _parseEscapedName(_quadLength, currQuad, currQuadBytes);\n    }\n\n    private int _decodeSplitEscaped(int value, int bytesRead) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            _quoted32 = value;\n            _quotedDigits = bytesRead;\n            return -1;\n        }\n        int c = _inputBuffer[_inputPtr++];\n        if (bytesRead == -1) { // expecting first char after backslash\n            switch (c) {\n                // First, ones that are mapped\n            case 'b':\n                return '\\b';\n            case 't':\n                return '\\t';\n            case 'n':\n                return '\\n';\n            case 'f':\n                return '\\f';\n            case 'r':\n                return '\\r';\n    \n                // And these are to be returned as they are\n            case '\"':\n            case '/':\n            case '\\\\':\n                return c;\n    \n            case 'u': // and finally hex-escaped\n                break;\n    \n            default:\n                {\n                 // !!! TODO: Decode UTF-8 characters properly...\n    //              char ch = (char) _decodeCharForError(c);\n                    char ch = (char) c;\n                    return _handleUnrecognizedCharacterEscape(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = 0;\n                _quoted32 = 0;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++];\n            bytesRead = 0;\n        }\n        c &= 0xFF;\n        while (true) {\n            int digit = CharTypes.charToHex(c);\n            if (digit < 0) {\n                _reportUnexpectedChar(c, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n            if (++bytesRead == 4) {\n                return value;\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = bytesRead;\n                _quoted32 = value;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, String decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return _valueComplete(JsonToken.VALUE_STRING);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishRegularString();\n    }\n\n    private final JsonToken _finishRegularString() throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }\n\n    protected JsonToken _startAposString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (c == INT_APOS) {\n                _inputPtr = ptr+1;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n\n            if (codes[c] != 0) {\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishAposString();\n    }\n\n    private final JsonToken _finishAposString() throws IOException\n    {\n        int c;\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_APOS_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if ((codes[c] != 0) && (c != INT_QUOTE)) {\n                        break ascii_loop;\n                    }\n                    if (c == INT_APOS) {\n                        _inputPtr = ptr;\n                        _textBuffer.setCurrentLength(outPtr);\n                        return _valueComplete(JsonToken.VALUE_STRING);\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Escape or multi-byte?\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_APOS_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }\n    \n    private final boolean _decodeSplitMultiByte(int c, int type, boolean gotNext)\n            throws IOException\n    {\n        switch (type) {\n        case 1:\n            c = _decodeSplitEscaped(0, -1);\n            if (c < 0) {\n                _minorState = MINOR_VALUE_STRING_ESCAPE;\n                return false;\n            }\n            _textBuffer.append((char) c);\n            return true;\n        case 2: // 2-byte UTF; easy, either got both, or just miss one\n            if (gotNext) {\n                // NOTE: always succeeds, no need to check\n                c = _decodeUTF8_2(c, _inputBuffer[_inputPtr++]);\n                _textBuffer.append((char) c);\n                return true;\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_2;\n            _pending32 = c;\n            return false;\n        case 3: // 3-byte UTF\n            c &= 0x0F;\n            if (gotNext) {\n                return _decodeSplitUTF8_3(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_3;\n            _pending32 = c;\n            _pendingBytes = 1;\n            return false;\n        case 4: // 4-byte UTF\n            c &= 0x07;\n            if (gotNext) {\n                return _decodeSplitUTF8_4(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _pending32 = c;\n            _pendingBytes = 1;\n            _minorState = MINOR_VALUE_STRING_UTF8_4;\n            return false;\n        default:\n            if (c < INT_SPACE) {\n                // Note: call can now actually return (to allow unquoted linefeeds)\n                _throwUnquotedSpace(c, \"string value\");\n            } else {\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            _textBuffer.append((char) c);\n            return true;\n        }\n    }\n\n    private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_3;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        _textBuffer.append((char) ((prev << 6) | (next & 0x3F)));\n        return true;\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final boolean _decodeSplitUTF8_4(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            prevCount = 2;\n            next = _inputBuffer[_inputPtr++];\n        }\n        if (prevCount == 2) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 3;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        int c = ((prev << 6) | (next & 0x3F)) - 0x10000;\n        // Let's add first part right away:\n        _textBuffer.append((char) (0xD800 | (c >> 10)));\n        c = 0xDC00 | (c & 0x3FF);\n        // And let the other char output down below\n        _textBuffer.append((char) c);\n        return true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeCharEscape() throws IOException\n    {\n        int left = _inputEnd - _inputPtr;\n        if (left < 5) { // offline boundary-checking case:\n            return _decodeSplitEscaped(0, -1);\n        }\n        return _decodeFastCharEscape();\n    }\n\n    private final int _decodeFastCharEscape() throws IOException\n    {\n        int c = (int) _inputBuffer[_inputPtr++];\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            {\n             // !!! TODO: Decode UTF-8 characters properly...\n//              char ch = (char) _decodeCharForError(c);\n                char ch = (char) c;\n                return _handleUnrecognizedCharacterEscape(ch);\n            }\n        }\n\n        int ch = (int) _inputBuffer[_inputPtr++];\n        int digit = CharTypes.charToHex(ch);\n        int result = digit;\n\n        if (digit >= 0) {\n            ch = (int) _inputBuffer[_inputPtr++];\n            digit = CharTypes.charToHex(ch);\n            if (digit >= 0) {\n                result = (result << 4) | digit;\n                ch = (int) _inputBuffer[_inputPtr++];\n                digit = CharTypes.charToHex(ch);\n                if (digit >= 0) {\n                    result = (result << 4) | digit;\n                    ch = (int) _inputBuffer[_inputPtr++];\n                    digit = CharTypes.charToHex(ch);\n                    if (digit >= 0) {\n                        return (result << 4) | digit;\n                    }\n                }\n            }\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"expected a hex-digit for character escape sequence\");\n        return -1;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeUTF8_2(int c, int d) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUTF8_3(int c, int d, int e) throws IOException\n    {\n        c &= 0x0F;\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        return (c << 6) | (e & 0x3F);\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final int _decodeUTF8_4(int c, int d, int e, int f) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (e & 0x3F);\n        if ((f & 0xC0) != 0x080) {\n            _reportInvalidOther(f & 0xFF, _inputPtr);\n        }\n        return ((c << 6) | (f & 0x3F)) - 0x10000;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, other\n    /**********************************************************************\n     */\n}\n"}, "generated_test_class": "Certainly! Below is a set of unit tests for the `feedInput` method of the `NonBlockingJsonParser` class. These tests aim to cover all branches and lines in the method to ensure thorough testing.\n\nFirst, let's set up the necessary imports and class structure for the tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.mockito.Mockito;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.*;\n\npublic class NonBlockingJsonParserTest {\n\n    private NonBlockingJsonParser parser;\n    private byte[] inputBuffer;\n\n    @Rule\n    public ExpectedException exceptionRule = ExpectedException.none();\n\n    @Before\n    public void setUp() {\n        parser = Mockito.spy(new NonBlockingJsonParser());\n        inputBuffer = \"testinput\".getBytes();\n    }\n\n    // Utility method to initialize parser fields for testing\n    private void initializeParserFields(int inputPtr, int inputEnd, int currInputProcessed,\n                                       int currInputRowStart, int currBufferStart, int origBufferLen, boolean endOfInput) {\n        parser._inputPtr = inputPtr;\n        parser._inputEnd = inputEnd;\n        parser._currInputProcessed = currInputProcessed;\n        parser._currInputRowStart = currInputRowStart;\n        parser._currBufferStart = currBufferStart;\n        parser._origBufferLen = origBufferLen;\n        parser._endOfInput = endOfInput;\n    }\n}\n```\n\nNow, let's write the tests:\n\n```java\n@Test\npublic void testFeedInput_WithRemainingInput() throws IOException {\n    // Arrange\n    initializeParserFields(0, 1, 0, 0, 0, 1, false);\n\n    // Act & Assert\n    exceptionRule.expect(IOException.class);\n    exceptionRule.expectMessage(\"Still have 1 undecoded bytes, should not call 'feedInput'\");\n    parser.feedInput(inputBuffer, 0, inputBuffer.length);\n}\n\n@Test\npublic void testFeedInput_WithEndBeforeStart() throws IOException {\n    // Arrange\n    initializeParserFields(0, 0, 0, 0, 0, 0, false);\n\n    // Act & Assert\n    exceptionRule.expect(IOException.class);\n    exceptionRule.expectMessage(\"Input end (-1) may not be before start (0)\");\n    parser.feedInput(inputBuffer, 0, -1);\n}\n\n@Test\npublic void testFeedInput_AlreadyClosed() throws IOException {\n    // Arrange\n    initializeParserFields(0, 0, 0, 0, 0, 0, true);\n\n    // Act & Assert\n    exceptionRule.expect(IOException.class);\n    exceptionRule.expectMessage(\"Already closed, can not feed more input\");\n    parser.feedInput(inputBuffer, 0, inputBuffer.length);\n}\n\n@Test\npublic void testFeedInput_Successful() throws IOException {\n    // Arrange\n    initializeParserFields(0, 0, 0, 0, 0, 0, false);\n    int start = 0;\n    int end = inputBuffer.length;\n\n    // Act\n    parser.feedInput(inputBuffer, start, end);\n\n    // Assert\n    assertEquals(inputBuffer, parser._inputBuffer);\n    assertEquals(start, parser._inputPtr);\n    assertEquals(end, parser._inputEnd);\n    assertEquals(end - start, parser._origBufferLen);\n    assertEquals(end, parser._currInputProcessed);\n    assertEquals(start - (0 - 0), parser._currInputRowStart);\n    assertEquals(start, parser._currBufferStart);\n}\n\n@Test\npublic void testFeedInput_WithInitialProcessedInput() throws IOException {\n    // Arrange\n    initializeParserFields(0, 0, 10, 5, 0, 0, false);\n    int start = 0;\n    int end = inputBuffer.length;\n\n    // Act\n    parser.feedInput(inputBuffer, start, end);\n\n    // Assert\n    assertEquals(inputBuffer, parser._inputBuffer);\n    assertEquals(start, parser._inputPtr);\n    assertEquals(end, parser._inputEnd);\n    assertEquals(end - start, parser._origBufferLen);\n    assertEquals(10 + inputBuffer.length, parser._currInputProcessed);\n    assertEquals(start - (0 - 5), parser._currInputRowStart);\n    assertEquals(start, parser._currBufferStart);\n}\n```\n\n### Explanation:\n1. **testFeedInput_WithRemainingInput**: Tests the scenario where there are remaining bytes in the buffer that haven't been processed yet.\n2. **testFeedInput_WithEndBeforeStart**: Tests the scenario where the `end` index is less than the `start` index, which is an invalid condition.\n3. **testFeedInput_AlreadyClosed**: Tests the scenario where the parser is already marked as end-of-input.\n4. **testFeedInput_Successful**: Tests the successful execution of `feedInput` when all preconditions are met.\n5. **testFeedInput_WithInitialProcessedInput**: Tests the scenario where there is already some processed input, and we feed new input into the parser.\n\nThese tests cover all the branches and lines in the `feedInput` method, ensuring that it behaves as expected under different conditions."}
{"bug_id": "JacksonCore_26", "version": "fixed", "focal_method_signature": "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#releaseBuffered(OutputStream#out)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_26/fixed/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java", "focal_method": "@Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int avail = _inputEnd - _inputPtr;\n        if (avail > 0) {\n            out.write(_inputBuffer, _inputPtr, avail);\n        }\n        return avail;\n    }", "return_type": "int", "assertion_subject_candidates": ["int", "ByteArrayFeeder com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#getNonBlockingInputFeeder()"], "focal_class": {"name": "NonBlockingJsonParser", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_26/fixed/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java", "superclass": "extends NonBlockingJsonParserBase", "interface": "implements ByteArrayFeeder", "imports": ["import java.io.IOException;", "import java.io.OutputStream;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.async.ByteArrayFeeder;", "import com.fasterxml.jackson.core.async.NonBlockingInputFeeder;", "import com.fasterxml.jackson.core.io.CharTypes;", "import com.fasterxml.jackson.core.io.IOContext;", "import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;", "import com.fasterxml.jackson.core.util.VersionUtil;"], "fields": ["@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask()", "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask()", "private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask()", "private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask()", "private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask()", "private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask()", "private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8()", "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "protected byte[] _inputBuffer = NO_BYTES", "protected int _origBufferLen"], "methods": ["ByteArrayFeeder com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#getNonBlockingInputFeeder()", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#needMoreInput()", "void com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#feedInput(byte[]#buf,int#start,int#end)", "void com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#endOfInput()", "char com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeEscaped()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#nextToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishTokenWithEOF()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startDocument(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishBOM(int#bytesHandled)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFieldName(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFieldNameAfterComma(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValue(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValueExpectComma(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValueExpectColon(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValueAfterComma(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startUnexpectedValue(boolean#leadingComma,int#ch)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_skipWS(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startSlashComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishHashComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishCppComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishCComment(int#fromMinorState,boolean#gotStar)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startAfterComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFalseToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startTrueToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startNullToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishKeywordToken(String#expToken,int#matched,JsonToken#result)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishKeywordTokenWithEOF(String#expToken,int#matched,JsonToken#result)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNonStdToken(int#type,int#matched)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNonStdTokenWithEOF(int#type,int#matched)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishErrorToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishErrorTokenWithEOF()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_reportErrorToken(String#actualToken)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startPositiveNumber(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startNegativeNumber()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startNumberLeadingZero()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberMinus(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberLeadingZeroes()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberLeadingNegZeroes()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberIntegralPart(char[]#outBuf,int#outPtr)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFloat(char[]#outBuf,int#outPtr,int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishFloatFraction()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishFloatExponent(boolean#checkSign,int#ch)", "String com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_fastParseName()", "String com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_parseMediumName(int#ptr,int#q2)", "String com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_parseMediumName2(int#ptr,int#q3,int#q2)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_parseEscapedName(int#qlen,int#currQuad,int#currQuadBytes)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_handleOddName(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishUnquotedName(int#qlen,int#currQuad,int#currQuadBytes)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishAposName(int#qlen,int#currQuad,int#currQuadBytes)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishFieldWithEscape()", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitEscaped(int#value,int#bytesRead)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startString()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishRegularString()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startAposString()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishAposString()", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitMultiByte(int#c,int#type,boolean#gotNext)", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitUTF8_3(int#prev,int#prevCount,int#next)", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitUTF8_4(int#prev,int#prevCount,int#next)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeCharEscape()", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeFastCharEscape()", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeUTF8_2(int#c,int#d)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeUTF8_3(int#c,int#d,int#e)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeUTF8_4(int#c,int#d,int#e,int#f)"], "other_methods": ["@Override\n    public ByteArrayFeeder getNonBlockingInputFeeder();", "@Override\n    public final boolean needMoreInput();", "@Override\n    public void feedInput(byte[] buf,int start,int end);", "@Override\n    public void endOfInput();", "@Override\n    public JsonToken nextToken();"], "fields_dict": {"int#FEAT_MASK_TRAILING_COMMA": "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "int#FEAT_MASK_LEADING_ZEROS": "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask()", "int#FEAT_MASK_ALLOW_MISSING": "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask()", "int#FEAT_MASK_ALLOW_SINGLE_QUOTES": "private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask()", "int#FEAT_MASK_ALLOW_UNQUOTED_NAMES": "private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask()", "int#FEAT_MASK_ALLOW_JAVA_COMMENTS": "private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask()", "int#FEAT_MASK_ALLOW_YAML_COMMENTS": "private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask()", "int[]#_icUTF8": "private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8()", "int[]#_icLatin1": "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "byte[]#_inputBuffer": "protected byte[] _inputBuffer = NO_BYTES", "int#_origBufferLen": "protected int _origBufferLen"}, "text": "package com.fasterxml.jackson.core.json.async;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.async.ByteArrayFeeder;\nimport com.fasterxml.jackson.core.async.NonBlockingInputFeeder;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\npublic class NonBlockingJsonParser\n    extends NonBlockingJsonParserBase\n    implements ByteArrayFeeder\n{\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask();\n    private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask();\n    private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask();\n    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask();\n    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask();\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************************\n    /* Input source config\n    /**********************************************************************\n     */\n\n    /**\n     * This buffer is actually provided via {@link NonBlockingInputFeeder}\n     */\n    protected byte[] _inputBuffer = NO_BYTES;\n\n    /**\n     * In addition to current buffer pointer, and end pointer,\n     * we will also need to know number of bytes originally\n     * contained. This is needed to correctly update location\n     * information when the block has been completed.\n     */\n    protected int _origBufferLen;\n\n    // And from ParserBase:\n//  protected int _inputPtr;\n//  protected int _inputEnd;\n\n    /*\n    /**********************************************************************\n    /* Life-cycle\n    /**********************************************************************\n     */\n\n    public NonBlockingJsonParser(IOContext ctxt, int parserFeatures,\n            ByteQuadsCanonicalizer sym)\n    {\n        super(ctxt, parserFeatures, sym);\n    }\n\n    /*\n    /**********************************************************************\n    /* AsyncInputFeeder impl\n    /**********************************************************************\n     */\n\n    @Override\n    public ByteArrayFeeder getNonBlockingInputFeeder() {\n        return this;\n    }\n\n    @Override\n    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _currBufferStart = start;\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n\n    @Override\n    public void endOfInput() {\n        _endOfInput = true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Abstract methods/overrides from JsonParser\n    /**********************************************************************\n     */\n\n    /* Implementing these methods efficiently for non-blocking cases would\n     * be complicated; so for now let's just use the default non-optimized\n     * implementation\n     */\n\n//    public boolean nextFieldName(SerializableString str) throws IOException\n//    public String nextTextValue() throws IOException\n//    public int nextIntValue(int defaultValue) throws IOException\n//    public long nextLongValue(long defaultValue) throws IOException\n//    public Boolean nextBooleanValue() throws IOException\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int avail = _inputEnd - _inputPtr;\n        if (avail > 0) {\n            out.write(_inputBuffer, _inputPtr, avail);\n        }\n        return avail;\n    }\n\n    // Should never be called: can not be implemented quite as expected\n    // due to non-blocking behavior\n    @Override\n    protected char _decodeEscaped() throws IOException {\n        VersionUtil.throwInternal();\n        return ' ';\n    }\n\n    /*\n    /**********************************************************************\n    /* Main-level decoding\n    /**********************************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // First: regardless of where we really are, need at least one more byte;\n        // can simplify some of the checks by short-circuiting right away\n        if (_inputPtr >= _inputEnd) {\n            if (_closed) {\n                return null;\n            }\n            // note: if so, do not even bother changing state\n            if (_endOfInput) { // except for this special case\n                // End-of-input within (possibly...) started token is bit complicated,\n                // so offline\n                if (_currToken == JsonToken.NOT_AVAILABLE) {\n                    return _finishTokenWithEOF();\n                }\n                return _eofAsNextToken();\n            }\n            return JsonToken.NOT_AVAILABLE;\n        }\n        // in the middle of tokenization?\n        if (_currToken == JsonToken.NOT_AVAILABLE) {\n            return _finishToken();\n        }\n\n        // No: fresh new token; may or may not have existing one\n        _numTypesValid = NR_UNKNOWN;\n        _tokenInputTotal = _currInputProcessed + _inputPtr;\n        // also: clear any data retained so far\n        _binaryValue = null;\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n\n        switch (_majorState) {\n        case MAJOR_INITIAL:\n            return _startDocument(ch);\n\n        case MAJOR_ROOT:\n            return _startValue(ch);\n\n        case MAJOR_OBJECT_FIELD_FIRST: // expect field-name or end-object\n            return _startFieldName(ch);\n        case MAJOR_OBJECT_FIELD_NEXT: // expect comma + field-name or end-object\n            return _startFieldNameAfterComma(ch);\n\n        case MAJOR_OBJECT_VALUE: // expect colon, followed by value\n            return _startValueExpectColon(ch);\n\n        case MAJOR_ARRAY_ELEMENT_FIRST: // expect value or end-array\n            return _startValue(ch);\n\n        case MAJOR_ARRAY_ELEMENT_NEXT: // expect leading comma + value or end-array\n            return _startValueExpectComma(ch);\n\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method called when decoding of a token has been started, but not yet completed due\n     * to missing input; method is to continue decoding due to at least one more byte\n     * being made available to decode.\n     */\n    protected final JsonToken _finishToken() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        switch (_minorState) {\n        case MINOR_ROOT_BOM:\n            return _finishBOM(_pending32);\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n\n        // Field name states\n        case MINOR_FIELD_NAME:\n            return _parseEscapedName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_NAME_ESCAPE:\n            return _finishFieldWithEscape();\n        case MINOR_FIELD_APOS_NAME:\n            return _finishAposName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_UNQUOTED_NAME:\n            return _finishUnquotedName(_quadLength,  _pending32, _pendingBytes);\n\n        // Value states\n\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(_inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordToken(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordToken(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordToken(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdToken(_nonStdTokenType, _pending32);\n\n        case MINOR_NUMBER_MINUS:\n            return _finishNumberMinus(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_ZERO:\n            return _finishNumberLeadingZeroes();\n        case MINOR_NUMBER_MINUSZERO:\n            return _finishNumberLeadingNegZeroes();\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            return _finishNumberIntegralPart(_textBuffer.getBufferWithoutReset(),\n                    _textBuffer.getCurrentSegmentSize());\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            return _finishFloatFraction();\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _finishFloatExponent(false, _inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_STRING:\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_2:\n            _textBuffer.append((char) _decodeUTF8_2(_pending32, _inputBuffer[_inputPtr++]));\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_3:\n            if (!_decodeSplitUTF8_3(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_4:\n            if (!_decodeSplitUTF8_4(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_STRING_ESCAPE:\n            {\n                int c = _decodeSplitEscaped(_quoted32, _quotedDigits);\n                if (c < 0) {\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                _textBuffer.append((char) c);\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_APOS_STRING:\n            return _finishAposString();\n\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorToken();\n\n        // Comments\n            \n        case MINOR_COMMENT_LEADING_SLASH:\n            return _startSlashComment(_pending32);\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n            return _finishCComment(_pending32, true);\n        case MINOR_COMMENT_C:\n            return _finishCComment(_pending32, false);\n        case MINOR_COMMENT_CPP:\n            return _finishCppComment(_pending32);\n        case MINOR_COMMENT_YAML:\n            return _finishHashComment(_pending32);\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method similar to {@link #_finishToken}, but called when no more input is\n     * available, and end-of-input has been detected. This is usually problem\n     * case, but not always: root-level values may be properly terminated by\n     * this, and similarly trailing white-space may have been skipped.\n     */\n    protected final JsonToken _finishTokenWithEOF() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        JsonToken t = _currToken;\n        switch (_minorState) {\n        case MINOR_ROOT_GOT_SEPARATOR: // fine, just skip some trailing space\n            return _eofAsNextToken();\n        case MINOR_VALUE_LEADING_WS: // finished at token boundary; probably fine\n            return _eofAsNextToken();\n//        case MINOR_VALUE_EXPECTING_COMMA: // not fine\n//        case MINOR_VALUE_EXPECTING_COLON: // not fine\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordTokenWithEOF(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordTokenWithEOF(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordTokenWithEOF(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdTokenWithEOF(_nonStdTokenType, _pending32);\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorTokenWithEOF();\n\n        // Number-parsing states; valid stopping points, more explicit errors\n        case MINOR_NUMBER_ZERO:\n        case MINOR_NUMBER_MINUSZERO:\n            // NOTE: does NOT retain possible leading minus-sign (can change if\n            // absolutely needs be)\n            return _valueCompleteInt(0, \"0\");\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            // Fine: just need to ensure we have value fully defined\n            {\n                int len = _textBuffer.getCurrentSegmentSize();\n                if (_numberNegative) {\n                    --len;\n                }\n                _intLength = len;\n            }\n            return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            _expLength = 0;\n            // fall through\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            _reportInvalidEOF(\": was expecting fraction after exponent marker\", JsonToken.VALUE_NUMBER_FLOAT);\n\n            // How about comments? \n            // Inside C-comments; not legal\n\n//        case MINOR_COMMENT_LEADING_SLASH: // not legal, but use default error\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n        case MINOR_COMMENT_C:\n            _reportInvalidEOF(\": was expecting closing '*/' for comment\", JsonToken.NOT_AVAILABLE);\n\n        case MINOR_COMMENT_CPP:\n        case MINOR_COMMENT_YAML:\n            // within C++/YAML comments, ok, as long as major state agrees...\n            return _eofAsNextToken();\n            \n        default:\n        }\n        _reportInvalidEOF(\": was expecting rest of token (internal state: \"+_minorState+\")\", _currToken);\n        return t; // never gets here\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, root level\n    /**********************************************************************\n     */\n\n    private final JsonToken _startDocument(int ch) throws IOException\n    {\n        ch &= 0xFF;\n\n        // Very first byte: could be BOM\n        if ((ch == 0xEF) && (_minorState != MINOR_ROOT_BOM)) {\n            return _finishBOM(1);\n        }\n\n        // If not BOM (or we got past it), could be whitespace or comment to skip\n        while (ch <= 0x020) {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_ROOT_GOT_SEPARATOR;\n                if (_closed) {\n                    return null;\n                }\n                // note: if so, do not even bother changing state\n                if (_endOfInput) { // except for this special case\n                    return _eofAsNextToken();\n                }\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        return _startValue(ch);\n    }\n\n    private final JsonToken _finishBOM(int bytesHandled) throws IOException\n    {\n        // public final static byte UTF8_BOM_1 = (byte) 0xEF;\n        // public final static byte UTF8_BOM_2 = (byte) 0xBB;\n        // public final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n        while (_inputPtr < _inputEnd) {\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (bytesHandled) {\n            case 3:\n                // got it all; go back to \"start document\" handling, without changing\n                // minor state (to let it know we've done BOM)\n                _currInputProcessed -= 3;\n                return _startDocument(ch);\n            case 2:\n                if (ch != 0xBF) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF 0xBB; should get 0xBF as third byte of UTF-8 BOM\", ch);\n                }\n                break;\n            case 1:\n                if (ch != 0xBB) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF; should get 0xBB as second byte UTF-8 BOM\", ch);\n                }\n                break;\n            }\n            ++bytesHandled;\n        }\n        _pending32 = bytesHandled;\n        _minorState = MINOR_ROOT_BOM;\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, primary field name decoding\n    /**********************************************************************\n     */\n\n    /**\n     * Method that handles initial token type recognition for token\n     * that has to be either FIELD_NAME or END_OBJECT.\n     */\n    private final JsonToken _startFieldName(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    private final JsonToken _startFieldNameAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) { // either comma, separating entries, or closing right curly\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_FIELD_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                    return _closeObjectScope();\n                }\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, value decoding\n    /**********************************************************************\n     */\n    \n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value may be preceded by leading white-space, but no separator (comma).\n     */\n    private final JsonToken _startValue(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/': // c/c++ comments\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n            \n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            return _closeArrayScope();\n        case '{':\n            return _startObjectScope();\n        case '}':\n            return _closeObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /**\n     * Helper method called to parse token that is either a value token in array\n     * or end-array marker\n     */\n    private final JsonToken _startValueExpectComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) {\n            if (ch == INT_RBRACKET) {\n                return _closeArrayScope();\n            }\n            if (ch == INT_RCURLY){\n                return _closeObjectScope();\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value MUST be preceded by a semi-colon (which may be surrounded by white-space)\n     */\n    private final JsonToken _startValueExpectColon(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COLON;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COLON) {\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            // can not omit colon here\n            _reportUnexpectedChar(ch, \"was expecting a colon to separate field name and value\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case '{':\n            return _startObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /* Method called when we have already gotten a comma (i.e. not the first value)\n     */\n    private final JsonToken _startValueAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException\n    {\n        switch (ch) {\n        case ']':\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n            //   we may allow \"missing values\", that is, encountering a trailing\n            //   comma or closing marker where value would be expected\n            if ((_features & FEAT_MASK_ALLOW_MISSING) != 0) {\n                --_inputPtr;\n                return _valueComplete(JsonToken.VALUE_NULL);\n            }\n            // fall through\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }\n        // !!! TODO: maybe try to collect more information for better diagnostics\n        _reportUnexpectedChar(ch, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, skipping white-space, comments\n    /**********************************************************************\n     */\n    \n    private final int _skipWS(int ch) throws IOException\n    {\n        do {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _currToken = JsonToken.NOT_AVAILABLE;\n                return 0;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        } while (ch <= 0x0020);\n        return ch;\n    }\n\n    private final JsonToken _startSlashComment(int fromMinorState) throws IOException\n    {\n        if ((_features & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n\n        // After that, need to verify if we have c/c++ comment\n        if (_inputPtr >= _inputEnd) {\n            _pending32 = fromMinorState;\n            _minorState = MINOR_COMMENT_LEADING_SLASH;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++];\n        if (ch == INT_ASTERISK) { // c-style\n            return _finishCComment(fromMinorState, false);\n        }\n        if (ch == INT_SLASH) { // c++-style\n            return _finishCppComment(fromMinorState);\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"was expecting either '*' or '/' for a comment\");\n        return null;\n    }\n\n    private final JsonToken _finishHashComment(int fromMinorState) throws IOException\n    {\n        // Could by-pass this check by refactoring, but for now simplest way...\n        if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {\n            _reportUnexpectedChar('#', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_YAML_COMMENTS' not enabled for parser)\");\n        }\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_YAML;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCppComment(int fromMinorState) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_CPP;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCComment(int fromMinorState, boolean gotStar) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = gotStar ? MINOR_COMMENT_CLOSING_ASTERISK : MINOR_COMMENT_C;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            } else if (ch == INT_ASTERISK) {\n                gotStar = true;\n                continue;\n            } else if (ch == INT_SLASH) {\n                if (gotStar) {\n                    break;\n                }\n            }\n            gotStar = false;\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _startAfterComment(int fromMinorState) throws IOException\n    {\n        // Ok, then, need one more character...\n        if (_inputPtr >= _inputEnd) {\n            _minorState = fromMinorState;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        switch (fromMinorState) {\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(ch);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(ch);\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(ch);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(ch);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(ch);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(ch);\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Tertiary decoding, simple tokens\n    /**********************************************************************\n     */\n\n    protected JsonToken _startFalseToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'a') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 's')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_FALSE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_FALSE;\n        return _finishKeywordToken(\"false\", 1, JsonToken.VALUE_FALSE);\n    }\n\n    protected JsonToken _startTrueToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'r') \n                   && (buf[ptr++] == 'u')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_TRUE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_TRUE;\n        return _finishKeywordToken(\"true\", 1, JsonToken.VALUE_TRUE);\n    }\n\n    protected JsonToken _startNullToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'u') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 'l')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_NULL);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_NULL;\n        return _finishKeywordToken(\"null\", 1, JsonToken.VALUE_NULL);\n    }\n\n    protected JsonToken _finishKeywordToken(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _pending32 = matched;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueComplete(result);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishKeywordTokenWithEOF(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        if (matched == expToken.length()) {\n            return (_currToken = result);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishNonStdToken(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _nonStdTokenType = type;\n                _pending32 = matched;\n                _minorState = MINOR_VALUE_TOKEN_NON_STD;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueNonStdNumberComplete(type);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishNonStdTokenWithEOF(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        if (matched == expToken.length()) {\n            return _valueNonStdNumberComplete(type);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishErrorToken() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = (int) _inputBuffer[_inputPtr++];\n\n// !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(i);\n\n            char ch = (char) i;\n            if (Character.isJavaIdentifierPart(ch)) {\n                // 11-Jan-2016, tatu: note: we will fully consume the character,\n                // included or not, so if recovery was possible, it'd be off-by-one...\n                _textBuffer.append(ch);\n                if (_textBuffer.size() < MAX_ERROR_TOKEN_LENGTH) {\n                    continue;\n                }\n            }\n            return _reportErrorToken(_textBuffer.contentsAsString());\n        }\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    protected JsonToken _finishErrorTokenWithEOF() throws IOException\n    {\n        return _reportErrorToken(_textBuffer.contentsAsString());\n    }\n\n    protected JsonToken _reportErrorToken(String actualToken) throws IOException\n    {\n        // !!! TODO: Include non-standard ones if enabled\n        _reportError(\"Unrecognized token '%s': was expecting %s\", _textBuffer.contentsAsString(),\n                \"'null', 'true' or 'false'\");\n        return JsonToken.NOT_AVAILABLE; // never gets here\n    }\n    \n    /*\n    /**********************************************************************\n    /* Second-level decoding, Number decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startPositiveNumber(int ch) throws IOException\n    {\n        _numberNegative = false;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = (char) ch;\n        // in unlikely event of not having more input, denote location\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(1);\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        int outPtr = 1;\n\n        ch = _inputBuffer[_inputPtr] & 0xFF;\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNegativeNumber() throws IOException\n    {\n        _numberNegative = true;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_MINUS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            // One special case: if first char is 0, must not be followed by a digit\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(2);\n            _intLength = 1;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[_inputPtr];\n        int outPtr = 2;\n\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand, to ensure contiguous buffer, outPtr is the length\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr-1;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNumberLeadingZero() throws IOException\n    {\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_ZERO;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        // While we could call `_finishNumberLeadingZeroes()`, let's try checking\n        // the very first char after first zero since the most common case is that\n        // there is a separator\n\n        int ch = _inputBuffer[ptr++] & 0xFF;\n        // one early check: leading zeroes may or may not be allowed\n        if (ch < INT_0) {\n            if (ch == INT_PERIOD) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n        } else if (ch > INT_9) {\n            if (ch == INT_e || ch == INT_E) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n            // Ok; unfortunately we have closing bracket/curly that are valid so need\n            // (colon not possible since this is within value, not after key)\n            // \n            if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                reportUnexpectedNumberChar(ch,\n                        \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n            }\n        } else { // leading zero case (zero followed by a digit)\n            // leave inputPtr as is (i.e. \"push back\" digit)\n            return _finishNumberLeadingZeroes();\n        }\n        // leave _inputPtr as-is, to push back byte we checked\n        return _valueCompleteInt(0, \"0\");\n    }\n\n    protected JsonToken _finishNumberMinus(int ch) throws IOException\n    {\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        _intLength = 1;\n        return _finishNumberIntegralPart(outBuf, 2);\n    }\n\n    protected JsonToken _finishNumberLeadingZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_ZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 0 and 9\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 1);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberLeadingNegZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_MINUSZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 1 and 9; go integral\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = '-';\n                outBuf[1] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 2);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws IOException\n    {\n        int negMod = _numberNegative ? -1 : 0;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            ++_inputPtr;\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n        }\n        _intLength = outPtr+negMod;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException\n    {\n        int fractLen = 0;\n        if (ch == INT_PERIOD) {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = '.';\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_FRACTION_DIGITS;\n                    _fractLength = fractLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n                if (ch < INT_0 || ch > INT_9) {\n                    ch &= 0xFF; // but here we'll want to mask it to unsigned 8-bit\n                    // must be followed by sequence of ints, one minimum\n                    if (fractLen == 0) {\n                        reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                    }\n                    break;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                ++fractLen;\n            }\n        }\n        _fractLength = fractLen;\n        int expLen = 0;\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                _expLength = 0;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            while (ch >= INT_0 && ch <= INT_9) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = expLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            ch &= 0xFF;\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatFraction() throws IOException\n    {\n        int fractLen = _fractLength;\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        // caller guarantees at least one char; also, sign-extension not needed here\n        int ch;\n        while (((ch = _inputBuffer[_inputPtr++]) >= INT_0) && (ch <= INT_9)) {\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _fractLength = fractLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n        }\n        \n        // Ok, fraction done; what have we got next?\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n        }\n        _fractLength = fractLen;\n        _textBuffer.setCurrentLength(outPtr);\n\n        // Ok: end of floating point number or exponent?\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            _textBuffer.append((char) ch);\n            _expLength = 0;\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = 0;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws IOException\n    {\n        if (checkSign) {\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                _textBuffer.append((char) ch);\n                if (_inputPtr >= _inputEnd) {\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n        }\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int expLen = _expLength;\n\n        while (ch >= INT_0 && ch <= INT_9) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _expLength = expLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        ch &= 0xFF;\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    /*\n    /**********************************************************************\n    /* Name-decoding, tertiary decoding\n    /**********************************************************************\n     */\n\n    private final String _fastParseName() throws IOException\n    {\n        // If so, can also unroll loops nicely\n        // This may seem weird, but here we do NOT want to worry about UTF-8\n        // decoding. Rather, we'll assume that part is ok (if not it will be\n        // caught later on), and just handle quotes and backslashes here.\n\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int ptr = _inputPtr;\n\n        int q0 = input[ptr++] & 0xFF;\n        if (codes[q0] == 0) {\n            int i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                int q = (q0 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[ptr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return _parseMediumName(ptr, i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            _inputPtr = ptr;\n                            return _findName(q, 4);\n                        }\n                        return null;\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        _inputPtr = ptr;\n                        return _findName(q, 3);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    _inputPtr = ptr;\n                    return _findName(q, 2);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                _inputPtr = ptr;\n                return _findName(q0, 1);\n            }\n            return null;\n        }\n        if (q0 == INT_QUOTE) {\n            _inputPtr = ptr;\n            return \"\";\n        }\n        return null;\n    }\n\n    private final String _parseMediumName(int ptr, int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] == 0) {\n            q2 = (q2 << 8) | i;\n            i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                q2 = (q2 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q2 = (q2 << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        return _parseMediumName2(ptr, i, q2);\n                    }\n                    if (i == INT_QUOTE) { // 8 bytes\n                        _inputPtr = ptr;\n                        return _findName(_quad1, q2, 4);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 7 bytes\n                    _inputPtr = ptr;\n                    return _findName(_quad1, q2, 3);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // 6 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, 2);\n            }\n            return null;\n        }\n        if (i == INT_QUOTE) { // 5 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, 1);\n        }\n        return null;\n    }\n\n    private final String _parseMediumName2(int ptr, int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 1);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 2);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 3);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (i == INT_QUOTE) { // 12 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, q3, 4);\n        }\n        // Could continue\n        return null;\n    }\n\n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hence is offlined to a separate method.\n     */\n    private final JsonToken _parseEscapedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        // This may seem weird, but here we do not want to worry about\n        // UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n        // caught later on), and just handle quotes and backslashes here.\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[ch] == 0) {\n                if (currQuadBytes < 4) {\n                    ++currQuadBytes;\n                    currQuad = (currQuad << 8) | ch;\n                    continue;\n                }\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n                continue;\n            }\n\n            // Otherwise bit longer handling\n            if (ch == INT_QUOTE) { // we are done\n                break;\n            }\n            // Unquoted white space?\n            if (ch != INT_BACKSLASH) {\n                // Call can actually now return (if unquoted linefeeds allowed)\n                _throwUnquotedSpace(ch, \"name\");\n            } else {\n                // Nope, escape sequence\n                ch = _decodeCharEscape();\n                if (ch < 0) { // method has set up state about escape sequence\n                    _minorState = MINOR_FIELD_NAME_ESCAPE;\n                    _minorStateAfterSplit = MINOR_FIELD_NAME;\n                    _quadLength = qlen;\n                    _pending32 = currQuad;\n                    _pendingBytes = currQuadBytes;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n            }\n\n            // May need to UTF-8 (re-)encode it, if it's beyond\n            // 7-bit ASCII. Gets pretty messy. If this happens often, may\n            // want to use different name canonicalization to avoid these hits.\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            if (ch > 127) {\n                // Ok, we'll need room for first byte right away\n                if (currQuadBytes >= 4) {\n                    quads[qlen++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                if (ch < 0x800) { // 2-byte\n                    currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                    ++currQuadBytes;\n                    // Second byte gets output below:\n                } else { // 3 bytes; no need to worry about surrogates here\n                    currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                    ++currQuadBytes;\n                    // need room for middle byte?\n                    if (currQuadBytes >= 4) {\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                    ++currQuadBytes;\n                }\n                // And same last byte in both cases, gets output below:\n                ch = 0x80 | (ch & 0x3f);\n            }\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n                continue;\n            }\n            quads[qlen++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare, but may happen\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an exception; but\n     * in non-standard modes may be able to parse name.\n     */\n    private JsonToken _handleOddName(int ch) throws IOException\n    {\n        // First: may allow single quotes\n        switch (ch) {\n        case '#':\n            // Careful, since this may alternatively be leading char of\n            // unquoted name...\n            if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) != 0) {\n                return _finishHashComment(MINOR_FIELD_LEADING_WS);\n            }\n            break;\n        case '/':\n            return _startSlashComment(MINOR_FIELD_LEADING_WS);\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _finishAposName(0, 0, 0);\n            }\n            break;\n        case ']': // for better error reporting...\n            return _closeArrayScope();\n        }\n        // allow unquoted names if feature enabled:\n        if ((_features & FEAT_MASK_ALLOW_UNQUOTED_NAMES) == 0) {\n         // !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(ch);\n            char c = (char) ch;\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        // Also: note that although we use a different table here, it does NOT handle UTF-8\n        // decoding. It'll just pass those high-bit codes as acceptable for later decoding.\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        return _finishUnquotedName(0, ch, 1);\n    }\n\n    /**\n     * Parsing of optionally supported non-standard \"unquoted\" names: names without\n     * either double-quotes or apostrophes surrounding them.\n     * Unlike other \n     */\n    private JsonToken _finishUnquotedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n\n        // Ok, now; instead of ultra-optimizing parsing here (as with regular JSON names),\n        // let's just use the generic \"slow\" variant. Can measure its impact later on if need be.\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_UNQUOTED_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    private JsonToken _finishAposName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_APOS_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch == INT_APOS) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeCharEscape();\n                    if (ch < 0) { // method has set up state about escape sequence\n                        _minorState = MINOR_FIELD_NAME_ESCAPE;\n                        _minorStateAfterSplit = MINOR_FIELD_APOS_NAME;\n                        _quadLength = qlen;\n                        _pending32 = currQuad;\n                        _pendingBytes = currQuadBytes;\n                        return (_currToken = JsonToken.NOT_AVAILABLE);\n                    }\n                }\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare case but possible\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    protected final JsonToken _finishFieldWithEscape() throws IOException\n    {\n        // First: try finishing what wasn't yet:\n        int ch = _decodeSplitEscaped(_quoted32, _quotedDigits);\n        if (ch < 0) { // ... if possible\n            _minorState = MINOR_FIELD_NAME_ESCAPE;\n            return JsonToken.NOT_AVAILABLE;\n        }\n        if (_quadLength >= _quadBuffer.length) {\n            _quadBuffer = growArrayBy(_quadBuffer, 32);\n        }\n        int currQuad = _pending32;\n        int currQuadBytes = _pendingBytes;\n        if (ch > 127) {\n            // Ok, we'll need room for first byte right away\n            if (currQuadBytes >= 4) {\n                _quadBuffer[_quadLength++] = currQuad;\n                currQuad = 0;\n                currQuadBytes = 0;\n            }\n            if (ch < 0x800) { // 2-byte\n                currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                ++currQuadBytes;\n                // Second byte gets output below:\n            } else { // 3 bytes; no need to worry about surrogates here\n                currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                // need room for middle byte?\n                if (++currQuadBytes >= 4) {\n                    _quadBuffer[_quadLength++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                ++currQuadBytes;\n            }\n            // And same last byte in both cases, gets output below:\n            ch = 0x80 | (ch & 0x3f);\n        }\n        if (currQuadBytes < 4) {\n            ++currQuadBytes;\n            currQuad = (currQuad << 8) | ch;\n        } else {\n            _quadBuffer[_quadLength++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n        if (_minorStateAfterSplit == MINOR_FIELD_APOS_NAME) {\n            return _finishAposName(_quadLength, currQuad, currQuadBytes);\n        }\n        return _parseEscapedName(_quadLength, currQuad, currQuadBytes);\n    }\n\n    private int _decodeSplitEscaped(int value, int bytesRead) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            _quoted32 = value;\n            _quotedDigits = bytesRead;\n            return -1;\n        }\n        int c = _inputBuffer[_inputPtr++];\n        if (bytesRead == -1) { // expecting first char after backslash\n            switch (c) {\n                // First, ones that are mapped\n            case 'b':\n                return '\\b';\n            case 't':\n                return '\\t';\n            case 'n':\n                return '\\n';\n            case 'f':\n                return '\\f';\n            case 'r':\n                return '\\r';\n    \n                // And these are to be returned as they are\n            case '\"':\n            case '/':\n            case '\\\\':\n                return c;\n    \n            case 'u': // and finally hex-escaped\n                break;\n    \n            default:\n                {\n                 // !!! TODO: Decode UTF-8 characters properly...\n    //              char ch = (char) _decodeCharForError(c);\n                    char ch = (char) c;\n                    return _handleUnrecognizedCharacterEscape(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = 0;\n                _quoted32 = 0;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++];\n            bytesRead = 0;\n        }\n        c &= 0xFF;\n        while (true) {\n            int digit = CharTypes.charToHex(c);\n            if (digit < 0) {\n                _reportUnexpectedChar(c, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n            if (++bytesRead == 4) {\n                return value;\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = bytesRead;\n                _quoted32 = value;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, String decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return _valueComplete(JsonToken.VALUE_STRING);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishRegularString();\n    }\n\n    private final JsonToken _finishRegularString() throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }\n\n    protected JsonToken _startAposString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (c == INT_APOS) {\n                _inputPtr = ptr+1;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n\n            if (codes[c] != 0) {\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishAposString();\n    }\n\n    private final JsonToken _finishAposString() throws IOException\n    {\n        int c;\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_APOS_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if ((codes[c] != 0) && (c != INT_QUOTE)) {\n                        break ascii_loop;\n                    }\n                    if (c == INT_APOS) {\n                        _inputPtr = ptr;\n                        _textBuffer.setCurrentLength(outPtr);\n                        return _valueComplete(JsonToken.VALUE_STRING);\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Escape or multi-byte?\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_APOS_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }\n    \n    private final boolean _decodeSplitMultiByte(int c, int type, boolean gotNext)\n            throws IOException\n    {\n        switch (type) {\n        case 1:\n            c = _decodeSplitEscaped(0, -1);\n            if (c < 0) {\n                _minorState = MINOR_VALUE_STRING_ESCAPE;\n                return false;\n            }\n            _textBuffer.append((char) c);\n            return true;\n        case 2: // 2-byte UTF; easy, either got both, or just miss one\n            if (gotNext) {\n                // NOTE: always succeeds, no need to check\n                c = _decodeUTF8_2(c, _inputBuffer[_inputPtr++]);\n                _textBuffer.append((char) c);\n                return true;\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_2;\n            _pending32 = c;\n            return false;\n        case 3: // 3-byte UTF\n            c &= 0x0F;\n            if (gotNext) {\n                return _decodeSplitUTF8_3(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_3;\n            _pending32 = c;\n            _pendingBytes = 1;\n            return false;\n        case 4: // 4-byte UTF\n            c &= 0x07;\n            if (gotNext) {\n                return _decodeSplitUTF8_4(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _pending32 = c;\n            _pendingBytes = 1;\n            _minorState = MINOR_VALUE_STRING_UTF8_4;\n            return false;\n        default:\n            if (c < INT_SPACE) {\n                // Note: call can now actually return (to allow unquoted linefeeds)\n                _throwUnquotedSpace(c, \"string value\");\n            } else {\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            _textBuffer.append((char) c);\n            return true;\n        }\n    }\n\n    private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_3;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        _textBuffer.append((char) ((prev << 6) | (next & 0x3F)));\n        return true;\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final boolean _decodeSplitUTF8_4(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            prevCount = 2;\n            next = _inputBuffer[_inputPtr++];\n        }\n        if (prevCount == 2) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 3;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        int c = ((prev << 6) | (next & 0x3F)) - 0x10000;\n        // Let's add first part right away:\n        _textBuffer.append((char) (0xD800 | (c >> 10)));\n        c = 0xDC00 | (c & 0x3FF);\n        // And let the other char output down below\n        _textBuffer.append((char) c);\n        return true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeCharEscape() throws IOException\n    {\n        int left = _inputEnd - _inputPtr;\n        if (left < 5) { // offline boundary-checking case:\n            return _decodeSplitEscaped(0, -1);\n        }\n        return _decodeFastCharEscape();\n    }\n\n    private final int _decodeFastCharEscape() throws IOException\n    {\n        int c = (int) _inputBuffer[_inputPtr++];\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            {\n             // !!! TODO: Decode UTF-8 characters properly...\n//              char ch = (char) _decodeCharForError(c);\n                char ch = (char) c;\n                return _handleUnrecognizedCharacterEscape(ch);\n            }\n        }\n\n        int ch = (int) _inputBuffer[_inputPtr++];\n        int digit = CharTypes.charToHex(ch);\n        int result = digit;\n\n        if (digit >= 0) {\n            ch = (int) _inputBuffer[_inputPtr++];\n            digit = CharTypes.charToHex(ch);\n            if (digit >= 0) {\n                result = (result << 4) | digit;\n                ch = (int) _inputBuffer[_inputPtr++];\n                digit = CharTypes.charToHex(ch);\n                if (digit >= 0) {\n                    result = (result << 4) | digit;\n                    ch = (int) _inputBuffer[_inputPtr++];\n                    digit = CharTypes.charToHex(ch);\n                    if (digit >= 0) {\n                        return (result << 4) | digit;\n                    }\n                }\n            }\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"expected a hex-digit for character escape sequence\");\n        return -1;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeUTF8_2(int c, int d) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUTF8_3(int c, int d, int e) throws IOException\n    {\n        c &= 0x0F;\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        return (c << 6) | (e & 0x3F);\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final int _decodeUTF8_4(int c, int d, int e, int f) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (e & 0x3F);\n        if ((f & 0xC0) != 0x080) {\n            _reportInvalidOther(f & 0xFF, _inputPtr);\n        }\n        return ((c << 6) | (f & 0x3F)) - 0x10000;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, other\n    /**********************************************************************\n     */\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `releaseBuffered` method in the `NonBlockingJsonParser` class. These tests aim to maximize both branch and line coverage. \n\nFirst, ensure you have the necessary JUnit 4 library in your project. You can add it via Maven if you are using it:\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\nNow, here are the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class NonBlockingJsonParserTest {\n\n    private NonBlockingJsonParser parser;\n\n    @Before\n    public void setUp() {\n        parser = new NonBlockingJsonParser() {\n            @Override\n            public ByteArrayFeeder getNonBlockingInputFeeder() {\n                return this;\n            }\n\n            @Override\n            public boolean needMoreInput() {\n                return false;\n            }\n\n            @Override\n            public void feedInput(byte[] buf, int start, int end) {\n                // No-op\n            }\n\n            @Override\n            public void endOfInput() {\n                // No-op\n            }\n\n            @Override\n            public JsonToken nextToken() {\n                return null;\n            }\n        };\n    }\n\n    @Test\n    public void testReleaseBuffered_NoDataAvailable() throws IOException {\n        // Arrange\n        parser._inputBuffer = new byte[]{};\n        parser._inputPtr = 0;\n        parser._inputEnd = 0;\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        // Act\n        int result = parser.releaseBuffered(out);\n\n        // Assert\n        assertEquals(0, result);\n        assertEquals(0, out.size());\n    }\n\n    @Test\n    public void testReleaseBuffered_DataAvailable() throws IOException {\n        // Arrange\n        parser._inputBuffer = new byte[]{0x74, 0x65, 0x73, 0x74}; // \"test\"\n        parser._inputPtr = 0;\n        parser._inputEnd = 4;\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        // Act\n        int result = parser.releaseBuffered(out);\n\n        // Assert\n        assertEquals(4, result);\n        assertEquals(\"test\", out.toString());\n    }\n\n    @Test\n    public void testReleaseBuffered_PartialDataAvailable() throws IOException {\n        // Arrange\n        parser._inputBuffer = new byte[]{0x74, 0x65, 0x73, 0x74}; // \"test\"\n        parser._inputPtr = 2;\n        parser._inputEnd = 4;\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        // Act\n        int result = parser.releaseBuffered(out);\n\n        // Assert\n        assertEquals(2, result);\n        assertEquals(\"st\", out.toString());\n    }\n\n    @Test\n    public void testReleaseBuffered_BufferReused() throws IOException {\n        // Arrange\n        parser._inputBuffer = new byte[]{0x74, 0x65, 0x73, 0x74}; // \"test\"\n        parser._inputPtr = 0;\n        parser._inputEnd = 4;\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        // Act\n        parser.releaseBuffered(out);\n\n        // Check first release\n        assertEquals(4, out.size());\n\n        // Reset pointers for second release\n        parser._inputPtr = 0;\n        parser._inputEnd = 2;\n\n        // Act again\n        parser.releaseBuffered(out);\n\n        // Assert\n        assertEquals(6, out.size());\n        assertEquals(\"testte\", out.toString());\n    }\n}\n```\n\n### Explanation:\n1. **testReleaseBuffered_NoDataAvailable**: Tests the scenario where there is no data available in the buffer.\n2. **testReleaseBuffered_DataAvailable**: Tests the scenario where there is complete data available in the buffer.\n3. **testReleaseBuffered_PartialDataAvailable**: Tests the scenario where only a part of the buffer is available.\n4. **testReleaseBuffered_BufferReused**: Tests that the buffer can be reused and the data is correctly appended to the `OutputStream`.\n\nThese tests ensure that all branches of the `releaseBuffered` method are covered and help in achieving high line coverage."}
{"bug_id": "JacksonCore_26", "version": "fixed", "focal_method_signature": "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#nextToken()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_26/fixed/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java", "focal_method": "@Override\n    public JsonToken nextToken() throws IOException\n    {\n        // First: regardless of where we really are, need at least one more byte;\n        // can simplify some of the checks by short-circuiting right away\n        if (_inputPtr >= _inputEnd) {\n            if (_closed) {\n                return null;\n            }\n            // note: if so, do not even bother changing state\n            if (_endOfInput) { // except for this special case\n                // End-of-input within (possibly...) started token is bit complicated,\n                // so offline\n                if (_currToken == JsonToken.NOT_AVAILABLE) {\n                    return _finishTokenWithEOF();\n                }\n                return _eofAsNextToken();\n            }\n            return JsonToken.NOT_AVAILABLE;\n        }\n        // in the middle of tokenization?\n        if (_currToken == JsonToken.NOT_AVAILABLE) {\n            return _finishToken();\n        }\n\n        // No: fresh new token; may or may not have existing one\n        _numTypesValid = NR_UNKNOWN;\n        _tokenInputTotal = _currInputProcessed + _inputPtr;\n        // also: clear any data retained so far\n        _binaryValue = null;\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n\n        switch (_majorState) {\n        case MAJOR_INITIAL:\n            return _startDocument(ch);\n\n        case MAJOR_ROOT:\n            return _startValue(ch);\n\n        case MAJOR_OBJECT_FIELD_FIRST: // expect field-name or end-object\n            return _startFieldName(ch);\n        case MAJOR_OBJECT_FIELD_NEXT: // expect comma + field-name or end-object\n            return _startFieldNameAfterComma(ch);\n\n        case MAJOR_OBJECT_VALUE: // expect colon, followed by value\n            return _startValueExpectColon(ch);\n\n        case MAJOR_ARRAY_ELEMENT_FIRST: // expect value or end-array\n            return _startValue(ch);\n\n        case MAJOR_ARRAY_ELEMENT_NEXT: // expect leading comma + value or end-array\n            return _startValueExpectComma(ch);\n\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }", "return_type": "JsonToken", "assertion_subject_candidates": ["ByteArrayFeeder com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#getNonBlockingInputFeeder()"], "focal_class": {"name": "NonBlockingJsonParser", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_26/fixed/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java", "superclass": "extends NonBlockingJsonParserBase", "interface": "implements ByteArrayFeeder", "imports": ["import java.io.IOException;", "import java.io.OutputStream;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.async.ByteArrayFeeder;", "import com.fasterxml.jackson.core.async.NonBlockingInputFeeder;", "import com.fasterxml.jackson.core.io.CharTypes;", "import com.fasterxml.jackson.core.io.IOContext;", "import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;", "import com.fasterxml.jackson.core.util.VersionUtil;"], "fields": ["@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask()", "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask()", "private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask()", "private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask()", "private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask()", "private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask()", "private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8()", "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "protected byte[] _inputBuffer = NO_BYTES", "protected int _origBufferLen"], "methods": ["ByteArrayFeeder com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#getNonBlockingInputFeeder()", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#needMoreInput()", "void com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#feedInput(byte[]#buf,int#start,int#end)", "void com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#endOfInput()", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#releaseBuffered(OutputStream#out)", "char com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeEscaped()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishTokenWithEOF()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startDocument(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishBOM(int#bytesHandled)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFieldName(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFieldNameAfterComma(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValue(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValueExpectComma(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValueExpectColon(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startValueAfterComma(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startUnexpectedValue(boolean#leadingComma,int#ch)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_skipWS(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startSlashComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishHashComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishCppComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishCComment(int#fromMinorState,boolean#gotStar)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startAfterComment(int#fromMinorState)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFalseToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startTrueToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startNullToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishKeywordToken(String#expToken,int#matched,JsonToken#result)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishKeywordTokenWithEOF(String#expToken,int#matched,JsonToken#result)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNonStdToken(int#type,int#matched)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNonStdTokenWithEOF(int#type,int#matched)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishErrorToken()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishErrorTokenWithEOF()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_reportErrorToken(String#actualToken)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startPositiveNumber(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startNegativeNumber()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startNumberLeadingZero()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberMinus(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberLeadingZeroes()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberLeadingNegZeroes()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishNumberIntegralPart(char[]#outBuf,int#outPtr)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startFloat(char[]#outBuf,int#outPtr,int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishFloatFraction()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishFloatExponent(boolean#checkSign,int#ch)", "String com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_fastParseName()", "String com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_parseMediumName(int#ptr,int#q2)", "String com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_parseMediumName2(int#ptr,int#q3,int#q2)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_parseEscapedName(int#qlen,int#currQuad,int#currQuadBytes)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_handleOddName(int#ch)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishUnquotedName(int#qlen,int#currQuad,int#currQuadBytes)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishAposName(int#qlen,int#currQuad,int#currQuadBytes)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishFieldWithEscape()", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitEscaped(int#value,int#bytesRead)", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startString()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishRegularString()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_startAposString()", "JsonToken com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_finishAposString()", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitMultiByte(int#c,int#type,boolean#gotNext)", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitUTF8_3(int#prev,int#prevCount,int#next)", "boolean com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeSplitUTF8_4(int#prev,int#prevCount,int#next)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeCharEscape()", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeFastCharEscape()", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeUTF8_2(int#c,int#d)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeUTF8_3(int#c,int#d,int#e)", "int com.fasterxml.jackson.core.json.async.NonBlockingJsonParser#_decodeUTF8_4(int#c,int#d,int#e,int#f)"], "other_methods": ["@Override\n    public ByteArrayFeeder getNonBlockingInputFeeder();", "@Override\n    public final boolean needMoreInput();", "@Override\n    public void feedInput(byte[] buf,int start,int end);", "@Override\n    public void endOfInput();", "@Override\n    public int releaseBuffered(OutputStream out);"], "fields_dict": {"int#FEAT_MASK_TRAILING_COMMA": "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "int#FEAT_MASK_LEADING_ZEROS": "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask()", "int#FEAT_MASK_ALLOW_MISSING": "@SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask()", "int#FEAT_MASK_ALLOW_SINGLE_QUOTES": "private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask()", "int#FEAT_MASK_ALLOW_UNQUOTED_NAMES": "private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask()", "int#FEAT_MASK_ALLOW_JAVA_COMMENTS": "private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask()", "int#FEAT_MASK_ALLOW_YAML_COMMENTS": "private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask()", "int[]#_icUTF8": "private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8()", "int[]#_icLatin1": "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "byte[]#_inputBuffer": "protected byte[] _inputBuffer = NO_BYTES", "int#_origBufferLen": "protected int _origBufferLen"}, "text": "package com.fasterxml.jackson.core.json.async;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.async.ByteArrayFeeder;\nimport com.fasterxml.jackson.core.async.NonBlockingInputFeeder;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\npublic class NonBlockingJsonParser\n    extends NonBlockingJsonParserBase\n    implements ByteArrayFeeder\n{\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_LEADING_ZEROS = Feature.ALLOW_NUMERIC_LEADING_ZEROS.getMask();\n    @SuppressWarnings(\"deprecation\")\n    private final static int FEAT_MASK_ALLOW_MISSING = Feature.ALLOW_MISSING_VALUES.getMask();\n    private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = Feature.ALLOW_SINGLE_QUOTES.getMask();\n    private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = Feature.ALLOW_UNQUOTED_FIELD_NAMES.getMask();\n    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = Feature.ALLOW_COMMENTS.getMask();\n    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = Feature.ALLOW_YAML_COMMENTS.getMask();\n\n    // This is the main input-code lookup table, fetched eagerly\n    private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************************\n    /* Input source config\n    /**********************************************************************\n     */\n\n    /**\n     * This buffer is actually provided via {@link NonBlockingInputFeeder}\n     */\n    protected byte[] _inputBuffer = NO_BYTES;\n\n    /**\n     * In addition to current buffer pointer, and end pointer,\n     * we will also need to know number of bytes originally\n     * contained. This is needed to correctly update location\n     * information when the block has been completed.\n     */\n    protected int _origBufferLen;\n\n    // And from ParserBase:\n//  protected int _inputPtr;\n//  protected int _inputEnd;\n\n    /*\n    /**********************************************************************\n    /* Life-cycle\n    /**********************************************************************\n     */\n\n    public NonBlockingJsonParser(IOContext ctxt, int parserFeatures,\n            ByteQuadsCanonicalizer sym)\n    {\n        super(ctxt, parserFeatures, sym);\n    }\n\n    /*\n    /**********************************************************************\n    /* AsyncInputFeeder impl\n    /**********************************************************************\n     */\n\n    @Override\n    public ByteArrayFeeder getNonBlockingInputFeeder() {\n        return this;\n    }\n\n    @Override\n    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _currBufferStart = start;\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n\n    @Override\n    public void endOfInput() {\n        _endOfInput = true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Abstract methods/overrides from JsonParser\n    /**********************************************************************\n     */\n\n    /* Implementing these methods efficiently for non-blocking cases would\n     * be complicated; so for now let's just use the default non-optimized\n     * implementation\n     */\n\n//    public boolean nextFieldName(SerializableString str) throws IOException\n//    public String nextTextValue() throws IOException\n//    public int nextIntValue(int defaultValue) throws IOException\n//    public long nextLongValue(long defaultValue) throws IOException\n//    public Boolean nextBooleanValue() throws IOException\n\n    @Override\n    public int releaseBuffered(OutputStream out) throws IOException {\n        int avail = _inputEnd - _inputPtr;\n        if (avail > 0) {\n            out.write(_inputBuffer, _inputPtr, avail);\n        }\n        return avail;\n    }\n\n    // Should never be called: can not be implemented quite as expected\n    // due to non-blocking behavior\n    @Override\n    protected char _decodeEscaped() throws IOException {\n        VersionUtil.throwInternal();\n        return ' ';\n    }\n\n    /*\n    /**********************************************************************\n    /* Main-level decoding\n    /**********************************************************************\n     */\n\n    @Override\n    public JsonToken nextToken() throws IOException\n    {\n        // First: regardless of where we really are, need at least one more byte;\n        // can simplify some of the checks by short-circuiting right away\n        if (_inputPtr >= _inputEnd) {\n            if (_closed) {\n                return null;\n            }\n            // note: if so, do not even bother changing state\n            if (_endOfInput) { // except for this special case\n                // End-of-input within (possibly...) started token is bit complicated,\n                // so offline\n                if (_currToken == JsonToken.NOT_AVAILABLE) {\n                    return _finishTokenWithEOF();\n                }\n                return _eofAsNextToken();\n            }\n            return JsonToken.NOT_AVAILABLE;\n        }\n        // in the middle of tokenization?\n        if (_currToken == JsonToken.NOT_AVAILABLE) {\n            return _finishToken();\n        }\n\n        // No: fresh new token; may or may not have existing one\n        _numTypesValid = NR_UNKNOWN;\n        _tokenInputTotal = _currInputProcessed + _inputPtr;\n        // also: clear any data retained so far\n        _binaryValue = null;\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n\n        switch (_majorState) {\n        case MAJOR_INITIAL:\n            return _startDocument(ch);\n\n        case MAJOR_ROOT:\n            return _startValue(ch);\n\n        case MAJOR_OBJECT_FIELD_FIRST: // expect field-name or end-object\n            return _startFieldName(ch);\n        case MAJOR_OBJECT_FIELD_NEXT: // expect comma + field-name or end-object\n            return _startFieldNameAfterComma(ch);\n\n        case MAJOR_OBJECT_VALUE: // expect colon, followed by value\n            return _startValueExpectColon(ch);\n\n        case MAJOR_ARRAY_ELEMENT_FIRST: // expect value or end-array\n            return _startValue(ch);\n\n        case MAJOR_ARRAY_ELEMENT_NEXT: // expect leading comma + value or end-array\n            return _startValueExpectComma(ch);\n\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method called when decoding of a token has been started, but not yet completed due\n     * to missing input; method is to continue decoding due to at least one more byte\n     * being made available to decode.\n     */\n    protected final JsonToken _finishToken() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        switch (_minorState) {\n        case MINOR_ROOT_BOM:\n            return _finishBOM(_pending32);\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n\n        // Field name states\n        case MINOR_FIELD_NAME:\n            return _parseEscapedName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_NAME_ESCAPE:\n            return _finishFieldWithEscape();\n        case MINOR_FIELD_APOS_NAME:\n            return _finishAposName(_quadLength,  _pending32, _pendingBytes);\n        case MINOR_FIELD_UNQUOTED_NAME:\n            return _finishUnquotedName(_quadLength,  _pending32, _pendingBytes);\n\n        // Value states\n\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(_inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordToken(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordToken(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordToken(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdToken(_nonStdTokenType, _pending32);\n\n        case MINOR_NUMBER_MINUS:\n            return _finishNumberMinus(_inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_ZERO:\n            return _finishNumberLeadingZeroes();\n        case MINOR_NUMBER_MINUSZERO:\n            return _finishNumberLeadingNegZeroes();\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            return _finishNumberIntegralPart(_textBuffer.getBufferWithoutReset(),\n                    _textBuffer.getCurrentSegmentSize());\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            return _finishFloatFraction();\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _finishFloatExponent(false, _inputBuffer[_inputPtr++] & 0xFF);\n\n        case MINOR_VALUE_STRING:\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_2:\n            _textBuffer.append((char) _decodeUTF8_2(_pending32, _inputBuffer[_inputPtr++]));\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_3:\n            if (!_decodeSplitUTF8_3(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n        case MINOR_VALUE_STRING_UTF8_4:\n            if (!_decodeSplitUTF8_4(_pending32, _pendingBytes, _inputBuffer[_inputPtr++])) {\n                return JsonToken.NOT_AVAILABLE;\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_STRING_ESCAPE:\n            {\n                int c = _decodeSplitEscaped(_quoted32, _quotedDigits);\n                if (c < 0) {\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                _textBuffer.append((char) c);\n            }\n            if (_minorStateAfterSplit == MINOR_VALUE_APOS_STRING) {\n                return _finishAposString();\n            }\n            return _finishRegularString();\n\n        case MINOR_VALUE_APOS_STRING:\n            return _finishAposString();\n\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorToken();\n\n        // Comments\n            \n        case MINOR_COMMENT_LEADING_SLASH:\n            return _startSlashComment(_pending32);\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n            return _finishCComment(_pending32, true);\n        case MINOR_COMMENT_C:\n            return _finishCComment(_pending32, false);\n        case MINOR_COMMENT_CPP:\n            return _finishCppComment(_pending32);\n        case MINOR_COMMENT_YAML:\n            return _finishHashComment(_pending32);\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /**\n     * Method similar to {@link #_finishToken}, but called when no more input is\n     * available, and end-of-input has been detected. This is usually problem\n     * case, but not always: root-level values may be properly terminated by\n     * this, and similarly trailing white-space may have been skipped.\n     */\n    protected final JsonToken _finishTokenWithEOF() throws IOException\n    {\n        // NOTE: caller ensures there's input available...\n        JsonToken t = _currToken;\n        switch (_minorState) {\n        case MINOR_ROOT_GOT_SEPARATOR: // fine, just skip some trailing space\n            return _eofAsNextToken();\n        case MINOR_VALUE_LEADING_WS: // finished at token boundary; probably fine\n            return _eofAsNextToken();\n//        case MINOR_VALUE_EXPECTING_COMMA: // not fine\n//        case MINOR_VALUE_EXPECTING_COLON: // not fine\n        case MINOR_VALUE_TOKEN_NULL:\n            return _finishKeywordTokenWithEOF(\"null\", _pending32, JsonToken.VALUE_NULL);\n        case MINOR_VALUE_TOKEN_TRUE:\n            return _finishKeywordTokenWithEOF(\"true\", _pending32, JsonToken.VALUE_TRUE);\n        case MINOR_VALUE_TOKEN_FALSE:\n            return _finishKeywordTokenWithEOF(\"false\", _pending32, JsonToken.VALUE_FALSE);\n        case MINOR_VALUE_TOKEN_NON_STD:\n            return _finishNonStdTokenWithEOF(_nonStdTokenType, _pending32);\n        case MINOR_VALUE_TOKEN_ERROR: // case of \"almost token\", just need tokenize for error\n            return _finishErrorTokenWithEOF();\n\n        // Number-parsing states; valid stopping points, more explicit errors\n        case MINOR_NUMBER_ZERO:\n        case MINOR_NUMBER_MINUSZERO:\n            // NOTE: does NOT retain possible leading minus-sign (can change if\n            // absolutely needs be)\n            return _valueCompleteInt(0, \"0\");\n        case MINOR_NUMBER_INTEGER_DIGITS:\n            // Fine: just need to ensure we have value fully defined\n            {\n                int len = _textBuffer.getCurrentSegmentSize();\n                if (_numberNegative) {\n                    --len;\n                }\n                _intLength = len;\n            }\n            return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n\n        case MINOR_NUMBER_FRACTION_DIGITS:\n            _expLength = 0;\n            // fall through\n        case MINOR_NUMBER_EXPONENT_DIGITS:\n            return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n\n        case MINOR_NUMBER_EXPONENT_MARKER:\n            _reportInvalidEOF(\": was expecting fraction after exponent marker\", JsonToken.VALUE_NUMBER_FLOAT);\n\n            // How about comments? \n            // Inside C-comments; not legal\n\n//        case MINOR_COMMENT_LEADING_SLASH: // not legal, but use default error\n        case MINOR_COMMENT_CLOSING_ASTERISK:\n        case MINOR_COMMENT_C:\n            _reportInvalidEOF(\": was expecting closing '*/' for comment\", JsonToken.NOT_AVAILABLE);\n\n        case MINOR_COMMENT_CPP:\n        case MINOR_COMMENT_YAML:\n            // within C++/YAML comments, ok, as long as major state agrees...\n            return _eofAsNextToken();\n            \n        default:\n        }\n        _reportInvalidEOF(\": was expecting rest of token (internal state: \"+_minorState+\")\", _currToken);\n        return t; // never gets here\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, root level\n    /**********************************************************************\n     */\n\n    private final JsonToken _startDocument(int ch) throws IOException\n    {\n        ch &= 0xFF;\n\n        // Very first byte: could be BOM\n        if ((ch == 0xEF) && (_minorState != MINOR_ROOT_BOM)) {\n            return _finishBOM(1);\n        }\n\n        // If not BOM (or we got past it), could be whitespace or comment to skip\n        while (ch <= 0x020) {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_ROOT_GOT_SEPARATOR;\n                if (_closed) {\n                    return null;\n                }\n                // note: if so, do not even bother changing state\n                if (_endOfInput) { // except for this special case\n                    return _eofAsNextToken();\n                }\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        return _startValue(ch);\n    }\n\n    private final JsonToken _finishBOM(int bytesHandled) throws IOException\n    {\n        // public final static byte UTF8_BOM_1 = (byte) 0xEF;\n        // public final static byte UTF8_BOM_2 = (byte) 0xBB;\n        // public final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n        while (_inputPtr < _inputEnd) {\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            switch (bytesHandled) {\n            case 3:\n                // got it all; go back to \"start document\" handling, without changing\n                // minor state (to let it know we've done BOM)\n                _currInputProcessed -= 3;\n                return _startDocument(ch);\n            case 2:\n                if (ch != 0xBF) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF 0xBB; should get 0xBF as third byte of UTF-8 BOM\", ch);\n                }\n                break;\n            case 1:\n                if (ch != 0xBB) {\n                    _reportError(\"Unexpected byte 0x%02x following 0xEF; should get 0xBB as second byte UTF-8 BOM\", ch);\n                }\n                break;\n            }\n            ++bytesHandled;\n        }\n        _pending32 = bytesHandled;\n        _minorState = MINOR_ROOT_BOM;\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, primary field name decoding\n    /**********************************************************************\n     */\n\n    /**\n     * Method that handles initial token type recognition for token\n     * that has to be either FIELD_NAME or END_OBJECT.\n     */\n    private final JsonToken _startFieldName(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    private final JsonToken _startFieldNameAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) { // either comma, separating entries, or closing right curly\n            if (ch == INT_RCURLY) {\n                return _closeObjectScope();\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_FIELD_LEADING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_FIELD_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_FIELD_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch != INT_QUOTE) {\n            if (ch == INT_RCURLY) {\n                if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                    return _closeObjectScope();\n                }\n            }\n            return _handleOddName(ch);\n        }\n        // First: can we optimize out bounds checks?\n        if ((_inputPtr + 13) <= _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\n            String n = _fastParseName();\n            if (n != null) {\n                return _fieldComplete(n);\n            }\n        }\n        return _parseEscapedName(0, 0, 0);\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, value decoding\n    /**********************************************************************\n     */\n    \n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value may be preceded by leading white-space, but no separator (comma).\n     */\n    private final JsonToken _startValue(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/': // c/c++ comments\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n            \n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            return _closeArrayScope();\n        case '{':\n            return _startObjectScope();\n        case '}':\n            return _closeObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /**\n     * Helper method called to parse token that is either a value token in array\n     * or end-array marker\n     */\n    private final JsonToken _startValueExpectComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COMMA;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COMMA) {\n            if (ch == INT_RBRACKET) {\n                return _closeArrayScope();\n            }\n            if (ch == INT_RCURLY){\n                return _closeObjectScope();\n            }\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COMMA);\n            }\n            _reportUnexpectedChar(ch, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    /**\n     * Helper method called to detect type of a value token (at any level), and possibly\n     * decode it if contained in input buffer.\n     * Value MUST be preceded by a semi-colon (which may be surrounded by white-space)\n     */\n    private final JsonToken _startValueExpectColon(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_EXPECTING_COLON;\n                return _currToken;\n            }\n        }\n        if (ch != INT_COLON) {\n            if (ch == INT_SLASH) {\n                return _startSlashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            if (ch == INT_HASH) {\n                return _finishHashComment(MINOR_VALUE_EXPECTING_COLON);\n            }\n            // can not omit colon here\n            _reportUnexpectedChar(ch, \"was expecting a colon to separate field name and value\");\n        }\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_VALUE_LEADING_WS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[ptr];\n        _inputPtr = ptr+1;\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch); // will skip through all available ws (and comments)\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_LEADING_WS;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_LEADING_WS);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_LEADING_WS);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n\n        case '1':\n        case '2': case '3':\n        case '4': case '5':\n        case '6': case '7':\n        case '8': case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case '{':\n            return _startObjectScope();\n        default:\n        }\n        return _startUnexpectedValue(false, ch);\n    }\n\n    /* Method called when we have already gotten a comma (i.e. not the first value)\n     */\n    private final JsonToken _startValueAfterComma(int ch) throws IOException\n    {\n        // First: any leading white space?\n        if (ch <= 0x0020) {\n            ch = _skipWS(ch);\n            if (ch <= 0) {\n                _minorState = MINOR_VALUE_WS_AFTER_COMMA;\n                return _currToken;\n            }\n        }\n        _updateTokenLocation();\n        if (ch == INT_QUOTE) {\n            return _startString();\n        }\n        switch (ch) {\n        case '#':\n            return _finishHashComment(MINOR_VALUE_WS_AFTER_COMMA);\n        case '-':\n            return _startNegativeNumber();\n        case '/':\n            return _startSlashComment(MINOR_VALUE_WS_AFTER_COMMA);\n\n        // Should we have separate handling for plus? Although\n        // it is not allowed per se, it may be erroneously used,\n        // and could be indicate by a more specific error message.\n        case '0':\n            return _startNumberLeadingZero();\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _startPositiveNumber(ch);\n        case 'f':\n            return _startFalseToken();\n        case 'n':\n            return _startNullToken();\n        case 't':\n            return _startTrueToken();\n        case '[':\n            return _startArrayScope();\n        case ']':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeArrayScope();\n            }\n            break;\n        case '{':\n            return _startObjectScope();\n        case '}':\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                return _closeObjectScope();\n            }\n            break;\n        default:\n        }\n        return _startUnexpectedValue(true, ch);\n    }\n\n    protected JsonToken _startUnexpectedValue(boolean leadingComma, int ch) throws IOException\n    {\n        switch (ch) {\n        case ']':\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n            //   we may allow \"missing values\", that is, encountering a trailing\n            //   comma or closing marker where value would be expected\n            if ((_features & FEAT_MASK_ALLOW_MISSING) != 0) {\n                --_inputPtr;\n                return _valueComplete(JsonToken.VALUE_NULL);\n            }\n            // fall through\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            break;\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _startAposString();\n            }\n            break;\n        case '+':\n            return _finishNonStdToken(NON_STD_TOKEN_PLUS_INFINITY, 1);\n        case 'N':\n            return _finishNonStdToken(NON_STD_TOKEN_NAN, 1);            \n        case 'I':\n            return _finishNonStdToken(NON_STD_TOKEN_INFINITY, 1);\n        }\n        // !!! TODO: maybe try to collect more information for better diagnostics\n        _reportUnexpectedChar(ch, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, skipping white-space, comments\n    /**********************************************************************\n     */\n    \n    private final int _skipWS(int ch) throws IOException\n    {\n        do {\n            if (ch != INT_SPACE) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _currToken = JsonToken.NOT_AVAILABLE;\n                return 0;\n            }\n            ch = _inputBuffer[_inputPtr++] & 0xFF;\n        } while (ch <= 0x0020);\n        return ch;\n    }\n\n    private final JsonToken _startSlashComment(int fromMinorState) throws IOException\n    {\n        if ((_features & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n\n        // After that, need to verify if we have c/c++ comment\n        if (_inputPtr >= _inputEnd) {\n            _pending32 = fromMinorState;\n            _minorState = MINOR_COMMENT_LEADING_SLASH;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++];\n        if (ch == INT_ASTERISK) { // c-style\n            return _finishCComment(fromMinorState, false);\n        }\n        if (ch == INT_SLASH) { // c++-style\n            return _finishCppComment(fromMinorState);\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"was expecting either '*' or '/' for a comment\");\n        return null;\n    }\n\n    private final JsonToken _finishHashComment(int fromMinorState) throws IOException\n    {\n        // Could by-pass this check by refactoring, but for now simplest way...\n        if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {\n            _reportUnexpectedChar('#', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_YAML_COMMENTS' not enabled for parser)\");\n        }\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_YAML;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCppComment(int fromMinorState) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_COMMENT_CPP;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            }\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _finishCComment(int fromMinorState, boolean gotStar) throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = gotStar ? MINOR_COMMENT_CLOSING_ASTERISK : MINOR_COMMENT_C;\n                _pending32 = fromMinorState;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < 0x020) {\n                if (ch == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch == INT_CR) {\n                    ++_currInputRowAlt;\n                    _currInputRowStart = _inputPtr;\n                } else if (ch != INT_TAB) {\n                    _throwInvalidSpace(ch);\n                }\n            } else if (ch == INT_ASTERISK) {\n                gotStar = true;\n                continue;\n            } else if (ch == INT_SLASH) {\n                if (gotStar) {\n                    break;\n                }\n            }\n            gotStar = false;\n        }\n        return _startAfterComment(fromMinorState);\n    }\n\n    private final JsonToken _startAfterComment(int fromMinorState) throws IOException\n    {\n        // Ok, then, need one more character...\n        if (_inputPtr >= _inputEnd) {\n            _minorState = fromMinorState;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        switch (fromMinorState) {\n        case MINOR_FIELD_LEADING_WS:\n            return _startFieldName(ch);\n        case MINOR_FIELD_LEADING_COMMA:\n            return _startFieldNameAfterComma(ch);\n        case MINOR_VALUE_LEADING_WS:\n            return _startValue(ch);\n        case MINOR_VALUE_EXPECTING_COMMA:\n            return _startValueExpectComma(ch);\n        case MINOR_VALUE_EXPECTING_COLON:\n            return _startValueExpectColon(ch);\n        case MINOR_VALUE_WS_AFTER_COMMA:\n            return _startValueAfterComma(ch);\n        default:\n        }\n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    /*\n    /**********************************************************************\n    /* Tertiary decoding, simple tokens\n    /**********************************************************************\n     */\n\n    protected JsonToken _startFalseToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'a') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 's')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_FALSE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_FALSE;\n        return _finishKeywordToken(\"false\", 1, JsonToken.VALUE_FALSE);\n    }\n\n    protected JsonToken _startTrueToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'r') \n                   && (buf[ptr++] == 'u')\n                   && (buf[ptr++] == 'e')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_TRUE);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_TRUE;\n        return _finishKeywordToken(\"true\", 1, JsonToken.VALUE_TRUE);\n    }\n\n    protected JsonToken _startNullToken() throws IOException\n    {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) { // yes, can determine efficiently\n            byte[] buf = _inputBuffer;\n            if ((buf[ptr++] == 'u') \n                   && (buf[ptr++] == 'l')\n                   && (buf[ptr++] == 'l')) {\n                int ch = buf[ptr] & 0xFF;\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return _valueComplete(JsonToken.VALUE_NULL);\n                }\n            }\n        }\n        _minorState = MINOR_VALUE_TOKEN_NULL;\n        return _finishKeywordToken(\"null\", 1, JsonToken.VALUE_NULL);\n    }\n\n    protected JsonToken _finishKeywordToken(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _pending32 = matched;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueComplete(result);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishKeywordTokenWithEOF(String expToken, int matched,\n            JsonToken result) throws IOException\n    {\n        if (matched == expToken.length()) {\n            return (_currToken = result);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishNonStdToken(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        final int end = expToken.length();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _nonStdTokenType = type;\n                _pending32 = matched;\n                _minorState = MINOR_VALUE_TOKEN_NON_STD;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr];\n            if (matched == end) { // need to verify trailing separator\n                if (ch < INT_0 || (ch == INT_RBRACKET) || (ch == INT_RCURLY)) { // expected/allowed chars\n                    return _valueNonStdNumberComplete(type);\n                }\n                break;\n            }\n            if (ch != expToken.charAt(matched)) {\n                break;\n            }\n            ++matched;\n            ++_inputPtr;\n        }\n        _minorState = MINOR_VALUE_TOKEN_ERROR;\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorToken();\n    }\n\n    protected JsonToken _finishNonStdTokenWithEOF(int type, int matched) throws IOException\n    {\n        final String expToken = _nonStdToken(type);\n        if (matched == expToken.length()) {\n            return _valueNonStdNumberComplete(type);\n        }\n        _textBuffer.resetWithCopy(expToken, 0, matched);\n        return _finishErrorTokenWithEOF();\n    }\n\n    protected JsonToken _finishErrorToken() throws IOException\n    {\n        while (_inputPtr < _inputEnd) {\n            int i = (int) _inputBuffer[_inputPtr++];\n\n// !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(i);\n\n            char ch = (char) i;\n            if (Character.isJavaIdentifierPart(ch)) {\n                // 11-Jan-2016, tatu: note: we will fully consume the character,\n                // included or not, so if recovery was possible, it'd be off-by-one...\n                _textBuffer.append(ch);\n                if (_textBuffer.size() < MAX_ERROR_TOKEN_LENGTH) {\n                    continue;\n                }\n            }\n            return _reportErrorToken(_textBuffer.contentsAsString());\n        }\n        return (_currToken = JsonToken.NOT_AVAILABLE);\n    }\n\n    protected JsonToken _finishErrorTokenWithEOF() throws IOException\n    {\n        return _reportErrorToken(_textBuffer.contentsAsString());\n    }\n\n    protected JsonToken _reportErrorToken(String actualToken) throws IOException\n    {\n        // !!! TODO: Include non-standard ones if enabled\n        _reportError(\"Unrecognized token '%s': was expecting %s\", _textBuffer.contentsAsString(),\n                \"'null', 'true' or 'false'\");\n        return JsonToken.NOT_AVAILABLE; // never gets here\n    }\n    \n    /*\n    /**********************************************************************\n    /* Second-level decoding, Number decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startPositiveNumber(int ch) throws IOException\n    {\n        _numberNegative = false;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = (char) ch;\n        // in unlikely event of not having more input, denote location\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(1);\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        int outPtr = 1;\n\n        ch = _inputBuffer[_inputPtr] & 0xFF;\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNegativeNumber() throws IOException\n    {\n        _numberNegative = true;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_MINUS;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        int ch = _inputBuffer[_inputPtr++] & 0xFF;\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            // One special case: if first char is 0, must not be followed by a digit\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        if (_inputPtr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n            _textBuffer.setCurrentLength(2);\n            _intLength = 1;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n        ch = _inputBuffer[_inputPtr];\n        int outPtr = 2;\n\n        while (true) {\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr-1;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand, to ensure contiguous buffer, outPtr is the length\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (++_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr] & 0xFF;\n        }\n        _intLength = outPtr-1;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startNumberLeadingZero() throws IOException\n    {\n        int ptr = _inputPtr;\n        if (ptr >= _inputEnd) {\n            _minorState = MINOR_NUMBER_ZERO;\n            return (_currToken = JsonToken.NOT_AVAILABLE);\n        }\n\n        // While we could call `_finishNumberLeadingZeroes()`, let's try checking\n        // the very first char after first zero since the most common case is that\n        // there is a separator\n\n        int ch = _inputBuffer[ptr++] & 0xFF;\n        // one early check: leading zeroes may or may not be allowed\n        if (ch < INT_0) {\n            if (ch == INT_PERIOD) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n        } else if (ch > INT_9) {\n            if (ch == INT_e || ch == INT_E) {\n                _inputPtr = ptr;\n                _intLength = 1;\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                outBuf[0] = '0';\n                return _startFloat(outBuf, 1, ch);\n            }\n            // Ok; unfortunately we have closing bracket/curly that are valid so need\n            // (colon not possible since this is within value, not after key)\n            // \n            if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                reportUnexpectedNumberChar(ch,\n                        \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n            }\n        } else { // leading zero case (zero followed by a digit)\n            // leave inputPtr as is (i.e. \"push back\" digit)\n            return _finishNumberLeadingZeroes();\n        }\n        // leave _inputPtr as-is, to push back byte we checked\n        return _valueCompleteInt(0, \"0\");\n    }\n\n    protected JsonToken _finishNumberMinus(int ch) throws IOException\n    {\n        if (ch <= INT_0) {\n            if (ch == INT_0) {\n                return _finishNumberLeadingNegZeroes();\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        } else if (ch > INT_9) {\n            if (ch == 'I') {\n                return _finishNonStdToken(NON_STD_TOKEN_MINUS_INFINITY, 2);\n            }\n            reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        }\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        outBuf[0] = '-';\n        outBuf[1] = (char) ch;\n        _intLength = 1;\n        return _finishNumberIntegralPart(outBuf, 2);\n    }\n\n    protected JsonToken _finishNumberLeadingZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_ZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 1, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 0 and 9\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 1);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberLeadingNegZeroes() throws IOException\n    {\n        // In general, skip further zeroes (if allowed), look for legal follow-up\n        // numeric characters; likely legal separators, or, known illegal (letters).\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_MINUSZERO;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n            } else if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                    outBuf[0] = '-';\n                    outBuf[1] = '0';\n                    _intLength = 1;\n                    return _startFloat(outBuf, 2, ch);\n                }\n                // Ok; unfortunately we have closing bracket/curly that are valid so need\n                // (colon not possible since this is within value, not after key)\n                // \n                if ((ch != INT_RBRACKET) && (ch != INT_RCURLY)) {\n                    reportUnexpectedNumberChar(ch,\n                            \"expected digit (0-9), decimal point (.) or exponent indicator (e/E) to follow '0'\");\n                }\n            } else { // Number between 1 and 9; go integral\n                // although not guaranteed, seems likely valid separator (white space,\n                // comma, end bracket/curly); next time token needed will verify\n                if ((_features & FEAT_MASK_LEADING_ZEROS) == 0) {\n                    reportInvalidNumber(\"Leading zeroes not allowed\");\n                }\n                if (ch == INT_0) { // coalesce multiple leading zeroes into just one\n                    continue;\n                }\n                char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n                // trim out leading zero\n                outBuf[0] = '-';\n                outBuf[1] = (char) ch;\n                _intLength = 1;\n                return _finishNumberIntegralPart(outBuf, 2);\n            }\n            --_inputPtr;\n            return _valueCompleteInt(0, \"0\");\n        }\n    }\n\n    protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws IOException\n    {\n        int negMod = _numberNegative ? -1 : 0;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_INTEGER_DIGITS;\n                _textBuffer.setCurrentLength(outPtr);\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (ch < INT_0) {\n                if (ch == INT_PERIOD) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            if (ch > INT_9) {\n                if (ch == INT_e || ch == INT_E) {\n                    _intLength = outPtr+negMod;\n                    ++_inputPtr;\n                    return _startFloat(outBuf, outPtr, ch);\n                }\n                break;\n            }\n            ++_inputPtr;\n            if (outPtr >= outBuf.length) {\n                // NOTE: must expand to ensure contents all in a single buffer (to keep\n                // other parts of parsing simpler)\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n        }\n        _intLength = outPtr+negMod;\n        _textBuffer.setCurrentLength(outPtr);\n        return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n    }\n\n    protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws IOException\n    {\n        int fractLen = 0;\n        if (ch == INT_PERIOD) {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = '.';\n            while (true) {\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_FRACTION_DIGITS;\n                    _fractLength = fractLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n                if (ch < INT_0 || ch > INT_9) {\n                    ch &= 0xFF; // but here we'll want to mask it to unsigned 8-bit\n                    // must be followed by sequence of ints, one minimum\n                    if (fractLen == 0) {\n                        reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                    }\n                    break;\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                ++fractLen;\n            }\n        }\n        _fractLength = fractLen;\n        int expLen = 0;\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                _expLength = 0;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            ch = _inputBuffer[_inputPtr++]; // ok to have sign extension for now\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            while (ch >= INT_0 && ch <= INT_9) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.expandCurrentSegment();\n                }\n                outBuf[outPtr++] = (char) ch;\n                if (_inputPtr >= _inputEnd) {\n                    _textBuffer.setCurrentLength(outPtr);\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = expLen;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            ch &= 0xFF;\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatFraction() throws IOException\n    {\n        int fractLen = _fractLength;\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        // caller guarantees at least one char; also, sign-extension not needed here\n        int ch;\n        while (((ch = _inputBuffer[_inputPtr++]) >= INT_0) && (ch <= INT_9)) {\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _fractLength = fractLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n        }\n        \n        // Ok, fraction done; what have we got next?\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n        }\n        _fractLength = fractLen;\n        _textBuffer.setCurrentLength(outPtr);\n\n        // Ok: end of floating point number or exponent?\n        if (ch == INT_e || ch == INT_E) { // exponent?\n            _textBuffer.append((char) ch);\n            _expLength = 0;\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_NUMBER_EXPONENT_MARKER;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            return _finishFloatExponent(true, _inputBuffer[_inputPtr++] & 0xFF);\n        }\n\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = 0;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws IOException\n    {\n        if (checkSign) {\n            _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                _textBuffer.append((char) ch);\n                if (_inputPtr >= _inputEnd) {\n                    _minorState = MINOR_NUMBER_EXPONENT_DIGITS;\n                    _expLength = 0;\n                    return JsonToken.NOT_AVAILABLE;\n                }\n                ch = _inputBuffer[_inputPtr++];\n            }\n        }\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int expLen = _expLength;\n\n        while (ch >= INT_0 && ch <= INT_9) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.expandCurrentSegment();\n            }\n            outBuf[outPtr++] = (char) ch;\n            if (_inputPtr >= _inputEnd) {\n                _textBuffer.setCurrentLength(outPtr);\n                _expLength = expLen;\n                return JsonToken.NOT_AVAILABLE;\n            }\n            ch = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        ch &= 0xFF;\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n        }\n        // push back the last char\n        --_inputPtr;\n        _textBuffer.setCurrentLength(outPtr);\n        // negative, int-length, fract-length already set, so...\n        _expLength = expLen;\n        return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n    }\n\n    /*\n    /**********************************************************************\n    /* Name-decoding, tertiary decoding\n    /**********************************************************************\n     */\n\n    private final String _fastParseName() throws IOException\n    {\n        // If so, can also unroll loops nicely\n        // This may seem weird, but here we do NOT want to worry about UTF-8\n        // decoding. Rather, we'll assume that part is ok (if not it will be\n        // caught later on), and just handle quotes and backslashes here.\n\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n        int ptr = _inputPtr;\n\n        int q0 = input[ptr++] & 0xFF;\n        if (codes[q0] == 0) {\n            int i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                int q = (q0 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q = (q << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        q = (q << 8) | i;\n                        i = input[ptr++] & 0xFF;\n                        if (codes[i] == 0) {\n                            _quad1 = q;\n                            return _parseMediumName(ptr, i);\n                        }\n                        if (i == INT_QUOTE) { // 4 byte/char case or broken\n                            _inputPtr = ptr;\n                            return _findName(q, 4);\n                        }\n                        return null;\n                    }\n                    if (i == INT_QUOTE) { // 3 byte/char case or broken\n                        _inputPtr = ptr;\n                        return _findName(q, 3);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 2 byte/char case or broken\n                    _inputPtr = ptr;\n                    return _findName(q, 2);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // one byte/char case or broken\n                _inputPtr = ptr;\n                return _findName(q0, 1);\n            }\n            return null;\n        }\n        if (q0 == INT_QUOTE) {\n            _inputPtr = ptr;\n            return \"\";\n        }\n        return null;\n    }\n\n    private final String _parseMediumName(int ptr, int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Ok, got 5 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] == 0) {\n            q2 = (q2 << 8) | i;\n            i = input[ptr++] & 0xFF;\n            if (codes[i] == 0) {\n                q2 = (q2 << 8) | i;\n                i = input[ptr++] & 0xFF;\n                if (codes[i] == 0) {\n                    q2 = (q2 << 8) | i;\n                    i = input[ptr++] & 0xFF;\n                    if (codes[i] == 0) {\n                        return _parseMediumName2(ptr, i, q2);\n                    }\n                    if (i == INT_QUOTE) { // 8 bytes\n                        _inputPtr = ptr;\n                        return _findName(_quad1, q2, 4);\n                    }\n                    return null;\n                }\n                if (i == INT_QUOTE) { // 7 bytes\n                    _inputPtr = ptr;\n                    return _findName(_quad1, q2, 3);\n                }\n                return null;\n            }\n            if (i == INT_QUOTE) { // 6 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, 2);\n            }\n            return null;\n        }\n        if (i == INT_QUOTE) { // 5 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, 1);\n        }\n        return null;\n    }\n\n    private final String _parseMediumName2(int ptr, int q3, final int q2) throws IOException\n    {\n        final byte[] input = _inputBuffer;\n        final int[] codes = _icLatin1;\n\n        // Got 9 name bytes so far\n        int i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 9 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 1);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 10 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 2);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (codes[i] != 0) {\n            if (i == INT_QUOTE) { // 11 bytes\n                _inputPtr = ptr;\n                return _findName(_quad1, q2, q3, 3);\n            }\n            return null;\n        }\n        q3 = (q3 << 8) | i;\n        i = input[ptr++] & 0xFF;\n        if (i == INT_QUOTE) { // 12 bytes\n            _inputPtr = ptr;\n            return _findName(_quad1, q2, q3, 4);\n        }\n        // Could continue\n        return null;\n    }\n\n    /**\n     * Slower parsing method which is generally branched to when\n     * an escape sequence is detected (or alternatively for long\n     * names, one crossing input buffer boundary).\n     * Needs to be able to handle more exceptional cases, gets slower,\n     * and hence is offlined to a separate method.\n     */\n    private final JsonToken _parseEscapedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        // This may seem weird, but here we do not want to worry about\n        // UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n        // caught later on), and just handle quotes and backslashes here.\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (codes[ch] == 0) {\n                if (currQuadBytes < 4) {\n                    ++currQuadBytes;\n                    currQuad = (currQuad << 8) | ch;\n                    continue;\n                }\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n                continue;\n            }\n\n            // Otherwise bit longer handling\n            if (ch == INT_QUOTE) { // we are done\n                break;\n            }\n            // Unquoted white space?\n            if (ch != INT_BACKSLASH) {\n                // Call can actually now return (if unquoted linefeeds allowed)\n                _throwUnquotedSpace(ch, \"name\");\n            } else {\n                // Nope, escape sequence\n                ch = _decodeCharEscape();\n                if (ch < 0) { // method has set up state about escape sequence\n                    _minorState = MINOR_FIELD_NAME_ESCAPE;\n                    _minorStateAfterSplit = MINOR_FIELD_NAME;\n                    _quadLength = qlen;\n                    _pending32 = currQuad;\n                    _pendingBytes = currQuadBytes;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n            }\n\n            // May need to UTF-8 (re-)encode it, if it's beyond\n            // 7-bit ASCII. Gets pretty messy. If this happens often, may\n            // want to use different name canonicalization to avoid these hits.\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            if (ch > 127) {\n                // Ok, we'll need room for first byte right away\n                if (currQuadBytes >= 4) {\n                    quads[qlen++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                if (ch < 0x800) { // 2-byte\n                    currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                    ++currQuadBytes;\n                    // Second byte gets output below:\n                } else { // 3 bytes; no need to worry about surrogates here\n                    currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                    ++currQuadBytes;\n                    // need room for middle byte?\n                    if (currQuadBytes >= 4) {\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                    ++currQuadBytes;\n                }\n                // And same last byte in both cases, gets output below:\n                ch = 0x80 | (ch & 0x3f);\n            }\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n                continue;\n            }\n            quads[qlen++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare, but may happen\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an exception; but\n     * in non-standard modes may be able to parse name.\n     */\n    private JsonToken _handleOddName(int ch) throws IOException\n    {\n        // First: may allow single quotes\n        switch (ch) {\n        case '#':\n            // Careful, since this may alternatively be leading char of\n            // unquoted name...\n            if ((_features & FEAT_MASK_ALLOW_YAML_COMMENTS) != 0) {\n                return _finishHashComment(MINOR_FIELD_LEADING_WS);\n            }\n            break;\n        case '/':\n            return _startSlashComment(MINOR_FIELD_LEADING_WS);\n        case '\\'':\n            if ((_features & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {\n                return _finishAposName(0, 0, 0);\n            }\n            break;\n        case ']': // for better error reporting...\n            return _closeArrayScope();\n        }\n        // allow unquoted names if feature enabled:\n        if ((_features & FEAT_MASK_ALLOW_UNQUOTED_NAMES) == 0) {\n         // !!! TODO: Decode UTF-8 characters properly...\n//            char c = (char) _decodeCharForError(ch);\n            char c = (char) ch;\n            _reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n        }\n        // Also: note that although we use a different table here, it does NOT handle UTF-8\n        // decoding. It'll just pass those high-bit codes as acceptable for later decoding.\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n        // Also: must start with a valid character...\n        if (codes[ch] != 0) {\n            _reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n\n        return _finishUnquotedName(0, ch, 1);\n    }\n\n    /**\n     * Parsing of optionally supported non-standard \"unquoted\" names: names without\n     * either double-quotes or apostrophes surrounding them.\n     * Unlike other \n     */\n    private JsonToken _finishUnquotedName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = CharTypes.getInputCodeUtf8JsNames();\n\n        // Ok, now; instead of ultra-optimizing parsing here (as with regular JSON names),\n        // let's just use the generic \"slow\" variant. Can measure its impact later on if need be.\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_UNQUOTED_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr] & 0xFF;\n            if (codes[ch] != 0) {\n                break;\n            }\n            ++_inputPtr;\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = currQuad;\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    private JsonToken _finishAposName(int qlen, int currQuad, int currQuadBytes)\n        throws IOException\n    {\n        int[] quads = _quadBuffer;\n        final int[] codes = _icLatin1;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                _quadLength = qlen;\n                _pending32 = currQuad;\n                _pendingBytes = currQuadBytes;\n                _minorState = MINOR_FIELD_APOS_NAME;\n                return (_currToken = JsonToken.NOT_AVAILABLE);\n            }\n            int ch = _inputBuffer[_inputPtr++] & 0xFF;\n            if (ch == INT_APOS) {\n                break;\n            }\n            // additional check to skip handling of double-quotes\n            if (ch != '\"' && codes[ch] != 0) {\n                if (ch != '\\\\') {\n                    // Unquoted white space?\n                    _throwUnquotedSpace(ch, \"name\");\n                } else {\n                    // Nope, escape sequence\n                    ch = _decodeCharEscape();\n                    if (ch < 0) { // method has set up state about escape sequence\n                        _minorState = MINOR_FIELD_NAME_ESCAPE;\n                        _minorStateAfterSplit = MINOR_FIELD_APOS_NAME;\n                        _quadLength = qlen;\n                        _pending32 = currQuad;\n                        _pendingBytes = currQuadBytes;\n                        return (_currToken = JsonToken.NOT_AVAILABLE);\n                    }\n                }\n                if (ch > 127) {\n                    // Ok, we'll need room for first byte right away\n                    if (currQuadBytes >= 4) {\n                        if (qlen >= quads.length) {\n                            _quadBuffer = quads = growArrayBy(quads, quads.length);\n                        }\n                        quads[qlen++] = currQuad;\n                        currQuad = 0;\n                        currQuadBytes = 0;\n                    }\n                    if (ch < 0x800) { // 2-byte\n                        currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                        ++currQuadBytes;\n                        // Second byte gets output below:\n                    } else { // 3 bytes; no need to worry about surrogates here\n                        currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                        ++currQuadBytes;\n                        // need room for middle byte?\n                        if (currQuadBytes >= 4) {\n                            if (qlen >= quads.length) {\n                                _quadBuffer = quads = growArrayBy(quads, quads.length);\n                            }\n                            quads[qlen++] = currQuad;\n                            currQuad = 0;\n                            currQuadBytes = 0;\n                        }\n                        currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                        ++currQuadBytes;\n                    }\n                    // And same last byte in both cases, gets output below:\n                    ch = 0x80 | (ch & 0x3f);\n                }\n            }\n            // Ok, we have one more byte to add at any rate:\n            if (currQuadBytes < 4) {\n                ++currQuadBytes;\n                currQuad = (currQuad << 8) | ch;\n            } else {\n                if (qlen >= quads.length) {\n                    _quadBuffer = quads = growArrayBy(quads, quads.length);\n                }\n                quads[qlen++] = currQuad;\n                currQuad = ch;\n                currQuadBytes = 1;\n            }\n        }\n\n        if (currQuadBytes > 0) {\n            if (qlen >= quads.length) {\n                _quadBuffer = quads = growArrayBy(quads, quads.length);\n            }\n            quads[qlen++] = _padLastQuad(currQuad, currQuadBytes);\n        } else if (qlen == 0) { // rare case but possible\n            return _fieldComplete(\"\");\n        }\n        String name = _symbols.findName(quads, qlen);\n        if (name == null) {\n            name = _addName(quads, qlen, currQuadBytes);\n        }\n        return _fieldComplete(name);\n    }\n\n    protected final JsonToken _finishFieldWithEscape() throws IOException\n    {\n        // First: try finishing what wasn't yet:\n        int ch = _decodeSplitEscaped(_quoted32, _quotedDigits);\n        if (ch < 0) { // ... if possible\n            _minorState = MINOR_FIELD_NAME_ESCAPE;\n            return JsonToken.NOT_AVAILABLE;\n        }\n        if (_quadLength >= _quadBuffer.length) {\n            _quadBuffer = growArrayBy(_quadBuffer, 32);\n        }\n        int currQuad = _pending32;\n        int currQuadBytes = _pendingBytes;\n        if (ch > 127) {\n            // Ok, we'll need room for first byte right away\n            if (currQuadBytes >= 4) {\n                _quadBuffer[_quadLength++] = currQuad;\n                currQuad = 0;\n                currQuadBytes = 0;\n            }\n            if (ch < 0x800) { // 2-byte\n                currQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n                ++currQuadBytes;\n                // Second byte gets output below:\n            } else { // 3 bytes; no need to worry about surrogates here\n                currQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n                // need room for middle byte?\n                if (++currQuadBytes >= 4) {\n                    _quadBuffer[_quadLength++] = currQuad;\n                    currQuad = 0;\n                    currQuadBytes = 0;\n                }\n                currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n                ++currQuadBytes;\n            }\n            // And same last byte in both cases, gets output below:\n            ch = 0x80 | (ch & 0x3f);\n        }\n        if (currQuadBytes < 4) {\n            ++currQuadBytes;\n            currQuad = (currQuad << 8) | ch;\n        } else {\n            _quadBuffer[_quadLength++] = currQuad;\n            currQuad = ch;\n            currQuadBytes = 1;\n        }\n        if (_minorStateAfterSplit == MINOR_FIELD_APOS_NAME) {\n            return _finishAposName(_quadLength, currQuad, currQuadBytes);\n        }\n        return _parseEscapedName(_quadLength, currQuad, currQuadBytes);\n    }\n\n    private int _decodeSplitEscaped(int value, int bytesRead) throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            _quoted32 = value;\n            _quotedDigits = bytesRead;\n            return -1;\n        }\n        int c = _inputBuffer[_inputPtr++];\n        if (bytesRead == -1) { // expecting first char after backslash\n            switch (c) {\n                // First, ones that are mapped\n            case 'b':\n                return '\\b';\n            case 't':\n                return '\\t';\n            case 'n':\n                return '\\n';\n            case 'f':\n                return '\\f';\n            case 'r':\n                return '\\r';\n    \n                // And these are to be returned as they are\n            case '\"':\n            case '/':\n            case '\\\\':\n                return c;\n    \n            case 'u': // and finally hex-escaped\n                break;\n    \n            default:\n                {\n                 // !!! TODO: Decode UTF-8 characters properly...\n    //              char ch = (char) _decodeCharForError(c);\n                    char ch = (char) c;\n                    return _handleUnrecognizedCharacterEscape(ch);\n                }\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = 0;\n                _quoted32 = 0;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++];\n            bytesRead = 0;\n        }\n        c &= 0xFF;\n        while (true) {\n            int digit = CharTypes.charToHex(c);\n            if (digit < 0) {\n                _reportUnexpectedChar(c, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n            if (++bytesRead == 4) {\n                return value;\n            }\n            if (_inputPtr >= _inputEnd) {\n                _quotedDigits = bytesRead;\n                _quoted32 = value;\n                return -1;\n            }\n            c = _inputBuffer[_inputPtr++] & 0xFF;\n        }\n    }\n\n    /*\n    /**********************************************************************\n    /* Second-level decoding, String decoding\n    /**********************************************************************\n     */\n\n    protected JsonToken _startString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (codes[c] != 0) {\n                if (c == INT_QUOTE) {\n                    _inputPtr = ptr+1;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return _valueComplete(JsonToken.VALUE_STRING);\n                }\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishRegularString();\n    }\n\n    private final JsonToken _finishRegularString() throws IOException\n    {\n        int c;\n\n        // Here we do want to do full decoding, hence:\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            // Then the tight ASCII non-funny-char loop:\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if (codes[c] != 0) {\n                        break ascii_loop;\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Ok: end marker, escape or multi-byte?\n            if (c == INT_QUOTE) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }\n\n    protected JsonToken _startAposString() throws IOException\n    {\n        int ptr = _inputPtr;\n        int outPtr = 0;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        final int[] codes = _icUTF8;\n\n        final int max = Math.min(_inputEnd, (ptr + outBuf.length));\n        final byte[] inputBuffer = _inputBuffer;\n        while (ptr < max) {\n            int c = (int) inputBuffer[ptr] & 0xFF;\n            if (c == INT_APOS) {\n                _inputPtr = ptr+1;\n                _textBuffer.setCurrentLength(outPtr);\n                return _valueComplete(JsonToken.VALUE_STRING);\n            }\n\n            if (codes[c] != 0) {\n                break;\n            }\n            ++ptr;\n            outBuf[outPtr++] = (char) c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        _inputPtr = ptr;\n        return _finishAposString();\n    }\n\n    private final JsonToken _finishAposString() throws IOException\n    {\n        int c;\n        final int[] codes = _icUTF8;\n        final byte[] inputBuffer = _inputBuffer;\n\n        char[] outBuf = _textBuffer.getBufferWithoutReset();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        int ptr = _inputPtr;\n        final int safeEnd = _inputEnd - 5; // longest escape is 6 chars\n        \n        main_loop:\n        while (true) {\n            ascii_loop:\n            while (true) {\n                if (ptr >= _inputEnd) {\n                    _inputPtr = ptr;\n                    _minorState = MINOR_VALUE_APOS_STRING;\n                    _textBuffer.setCurrentLength(outPtr);\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\n                while (ptr < max) {\n                    c = inputBuffer[ptr++] & 0xFF;\n                    if ((codes[c] != 0) && (c != INT_QUOTE)) {\n                        break ascii_loop;\n                    }\n                    if (c == INT_APOS) {\n                        _inputPtr = ptr;\n                        _textBuffer.setCurrentLength(outPtr);\n                        return _valueComplete(JsonToken.VALUE_STRING);\n                    }\n                    outBuf[outPtr++] = (char) c;\n                }\n            }\n            // Escape or multi-byte?\n            // If possibly split, use off-lined longer version\n            if (ptr >= safeEnd) {\n                _inputPtr = ptr;\n                _textBuffer.setCurrentLength(outPtr);\n                if (!_decodeSplitMultiByte(c, codes[c], ptr < _inputEnd)) {\n                    _minorStateAfterSplit = MINOR_VALUE_APOS_STRING;\n                    return (_currToken = JsonToken.NOT_AVAILABLE);\n                }\n                outBuf = _textBuffer.getBufferWithoutReset();\n                outPtr = _textBuffer.getCurrentSegmentSize();\n                ptr = _inputPtr;\n                continue main_loop;\n            }\n            // otherwise use inlined\n            switch (codes[c]) {\n            case 1: // backslash\n                _inputPtr = ptr;\n                c = _decodeFastCharEscape(); // since we know it's not split\n                ptr = _inputPtr;\n                break;\n            case 2: // 2-byte UTF\n                c = _decodeUTF8_2(c, _inputBuffer[ptr++]);\n                break;\n            case 3: // 3-byte UTF\n                c = _decodeUTF8_3(c, _inputBuffer[ptr++], _inputBuffer[ptr++]);\n                break;\n            case 4: // 4-byte UTF\n                c = _decodeUTF8_4(c, _inputBuffer[ptr++], _inputBuffer[ptr++],\n                        _inputBuffer[ptr++]);\n                // Let's add first part right away:\n                outBuf[outPtr++] = (char) (0xD800 | (c >> 10));\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                c = 0xDC00 | (c & 0x3FF);\n                // And let the other char output down below\n                break;\n            default:\n                if (c < INT_SPACE) {\n                    // Note: call can now actually return (to allow unquoted linefeeds)\n                    _throwUnquotedSpace(c, \"string value\");\n                } else {\n                    // Is this good enough error message?\n                    _reportInvalidChar(c);\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = (char) c;\n        }\n    }\n    \n    private final boolean _decodeSplitMultiByte(int c, int type, boolean gotNext)\n            throws IOException\n    {\n        switch (type) {\n        case 1:\n            c = _decodeSplitEscaped(0, -1);\n            if (c < 0) {\n                _minorState = MINOR_VALUE_STRING_ESCAPE;\n                return false;\n            }\n            _textBuffer.append((char) c);\n            return true;\n        case 2: // 2-byte UTF; easy, either got both, or just miss one\n            if (gotNext) {\n                // NOTE: always succeeds, no need to check\n                c = _decodeUTF8_2(c, _inputBuffer[_inputPtr++]);\n                _textBuffer.append((char) c);\n                return true;\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_2;\n            _pending32 = c;\n            return false;\n        case 3: // 3-byte UTF\n            c &= 0x0F;\n            if (gotNext) {\n                return _decodeSplitUTF8_3(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _minorState = MINOR_VALUE_STRING_UTF8_3;\n            _pending32 = c;\n            _pendingBytes = 1;\n            return false;\n        case 4: // 4-byte UTF\n            c &= 0x07;\n            if (gotNext) {\n                return _decodeSplitUTF8_4(c, 1, _inputBuffer[_inputPtr++]);\n            }\n            _pending32 = c;\n            _pendingBytes = 1;\n            _minorState = MINOR_VALUE_STRING_UTF8_4;\n            return false;\n        default:\n            if (c < INT_SPACE) {\n                // Note: call can now actually return (to allow unquoted linefeeds)\n                _throwUnquotedSpace(c, \"string value\");\n            } else {\n                // Is this good enough error message?\n                _reportInvalidChar(c);\n            }\n            _textBuffer.append((char) c);\n            return true;\n        }\n    }\n\n    private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_3;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        _textBuffer.append((char) ((prev << 6) | (next & 0x3F)));\n        return true;\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final boolean _decodeSplitUTF8_4(int prev, int prevCount, int next)\n        throws IOException\n    {\n        if (prevCount == 1) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 2;\n                return false;\n            }\n            prevCount = 2;\n            next = _inputBuffer[_inputPtr++];\n        }\n        if (prevCount == 2) {\n            if ((next & 0xC0) != 0x080) {\n                _reportInvalidOther(next & 0xFF, _inputPtr);\n            }\n            prev = (prev << 6) | (next & 0x3F);\n            if (_inputPtr >= _inputEnd) {\n                _minorState = MINOR_VALUE_STRING_UTF8_4;\n                _pending32 = prev;\n                _pendingBytes = 3;\n                return false;\n            }\n            next = _inputBuffer[_inputPtr++];\n        }\n        if ((next & 0xC0) != 0x080) {\n            _reportInvalidOther(next & 0xFF, _inputPtr);\n        }\n        int c = ((prev << 6) | (next & 0x3F)) - 0x10000;\n        // Let's add first part right away:\n        _textBuffer.append((char) (0xD800 | (c >> 10)));\n        c = 0xDC00 | (c & 0x3FF);\n        // And let the other char output down below\n        _textBuffer.append((char) c);\n        return true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeCharEscape() throws IOException\n    {\n        int left = _inputEnd - _inputPtr;\n        if (left < 5) { // offline boundary-checking case:\n            return _decodeSplitEscaped(0, -1);\n        }\n        return _decodeFastCharEscape();\n    }\n\n    private final int _decodeFastCharEscape() throws IOException\n    {\n        int c = (int) _inputBuffer[_inputPtr++];\n        switch (c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return (char) c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            {\n             // !!! TODO: Decode UTF-8 characters properly...\n//              char ch = (char) _decodeCharForError(c);\n                char ch = (char) c;\n                return _handleUnrecognizedCharacterEscape(ch);\n            }\n        }\n\n        int ch = (int) _inputBuffer[_inputPtr++];\n        int digit = CharTypes.charToHex(ch);\n        int result = digit;\n\n        if (digit >= 0) {\n            ch = (int) _inputBuffer[_inputPtr++];\n            digit = CharTypes.charToHex(ch);\n            if (digit >= 0) {\n                result = (result << 4) | digit;\n                ch = (int) _inputBuffer[_inputPtr++];\n                digit = CharTypes.charToHex(ch);\n                if (digit >= 0) {\n                    result = (result << 4) | digit;\n                    ch = (int) _inputBuffer[_inputPtr++];\n                    digit = CharTypes.charToHex(ch);\n                    if (digit >= 0) {\n                        return (result << 4) | digit;\n                    }\n                }\n            }\n        }\n        _reportUnexpectedChar(ch & 0xFF, \"expected a hex-digit for character escape sequence\");\n        return -1;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, UTF8 decoding\n    /**********************************************************************\n     */\n\n    private final int _decodeUTF8_2(int c, int d) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        return ((c & 0x1F) << 6) | (d & 0x3F);\n    }\n\n    private final int _decodeUTF8_3(int c, int d, int e) throws IOException\n    {\n        c &= 0x0F;\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        return (c << 6) | (e & 0x3F);\n    }\n\n    // @return Character value <b>minus 0x10000</c>; this so that caller\n    //    can readily expand it to actual surrogates\n    private final int _decodeUTF8_4(int c, int d, int e, int f) throws IOException\n    {\n        if ((d & 0xC0) != 0x080) {\n            _reportInvalidOther(d & 0xFF, _inputPtr);\n        }\n        c = ((c & 0x07) << 6) | (d & 0x3F);\n        if ((e & 0xC0) != 0x080) {\n            _reportInvalidOther(e & 0xFF, _inputPtr);\n        }\n        c = (c << 6) | (e & 0x3F);\n        if ((f & 0xC0) != 0x080) {\n            _reportInvalidOther(f & 0xFF, _inputPtr);\n        }\n        return ((c << 6) | (f & 0x3F)) - 0x10000;\n    }\n\n    /*\n    /**********************************************************************\n    /* Internal methods, other\n    /**********************************************************************\n     */\n}\n"}, "generated_test_class": "Sure! Below are some unit tests for the `nextToken()` method of the `NonBlockingJsonParser` class. These tests are written in Java 1.7 and use JUnit 4 to maximize branch and line coverage. \n\nPlease note that since the actual implementation details of methods like `_finishTokenWithEOF()`, `_eofAsNextToken()`, `_finishToken()`, `_startDocument()`, `_startValue()`, etc., are not provided, I will mock or stub them where necessary. Additionally, some private fields like `_inputPtr`, `_inputEnd`, `_closed`, `_endOfInput`, `_currToken`, `_majorState`, etc., need to be accessed and modified, which may require additional setup (e.g., using reflection or changing the fields to package-private for test access).\n\nHere are the test cases:\n\n```java\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.core.JsonParser.Feature;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n\npublic class NonBlockingJsonParserTest {\n\n    private NonBlockingJsonParser parser;\n    private byte[] inputBuffer;\n    \n    @Before\n    public void setUp() throws Exception {\n        parser = spy(new NonBlockingJsonParser() {\n            @Override\n            public ByteArrayFeeder getNonBlockingInputFeeder() { return null; }\n            @Override\n            public final boolean needMoreInput() { return false; }\n            @Override\n            public void feedInput(byte[] buf, int start, int end) {}\n            @Override\n            public void endOfInput() {}\n            @Override\n            public int releaseBuffered(OutputStream out) { return 0; }\n        });\n        \n        inputBuffer = new byte[10];\n        parser._inputBuffer = inputBuffer;\n        parser._inputPtr = 0;\n        parser._inputEnd = 0;\n        parser._closed = false;\n        parser._endOfInput = false;\n        parser._currToken = JsonToken.NOT_AVAILABLE;\n        parser._majorState = NonBlockingJsonParser.MAJOR_INITIAL;\n    }\n\n    @Test\n    public void testNextToken_NoInput_Closed() throws IOException {\n        parser._closed = true;\n        assertNull(parser.nextToken());\n    }\n\n    @Test\n    public void testNextToken_NoInput_NotClosed_NoEndOfInput() throws IOException {\n        assertNull(parser.nextToken());\n    }\n\n    @Test\n    public void testNextToken_NoInput_NotClosed_EndOfInput_NotAvailableToken() throws IOException {\n        parser._endOfInput = true;\n        parser._currToken = JsonToken.NOT_AVAILABLE;\n        doReturn(JsonToken.END_OBJECT).when(parser)._finishTokenWithEOF();\n        assertEquals(JsonToken.END_OBJECT, parser.nextToken());\n    }\n\n    @Test\n    public void testNextToken_NoInput_NotClosed_EndOfInput_AvailableToken() throws IOException {\n        parser._endOfInput = true;\n        parser._currToken = JsonToken.START_OBJECT;\n        doReturn(JsonToken.END_OBJECT).when(parser)._eofAsNextToken();\n        assertEquals(JsonToken.END_OBJECT, parser.nextToken());\n    }\n\n    @Test\n    public void testNextToken_NotInTokenization() throws IOException {\n        parser._inputEnd = 1;\n        inputBuffer[0] = (byte) '{';\n        parser._currToken = JsonToken.START_OBJECT;\n        doReturn(JsonToken.START_OBJECT).when(parser)._finishToken();\n        assertEquals(JsonToken.START_OBJECT, parser.nextToken());\n    }\n\n    @Test\n    public void testNextToken_NewToken_MajorInitial() throws IOException {\n        parser._inputEnd = 1;\n        inputBuffer[0] = (byte) '{';\n        parser._currToken = JsonToken.NOT_AVAILABLE;\n        parser._majorState = NonBlockingJsonParser.MAJOR_INITIAL;\n        doReturn(JsonToken.START_OBJECT).when(parser)._startDocument((byte) '{');\n        assertEquals(JsonToken.START_OBJECT, parser.nextToken());\n    }\n\n    @Test\n    public void testNextToken_NewToken_MajorRoot() throws IOException {\n        parser._inputEnd = 1;\n        inputBuffer[0] = (byte) '0';\n        parser._currToken = JsonToken.NOT_AVAILABLE;\n        parser._majorState = NonBlockingJsonParser.MAJOR_ROOT;\n        doReturn(JsonToken.VALUE_NUMBER_INT).when(parser)._startValue((byte) '0');\n        assertEquals(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n    }\n\n    @Test\n    public void testNextToken_NewToken_MajorObjectFieldFirst() throws IOException {\n        parser._inputEnd = 1;\n        inputBuffer[0] = (byte) 'f';\n        parser._currToken = JsonToken.NOT_AVAILABLE;\n        parser._majorState = NonBlockingJsonParser.MAJOR_OBJECT_FIELD_FIRST;\n        doReturn(JsonToken.FIELD_NAME).when(parser)._startFieldName((byte) 'f');\n        assertEquals(JsonToken.FIELD_NAME, parser.nextToken());\n    }\n\n    @Test\n    public void testNextToken_NewToken_MajorObjectFieldNext() throws IOException {\n        parser._inputEnd = 1;\n        inputBuffer[0] = (byte) 'f';\n        parser._currToken = JsonToken.NOT_AVAILABLE;\n        parser._majorState = NonBlockingJsonParser.MAJOR_OBJECT_FIELD_NEXT;\n        doReturn(JsonToken.FIELD_NAME).when(parser)._startFieldNameAfterComma((byte) 'f');\n        assertEquals(JsonToken.FIELD_NAME, parser.nextToken());\n    }\n\n    @Test\n    public void testNextToken_NewToken_MajorObjectValue() throws IOException {\n        parser._inputEnd = 1;\n        inputBuffer[0] = (byte) ':';\n        parser._currToken = JsonToken.NOT_AVAILABLE;\n        parser._majorState = NonBlockingJsonParser.MAJOR_OBJECT_VALUE;\n        doReturn(JsonToken.VALUE_STRING).when(parser)._startValueExpectColon((byte) ':');\n        assertEquals(JsonToken.VALUE_STRING, parser.nextToken());\n    }\n\n    @Test\n    public void testNextToken_NewToken_MajorArrayElementFirst() throws IOException {\n        parser._inputEnd = 1;\n        inputBuffer[0] = (byte) '0';\n        parser._currToken = JsonToken.NOT_AVAILABLE;\n        parser._majorState = NonBlockingJsonParser.MAJOR_ARRAY_ELEMENT_FIRST;\n        doReturn(JsonToken.VALUE_NUMBER_INT).when(parser)._startValue((byte) '0');\n        assertEquals(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n    }\n\n    @Test\n    public void testNextToken_NewToken_MajorArrayElementNext() throws IOException {\n        parser._inputEnd = 1;\n        inputBuffer[0] = (byte) '0';\n        parser._currToken = JsonToken.NOT_AVAILABLE;\n        parser._majorState = NonBlockingJsonParser.MAJOR_ARRAY_ELEMENT_NEXT;\n        doReturn(JsonToken.VALUE_NUMBER_INT).when(parser)._startValueExpectComma((byte) '0');\n        assertEquals(JsonToken.VALUE_NUMBER_INT, parser.nextToken());\n    }\n\n    @Test(expected = IOException.class)\n    public void testNextToken_UnknownMajorState() throws IOException {\n        parser._inputEnd = 1;\n        parser._majorState = 999; // Unknown major state\n        parser.nextToken();\n    }\n\n    @Test\n    public void testNextToken_NotEnoughInput_SuppressIOException() throws IOException {\n        parser._inputEnd = 0;\n        parser.nextToken();  // should not throw IOException\n    }\n\n    @Test\n    public void testNextToken_NotEnoughInput_EndOfInput() throws IOException {\n        parser._inputPtr = 1;\n        parser._inputEnd = 1;\n        parser._endOfInput = true;\n        parser.nextToken();  // should not throw IOException\n    }\n\n    @Test\n    public void testNextToken_EmptyInputBuffer() throws IOException {\n        parser._inputEnd = 0;\n        parser.nextToken();  // should return NOT_AVAILABLE\n        assertEquals(JsonToken.NOT_AVAILABLE, parser.nextToken());\n    }\n}\n```\n\n### Explanation:\n1. **Setup**: The `setUp()` method initializes the `NonBlockingJsonParser` instance and sets up the required fields.\n2. **Test Cases**:\n   - `testNextToken_NoInput_Closed`: Tests the scenario when no input is available and the parser is closed.\n   - `testNextToken_NoInput_NotClosed_NoEndOfInput`: Tests the scenario when no input is available, the parser is not closed, and end of input has not been reached.\n   - `testNextToken_NoInput_NotClosed_EndOfInput_NotAvailableToken`: Tests the scenario when no input is available, the parser is not closed, end of input has been reached, and the current token is `NOT_AVAILABLE`.\n   - `testNextToken_NoInput_NotClosed_EndOfInput_AvailableToken`: Tests the scenario when no input is available, the parser is not closed, end of input has been reached, and the current token is not `NOT_AVAILABLE`.\n   - `testNextToken_NotInTokenization`: Tests the scenario when the parser is in the middle of tokenization.\n   - `testNextToken_NewToken_MajorInitial`: Tests the scenario when a new token is started in the `MAJOR_INITIAL` state.\n   - `testNextToken_NewToken_MajorRoot`: Tests the scenario when a new token is started in the `MAJOR_ROOT` state.\n   - `testNextToken_NewToken_MajorObjectFieldFirst`: Tests the scenario when a new token is started in the `MAJOR_OBJECT_FIELD_FIRST` state.\n   - `testNextToken_NewToken_MajorObjectFieldNext`: Tests the scenario when a new token is started in the `MAJOR_OBJECT_FIELD_NEXT` state.\n   - `testNextToken_NewToken_MajorObjectValue`: Tests the scenario when a new token is started in the `MAJOR_OBJECT_VALUE` state.\n   - `testNextToken_NewToken_MajorArrayElementFirst`: Tests the scenario when a new token is started in the `MAJOR_ARRAY_ELEMENT_FIRST` state.\n   - `testNextToken_NewToken_MajorArrayElementNext`: Tests the scenario when a new token is started in the `MAJOR_ARRAY_ELEMENT_NEXT` state.\n   - `testNextToken_UnknownMajorState`: Tests the scenario when an unknown major state is encountered, expecting an `IOException`.\n   - `testNextToken_NotEnoughInput_SuppressIOException`: Tests the scenario when there is not enough input, and it should not throw an `IOException`.\n   - `testNextToken_NotEnoughInput_EndOfInput`: Tests the scenario when there is not enough input and end of input has been reached.\n   - `testNextToken_EmptyInputBuffer`: Tests the scenario when the input buffer is empty.\n\nThese tests ensure that various branches and lines in the `nextToken()` method are executed, providing good coverage."}
{"bug_id": "JacksonCore_25", "version": "fixed", "focal_method_signature": "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#releaseBuffered(Writer#w)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_25/fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java", "focal_method": "@Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }", "return_type": "int", "assertion_subject_candidates": ["int", "ObjectCodec com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCodec()", "Object com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getInputSource()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg)"], "focal_class": {"name": "ReaderBasedJsonParser", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_25/fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java", "superclass": "extends ParserBase", "interface": "", "imports": ["import java.io.*;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.base.ParserBase;", "import com.fasterxml.jackson.core.io.CharTypes;", "import com.fasterxml.jackson.core.io.IOContext;", "import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;", "import com.fasterxml.jackson.core.util.*;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "protected Reader _reader", "protected char[] _inputBuffer", "protected boolean _bufferRecyclable", "protected ObjectCodec _objectCodec", "final protected CharsToNameCanonicalizer _symbols", "final protected int _hashSeed", "protected boolean _tokenIncomplete", "protected long _nameStartOffset", "protected int _nameStartRow", "protected int _nameStartCol"], "methods": ["ObjectCodec com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCodec()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#setCodec(ObjectCodec#c)", "Object com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getInputSource()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg)", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg,JsonToken#forToken)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_closeInput()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_releaseBuffers()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_loadMoreGuaranteed()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_loadMore()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getText()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getText(Writer#writer)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getValueAsString()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getValueAsString(String#defValue)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_getText2(JsonToken#t)", "char[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextCharacters()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextLength()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextOffset()", "byte[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_readBinary(Base64Variant#b64variant,OutputStream#out,byte[]#buffer)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextToken()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_nextAfterName()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#finishToken()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextFieldName(SerializableString#sstr)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextFieldName()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_isNextTokenNameYes(int#i)", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_isNextTokenNameMaybe(int#i,String#nameToMatch)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_nextTokenNotInObject(int#i)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextTextValue()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextIntValue(int#defaultValue)", "long com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextLongValue(long#defaultValue)", "Boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextBooleanValue()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parsePosNumber(int#ch)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseFloat(int#ch,int#startPtr,int#ptr,boolean#neg,int#intLen)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseNegNumber()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseNumber2(boolean#neg,int#startPtr)", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyNoLeadingZeroes()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyNLZ2()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleInvalidNumberStart(int#ch,boolean#negative)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyRootSpace(int#ch)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseName()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseName2(int#startPtr,int#hash,int#endChar)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddName(int#i)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseAposName()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddValue(int#i)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleApos()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddName2(int#startPtr,int#hash,int[]#codes)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_finishString()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_finishString2()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipString()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipCR()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColon()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColon2(boolean#gotColon)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColonFast(int#ptr)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipComma(int#i)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipAfterComma2()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipWSOrEnd()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipWSOrEnd2()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipComment()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipCComment()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipYAMLComment()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipLine()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_decodeEscaped()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchTrue()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchFalse()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchNull()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchToken(String#matchStr,int#i)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchToken2(String#matchStr,int#i)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_checkMatchEnd(String#matchStr,int#i,int#c)", "byte[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_decodeBase64(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTokenLocation()", "JsonLocation com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCurrentLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_updateLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_updateNameLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_reportInvalidToken(String#matchedPart)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_reportInvalidToken(String#matchedPart,String#msg)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_closeScope(int#i)"], "other_methods": ["@Override public ObjectCodec getCodec();", "@Override public void setCodec(ObjectCodec c);", "@Override public Object getInputSource();", "@Override\n    public final String getText();", "@Override // since 2.8\n    public int getText(Writer writer);", "@Override\n    public final String getValueAsString();", "@Override\n    public final String getValueAsString(String defValue);", "@Override\n    public final char[] getTextCharacters();", "@Override\n    public final int getTextLength();", "@Override\n    public final int getTextOffset();", "@Override\n    public byte[] getBinaryValue(Base64Variant b64variant);", "@Override\n    public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override\n    public final JsonToken nextToken();", "@Override\n    public void finishToken();", "@Override\n    public boolean nextFieldName(SerializableString sstr);", "@Override\n    public String nextFieldName();", "@Override\n    public final String nextTextValue();", "@Override\n    public final int nextIntValue(int defaultValue);", "@Override\n    public final long nextLongValue(long defaultValue);", "@Override\n    public final Boolean nextBooleanValue();", "@Override\n    public JsonLocation getTokenLocation();", "@Override\n    public JsonLocation getCurrentLocation();"], "fields_dict": {"int#FEAT_MASK_TRAILING_COMMA": "protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "int[]#_icLatin1": "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "Reader#_reader": "protected Reader _reader", "char[]#_inputBuffer": "protected char[] _inputBuffer", "boolean#_bufferRecyclable": "protected boolean _bufferRecyclable", "ObjectCodec#_objectCodec": "protected ObjectCodec _objectCodec", "CharsToNameCanonicalizer#_symbols": "final protected CharsToNameCanonicalizer _symbols", "int#_hashSeed": "final protected int _hashSeed", "boolean#_tokenIncomplete": "protected boolean _tokenIncomplete", "long#_nameStartOffset": "protected long _nameStartOffset", "int#_nameStartRow": "protected int _nameStartRow", "int#_nameStartCol": "protected int _nameStartCol"}, "text": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}\n"}, "generated_test_class": "To write unit tests for the `releaseBuffered` method in the `ReaderBasedJsonParser` class, we need to simulate various scenarios to ensure that all branches and lines of the method are covered. Here are some test cases that will help achieve this:\n\n1. **Test with empty buffer**: When `_inputEnd` equals `_inputPtr`, the method should return 0.\n2. **Test with non-empty buffer**: When `_inputEnd` is greater than `_inputPtr`, the method should write the buffered content to the writer and return the count of characters written.\n3. **Test with writer throwing an exception**: To ensure the method handles `IOException` correctly when the writer fails.\n\nLet's create the unit tests using JUnit 4:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\nimport java.io.IOException;\nimport java.io.Writer;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.*;\n\npublic class ReaderBasedJsonParserTest {\n\n    @Mock\n    private Writer mockWriter;\n\n    private ReaderBasedJsonParser parser;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        parser = new ReaderBasedJsonParser() {\n            @Override\n            public ObjectCodec getCodec() {\n                return null;\n            }\n\n            @Override\n            public void setCodec(ObjectCodec c) {\n            }\n\n            @Override\n            public Object getInputSource() {\n                return null;\n            }\n\n            @Override\n            public String getText() {\n                return null;\n            }\n\n            @Override\n            public int getText(Writer writer) {\n                return 0;\n            }\n\n            @Override\n            public String getValueAsString() {\n                return null;\n            }\n\n            @Override\n            public String getValueAsString(String defValue) {\n                return null;\n            }\n\n            @Override\n            public char[] getTextCharacters() {\n                return new char[0];\n            }\n\n            @Override\n            public int getTextLength() {\n                return 0;\n            }\n\n            @Override\n            public int getTextOffset() {\n                return 0;\n            }\n\n            @Override\n            public byte[] getBinaryValue(Base64Variant b64variant) {\n                return new byte[0];\n            }\n\n            @Override\n            public int readBinaryValue(Base64Variant b64variant, OutputStream out) {\n                return 0;\n            }\n\n            @Override\n            public JsonToken nextToken() {\n                return null;\n            }\n\n            @Override\n            public void finishToken() {\n            }\n\n            @Override\n            public boolean nextFieldName(SerializableString sstr) {\n                return false;\n            }\n\n            @Override\n            public String nextFieldName() {\n                return null;\n            }\n\n            @Override\n            public String nextTextValue() {\n                return null;\n            }\n\n            @Override\n            public int nextIntValue(int defaultValue) {\n                return 0;\n            }\n\n            @Override\n            public long nextLongValue(long defaultValue) {\n                return 0L;\n            }\n\n            @Override\n            public Boolean nextBooleanValue() {\n                return null;\n            }\n\n            @Override\n            public JsonLocation getTokenLocation() {\n                return null;\n            }\n\n            @Override\n            public JsonLocation getCurrentLocation() {\n                return null;\n            }\n        };\n\n        // Initialize the parser with a sample buffer\n        parser._inputBuffer = \"SampleText\".toCharArray();\n        parser._inputPtr = 0;\n        parser._inputEnd = parser._inputBuffer.length;\n    }\n\n    @Test\n    public void testReleaseBuffered_EmptyBuffer() throws IOException {\n        parser._inputPtr = parser._inputEnd;\n        int result = parser.releaseBuffered(mockWriter);\n        assertEquals(0, result);\n        verify(mockWriter, never()).write(any(char[].class), anyInt(), anyInt());\n    }\n\n    @Test\n    public void testReleaseBuffered_NonEmptyBuffer() throws IOException {\n        int result = parser.releaseBuffered(mockWriter);\n        assertEquals(parser._inputBuffer.length, result);\n        verify(mockWriter).write(parser._inputBuffer, 0, parser._inputBuffer.length);\n    }\n\n    @Test(expected = IOException.class)\n    public void testReleaseBuffered_WriterThrowsException() throws IOException {\n        parser._inputPtr = 0;\n        parser._inputEnd = parser._inputBuffer.length;\n        doThrow(new IOException(\"Writer failed\")).when(mockWriter).write(any(char[].class), anyInt(), anyInt());\n        parser.releaseBuffered(mockWriter);\n    }\n}\n```\n\n### Explanation:\n1. **Setup**:\n   - We use Mockito to mock the `Writer` object.\n   - We create a subclass of `ReaderBasedJsonParser` to implement all abstract methods, making it possible to instantiate for testing.\n   - We initialize the buffer and pointers to simulate different scenarios.\n\n2. **Test Cases**:\n   - **Empty Buffer**: We set `_inputPtr` equal to `_inputEnd` and verify that the method returns 0 and the writer is never called.\n   - **Non-Empty Buffer**: We verify that the method writes the correct amount of characters to the writer and returns the correct count.\n   - **Writer Throws Exception**: We configure the mock writer to throw an `IOException` and verify that the exception is propagated.\n\nThese tests should provide good branch and line coverage for the `releaseBuffered` method."}
{"bug_id": "JacksonCore_25", "version": "fixed", "focal_method_signature": "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getText()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_25/fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java", "focal_method": "@Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }", "return_type": "String", "assertion_subject_candidates": ["String", "ObjectCodec com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCodec()", "Object com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getInputSource()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg)"], "focal_class": {"name": "ReaderBasedJsonParser", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_25/fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java", "superclass": "extends ParserBase", "interface": "", "imports": ["import java.io.*;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.base.ParserBase;", "import com.fasterxml.jackson.core.io.CharTypes;", "import com.fasterxml.jackson.core.io.IOContext;", "import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;", "import com.fasterxml.jackson.core.util.*;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "protected Reader _reader", "protected char[] _inputBuffer", "protected boolean _bufferRecyclable", "protected ObjectCodec _objectCodec", "final protected CharsToNameCanonicalizer _symbols", "final protected int _hashSeed", "protected boolean _tokenIncomplete", "protected long _nameStartOffset", "protected int _nameStartRow", "protected int _nameStartCol"], "methods": ["ObjectCodec com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCodec()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#setCodec(ObjectCodec#c)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#releaseBuffered(Writer#w)", "Object com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getInputSource()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg)", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg,JsonToken#forToken)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_closeInput()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_releaseBuffers()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_loadMoreGuaranteed()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_loadMore()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getText(Writer#writer)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getValueAsString()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getValueAsString(String#defValue)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_getText2(JsonToken#t)", "char[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextCharacters()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextLength()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextOffset()", "byte[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_readBinary(Base64Variant#b64variant,OutputStream#out,byte[]#buffer)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextToken()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_nextAfterName()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#finishToken()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextFieldName(SerializableString#sstr)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextFieldName()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_isNextTokenNameYes(int#i)", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_isNextTokenNameMaybe(int#i,String#nameToMatch)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_nextTokenNotInObject(int#i)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextTextValue()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextIntValue(int#defaultValue)", "long com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextLongValue(long#defaultValue)", "Boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextBooleanValue()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parsePosNumber(int#ch)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseFloat(int#ch,int#startPtr,int#ptr,boolean#neg,int#intLen)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseNegNumber()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseNumber2(boolean#neg,int#startPtr)", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyNoLeadingZeroes()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyNLZ2()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleInvalidNumberStart(int#ch,boolean#negative)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyRootSpace(int#ch)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseName()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseName2(int#startPtr,int#hash,int#endChar)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddName(int#i)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseAposName()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddValue(int#i)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleApos()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddName2(int#startPtr,int#hash,int[]#codes)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_finishString()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_finishString2()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipString()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipCR()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColon()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColon2(boolean#gotColon)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColonFast(int#ptr)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipComma(int#i)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipAfterComma2()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipWSOrEnd()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipWSOrEnd2()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipComment()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipCComment()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipYAMLComment()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipLine()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_decodeEscaped()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchTrue()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchFalse()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchNull()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchToken(String#matchStr,int#i)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchToken2(String#matchStr,int#i)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_checkMatchEnd(String#matchStr,int#i,int#c)", "byte[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_decodeBase64(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTokenLocation()", "JsonLocation com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCurrentLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_updateLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_updateNameLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_reportInvalidToken(String#matchedPart)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_reportInvalidToken(String#matchedPart,String#msg)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_closeScope(int#i)"], "other_methods": ["@Override public ObjectCodec getCodec();", "@Override public void setCodec(ObjectCodec c);", "@Override\n    public int releaseBuffered(Writer w);", "@Override public Object getInputSource();", "@Override // since 2.8\n    public int getText(Writer writer);", "@Override\n    public final String getValueAsString();", "@Override\n    public final String getValueAsString(String defValue);", "@Override\n    public final char[] getTextCharacters();", "@Override\n    public final int getTextLength();", "@Override\n    public final int getTextOffset();", "@Override\n    public byte[] getBinaryValue(Base64Variant b64variant);", "@Override\n    public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override\n    public final JsonToken nextToken();", "@Override\n    public void finishToken();", "@Override\n    public boolean nextFieldName(SerializableString sstr);", "@Override\n    public String nextFieldName();", "@Override\n    public final String nextTextValue();", "@Override\n    public final int nextIntValue(int defaultValue);", "@Override\n    public final long nextLongValue(long defaultValue);", "@Override\n    public final Boolean nextBooleanValue();", "@Override\n    public JsonLocation getTokenLocation();", "@Override\n    public JsonLocation getCurrentLocation();"], "fields_dict": {"int#FEAT_MASK_TRAILING_COMMA": "protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "int[]#_icLatin1": "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "Reader#_reader": "protected Reader _reader", "char[]#_inputBuffer": "protected char[] _inputBuffer", "boolean#_bufferRecyclable": "protected boolean _bufferRecyclable", "ObjectCodec#_objectCodec": "protected ObjectCodec _objectCodec", "CharsToNameCanonicalizer#_symbols": "final protected CharsToNameCanonicalizer _symbols", "int#_hashSeed": "final protected int _hashSeed", "boolean#_tokenIncomplete": "protected boolean _tokenIncomplete", "long#_nameStartOffset": "protected long _nameStartOffset", "int#_nameStartRow": "protected int _nameStartRow", "int#_nameStartCol": "protected int _nameStartCol"}, "text": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}\n"}, "generated_test_class": "Certainly! Below is a set of unit tests for the `getText` method in the `ReaderBasedJsonParser` class using JUnit 4. These tests aim to cover different branches and lines of the method.\n\nBefore we write the tests, let's create a mock or a simplified version of the `ReaderBasedJsonParser` class for testing purposes, as we need to control the state of `_currToken`, `_tokenIncomplete`, and `_textBuffer`.\n\n```java\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.core.util.TextBuffer;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\npublic class ReaderBasedJsonParserTest {\n\n    @Mock\n    private TextBuffer _textBuffer;\n\n    private ReaderBasedJsonParser parser;\n\n    @Before\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        parser = spy(new ReaderBasedJsonParser());\n        doReturn(_textBuffer).when(parser).getTextBuffer();\n    }\n\n    @Test\n    public void testGetText_StringValueToken() throws Exception {\n        // Arrange\n        parser._currToken = JsonToken.VALUE_STRING;\n        parser._tokenIncomplete = true;\n        String expectedText = \"Mock String\";\n        when(_textBuffer.contentsAsString()).thenReturn(expectedText);\n\n        // Act\n        String result = parser.getText();\n\n        // Assert\n        assertFalse(parser._tokenIncomplete);\n        verify(parser).finishString();\n        verify(_textBuffer).contentsAsString();\n        assertEquals(expectedText, result);\n    }\n\n    @Test\n    public void testGetText_StringValueTokenComplete() throws Exception {\n        // Arrange\n        parser._currToken = JsonToken.VALUE_STRING;\n        parser._tokenIncomplete = false;\n        String expectedText = \"Mock String\";\n        when(_textBuffer.contentsAsString()).thenReturn(expectedText);\n\n        // Act\n        String result = parser.getText();\n\n        // Assert\n        assertFalse(parser._tokenIncomplete);\n        verify(parser, never()).finishString();\n        verify(_textBuffer).contentsAsString();\n        assertEquals(expectedText, result);\n    }\n\n    @Test\n    public void testGetText_NotStringValueToken() throws Exception {\n        // Arrange\n        parser._currToken = JsonToken.VALUE_NUMBER_INT;\n        parser._tokenIncomplete = true; // This will be ignored for non-string tokens\n        String expectedText = \"Mock Text from getText2\";\n        when(parser._getText2(parser._currToken)).thenReturn(expectedText);\n\n        // Act\n        String result = parser.getText();\n\n        // Assert\n        assertFalse(parser._tokenIncomplete);\n        verify(parser, never()).finishString();\n        verify(parser)._getText2(parser._currToken);\n        assertEquals(expectedText, result);\n    }\n\n    @Test\n    public void testGetText_NullToken() throws Exception {\n        // Arrange\n        parser._currToken = null;\n        String expectedText = \"Mock Text from getText2\";\n        when(parser._getText2(parser._currToken)).thenReturn(expectedText);\n\n        // Act\n        String result = parser.getText();\n\n        // Assert\n        assertFalse(parser._tokenIncomplete);\n        verify(parser, never()).finishString();\n        verify(parser)._getText2(parser._currToken);\n        assertEquals(expectedText, result);\n    }\n\n    private class ReaderBasedJsonParser extends com.fasterxml.jackson.core.JsonParser {\n        protected JsonToken _currToken;\n        protected boolean _tokenIncomplete;\n        protected TextBuffer _textBuffer;\n\n        public ReaderBasedJsonParser() {\n            _textBuffer = new TextBuffer(null);\n        }\n\n        @Override\n        public JsonToken getCurrentToken() {\n            return _currToken;\n        }\n\n        @Override\n        public TextBuffer getTextBuffer() {\n            return _textBuffer;\n        }\n\n        @Override\n        public void finishString() {\n            // Mocked method to check if called\n        }\n\n        protected String _getText2(JsonToken t) {\n            // Mocked method to check if called\n            return \"Mock Text from getText2\";\n        }\n\n        @Override\n        public String getText() throws IOException {\n            JsonToken t = _currToken;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    finishString(); // only strings can be incomplete\n                }\n                return _textBuffer.contentsAsString();\n            }\n            return _getText2(t);\n        }\n\n        @Override\n        public int releaseBuffered(Writer w) { return 0; }\n        @Override public ObjectCodec getCodec() { return null; }\n        @Override public void setCodec(ObjectCodec c) { }\n        @Override public Object getInputSource() { return null; }\n        @Override public int getText(Writer writer) { return 0; }\n        @Override public String getValueAsString() { return null; }\n        @Override public String getValueAsString(String defValue) { return null; }\n        @Override public char[] getTextCharacters() { return new char[0]; }\n        @Override public int getTextLength() { return 0; }\n        @Override public int getTextOffset() { return 0; }\n        @Override public byte[] getBinaryValue(Base64Variant b64variant) { return new byte[0]; }\n        @Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) { return 0; }\n        @Override public JsonToken nextToken() { return null; }\n        @Override public void finishToken() { }\n        @Override public boolean nextFieldName(SerializableString sstr) { return false; }\n        @Override public String nextFieldName() { return null; }\n        @Override public String nextTextValue() { return null; }\n        @Override public int nextIntValue(int defaultValue) { return 0; }\n        @Override public long nextLongValue(long defaultValue) { return 0; }\n        @Override public Boolean nextBooleanValue() { return null; }\n        @Override public JsonLocation getTokenLocation() { return null; }\n        @Override public JsonLocation getCurrentLocation() { return null; }\n    }\n}\n```\n\n### Explanation:\n1. **Test for String Token with Incomplete Token**:\n   - Sets `_currToken` to `JsonToken.VALUE_STRING` and `_tokenIncomplete` to `true`.\n   - Mocks `_textBuffer.contentsAsString()` to return an expected string.\n   - Verifies that `finishString()` is called and the expected string is returned.\n\n2. **Test for String Token with Complete Token**:\n   - Sets `_currToken` to `JsonToken.VALUE_STRING` and `_tokenIncomplete` to `false`.\n   - Mocks `_textBuffer.contentsAsString()` to return an expected string.\n   - Verifies that `finishString()` is not called and the expected string is returned.\n\n3. **Test for Non-String Token**:\n   - Sets `_currToken` to `JsonToken.VALUE_NUMBER_INT` (non-string token).\n   - Sets `_tokenIncomplete` to `true` but verifies it will be ignored.\n   - Mocks `_getText2(JsonToken)` to return an expected string.\n   - Verifies that `_getText2(JsonToken)` is called and the expected string is returned.\n\n4. **Test for Null Token**:\n   - Sets `_currToken` to `null`.\n   - Mocks `_getText2(JsonToken)` to return an expected string.\n   - Verifies that `_getText2(JsonToken)` is called and the expected string is returned.\n\nThese tests ensure that we cover all branches of the `getText` method, maximizing both branch and line coverage."}
{"bug_id": "JacksonCore_25", "version": "fixed", "focal_method_signature": "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getText(Writer#writer)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_25/fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java", "focal_method": "@Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }", "return_type": "int", "assertion_subject_candidates": ["int", "ObjectCodec com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCodec()", "Object com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getInputSource()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg)"], "focal_class": {"name": "ReaderBasedJsonParser", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_25/fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java", "superclass": "extends ParserBase", "interface": "", "imports": ["import java.io.*;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.base.ParserBase;", "import com.fasterxml.jackson.core.io.CharTypes;", "import com.fasterxml.jackson.core.io.IOContext;", "import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;", "import com.fasterxml.jackson.core.util.*;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "protected Reader _reader", "protected char[] _inputBuffer", "protected boolean _bufferRecyclable", "protected ObjectCodec _objectCodec", "final protected CharsToNameCanonicalizer _symbols", "final protected int _hashSeed", "protected boolean _tokenIncomplete", "protected long _nameStartOffset", "protected int _nameStartRow", "protected int _nameStartCol"], "methods": ["ObjectCodec com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCodec()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#setCodec(ObjectCodec#c)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#releaseBuffered(Writer#w)", "Object com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getInputSource()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg)", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg,JsonToken#forToken)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_closeInput()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_releaseBuffers()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_loadMoreGuaranteed()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_loadMore()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getText()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getValueAsString()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getValueAsString(String#defValue)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_getText2(JsonToken#t)", "char[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextCharacters()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextLength()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextOffset()", "byte[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_readBinary(Base64Variant#b64variant,OutputStream#out,byte[]#buffer)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextToken()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_nextAfterName()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#finishToken()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextFieldName(SerializableString#sstr)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextFieldName()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_isNextTokenNameYes(int#i)", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_isNextTokenNameMaybe(int#i,String#nameToMatch)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_nextTokenNotInObject(int#i)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextTextValue()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextIntValue(int#defaultValue)", "long com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextLongValue(long#defaultValue)", "Boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextBooleanValue()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parsePosNumber(int#ch)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseFloat(int#ch,int#startPtr,int#ptr,boolean#neg,int#intLen)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseNegNumber()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseNumber2(boolean#neg,int#startPtr)", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyNoLeadingZeroes()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyNLZ2()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleInvalidNumberStart(int#ch,boolean#negative)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyRootSpace(int#ch)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseName()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseName2(int#startPtr,int#hash,int#endChar)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddName(int#i)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseAposName()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddValue(int#i)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleApos()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddName2(int#startPtr,int#hash,int[]#codes)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_finishString()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_finishString2()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipString()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipCR()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColon()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColon2(boolean#gotColon)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColonFast(int#ptr)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipComma(int#i)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipAfterComma2()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipWSOrEnd()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipWSOrEnd2()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipComment()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipCComment()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipYAMLComment()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipLine()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_decodeEscaped()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchTrue()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchFalse()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchNull()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchToken(String#matchStr,int#i)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchToken2(String#matchStr,int#i)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_checkMatchEnd(String#matchStr,int#i,int#c)", "byte[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_decodeBase64(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTokenLocation()", "JsonLocation com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCurrentLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_updateLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_updateNameLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_reportInvalidToken(String#matchedPart)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_reportInvalidToken(String#matchedPart,String#msg)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_closeScope(int#i)"], "other_methods": ["@Override public ObjectCodec getCodec();", "@Override public void setCodec(ObjectCodec c);", "@Override\n    public int releaseBuffered(Writer w);", "@Override public Object getInputSource();", "@Override\n    public final String getText();", "@Override\n    public final String getValueAsString();", "@Override\n    public final String getValueAsString(String defValue);", "@Override\n    public final char[] getTextCharacters();", "@Override\n    public final int getTextLength();", "@Override\n    public final int getTextOffset();", "@Override\n    public byte[] getBinaryValue(Base64Variant b64variant);", "@Override\n    public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override\n    public final JsonToken nextToken();", "@Override\n    public void finishToken();", "@Override\n    public boolean nextFieldName(SerializableString sstr);", "@Override\n    public String nextFieldName();", "@Override\n    public final String nextTextValue();", "@Override\n    public final int nextIntValue(int defaultValue);", "@Override\n    public final long nextLongValue(long defaultValue);", "@Override\n    public final Boolean nextBooleanValue();", "@Override\n    public JsonLocation getTokenLocation();", "@Override\n    public JsonLocation getCurrentLocation();"], "fields_dict": {"int#FEAT_MASK_TRAILING_COMMA": "protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "int[]#_icLatin1": "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "Reader#_reader": "protected Reader _reader", "char[]#_inputBuffer": "protected char[] _inputBuffer", "boolean#_bufferRecyclable": "protected boolean _bufferRecyclable", "ObjectCodec#_objectCodec": "protected ObjectCodec _objectCodec", "CharsToNameCanonicalizer#_symbols": "final protected CharsToNameCanonicalizer _symbols", "int#_hashSeed": "final protected int _hashSeed", "boolean#_tokenIncomplete": "protected boolean _tokenIncomplete", "long#_nameStartOffset": "protected long _nameStartOffset", "int#_nameStartRow": "protected int _nameStartRow", "int#_nameStartCol": "protected int _nameStartCol"}, "text": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `getText(Writer writer)` method in the `ReaderBasedJsonParser` class. These tests aim to maximize both branch and line coverage.\n\n```java\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.core.io.JsonLocation;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\n\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\npublic class ReaderBasedJsonParserTest {\n\n    private ReaderBasedJsonParser parser;\n    private JsonToken mockToken;\n    private StringWriter writer;\n    private JsonParser.ParsingContext mockParsingContext;\n\n    @Before\n    public void setUp() throws Exception {\n        parser = Mockito.spy(new ReaderBasedJsonParser(null, 0, null, null, 0, null));\n        mockToken = mock(JsonToken.class);\n        mockParsingContext = mock(JsonParser.ParsingContext.class);\n        writer = new StringWriter();\n        when(parser._currToken).thenReturn(mockToken);\n        when(parser._parsingContext).thenReturn(mockParsingContext);\n    }\n\n    @Test\n    public void testGetTextWithIncompleteStringToken() throws IOException {\n        // Setup\n        when(mockToken).thenReturn(JsonToken.VALUE_STRING);\n        parser._tokenIncomplete = true;\n\n        // Test\n        int result = parser.getText(writer);\n\n        // Verify\n        verify(parser, times(1))._finishString();\n        assertEquals(0, result); // Assuming _textBuffer.contentsToWriter(writer) returns 0\n    }\n\n    @Test\n    public void testGetTextWithCompleteStringToken() throws IOException {\n        // Setup\n        when(mockToken).thenReturn(JsonToken.VALUE_STRING);\n        parser._tokenIncomplete = false;\n        when(parser._textBuffer.contentsToWriter(writer)).thenReturn(5);\n\n        // Test\n        int result = parser.getText(writer);\n\n        // Verify\n        verify(parser, times(0))._finishString();\n        assertEquals(5, result);\n    }\n\n    @Test\n    public void testGetTextWithFieldNameToken() throws IOException {\n        // Setup\n        when(mockToken).thenReturn(JsonToken.FIELD_NAME);\n        String fieldName = \"fieldName\";\n        when(mockParsingContext.getCurrentName()).thenReturn(fieldName);\n\n        // Test\n        int result = parser.getText(writer);\n\n        // Verify\n        assertEquals(fieldName.length(), result);\n        assertEquals(fieldName, writer.toString());\n    }\n\n    @Test\n    public void testGetTextWithNumericToken() throws IOException {\n        // Setup\n        when(mockToken).thenReturn(mock(JsonToken.Numeric.class));\n        when(mockToken.asCharArray()).thenReturn(\"123\".toCharArray());\n        when(parser._textBuffer.contentsToWriter(writer)).thenReturn(3);\n\n        // Test\n        int result = parser.getText(writer);\n\n        // Verify\n        assertEquals(3, result);\n    }\n\n    @Test\n    public void testGetTextWithOtherToken() throws IOException {\n        // Setup\n        when(mockToken).thenReturn(JsonToken.START_OBJECT);\n        char[] ch = \"{}\".toCharArray();\n        when(mockToken.asCharArray()).thenReturn(ch);\n\n        // Test\n        int result = parser.getText(writer);\n\n        // Verify\n        assertEquals(ch.length, result);\n        assertEquals(\"{}\", writer.toString());\n    }\n\n    @Test\n    public void testGetTextWithNullToken() throws IOException {\n        // Setup\n        when(mockToken).thenReturn(null);\n\n        // Test\n        int result = parser.getText(writer);\n\n        // Verify\n        assertEquals(0, result);\n    }\n}\n```\n\n### Explanation of Tests\n\n1. **testGetTextWithIncompleteStringToken**:\n   - Tests the scenario where the current token is an incomplete string.\n   - Verifies that `_finishString()` is called and the result is 0.\n\n2. **testGetTextWithCompleteStringToken**:\n   - Tests the scenario where the current token is a complete string.\n   - Verifies that `_finishString()` is not called and the result is the length of the string written to the writer.\n\n3. **testGetTextWithFieldNameToken**:\n   - Tests the scenario where the current token is a field name.\n   - Verifies that the field name is written to the writer and the result is the length of the field name.\n\n4. **testGetTextWithNumericToken**:\n   - Tests the scenario where the current token is a numeric token.\n   - Verifies that the numeric value is written to the writer and the result is the length of the numeric value.\n\n5. **testGetTextWithOtherToken**:\n   - Tests the scenario where the current token is not a string, field name, or numeric token.\n   - Verifies that the token's character array is written to the writer and the result is the length of the character array.\n\n6. **testGetTextWithNullToken**:\n   - Tests the scenario where the current token is null.\n   - Verifies that the result is 0.\n\nThese tests ensure that all branches and lines of the `getText(Writer writer)` method are covered."}
{"bug_id": "JacksonCore_25", "version": "fixed", "focal_method_signature": "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getValueAsString()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_25/fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java", "focal_method": "@Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }", "return_type": "String", "assertion_subject_candidates": ["String", "ObjectCodec com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCodec()", "Object com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getInputSource()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg)"], "focal_class": {"name": "ReaderBasedJsonParser", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_25/fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java", "superclass": "extends ParserBase", "interface": "", "imports": ["import java.io.*;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.base.ParserBase;", "import com.fasterxml.jackson.core.io.CharTypes;", "import com.fasterxml.jackson.core.io.IOContext;", "import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;", "import com.fasterxml.jackson.core.util.*;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "protected Reader _reader", "protected char[] _inputBuffer", "protected boolean _bufferRecyclable", "protected ObjectCodec _objectCodec", "final protected CharsToNameCanonicalizer _symbols", "final protected int _hashSeed", "protected boolean _tokenIncomplete", "protected long _nameStartOffset", "protected int _nameStartRow", "protected int _nameStartCol"], "methods": ["ObjectCodec com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCodec()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#setCodec(ObjectCodec#c)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#releaseBuffered(Writer#w)", "Object com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getInputSource()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg)", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg,JsonToken#forToken)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_closeInput()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_releaseBuffers()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_loadMoreGuaranteed()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_loadMore()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getText()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getText(Writer#writer)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getValueAsString(String#defValue)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_getText2(JsonToken#t)", "char[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextCharacters()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextLength()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextOffset()", "byte[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_readBinary(Base64Variant#b64variant,OutputStream#out,byte[]#buffer)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextToken()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_nextAfterName()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#finishToken()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextFieldName(SerializableString#sstr)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextFieldName()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_isNextTokenNameYes(int#i)", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_isNextTokenNameMaybe(int#i,String#nameToMatch)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_nextTokenNotInObject(int#i)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextTextValue()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextIntValue(int#defaultValue)", "long com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextLongValue(long#defaultValue)", "Boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextBooleanValue()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parsePosNumber(int#ch)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseFloat(int#ch,int#startPtr,int#ptr,boolean#neg,int#intLen)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseNegNumber()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseNumber2(boolean#neg,int#startPtr)", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyNoLeadingZeroes()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyNLZ2()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleInvalidNumberStart(int#ch,boolean#negative)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyRootSpace(int#ch)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseName()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseName2(int#startPtr,int#hash,int#endChar)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddName(int#i)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseAposName()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddValue(int#i)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleApos()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddName2(int#startPtr,int#hash,int[]#codes)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_finishString()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_finishString2()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipString()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipCR()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColon()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColon2(boolean#gotColon)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColonFast(int#ptr)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipComma(int#i)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipAfterComma2()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipWSOrEnd()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipWSOrEnd2()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipComment()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipCComment()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipYAMLComment()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipLine()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_decodeEscaped()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchTrue()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchFalse()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchNull()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchToken(String#matchStr,int#i)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchToken2(String#matchStr,int#i)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_checkMatchEnd(String#matchStr,int#i,int#c)", "byte[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_decodeBase64(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTokenLocation()", "JsonLocation com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCurrentLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_updateLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_updateNameLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_reportInvalidToken(String#matchedPart)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_reportInvalidToken(String#matchedPart,String#msg)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_closeScope(int#i)"], "other_methods": ["@Override public ObjectCodec getCodec();", "@Override public void setCodec(ObjectCodec c);", "@Override\n    public int releaseBuffered(Writer w);", "@Override public Object getInputSource();", "@Override\n    public final String getText();", "@Override // since 2.8\n    public int getText(Writer writer);", "@Override\n    public final String getValueAsString(String defValue);", "@Override\n    public final char[] getTextCharacters();", "@Override\n    public final int getTextLength();", "@Override\n    public final int getTextOffset();", "@Override\n    public byte[] getBinaryValue(Base64Variant b64variant);", "@Override\n    public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override\n    public final JsonToken nextToken();", "@Override\n    public void finishToken();", "@Override\n    public boolean nextFieldName(SerializableString sstr);", "@Override\n    public String nextFieldName();", "@Override\n    public final String nextTextValue();", "@Override\n    public final int nextIntValue(int defaultValue);", "@Override\n    public final long nextLongValue(long defaultValue);", "@Override\n    public final Boolean nextBooleanValue();", "@Override\n    public JsonLocation getTokenLocation();", "@Override\n    public JsonLocation getCurrentLocation();"], "fields_dict": {"int#FEAT_MASK_TRAILING_COMMA": "protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "int[]#_icLatin1": "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "Reader#_reader": "protected Reader _reader", "char[]#_inputBuffer": "protected char[] _inputBuffer", "boolean#_bufferRecyclable": "protected boolean _bufferRecyclable", "ObjectCodec#_objectCodec": "protected ObjectCodec _objectCodec", "CharsToNameCanonicalizer#_symbols": "final protected CharsToNameCanonicalizer _symbols", "int#_hashSeed": "final protected int _hashSeed", "boolean#_tokenIncomplete": "protected boolean _tokenIncomplete", "long#_nameStartOffset": "protected long _nameStartOffset", "int#_nameStartRow": "protected int _nameStartRow", "int#_nameStartCol": "protected int _nameStartCol"}, "text": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}\n"}, "generated_test_class": "To write unit tests for the `getValueAsString()` method of the `ReaderBasedJsonParser` class, we need to mock the internal state of the parser to cover different branches. Since we don't have access to the `_currToken` field, we will assume it is package-private or accessible through a method for testing purposes. We will also need to mock the behavior of `_finishString()`, `_textBuffer.contentsAsString()`, and `getCurrentName()`.\n\nHere is how you can write the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.junit.MockitoJUnitRunner;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.io.CharTypes;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class ReaderBasedJsonParserTest {\n\n    @Mock\n    private ReaderBasedJsonParser.MockTextBuffer _textBuffer;\n\n    @Mock\n    private JsonToken _currToken;\n\n    @Mock\n    private JsonParser _parser;\n\n    private ReaderBasedJsonParser parser;\n\n    @Before\n    public void setUp() throws Exception {\n        MockitoAnnotations.initMocks(this);\n        parser = new ReaderBasedJsonParser(\n            null,\n            Feature.collectDefaults(),\n            mock(Reader.class),\n            null,\n            mock(CharsToNameCanonicalizer.class),\n            0\n        );\n\n        // Setting up mocks to simulate internal state\n        parser._textBuffer = _textBuffer;\n        parser._currToken = _currToken;\n        parser._tokenIncomplete = false;\n    }\n\n    @Test\n    public void testGetValueAsString_ValueString() throws Exception {\n        // Setup\n        when(_currToken).thenReturn(JsonToken.VALUE_STRING);\n        when(_textBuffer.contentsAsString()).thenReturn(\"testString\");\n\n        // Execute\n        String result = parser.getValueAsString();\n\n        // Verify\n        assertEquals(\"testString\", result);\n        verify(_textBuffer, never()).contentsAsString(); // _tokenIncomplete is false, so _finishString() is not called\n\n        // Setup for incomplete token\n        parser._tokenIncomplete = true;\n\n        // Execute\n        result = parser.getValueAsString();\n\n        // Verify\n        assertEquals(\"testString\", result);\n        verify(_textBuffer).contentsAsString(); // _tokenIncomplete is true, so _finishString() is called\n    }\n\n    @Test\n    public void testGetValueAsString_ValueString_IncompleteToken() throws Exception {\n        // Setup\n        when(_currToken).thenReturn(JsonToken.VALUE_STRING);\n        parser._tokenIncomplete = true;\n        doAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                parser._tokenIncomplete = false;\n                return null;\n            }\n        }).when(parser).finishToken();\n\n        when(_textBuffer.contentsAsString()).thenReturn(\"incompleteString\");\n\n        // Execute\n        String result = parser.getValueAsString();\n\n        // Verify\n        assertEquals(\"incompleteString\", result);\n        verify(parser).finishToken();\n        verify(_textBuffer).contentsAsString();\n    }\n\n    @Test\n    public void testGetValueAsString_FieldName() throws Exception {\n        // Setup\n        when(_currToken).thenReturn(JsonToken.FIELD_NAME);\n        when(parser.getCurrentName()).thenReturn(\"fieldName\");\n\n        // Execute\n        String result = parser.getValueAsString();\n\n        // Verify\n        assertEquals(\"fieldName\", result);\n        verify(parser).getCurrentName();\n    }\n\n    @Test\n    public void testGetValueAsString_NullToken() throws Exception {\n        // Setup\n        when(_currToken).thenReturn(null);\n        when(superValueAsString()).thenReturn(\"defaultValue\");\n\n        // Execute\n        String result = parser.getValueAsString();\n\n        // Verify\n        assertEquals(\"defaultValue\", result);\n    }\n\n    private String superValueAsString() {\n        return superValueAsStringHelper(null);\n    }\n\n    private String superValueAsStringHelper(String defValue) {\n        return defValue;\n    }\n\n    private class ReaderBasedJsonParser extends com.fasterxml.jackson.core.JsonParser {\n\n        public ReaderBasedJsonParser(\n            ObjectCodec codec,\n            int features,\n            Reader reader,\n            Object inputBuffer,\n            CharsToNameCanonicalizer symbols,\n            int hashSeed\n        ) {\n            super(codec, features, reader, inputBuffer, symbols, hashSeed);\n        }\n\n        @Override\n        public String getText() {\n            return null;\n        }\n\n        @Override\n        public JsonToken nextToken() throws IOException, JsonProcessingException {\n            return null;\n        }\n\n        @Override\n        public JsonParser skipChildren() throws IOException, JsonProcessingException {\n            return null;\n        }\n\n        @Override\n        public void close() throws IOException {\n        }\n\n        @Override\n        public Version version() {\n            return null;\n        }\n\n        @Override\n        public JsonToken currentToken() {\n            return _currToken;\n        }\n\n        @Override\n        public int getCurrentLocation() {\n            return 0;\n        }\n\n        @Override\n        public String getCurrentName() throws IOException, JsonProcessingException {\n            return null;\n        }\n\n        @Override\n        public String getValueAsString() throws IOException {\n            if (_currToken == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    finishToken(); // only strings can be incomplete\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (_currToken == JsonToken.FIELD_NAME) {\n                return getCurrentName();\n            }\n            return super.getValueAsString(null);\n        }\n\n        @Override\n        public String getValueAsString(String defaultValue) throws IOException {\n            return superValueAsStringHelper(defaultValue);\n        }\n    }\n\n    private class MockTextBuffer extends com.fasterxml.jackson.core.util.TextBuffer {\n        @Override\n        public String contentsAsString() {\n            return super.contentsAsString();\n        }\n    }\n}\n```\n\n### Explanation:\n1. **Setup**:\n   - We mock the internal state of the parser using Mockito.\n   - We set up the `_currToken` and `_textBuffer` fields to simulate different scenarios.\n\n2. **Test Cases**:\n   - **`testGetValueAsString_ValueString`**: Tests the case where the current token is `VALUE_STRING`. It checks both complete and incomplete tokens.\n   - **`testGetValueAsString_FieldName`**: Tests the case where the current token is `FIELD_NAME`.\n   - **`testGetValueAsString_NullToken`**: Tests the case where the current token is `null`.\n\n3. **Verification**:\n   - We verify that the correct methods are called and the expected results are returned.\n   \nThis should cover all branches and achieve high line coverage for the `getValueAsString()` method."}
{"bug_id": "JacksonCore_25", "version": "fixed", "focal_method_signature": "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getValueAsString(String#defValue)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_25/fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java", "focal_method": "@Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }", "return_type": "String", "assertion_subject_candidates": ["String", "ObjectCodec com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCodec()", "Object com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getInputSource()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg)"], "focal_class": {"name": "ReaderBasedJsonParser", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/JacksonCore_25/fixed/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java", "superclass": "extends ParserBase", "interface": "", "imports": ["import java.io.*;", "import com.fasterxml.jackson.core.*;", "import com.fasterxml.jackson.core.base.ParserBase;", "import com.fasterxml.jackson.core.io.CharTypes;", "import com.fasterxml.jackson.core.io.IOContext;", "import com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;", "import com.fasterxml.jackson.core.util.*;", "import static com.fasterxml.jackson.core.JsonTokenId.*;"], "fields": ["protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "protected Reader _reader", "protected char[] _inputBuffer", "protected boolean _bufferRecyclable", "protected ObjectCodec _objectCodec", "final protected CharsToNameCanonicalizer _symbols", "final protected int _hashSeed", "protected boolean _tokenIncomplete", "protected long _nameStartOffset", "protected int _nameStartRow", "protected int _nameStartCol"], "methods": ["ObjectCodec com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCodec()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#setCodec(ObjectCodec#c)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#releaseBuffered(Writer#w)", "Object com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getInputSource()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg)", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getNextChar(String#eofMsg,JsonToken#forToken)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_closeInput()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_releaseBuffers()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_loadMoreGuaranteed()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_loadMore()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getText()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getText(Writer#writer)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getValueAsString()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_getText2(JsonToken#t)", "char[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextCharacters()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextLength()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTextOffset()", "byte[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getBinaryValue(Base64Variant#b64variant)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#readBinaryValue(Base64Variant#b64variant,OutputStream#out)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_readBinary(Base64Variant#b64variant,OutputStream#out,byte[]#buffer)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextToken()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_nextAfterName()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#finishToken()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextFieldName(SerializableString#sstr)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextFieldName()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_isNextTokenNameYes(int#i)", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_isNextTokenNameMaybe(int#i,String#nameToMatch)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_nextTokenNotInObject(int#i)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextTextValue()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextIntValue(int#defaultValue)", "long com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextLongValue(long#defaultValue)", "Boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#nextBooleanValue()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parsePosNumber(int#ch)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseFloat(int#ch,int#startPtr,int#ptr,boolean#neg,int#intLen)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseNegNumber()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseNumber2(boolean#neg,int#startPtr)", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyNoLeadingZeroes()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyNLZ2()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleInvalidNumberStart(int#ch,boolean#negative)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_verifyRootSpace(int#ch)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseName()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseName2(int#startPtr,int#hash,int#endChar)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddName(int#i)", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_parseAposName()", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddValue(int#i)", "JsonToken com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleApos()", "String com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_handleOddName2(int#startPtr,int#hash,int[]#codes)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_finishString()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_finishString2()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipString()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipCR()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColon()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColon2(boolean#gotColon)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipColonFast(int#ptr)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipComma(int#i)", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipAfterComma2()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipWSOrEnd()", "int com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipWSOrEnd2()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipComment()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipCComment()", "boolean com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipYAMLComment()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_skipLine()", "char com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_decodeEscaped()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchTrue()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchFalse()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchNull()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchToken(String#matchStr,int#i)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_matchToken2(String#matchStr,int#i)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_checkMatchEnd(String#matchStr,int#i,int#c)", "byte[] com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_decodeBase64(Base64Variant#b64variant)", "JsonLocation com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getTokenLocation()", "JsonLocation com.fasterxml.jackson.core.json.ReaderBasedJsonParser#getCurrentLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_updateLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_updateNameLocation()", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_reportInvalidToken(String#matchedPart)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_reportInvalidToken(String#matchedPart,String#msg)", "void com.fasterxml.jackson.core.json.ReaderBasedJsonParser#_closeScope(int#i)"], "other_methods": ["@Override public ObjectCodec getCodec();", "@Override public void setCodec(ObjectCodec c);", "@Override\n    public int releaseBuffered(Writer w);", "@Override public Object getInputSource();", "@Override\n    public final String getText();", "@Override // since 2.8\n    public int getText(Writer writer);", "@Override\n    public final String getValueAsString();", "@Override\n    public final char[] getTextCharacters();", "@Override\n    public final int getTextLength();", "@Override\n    public final int getTextOffset();", "@Override\n    public byte[] getBinaryValue(Base64Variant b64variant);", "@Override\n    public int readBinaryValue(Base64Variant b64variant,OutputStream out);", "@Override\n    public final JsonToken nextToken();", "@Override\n    public void finishToken();", "@Override\n    public boolean nextFieldName(SerializableString sstr);", "@Override\n    public String nextFieldName();", "@Override\n    public final String nextTextValue();", "@Override\n    public final int nextIntValue(int defaultValue);", "@Override\n    public final long nextLongValue(long defaultValue);", "@Override\n    public final Boolean nextBooleanValue();", "@Override\n    public JsonLocation getTokenLocation();", "@Override\n    public JsonLocation getCurrentLocation();"], "fields_dict": {"int#FEAT_MASK_TRAILING_COMMA": "protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask()", "int[]#_icLatin1": "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1()", "Reader#_reader": "protected Reader _reader", "char[]#_inputBuffer": "protected char[] _inputBuffer", "boolean#_bufferRecyclable": "protected boolean _bufferRecyclable", "ObjectCodec#_objectCodec": "protected ObjectCodec _objectCodec", "CharsToNameCanonicalizer#_symbols": "final protected CharsToNameCanonicalizer _symbols", "int#_hashSeed": "final protected int _hashSeed", "boolean#_tokenIncomplete": "protected boolean _tokenIncomplete", "long#_nameStartOffset": "protected long _nameStartOffset", "int#_nameStartRow": "protected int _nameStartRow", "int#_nameStartCol": "protected int _nameStartCol"}, "text": "package com.fasterxml.jackson.core.json;\n\nimport java.io.*;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.base.ParserBase;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer;\nimport com.fasterxml.jackson.core.util.*;\n\nimport static com.fasterxml.jackson.core.JsonTokenId.*;\n\n/**\n * This is a concrete implementation of {@link JsonParser}, which is\n * based on a {@link java.io.Reader} to handle low-level character\n * conversion tasks.\n */\npublic class ReaderBasedJsonParser // final in 2.3, earlier\n    extends ParserBase\n{\n    protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();\n\n    // Latin1 encoding is not supported, but we do use 8-bit subset for\n    // pre-processing task, to simplify first pass, keep it fast.\n    protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n    /*\n    /**********************************************************\n    /* Input configuration\n    /**********************************************************\n     */\n\n    /**\n     * Reader that can be used for reading more content, if one\n     * buffer from input source, but in some cases pre-loaded buffer\n     * is handed to the parser.\n     */\n    protected Reader _reader;\n\n    /**\n     * Current buffer from which data is read; generally data is read into\n     * buffer from input source.\n     */\n    protected char[] _inputBuffer;\n\n    /**\n     * Flag that indicates whether the input buffer is recycable (and\n     * needs to be returned to recycler once we are done) or not.\n     *<p>\n     * If it is not, it also means that parser can NOT modify underlying\n     * buffer.\n     */\n    protected boolean _bufferRecyclable;\n\n    /*\n    /**********************************************************\n    /* Configuration\n    /**********************************************************\n     */\n\n    protected ObjectCodec _objectCodec;\n\n    final protected CharsToNameCanonicalizer _symbols;\n\n    final protected int _hashSeed;\n\n    /*\n    /**********************************************************\n    /* Parsing state\n    /**********************************************************\n     */\n\n    /**\n     * Flag that indicates that the current token has not yet\n     * been fully processed, and needs to be finished for\n     * some access (or skipped to obtain the next token)\n     */\n    protected boolean _tokenIncomplete;\n\n    /**\n     * Value of {@link #_inputPtr} at the time when the first character of\n     * name token was read. Used for calculating token location when requested;\n     * combined with {@link #_currInputProcessed}, may be updated appropriately\n     * as needed.\n     *\n     * @since 2.7\n     */\n    protected long _nameStartOffset;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartRow;\n\n    /**\n     * @since 2.7\n     */\n    protected int _nameStartCol;\n\n    /*\n    /**********************************************************\n    /* Life-cycle\n    /**********************************************************\n     */\n\n    /**\n     * Method called when caller wants to provide input buffer directly,\n     * and it may or may not be recyclable use standard recycle context.\n     *\n     * @since 2.4\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n            ObjectCodec codec, CharsToNameCanonicalizer st,\n            char[] inputBuffer, int start, int end,\n            boolean bufferRecyclable)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = inputBuffer;\n        _inputPtr = start;\n        _inputEnd = end;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = bufferRecyclable;\n    }\n\n    /**\n     * Method called when input comes as a {@link java.io.Reader}, and buffer allocation\n     * can be done using default mechanism.\n     */\n    public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\n        ObjectCodec codec, CharsToNameCanonicalizer st)\n    {\n        super(ctxt, features);\n        _reader = r;\n        _inputBuffer = ctxt.allocTokenBuffer();\n        _inputPtr = 0;\n        _inputEnd = 0;\n        _objectCodec = codec;\n        _symbols = st;\n        _hashSeed = st.hashSeed();\n        _bufferRecyclable = true;\n    }\n\n    /*\n    /**********************************************************\n    /* Base method defs, overrides\n    /**********************************************************\n     */\n\n    @Override public ObjectCodec getCodec() { return _objectCodec; }\n    @Override public void setCodec(ObjectCodec c) { _objectCodec = c; }\n\n    @Override\n    public int releaseBuffered(Writer w) throws IOException {\n        int count = _inputEnd - _inputPtr;\n        if (count < 1) { return 0; }\n        // let's just advance ptr to end\n        int origPtr = _inputPtr;\n        w.write(_inputBuffer, origPtr, count);\n        return count;\n    }\n\n    @Override public Object getInputSource() { return _reader; }\n\n    @Deprecated // since 2.8\n    protected char getNextChar(String eofMsg) throws IOException {\n        return getNextChar(eofMsg, null);\n    }\n    \n    protected char getNextChar(String eofMsg, JsonToken forToken) throws IOException {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(eofMsg, forToken);\n            }\n        }\n        return _inputBuffer[_inputPtr++];\n    }\n\n    @Override\n    protected void _closeInput() throws IOException {\n        /* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n         *   on the underlying Reader, unless we \"own\" it, or auto-closing\n         *   feature is enabled.\n         *   One downside is that when using our optimized\n         *   Reader (granted, we only do that for UTF-32...) this\n         *   means that buffer recycling won't work correctly.\n         */\n        if (_reader != null) {\n            if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n                _reader.close();\n            }\n            _reader = null;\n        }\n    }\n\n    /**\n     * Method called to release internal buffers owned by the base\n     * reader. This may be called along with {@link #_closeInput} (for\n     * example, when explicitly closing this reader instance), or\n     * separately (if need be).\n     */\n    @Override\n    protected void _releaseBuffers() throws IOException {\n        super._releaseBuffers();\n        // merge new symbols, if any\n        _symbols.release();\n        // and release buffers, if they are recyclable ones\n        if (_bufferRecyclable) {\n            char[] buf = _inputBuffer;\n            if (buf != null) {\n                _inputBuffer = null;\n                _ioContext.releaseTokenBuffer(buf);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Low-level access, supporting\n    /**********************************************************\n     */\n\n    protected void _loadMoreGuaranteed() throws IOException {\n        if (!_loadMore()) { _reportInvalidEOF(); }\n    }\n    \n    protected boolean _loadMore() throws IOException\n    {\n        final int bufSize = _inputEnd;\n\n        _currInputProcessed += bufSize;\n        _currInputRowStart -= bufSize;\n\n        // 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n        //   this increase to avoid \"moving\" name-offset, resulting most likely\n        //   in negative value, which is fine as combine value remains unchanged.\n        _nameStartOffset -= bufSize;\n\n        if (_reader != null) {\n            int count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\n            if (count > 0) {\n                _inputPtr = 0;\n                _inputEnd = count;\n                return true;\n            }\n            // End of input\n            _closeInput();\n            // Should never return 0, so let's fail\n            if (count == 0) {\n                throw new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n            }\n        }\n        return false;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, data access\n    /**********************************************************\n     */\n\n    /**\n     * Method for accessing textual representation of the current event;\n     * if no current event (before first call to {@link #nextToken}, or\n     * after encountering end-of-input), returns null.\n     * Method can be called for any event.\n     */\n    @Override\n    public final String getText() throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        return _getText2(t);\n    }\n\n    @Override // since 2.8\n    public int getText(Writer writer) throws IOException\n    {\n        JsonToken t = _currToken;\n        if (t == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsToWriter(writer);\n        }\n        if (t == JsonToken.FIELD_NAME) {\n            String n = _parsingContext.getCurrentName();\n            writer.write(n);\n            return n.length();\n        }\n        if (t != null) {\n            if (t.isNumeric()) {\n                return _textBuffer.contentsToWriter(writer);\n            }\n            char[] ch = t.asCharArray();\n            writer.write(ch);\n            return ch.length;\n        }\n        return 0;\n    }\n    \n    // // // Let's override default impls for improved performance\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString() throws IOException\n    {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(null);\n    }\n\n    // @since 2.1\n    @Override\n    public final String getValueAsString(String defValue) throws IOException {\n        if (_currToken == JsonToken.VALUE_STRING) {\n            if (_tokenIncomplete) {\n                _tokenIncomplete = false;\n                _finishString(); // only strings can be incomplete\n            }\n            return _textBuffer.contentsAsString();\n        }\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return getCurrentName();\n        }\n        return super.getValueAsString(defValue);\n    }\n\n    protected final String _getText2(JsonToken t) {\n        if (t == null) {\n            return null;\n        }\n        switch (t.id()) {\n        case ID_FIELD_NAME:\n            return _parsingContext.getCurrentName();\n\n        case ID_STRING:\n            // fall through\n        case ID_NUMBER_INT:\n        case ID_NUMBER_FLOAT:\n            return _textBuffer.contentsAsString();\n        default:\n            return t.asString();\n        }\n    }\n\n    @Override\n    public final char[] getTextCharacters() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                if (!_nameCopied) {\n                    String name = _parsingContext.getCurrentName();\n                    int nameLen = name.length();\n                    if (_nameCopyBuffer == null) {\n                        _nameCopyBuffer = _ioContext.allocNameCopyBuffer(nameLen);\n                    } else if (_nameCopyBuffer.length < nameLen) {\n                        _nameCopyBuffer = new char[nameLen];\n                    }\n                    name.getChars(0, nameLen, _nameCopyBuffer, 0);\n                    _nameCopied = true;\n                }\n                return _nameCopyBuffer;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextBuffer();\n            default:\n                return _currToken.asCharArray();\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public final int getTextLength() throws IOException\n    {\n        if (_currToken != null) { // null only before/after document\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return _parsingContext.getCurrentName().length();\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.size();\n            default:\n                return _currToken.asCharArray().length;\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public final int getTextOffset() throws IOException\n    {\n        // Most have offset of 0, only some may have other values:\n        if (_currToken != null) {\n            switch (_currToken.id()) {\n            case ID_FIELD_NAME:\n                return 0;\n            case ID_STRING:\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString(); // only strings can be incomplete\n                }\n                // fall through\n            case ID_NUMBER_INT:\n            case ID_NUMBER_FLOAT:\n                return _textBuffer.getTextOffset();\n            default:\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public byte[] getBinaryValue(Base64Variant b64variant) throws IOException\n    {\n        if ((_currToken == JsonToken.VALUE_EMBEDDED_OBJECT) && (_binaryValue != null)) {\n            return _binaryValue;\n        }\n        if (_currToken != JsonToken.VALUE_STRING) {\n            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n        }\n        // To ensure that we won't see inconsistent data, better clear up state\n        if (_tokenIncomplete) {\n            try {\n                _binaryValue = _decodeBase64(b64variant);\n            } catch (IllegalArgumentException iae) {\n                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n            }\n            /* let's clear incomplete only now; allows for accessing other\n             * textual content in error cases\n             */\n            _tokenIncomplete = false;\n        } else { // may actually require conversion...\n            if (_binaryValue == null) {\n                @SuppressWarnings(\"resource\")\n                ByteArrayBuilder builder = _getByteArrayBuilder();\n                _decodeBase64(getText(), builder, b64variant);\n                _binaryValue = builder.toByteArray();\n            }\n        }\n        return _binaryValue;\n    }\n\n    @Override\n    public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException\n    {\n        // if we have already read the token, just use whatever we may have\n        if (!_tokenIncomplete || _currToken != JsonToken.VALUE_STRING) {\n            byte[] b = getBinaryValue(b64variant);\n            out.write(b);\n            return b.length;\n        }\n        // otherwise do \"real\" incremental parsing...\n        byte[] buf = _ioContext.allocBase64Buffer();\n        try {\n            return _readBinary(b64variant, out, buf);\n        } finally {\n            _ioContext.releaseBase64Buffer(buf);\n        }\n    }\n\n    protected int _readBinary(Base64Variant b64variant, OutputStream out, byte[] buffer) throws IOException\n    {\n        int outputPtr = 0;\n        final int outputEnd = buffer.length - 3;\n        int outputCount = 0;\n\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) { // reached the end, fair and square?\n                if (ch == '\"') {\n                    break;\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n\n            // enough room? If not, flush\n            if (outputPtr > outputEnd) {\n                outputCount += outputPtr;\n                out.write(buffer, 0, outputPtr);\n                outputPtr = 0;\n            }\n\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get padding\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        buffer[outputPtr++] = (byte) (decodedData >> 8);\n                        buffer[outputPtr++] = (byte) decodedData;\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        break;\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    /* With padding we only get 2 bytes; but we have\n                     * to shift it a bit so it is identical to triplet\n                     * case with partial output.\n                     * 3 chars gives 3x6 == 18 bits, of which 2 are\n                     * dummies, need to discard:\n                     */\n                    decodedData >>= 2;\n                    buffer[outputPtr++] = (byte) (decodedData >> 8);\n                    buffer[outputPtr++] = (byte) decodedData;\n                    continue;\n                }\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            buffer[outputPtr++] = (byte) (decodedData >> 16);\n            buffer[outputPtr++] = (byte) (decodedData >> 8);\n            buffer[outputPtr++] = (byte) decodedData;\n        }\n        _tokenIncomplete = false;\n        if (outputPtr > 0) {\n            outputCount += outputPtr;\n            out.write(buffer, 0, outputPtr);\n        }\n        return outputCount;\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, traversal\n    /**********************************************************\n     */\n\n    /**\n     * @return Next token from the stream, if any found, or null\n     *   to indicate end-of-input\n     */\n    @Override\n    public final JsonToken nextToken() throws IOException\n    {\n        /* First: field names are special -- we will always tokenize\n         * (part of) value along with field name to simplify\n         * state handling. If so, can and need to use secondary token:\n         */\n        if (_currToken == JsonToken.FIELD_NAME) {\n            return _nextAfterName();\n        }\n        // But if we didn't already have a name, and (partially?) decode number,\n        // need to ensure no numeric information is leaked\n        _numTypesValid = NR_UNKNOWN;\n        if (_tokenIncomplete) {\n            _skipString(); // only strings can be partial\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) { // end-of-input\n            // Should actually close/release things\n            // like input source, symbol table and recyclable buffers now.\n            close();\n            return (_currToken = null);\n        }\n        // clear any data retained so far\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return _currToken;\n        }\n\n        // Nope: do we then expect a comma?\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return _currToken;\n                }\n            }\n        }\n\n        /* And should we now have a name? Always true for Object contexts, since\n         * the intermediate 'expect-value' state is never retained.\n         */\n        boolean inObject = _parsingContext.inObject();\n        if (inObject) {\n            // First, field name itself:\n            _updateNameLocation();\n            String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n            _parsingContext.setCurrentName(name);\n            _currToken = JsonToken.FIELD_NAME;\n            i = _skipColon();\n        }\n        _updateLocation();\n\n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case '}':\n            // Error: } is not valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n\n        case '-':\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicate by a more specific error message.\n             */\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n\n        if (inObject) {\n            _nextToken = t;\n            return _currToken;\n        }\n        _currToken = t;\n        return t;\n    }\n\n    private final JsonToken _nextAfterName()\n    {\n        _nameCopied = false; // need to invalidate if it was copied\n        JsonToken t = _nextToken;\n        _nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n        \n        // Also: may need to start new context?\n        if (t == JsonToken.START_ARRAY) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        } else if (t == JsonToken.START_OBJECT) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        return (_currToken = t);\n    }\n\n    @Override\n    public void finishToken() throws IOException {\n        if (_tokenIncomplete) {\n            _tokenIncomplete = false;\n            _finishString(); // only strings can be incomplete\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Public API, nextXxx() overrides\n    /**********************************************************\n     */\n\n    // Implemented since 2.7\n    @Override\n    public boolean nextFieldName(SerializableString sstr) throws IOException\n    {\n        // // // Note: most of code below is copied from nextToken()\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return false;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return false;\n        }\n        _binaryValue = null;\n\n        // Closing scope?\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return false;\n        }\n\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n\n            // Was that a trailing comma?\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return false;\n                }\n            }\n        }\n\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return false;\n        }\n\n        _updateNameLocation();\n        if (i == INT_QUOTE) {\n            // when doing literal match, must consider escaping:\n            char[] nameChars = sstr.asQuotedChars();\n            final int len = nameChars.length;\n\n            // Require 4 more bytes for faster skipping of colon that follows name\n            if ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n                // first check length match by\n                final int end = _inputPtr+len;\n                if (_inputBuffer[end] == '\"') {\n                    int offset = 0;\n                    int ptr = _inputPtr;\n                    while (true) {\n                        if (ptr == end) { // yes, match!\n                            _parsingContext.setCurrentName(sstr.getValue());\n                            _isNextTokenNameYes(_skipColonFast(ptr+1));\n                            return true;\n                        }\n                        if (nameChars[offset] != _inputBuffer[ptr]) {\n                            break;\n                        }\n                        ++offset;\n                        ++ptr;\n                    }\n                }\n            }\n        }\n        return _isNextTokenNameMaybe(i, sstr.getValue());\n    }\n\n    @Override\n    public String nextFieldName() throws IOException\n    {\n        // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n\n        _numTypesValid = NR_UNKNOWN;\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nextAfterName();\n            return null;\n        }\n        if (_tokenIncomplete) {\n            _skipString();\n        }\n        int i = _skipWSOrEnd();\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n        _binaryValue = null;\n        if (i == INT_RBRACKET || i == INT_RCURLY) {\n            _closeScope(i);\n            return null;\n        }\n        if (_parsingContext.expectComma()) {\n            i = _skipComma(i);\n            if ((_features & FEAT_MASK_TRAILING_COMMA) != 0) {\n                if ((i == INT_RBRACKET) || (i == INT_RCURLY)) {\n                    _closeScope(i);\n                    return null;\n                }\n            }\n        }\n        if (!_parsingContext.inObject()) {\n            _updateLocation();\n            _nextTokenNotInObject(i);\n            return null;\n        }\n\n        _updateNameLocation();\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return name;\n        }\n        \n        // Ok: we must have a value... what is it?\n\n        JsonToken t;\n\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return name;\n    }\n\n    private final void _isNextTokenNameYes(int i) throws IOException\n    {\n        _currToken = JsonToken.FIELD_NAME;\n        _updateLocation();\n\n        switch (i) {\n        case '\"':\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        case '[':\n            _nextToken = JsonToken.START_ARRAY;\n            return;\n        case '{':\n            _nextToken = JsonToken.START_OBJECT;\n            return;\n        case 't':\n            _matchToken(\"true\", 1);\n            _nextToken = JsonToken.VALUE_TRUE;\n            return;\n        case 'f':\n            _matchToken(\"false\", 1);\n            _nextToken = JsonToken.VALUE_FALSE;\n            return;\n        case 'n':\n            _matchToken(\"null\", 1);\n            _nextToken = JsonToken.VALUE_NULL;\n            return;\n        case '-':\n            _nextToken = _parseNegNumber();\n            return;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            _nextToken = _parsePosNumber(i);\n            return;\n        }\n        _nextToken = _handleOddValue(i);\n    }\n\n    protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n    {\n        // // // and this is back to standard nextToken()\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return nameToMatch.equals(name);\n        }\n        // Ok: we must have a value... what is it?\n        JsonToken t;\n        switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n        }\n        _nextToken = t;\n        return nameToMatch.equals(name);\n    }\n\n    private final JsonToken _nextTokenNotInObject(int i) throws IOException\n    {\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            return (_currToken = JsonToken.VALUE_STRING);\n        }\n        switch (i) {\n        case '[':\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_ARRAY);\n        case '{':\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            return (_currToken = JsonToken.START_OBJECT);\n        case 't':\n            _matchToken(\"true\", 1);\n            return (_currToken = JsonToken.VALUE_TRUE);\n        case 'f':\n            _matchToken(\"false\", 1);\n            return (_currToken = JsonToken.VALUE_FALSE);\n        case 'n':\n            _matchToken(\"null\", 1);\n            return (_currToken = JsonToken.VALUE_NULL);\n        case '-':\n            return (_currToken = _parseNegNumber());\n            /* Should we have separate handling for plus? Although\n             * it is not allowed per se, it may be erroneously used,\n             * and could be indicated by a more specific error message.\n             */\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return (_currToken = _parsePosNumber(i));\n        /*\n         * This check proceeds only if the Feature.ALLOW_MISSING_VALUES is enabled\n         * The Check is for missing values. Incase of missing values in an array, the next token will be either ',' or ']'.\n         * This case, decrements the already incremented _inputPtr in the buffer in case of comma(,) \n         * so that the existing flow goes back to checking the next token which will be comma again and\n         * it continues the parsing.\n         * Also the case returns NULL as current token in case of ',' or ']'.    \n         */\n        case ',':\n        case ']':\n        \tif(isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n        \t\t_inputPtr--;\n        \t\treturn (_currToken = JsonToken.VALUE_NULL);  \n        \t}    \n        }\n        return (_currToken = _handleOddValue(i));\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final String nextTextValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_STRING) {\n                if (_tokenIncomplete) {\n                    _tokenIncomplete = false;\n                    _finishString();\n                }\n                return _textBuffer.contentsAsString();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final int nextIntValue(int defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getIntValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n    }\n\n    // note: identical to one in Utf8StreamParser\n    @Override\n    public final long nextLongValue(long defaultValue) throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_NUMBER_INT) {\n                return getLongValue();\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return defaultValue;\n        }\n        // !!! TODO: optimize this case as well\n        return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n    }\n\n    // note: identical to one in UTF8StreamJsonParser\n    @Override\n    public final Boolean nextBooleanValue() throws IOException\n    {\n        if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n            _nameCopied = false;\n            JsonToken t = _nextToken;\n            _nextToken = null;\n            _currToken = t;\n            if (t == JsonToken.VALUE_TRUE) {\n                return Boolean.TRUE;\n            }\n            if (t == JsonToken.VALUE_FALSE) {\n                return Boolean.FALSE;\n            }\n            if (t == JsonToken.START_ARRAY) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            } else if (t == JsonToken.START_OBJECT) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            return null;\n        }\n        JsonToken t = nextToken();\n        if (t != null) {\n            int id = t.id();\n            if (id == ID_TRUE) return Boolean.TRUE;\n            if (id == ID_FALSE) return Boolean.FALSE;\n        }\n        return null;\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, number parsing\n    /**********************************************************\n     */\n\n    /**\n     * Initial parsing method for number values. It needs to be able\n     * to parse enough input to be able to determine whether the\n     * value is to be considered a simple integer value, or a more\n     * generic decimal value: latter of which needs to be expressed\n     * as a floating point number. The basic rule is that if the number\n     * has no fractional or exponential part, it is an integer; otherwise\n     * a floating point number.\n     *<p>\n     * Because much of input has to be processed in any case, no partial\n     * parsing is done: all input text will be stored for further\n     * processing. However, actual numeric value conversion will be\n     * deferred, since it is usually the most complicated and costliest\n     * part of processing.\n     */\n    protected final JsonToken _parsePosNumber(int ch) throws IOException\n    {\n        /* Although we will always be complete with respect to textual\n         * representation (that is, all characters will be parsed),\n         * actual conversion to a number is deferred. Thus, need to\n         * note that no representations are valid yet\n         */\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include digit already read\n        final int inputLen = _inputEnd;\n\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(false, startPtr);\n        }\n\n        /* First, let's see if the whole number is contained within\n         * the input buffer unsplit. This should be the common case;\n         * and to simplify processing, we will just reparse contents\n         * in the alternative case (number split on buffer boundary)\n         */\n\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(false, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, false, intLen);\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(false, intLen);\n    }\n\n    private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n        throws IOException\n    {\n        final int inputLen = _inputEnd;\n        int fractLen = 0;\n\n        // And then see if we get other parts\n        if (ch == '.') { // yes, fraction\n            fract_loop:\n            while (true) {\n                if (ptr >= inputLen) {\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') { // and/or exponent\n            if (ptr >= inputLen) {\n                _inputPtr = startPtr;\n                return _parseNumber2(neg, startPtr);\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    _inputPtr = startPtr;\n                    return _parseNumber2(neg, startPtr);\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        --ptr; // need to push back following separator\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        // And there we have it!\n        return resetFloat(neg, intLen, fractLen, expLen);\n    }\n\n    protected final JsonToken _parseNegNumber() throws IOException\n    {\n        int ptr = _inputPtr;\n        int startPtr = ptr-1; // to include sign/digit already read\n        final int inputLen = _inputEnd;\n\n        if (ptr >= inputLen) {\n            return _parseNumber2(true, startPtr);\n        }\n        int ch = _inputBuffer[ptr++];\n        // First check: must have a digit to follow minus sign\n        if (ch > INT_9 || ch < INT_0) {\n            _inputPtr = ptr;\n            return _handleInvalidNumberStart(ch, true);\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            return _parseNumber2(true, startPtr);\n        }\n        int intLen = 1; // already got one\n\n        // First let's get the obligatory integer part:\n        int_loop:\n        while (true) {\n            if (ptr >= inputLen) {\n                return _parseNumber2(true, startPtr);\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n\n        if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n            _inputPtr = ptr;\n            return _parseFloat(ch, startPtr, ptr, true, intLen);\n        }\n        --ptr;\n        _inputPtr = ptr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(ch);\n        }\n        int len = ptr-startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return resetInt(true, intLen);\n    }\n\n    /**\n     * Method called to parse a number, when the primary parse\n     * method has failed to parse it, due to it being split on\n     * buffer boundary. As a result code is very similar, except\n     * that it has to explicitly copy contents to the text buffer\n     * instead of just sharing the main input buffer.\n     */\n    private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n    {\n        _inputPtr = neg ? (startPtr+1) : startPtr;\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = 0;\n\n        // Need to prepend sign?\n        if (neg) {\n            outBuf[outPtr++] = '-';\n        }\n\n        // This is the place to do leading-zero check(s) too:\n        int intLen = 0;\n        char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"No digit following minus sign\", JsonToken.VALUE_NUMBER_INT);\n        if (c == '0') {\n            c = _verifyNoLeadingZeroes();\n        }\n        boolean eof = false;\n\n        // Ok, first the obligatory integer part:\n        int_loop:\n        while (c >= '0' && c <= '9') {\n            ++intLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !_loadMore()) {\n                // EOF is legal for main level int values\n                c = CHAR_NULL;\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Also, integer part is not optional\n        if (intLen == 0) {\n            return _handleInvalidNumberStart(c, neg);\n        }\n\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (c == '.') { // yes, fraction\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            fract_loop:\n            while (true) {\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n                if (c < INT_0 || c > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            }\n        }\n\n        int expLen = 0;\n        if (c == 'e' || c == 'E') { // exponent?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Not optional, can require that we get one more char\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                : getNextChar(\"expected a digit for number exponent\");\n            // Sign indicator?\n            if (c == '-' || c == '+') {\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                // Likewise, non optional:\n                c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n                    : getNextChar(\"expected a digit for number exponent\");\n            }\n\n            exp_loop:\n            while (c <= INT_9 && c >= INT_0) {\n                ++expLen;\n                if (outPtr >= outBuf.length) {\n                    outBuf = _textBuffer.finishCurrentSegment();\n                    outPtr = 0;\n                }\n                outBuf[outPtr++] = c;\n                if (_inputPtr >= _inputEnd && !_loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            }\n        }\n\n        // Ok; unless we hit end-of-input, need to push last char read back\n        if (!eof) {\n            --_inputPtr;\n            if (_parsingContext.inRoot()) {\n                _verifyRootSpace(c);\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        // And there we have it!\n        return reset(neg, intLen, fractLen, expLen);\n    }\n\n    /**\n     * Method called when we have seen one zero, and want to ensure\n     * it is not followed by another\n     */\n    private final char _verifyNoLeadingZeroes() throws IOException\n    {\n        // Fast case first:\n        if (_inputPtr < _inputEnd) {\n            char ch = _inputBuffer[_inputPtr];\n            // if not followed by a number (probably '.'); return zero as is, to be included\n            if (ch < '0' || ch > '9') {\n                return '0';\n            }\n        }\n        // and offline the less common case\n        return _verifyNLZ2();\n    }\n\n    private char _verifyNLZ2() throws IOException\n    {\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return '0';\n        }\n        char ch = _inputBuffer[_inputPtr];\n        if (ch < '0' || ch > '9') {\n            return '0';\n        }\n        if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n            reportInvalidNumber(\"Leading zeroes not allowed\");\n        }\n        // if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n        ++_inputPtr; // Leading zero to be skipped\n        if (ch == INT_0) {\n            while (_inputPtr < _inputEnd || _loadMore()) {\n                ch = _inputBuffer[_inputPtr];\n                if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n                    return '0';\n                }\n                ++_inputPtr; // skip previous zero\n                if (ch != '0') { // followed by other number; return\n                    break;\n                }\n            }\n        }\n        return ch;\n    }\n\n    /**\n     * Method called if expected numeric value (due to leading sign) does not\n     * look like a number\n     */\n    protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n    {\n        if (ch == 'I') {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            ch = _inputBuffer[_inputPtr++];\n            if (ch == 'N') {\n                String match = negative ? \"-INF\" :\"+INF\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            } else if (ch == 'n') {\n                String match = negative ? \"-Infinity\" :\"+Infinity\";\n                _matchToken(match, 3);\n                if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                    return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n                }\n                _reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            }\n        }\n        reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n        return null;\n    }\n\n    /**\n     * Method called to ensure that a root-value is followed by a space\n     * token.\n     *<p>\n     * NOTE: caller MUST ensure there is at least one character available;\n     * and that input pointer is AT given char (not past)\n     */\n    private final void _verifyRootSpace(int ch) throws IOException\n    {\n        // caller had pushed it back, before calling; reset\n        ++_inputPtr;\n        switch (ch) {\n        case ' ':\n        case '\\t':\n            return;\n        case '\\r':\n            _skipCR();\n            return;\n        case '\\n':\n            ++_currInputRow;\n            _currInputRowStart = _inputPtr;\n            return;\n        }\n        _reportMissingRootWS(ch);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, secondary parsing\n    /**********************************************************\n     */\n\n    protected final String _parseName() throws IOException\n    {\n        // First: let's try to see if we have a simple name: one that does\n        // not cross input buffer boundary, and does not contain escape sequences.\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int[] codes = _icLatin1;\n\n        while (ptr < _inputEnd) {\n            int ch = _inputBuffer[ptr];\n            if (ch < codes.length && codes[ch] != 0) {\n                if (ch == '\"') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                break;\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n            ++ptr;\n        }\n        int start = _inputPtr;\n        _inputPtr = ptr;\n        return _parseName2(start, hash, INT_QUOTE);\n    }\n\n    private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n        /* Output pointers; calls will also ensure that the buffer is\n         * not shared and has room for at least one more char.\n         */\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in field name\", JsonToken.FIELD_NAME);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= endChar) {\n                    if (i == endChar) {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"name\");\n                    }\n                }\n            }\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    /**\n     * Method called when we see non-white space character other\n     * than double quote, when expecting a field name.\n     * In standard mode will just throw an expection; but\n     * in non-standard modes may be able to parse name.\n     */\n    protected String _handleOddName(int i) throws IOException\n    {\n        // [JACKSON-173]: allow single quotes\n        if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n            return _parseAposName();\n        }\n        // [JACKSON-69]: allow unquoted names if feature enabled:\n        if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n        final int maxCode = codes.length;\n\n        // Also: first char must be a valid name char, but NOT be number\n        boolean firstOk;\n\n        if (i < maxCode) { // identifier, or a number ([Issue#102])\n            firstOk = (codes[i] == 0);\n        } else {\n            firstOk = Character.isJavaIdentifierPart((char) i);\n        }\n        if (!firstOk) {\n            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n        }\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode) {\n                    if (codes[ch] != 0) {\n                        int start = _inputPtr-1; // -1 to bring back first char\n                        _inputPtr = ptr;\n                        return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                    }\n                } else if (!Character.isJavaIdentifierPart((char) ch)) {\n                    int start = _inputPtr-1; // -1 to bring back first char\n                    _inputPtr = ptr;\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n        int start = _inputPtr-1;\n        _inputPtr = ptr;\n        return _handleOddName2(start, hash, codes);\n    }\n\n    protected String _parseAposName() throws IOException\n    {\n        // Note: mostly copy of_parseFieldName\n        int ptr = _inputPtr;\n        int hash = _hashSeed;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch == '\\'') {\n                    int start = _inputPtr;\n                    _inputPtr = ptr+1; // to skip the quote\n                    return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n                }\n                if (ch < maxCode && codes[ch] != 0) {\n                    break;\n                }\n                hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        int start = _inputPtr;\n        _inputPtr = ptr;\n\n        return _parseName2(start, hash, '\\'');\n    }\n\n    /**\n     * Method for handling cases where first non-space character\n     * of an expected value token is not legal for standard JSON content.\n     */\n    protected JsonToken _handleOddValue(int i) throws IOException\n    {\n        // Most likely an error, unless we are to allow single-quote-strings\n        switch (i) {\n        case '\\'':\n            /* Allow single quotes? Unlike with regular Strings, we'll eagerly parse\n             * contents; this so that there'sno need to store information on quote char used.\n             * Also, no separation to fast/slow parsing; we'll just do\n             * one regular (~= slowish) parsing, to keep code simple\n             */\n            if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n                return _handleApos();\n            }\n            break;\n        case ']':\n            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled\n             *   we may allow \"missing values\", that is, encountering a trailing\n             *   comma or closing marker where value would be expected\n             */\n            if (!_parsingContext.inArray()) {\n                break;\n            }\n            // fall through\n        case ',':\n            if (isEnabled(Feature.ALLOW_MISSING_VALUES)) {\n                --_inputPtr;\n                return JsonToken.VALUE_NULL;\n            }\n            break;\n        case 'N':\n            _matchToken(\"NaN\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"NaN\", Double.NaN);\n            }\n            _reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case 'I':\n            _matchToken(\"Infinity\", 1);\n            if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n                return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n            }\n            _reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n            break;\n        case '+': // note: '-' is taken as number\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOFInValue(JsonToken.VALUE_NUMBER_INT);\n                }\n            }\n            return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n        }\n        // [core#77] Try to decode most likely token\n        if (Character.isJavaIdentifierStart(i)) {\n            _reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n        }\n        // but if it doesn't look like a token:\n        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n        return null;\n    }\n\n    protected JsonToken _handleApos() throws IOException\n    {\n        char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i <= '\\\\') {\n                if (i == '\\\\') {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i <= '\\'') {\n                    if (i == '\\'') {\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n        }\n    }\n\n    @Override\n    protected final void _finishString() throws IOException\n    {\n        /* First: let's try to see if we have simple String value: one\n         * that does not cross input buffer boundary, and does not\n         * contain escape sequences.\n         */\n        int ptr = _inputPtr;\n        final int inputLen = _inputEnd;\n\n        if (ptr < inputLen) {\n            final int[] codes = _icLatin1;\n            final int maxCode = codes.length;\n\n            do {\n                int ch = _inputBuffer[ptr];\n                if (ch < maxCode && codes[ch] != 0) {\n                    if (ch == '\"') {\n                        _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n                        _inputPtr = ptr+1;\n                        // Yes, we got it all\n                        return;\n                    }\n                    break;\n                }\n                ++ptr;\n            } while (ptr < inputLen);\n        }\n\n        // Either ran out of input, or bumped into an escape sequence...\n        _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n        _inputPtr = ptr;\n        _finishString2();\n    }\n\n    protected void _finishString2() throws IOException\n    {\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int[] codes = _icLatin1;\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n            }\n            char c = _inputBuffer[_inputPtr++];\n            int i = (int) c;\n            if (i < maxCode && codes[i] != 0) {\n                if (i == INT_QUOTE) {\n                    break;\n                } else if (i == INT_BACKSLASH) {\n                    /* Although chars outside of BMP are to be escaped as\n                     * an UTF-16 surrogate pair, does that affect decoding?\n                     * For now let's assume it does not.\n                     */\n                    c = _decodeEscaped();\n                } else if (i < INT_SPACE) {\n                    _throwUnquotedSpace(i, \"string value\");\n                } // anything else?\n            }\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n    }\n\n    /**\n     * Method called to skim through rest of unparsed String value,\n     * if it is not needed. This can be done bit faster if contents\n     * need not be stored for future access.\n     */\n    protected final void _skipString() throws IOException\n    {\n        _tokenIncomplete = false;\n\n        int inPtr = _inputPtr;\n        int inLen = _inputEnd;\n        char[] inBuf = _inputBuffer;\n\n        while (true) {\n            if (inPtr >= inLen) {\n                _inputPtr = inPtr;\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\": was expecting closing quote for a string value\",\n                            JsonToken.VALUE_STRING);\n                }\n                inPtr = _inputPtr;\n                inLen = _inputEnd;\n            }\n            char c = inBuf[inPtr++];\n            int i = (int) c;\n            if (i <= INT_BACKSLASH) {\n                if (i == INT_BACKSLASH) {\n                    // Although chars outside of BMP are to be escaped as an UTF-16 surrogate pair,\n                    // does that affect decoding? For now let's assume it does not.\n                    _inputPtr = inPtr;\n                    /*c = */ _decodeEscaped();\n                    inPtr = _inputPtr;\n                    inLen = _inputEnd;\n                } else if (i <= INT_QUOTE) {\n                    if (i == INT_QUOTE) {\n                        _inputPtr = inPtr;\n                        break;\n                    }\n                    if (i < INT_SPACE) {\n                        _inputPtr = inPtr;\n                        _throwUnquotedSpace(i, \"string value\");\n                    }\n                }\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other parsing\n    /**********************************************************\n     */\n\n    /**\n     * We actually need to check the character value here\n     * (to see if we have \\n following \\r).\n     */\n    protected final void _skipCR() throws IOException {\n        if (_inputPtr < _inputEnd || _loadMore()) {\n            if (_inputBuffer[_inputPtr] == '\\n') {\n                ++_inputPtr;\n            }\n        }\n        ++_currInputRow;\n        _currInputRowStart = _inputPtr;\n    }\n\n    private final int _skipColon() throws IOException\n    {\n        if ((_inputPtr + 4) >= _inputEnd) {\n            return _skipColon2(false);\n        }\n        char c = _inputBuffer[_inputPtr];\n        if (c == ':') { // common case, no leading space\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) { // nor trailing\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (c == ' ' || c == '\\t') {\n            c = _inputBuffer[++_inputPtr];\n        }\n        if (c == ':') {\n            int i = _inputBuffer[++_inputPtr];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    return _skipColon2(true);\n                }\n                ++_inputPtr;\n                return i;\n            }\n            if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[++_inputPtr];\n                if (i > INT_SPACE) {\n                    if (i == INT_SLASH || i == INT_HASH) {\n                        return _skipColon2(true);\n                    }\n                    ++_inputPtr;\n                    return i;\n                }\n            }\n            return _skipColon2(true);\n        }\n        return _skipColon2(false);\n    }\n\n    private final int _skipColon2(boolean gotColon) throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                if (gotColon) {\n                    return i;\n                }\n                if (i != INT_COLON) {\n                    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n                }\n                gotColon = true;\n                continue;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        _reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\",\n                null);\n        return -1;\n    }\n\n    // Variant called when we know there's at least 4 more bytes available\n    private final int _skipColonFast(int ptr) throws IOException\n    {\n        int i = (int) _inputBuffer[ptr++];\n        if (i == INT_COLON) { // common case, no leading space\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) { // nor trailing\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n            _inputPtr = ptr-1;\n            return _skipColon2(true); // true -> skipped colon\n        }\n        if (i == INT_SPACE || i == INT_TAB) {\n            i = _inputBuffer[ptr++];\n        }\n        boolean gotColon = (i == INT_COLON);\n        if (gotColon) {\n            i = _inputBuffer[ptr++];\n            if (i > INT_SPACE) {\n                if (i != INT_SLASH && i != INT_HASH) {\n                    _inputPtr = ptr;\n                    return i;\n                }\n            } else if (i == INT_SPACE || i == INT_TAB) {\n                i = (int) _inputBuffer[ptr++];\n                if (i > INT_SPACE) {\n                    if (i != INT_SLASH && i != INT_HASH) {\n                        _inputPtr = ptr;\n                        return i;\n                    }\n                }\n            }\n        }\n        _inputPtr = ptr-1;\n        return _skipColon2(gotColon);\n    }\n\n    // Primary loop: no reloading, comment handling\n    private final int _skipComma(int i) throws IOException\n    {\n        if (i != INT_COMMA) {\n            _reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.typeDesc()+\" entries\");\n        }\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipAfterComma2();\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipAfterComma2();\n    }\n\n    private final int _skipAfterComma2() throws IOException\n    {\n        while (_inputPtr < _inputEnd || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            }\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.typeDesc()+\" entries\");\n    }\n\n    private final int _skipWSOrEnd() throws IOException\n    {\n        // Let's handle first character separately since it is likely that\n        // it is either non-whitespace; or we have longer run of white space\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                return _eofAsNextChar();\n            }\n        }\n        int i = _inputBuffer[_inputPtr++];\n        if (i > INT_SPACE) {\n            if (i == INT_SLASH || i == INT_HASH) {\n                --_inputPtr;\n                return _skipWSOrEnd2();\n            }\n            return i;\n        }\n        if (i != INT_SPACE) {\n            if (i == INT_LF) {\n                ++_currInputRow;\n                _currInputRowStart = _inputPtr;\n            } else if (i == INT_CR) {\n                _skipCR();\n            } else if (i != INT_TAB) {\n                _throwInvalidSpace(i);\n            }\n        }\n\n        while (_inputPtr < _inputEnd) {\n            i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH || i == INT_HASH) {\n                    --_inputPtr;\n                    return _skipWSOrEnd2();\n                }\n                return i;\n            }\n            if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n        return _skipWSOrEnd2();\n    }\n\n    private int _skipWSOrEnd2() throws IOException\n    {\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // We ran out of input...\n                    return _eofAsNextChar();\n                }\n            }\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i > INT_SPACE) {\n                if (i == INT_SLASH) {\n                    _skipComment();\n                    continue;\n                }\n                if (i == INT_HASH) {\n                    if (_skipYAMLComment()) {\n                        continue;\n                    }\n                }\n                return i;\n            } else if (i != INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    private void _skipComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n            _reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n        }\n        // First: check which comment (if either) it is:\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            _reportInvalidEOF(\" in a comment\", null);\n        }\n        char c = _inputBuffer[_inputPtr++];\n        if (c == '/') {\n            _skipLine();\n        } else if (c == '*') {\n            _skipCComment();\n        } else {\n            _reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n        }\n    }\n\n    private void _skipCComment() throws IOException\n    {\n        // Ok: need the matching '*/'\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i <= '*') {\n                if (i == '*') { // end?\n                    if ((_inputPtr >= _inputEnd) && !_loadMore()) {\n                        break;\n                    }\n                    if (_inputBuffer[_inputPtr] == INT_SLASH) {\n                        ++_inputPtr;\n                        return;\n                    }\n                    continue;\n                }\n                if (i < INT_SPACE) {\n                    if (i == INT_LF) {\n                        ++_currInputRow;\n                        _currInputRowStart = _inputPtr;\n                    } else if (i == INT_CR) {\n                        _skipCR();\n                    } else if (i != INT_TAB) {\n                        _throwInvalidSpace(i);\n                    }\n                }\n            }\n        }\n        _reportInvalidEOF(\" in a comment\", null);\n    }\n\n    private boolean _skipYAMLComment() throws IOException\n    {\n        if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n            return false;\n        }\n        _skipLine();\n        return true;\n    }\n\n    private void _skipLine() throws IOException\n    {\n        // Ok: need to find EOF or linefeed\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            int i = (int) _inputBuffer[_inputPtr++];\n            if (i < INT_SPACE) {\n                if (i == INT_LF) {\n                    ++_currInputRow;\n                    _currInputRowStart = _inputPtr;\n                    break;\n                } else if (i == INT_CR) {\n                    _skipCR();\n                    break;\n                } else if (i != INT_TAB) {\n                    _throwInvalidSpace(i);\n                }\n            }\n        }\n    }\n\n    @Override\n    protected char _decodeEscaped() throws IOException\n    {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) {\n                _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n            }\n        }\n        char c = _inputBuffer[_inputPtr++];\n\n        switch ((int) c) {\n            // First, ones that are mapped\n        case 'b':\n            return '\\b';\n        case 't':\n            return '\\t';\n        case 'n':\n            return '\\n';\n        case 'f':\n            return '\\f';\n        case 'r':\n            return '\\r';\n\n            // And these are to be returned as they are\n        case '\"':\n        case '/':\n        case '\\\\':\n            return c;\n\n        case 'u': // and finally hex-escaped\n            break;\n\n        default:\n            return _handleUnrecognizedCharacterEscape(c);\n        }\n\n        // Ok, a hex escape. Need 4 characters\n        int value = 0;\n        for (int i = 0; i < 4; ++i) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) {\n                    _reportInvalidEOF(\" in character escape sequence\", JsonToken.VALUE_STRING);\n                }\n            }\n            int ch = (int) _inputBuffer[_inputPtr++];\n            int digit = CharTypes.charToHex(ch);\n            if (digit < 0) {\n                _reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n            }\n            value = (value << 4) | digit;\n        }\n        return (char) value;\n    }\n\n    private final void _matchTrue() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"true\", 1);\n    }\n\n    private final void _matchFalse() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 4) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"false\", 1);\n    }\n\n    private final void _matchNull() throws IOException {\n        int ptr = _inputPtr;\n        if ((ptr + 3) < _inputEnd) {\n            final char[] b = _inputBuffer;\n            if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n                char c = b[++ptr];\n                if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n                    _inputPtr = ptr;\n                    return;\n                }\n            }\n        }\n        // buffer boundary, or problem, offline\n        _matchToken(\"null\", 1);\n    }\n\n    /**\n     * Helper method for checking whether input matches expected token\n     */\n    protected final void _matchToken(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        if ((_inputPtr + len) >= _inputEnd) {\n            _matchToken2(matchStr, i);\n            return;\n        }\n\n        do {\n            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _matchToken2(String matchStr, int i) throws IOException\n    {\n        final int len = matchStr.length();\n        do {\n            if (((_inputPtr >= _inputEnd) && !_loadMore())\n                ||  (_inputBuffer[_inputPtr] != matchStr.charAt(i))) {\n                _reportInvalidToken(matchStr.substring(0, i));\n            }\n            ++_inputPtr;\n        } while (++i < len);\n    \n        // but let's also ensure we either get EOF, or non-alphanum char...\n        if (_inputPtr >= _inputEnd && !_loadMore()) {\n            return;\n        }\n        int ch = _inputBuffer[_inputPtr];\n        if (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n            _checkMatchEnd(matchStr, i, ch);\n        }\n    }\n\n    private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {\n        // but actually only alphanums are problematic\n        char ch = (char) c;\n        if (Character.isJavaIdentifierPart(ch)) {\n            _reportInvalidToken(matchStr.substring(0, i));\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Binary access\n    /**********************************************************\n     */\n\n    /**\n     * Efficient handling for incremental parsing of base64-encoded\n     * textual content.\n     */\n    @SuppressWarnings(\"resource\")\n    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n    {\n        ByteArrayBuilder builder = _getByteArrayBuilder();\n\n        //main_loop:\n        while (true) {\n            // first, we'll skip preceding white space, if any\n            char ch;\n            do {\n                if (_inputPtr >= _inputEnd) {\n                    _loadMoreGuaranteed();\n                }\n                ch = _inputBuffer[_inputPtr++];\n            } while (ch <= INT_SPACE);\n            int bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (ch == '\"') { // reached the end, fair and square?\n                    return builder.toByteArray();\n                }\n                bits = _decodeBase64Escape(b64variant, ch, 0);\n                if (bits < 0) { // white space to skip\n                    continue;\n                }\n            }\n            int decodedData = bits;\n\n            // then second base64 char; can't get padding yet, nor ws\n\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                bits = _decodeBase64Escape(b64variant, ch, 1);\n            }\n            decodedData = (decodedData << 6) | bits;\n\n            // third base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n\n            // First branch: can get padding (-> 1 byte)\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 4;\n                        builder.append(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 2);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // Ok, must get more padding chars, then\n                    if (_inputPtr >= _inputEnd) {\n                        _loadMoreGuaranteed();\n                    }\n                    ch = _inputBuffer[_inputPtr++];\n                    if (!b64variant.usesPaddingChar(ch)) {\n                        if (_decodeBase64Escape(b64variant, ch, 3) != Base64Variant.BASE64_VALUE_PADDING) {\n                            throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n                        }\n                    }\n                    // Got 12 bits, only need 8, need to shift\n                    decodedData >>= 4;\n                    builder.append(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // Nope, 2 or 3 bytes\n            decodedData = (decodedData << 6) | bits;\n            // fourth and last base64 char; can be padding, but not ws\n            if (_inputPtr >= _inputEnd) {\n                _loadMoreGuaranteed();\n            }\n            ch = _inputBuffer[_inputPtr++];\n            bits = b64variant.decodeBase64Char(ch);\n            if (bits < 0) {\n                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n                    // as per [JACKSON-631], could also just be 'missing'  padding\n                    if (ch == '\"') {\n                        decodedData >>= 2;\n                        builder.appendTwoBytes(decodedData);\n                        if (b64variant.usesPadding()) {\n                            --_inputPtr; // to keep parser state bit more consistent\n                            _handleBase64MissingPadding(b64variant);\n                        }\n                        return builder.toByteArray();\n                    }\n                    bits = _decodeBase64Escape(b64variant, ch, 3);\n                }\n                if (bits == Base64Variant.BASE64_VALUE_PADDING) {\n                    // With padding we only get 2 bytes; but we have\n                    // to shift it a bit so it is identical to triplet\n                    // case with partial output.\n                    // 3 chars gives 3x6 == 18 bits, of which 2 are\n                    // dummies, need to discard:\n                    decodedData >>= 2;\n                    builder.appendTwoBytes(decodedData);\n                    continue;\n                }\n                // otherwise we got escaped other char, to be processed below\n            }\n            // otherwise, our triplet is now complete\n            decodedData = (decodedData << 6) | bits;\n            builder.appendThreeBytes(decodedData);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, location updating (refactored in 2.7)\n    /**********************************************************\n     */\n\n    @Override\n    public JsonLocation getTokenLocation()\n    {\n        if (_currToken == JsonToken.FIELD_NAME) {\n            long total = _currInputProcessed + (_nameStartOffset-1);\n            return new JsonLocation(_getSourceReference(),\n                    -1L, total, _nameStartRow, _nameStartCol);\n        }\n        return new JsonLocation(_getSourceReference(),\n                -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);\n    }\n\n    @Override\n    public JsonLocation getCurrentLocation() {\n        int col = _inputPtr - _currInputRowStart + 1; // 1-based\n        return new JsonLocation(_getSourceReference(),\n                -1L, _currInputProcessed + _inputPtr,\n                _currInputRow, col);\n    }\n\n    // @since 2.7\n    private final void _updateLocation()\n    {\n        int ptr = _inputPtr;\n        _tokenInputTotal = _currInputProcessed + ptr;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = ptr - _currInputRowStart;\n    }\n\n    // @since 2.7\n    private final void _updateNameLocation()\n    {\n        int ptr = _inputPtr;\n        _nameStartOffset = ptr;\n        _nameStartRow = _currInputRow;\n        _nameStartCol = ptr - _currInputRowStart;\n    }\n\n    /*\n    /**********************************************************\n    /* Error reporting\n    /**********************************************************\n     */\n\n    protected void _reportInvalidToken(String matchedPart) throws IOException {\n        _reportInvalidToken(matchedPart, \"'null', 'true', 'false' or NaN\");\n    }\n\n    protected void _reportInvalidToken(String matchedPart, String msg) throws IOException\n    {\n        /* Let's just try to find what appears to be the token, using\n         * regular Java identifier character rules. It's just a heuristic,\n         * nothing fancy here.\n         */\n        StringBuilder sb = new StringBuilder(matchedPart);\n        while ((_inputPtr < _inputEnd) || _loadMore()) {\n            char c = _inputBuffer[_inputPtr];\n            if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            sb.append(c);\n            if (sb.length() >= MAX_ERROR_TOKEN_LENGTH) {\n                sb.append(\"...\");\n                break;\n            }\n        }\n        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n    }\n\n    /*\n    /**********************************************************\n    /* Internal methods, other\n    /**********************************************************\n     */\n\n    private void _closeScope(int i) throws JsonParseException {\n        if (i == INT_RBRACKET) {\n            _updateLocation();\n            if (!_parsingContext.inArray()) {\n                _reportMismatchedEndMarker(i, '}');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_ARRAY;\n        }\n        if (i == INT_RCURLY) {\n            _updateLocation();\n            if (!_parsingContext.inObject()) {\n                _reportMismatchedEndMarker(i, ']');\n            }\n            _parsingContext = _parsingContext.clearAndGetParent();\n            _currToken = JsonToken.END_OBJECT;\n        }\n    }\n}\n"}, "generated_test_class": "To write unit tests for the `getValueAsString(String defValue)` method in the `ReaderBasedJsonParser` class, we need to consider different branches and conditions that the method can take. Specifically, we need to cover the following scenarios:\n\n1. When `_currToken` is `JsonToken.VALUE_STRING` and `_tokenIncomplete` is `true`.\n2. When `_currToken` is `JsonToken.VALUE_STRING` and `_tokenIncomplete` is `false`.\n3. When `_currToken` is `JsonToken.FIELD_NAME`.\n4. When `_currToken` is neither `JsonToken.VALUE_STRING` nor `JsonToken.FIELD_NAME`.\n\nFor the first two scenarios, we need to mock `_textBuffer.contentsAsString()` to return a specific string. For the third scenario, we need to mock `getCurrentName()` to return a specific string. For the fourth scenario, we need to ensure that `super.getValueAsString(defValue)` is called and returns the default value.\n\nHere's how we can write the unit tests:\n\n```java\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\nimport com.fasterxml.jackson.core.JsonLocation;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.core.io.CharTypes;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.json.ReaderBasedJsonParser;\nimport com.fasterxml.jackson.core.util.JsonParserDelegate;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mockito;\n\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\n\npublic class ReaderBasedJsonParserTest {\n\n    private ReaderBasedJsonParser parser;\n    private JsonParser superParser;\n    private StringBuilder _textBuffer;\n\n    @Before\n    public void setUp() throws IOException {\n        // Mocking the superclass ParserBase methods\n        superParser = mock(JsonParserDelegate.class);\n        IOContext ioContext = mock(IOContext.class);\n        Reader reader = new StringReader(\"{}\");\n        _textBuffer = new StringBuilder();\n\n        // Setting up the parser instance\n        parser = new ReaderBasedJsonParser(ioContext, 0, reader, null, CharTypes.getInputCodeLatin1()) {\n            @Override\n            public JsonToken nextToken() throws IOException {\n                return super.nextToken();\n            }\n\n            @Override\n            public String getCurrentName() {\n                return \"fieldName\";\n            }\n\n            @Override\n            public JsonToken getCurrentToken() {\n                return _currToken;\n            }\n\n            @Override\n            public JsonLocation getTokenLocation() {\n                return null;\n            }\n\n            @Override\n            public JsonLocation getCurrentLocation() {\n                return null;\n            }\n\n            @Override\n            public String getText() {\n                return _textBuffer.toString();\n            }\n\n            @Override\n            public void _finishString() {\n                _textBuffer.append(\"finishedString\");\n            }\n        };\n    }\n\n    @Test\n    public void testGetValueAsString_ValueStringToken_Incomplete() throws IOException {\n        // Setting up the scenario where _currToken is VALUE_STRING and _tokenIncomplete is true\n        parser._currToken = JsonToken.VALUE_STRING;\n        parser._tokenIncomplete = true;\n        _textBuffer.setLength(0);\n        _textBuffer.append(\"incompleteString\");\n\n        // Calling the method under test\n        String result = parser.getValueAsString(\"defValue\");\n\n        // Verifying the result\n        assertEquals(\"incompleteStringfinishedString\", result);\n        assertFalse(parser._tokenIncomplete);\n    }\n\n    @Test\n    public void testGetValueAsString_ValueStringToken_Complete() throws IOException {\n        // Setting up the scenario where _currToken is VALUE_STRING and _tokenIncomplete is false\n        parser._currToken = JsonToken.VALUE_STRING;\n        parser._tokenIncomplete = false;\n        _textBuffer.setLength(0);\n        _textBuffer.append(\"completeString\");\n\n        // Calling the method under test\n        String result = parser.getValueAsString(\"defValue\");\n\n        // Verifying the result\n        assertEquals(\"completeString\", result);\n        assertFalse(parser._tokenIncomplete);\n    }\n\n    @Test\n    public void testGetValueAsString_FieldNameToken() throws IOException {\n        // Setting up the scenario where _currToken is FIELD_NAME\n        parser._currToken = JsonToken.FIELD_NAME;\n\n        // Calling the method under test\n        String result = parser.getValueAsString(\"defValue\");\n\n        // Verifying the result\n        assertEquals(\"fieldName\", result);\n    }\n\n    @Test\n    public void testGetValueAsString_OtherToken() throws IOException {\n        // Setting up the scenario where _currToken is neither VALUE_STRING nor FIELD_NAME\n        parser._currToken = JsonToken.START_OBJECT;\n\n        // Calling the method under test\n        String result = parser.getValueAsString(\"defValue\");\n\n        // Verifying the result\n        assertEquals(\"defValue\", result);\n    }\n}\n```\n\nIn this test suite, we have covered all the branches of the `getValueAsString` method:\n\n- When `_currToken` is `JsonToken.VALUE_STRING` and `_tokenIncomplete` is `true`.\n- When `_currToken` is `JsonToken.VALUE_STRING` and `_tokenIncomplete` is `false`.\n- When `_currToken` is `JsonToken.FIELD_NAME`.\n- When `_currToken` is neither `JsonToken.VALUE_STRING` nor `JsonToken.FIELD_NAME`.\n\nEach test checks the expected return value and any side effects, such as modifications to `_tokenIncomplete`."}
