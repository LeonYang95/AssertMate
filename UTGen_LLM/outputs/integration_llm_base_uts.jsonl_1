{"bug_id": "Closure_27", "version": "fixed", "focal_method_signature": "Node com.google.javascript.rhino.IR#script(#Node ... stmts)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "focal_method": "public static Node script(Node ... stmts) {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }", "return_type": "Node", "assertion_subject_candidates": ["int com.google.javascript.rhino.Node#getType()", "boolean com.google.javascript.rhino.Node#hasChildren()", "Node com.google.javascript.rhino.Node#getFirstChild()", "Node com.google.javascript.rhino.Node#getLastChild()", "Node com.google.javascript.rhino.Node#getNext()", "String com.google.javascript.rhino.Node#toString()", "String com.google.javascript.rhino.Node#toStringTree()", "StaticSourceFile com.google.javascript.rhino.Node#getStaticSourceFile()", "InputId com.google.javascript.rhino.Node#getInputId()", "int com.google.javascript.rhino.Node#getLength()", "int com.google.javascript.rhino.Node#getLineno()", "int com.google.javascript.rhino.Node#getCharno()", "int com.google.javascript.rhino.Node#getSourcePosition()", "Iterable<Node> com.google.javascript.rhino.Node#siblings()", "Node com.google.javascript.rhino.Node#getParent()", "AncestorIterable com.google.javascript.rhino.Node#getAncestors()", "boolean com.google.javascript.rhino.Node#hasOneChild()", "boolean com.google.javascript.rhino.Node#hasMoreThanOneChild()", "JSType com.google.javascript.rhino.Node#getJSType()", "FileLevelJsDocBuilder com.google.javascript.rhino.Node#getJsDocBuilderForNode()", "JSDocInfo com.google.javascript.rhino.Node#getJSDocInfo()", "boolean com.google.javascript.rhino.Node#isVarArgs()", "boolean com.google.javascript.rhino.Node#isOptionalArg()", "boolean com.google.javascript.rhino.Node#isSyntheticBlock()", "Set<String> com.google.javascript.rhino.Node#getDirectives()", "boolean com.google.javascript.rhino.Node#wasEmptyNode()", "int com.google.javascript.rhino.Node#getSideEffectFlags()", "boolean com.google.javascript.rhino.Node#isOnlyModifiesThisCall()", "boolean com.google.javascript.rhino.Node#isNoSideEffectsCall()", "boolean com.google.javascript.rhino.Node#isLocalResultCall()", "boolean com.google.javascript.rhino.Node#isQuotedString()", "boolean com.google.javascript.rhino.Node#isAdd()", "boolean com.google.javascript.rhino.Node#isAnd()", "boolean com.google.javascript.rhino.Node#isArrayLit()", "boolean com.google.javascript.rhino.Node#isAssign()", "boolean com.google.javascript.rhino.Node#isAssignAdd()", "boolean com.google.javascript.rhino.Node#isBlock()", "boolean com.google.javascript.rhino.Node#isBreak()", "boolean com.google.javascript.rhino.Node#isCall()", "boolean com.google.javascript.rhino.Node#isCase()", "boolean com.google.javascript.rhino.Node#isCatch()", "boolean com.google.javascript.rhino.Node#isComma()", "boolean com.google.javascript.rhino.Node#isContinue()", "boolean com.google.javascript.rhino.Node#isDebugger()", "boolean com.google.javascript.rhino.Node#isDec()", "boolean com.google.javascript.rhino.Node#isDefaultCase()", "boolean com.google.javascript.rhino.Node#isDelProp()", "boolean com.google.javascript.rhino.Node#isDo()", "boolean com.google.javascript.rhino.Node#isEmpty()", "boolean com.google.javascript.rhino.Node#isExprResult()", "boolean com.google.javascript.rhino.Node#isFalse()", "boolean com.google.javascript.rhino.Node#isFor()", "boolean com.google.javascript.rhino.Node#isFunction()", "boolean com.google.javascript.rhino.Node#isGetterDef()", "boolean com.google.javascript.rhino.Node#isGetElem()", "boolean com.google.javascript.rhino.Node#isGetProp()", "boolean com.google.javascript.rhino.Node#isHook()", "boolean com.google.javascript.rhino.Node#isIf()", "boolean com.google.javascript.rhino.Node#isIn()", "boolean com.google.javascript.rhino.Node#isInc()", "boolean com.google.javascript.rhino.Node#isInstanceOf()", "boolean com.google.javascript.rhino.Node#isLabel()", "boolean com.google.javascript.rhino.Node#isLabelName()", "boolean com.google.javascript.rhino.Node#isName()", "boolean com.google.javascript.rhino.Node#isNE()", "boolean com.google.javascript.rhino.Node#isNew()", "boolean com.google.javascript.rhino.Node#isNot()", "boolean com.google.javascript.rhino.Node#isNull()", "boolean com.google.javascript.rhino.Node#isNumber()", "boolean com.google.javascript.rhino.Node#isObjectLit()", "boolean com.google.javascript.rhino.Node#isOr()", "boolean com.google.javascript.rhino.Node#isParamList()", "boolean com.google.javascript.rhino.Node#isRegExp()", "boolean com.google.javascript.rhino.Node#isReturn()", "boolean com.google.javascript.rhino.Node#isScript()", "boolean com.google.javascript.rhino.Node#isSetterDef()", "boolean com.google.javascript.rhino.Node#isString()", "boolean com.google.javascript.rhino.Node#isStringKey()", "boolean com.google.javascript.rhino.Node#isSwitch()", "boolean com.google.javascript.rhino.Node#isThis()", "boolean com.google.javascript.rhino.Node#isThrow()", "boolean com.google.javascript.rhino.Node#isTrue()", "boolean com.google.javascript.rhino.Node#isTry()", "boolean com.google.javascript.rhino.Node#isTypeOf()", "boolean com.google.javascript.rhino.Node#isVar()", "boolean com.google.javascript.rhino.Node#isVoid()", "boolean com.google.javascript.rhino.Node#isWhile()", "boolean com.google.javascript.rhino.Node#isWith()"], "focal_class": {"name": "IR", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import java.util.List;"], "fields": [], "methods": ["Node com.google.javascript.rhino.IR#empty()", "Node com.google.javascript.rhino.IR#function(Node#name,Node#params,Node#body)", "Node com.google.javascript.rhino.IR#paramList()", "Node com.google.javascript.rhino.IR#paramList(Node#param)", "Node com.google.javascript.rhino.IR#paramList(#Node ... params)", "Node com.google.javascript.rhino.IR#paramList(List<Node>#params)", "Node com.google.javascript.rhino.IR#block()", "Node com.google.javascript.rhino.IR#block(Node#stmt)", "Node com.google.javascript.rhino.IR#block(#Node ... stmts)", "Node com.google.javascript.rhino.IR#blockUnchecked(Node#stmt)", "Node com.google.javascript.rhino.IR#var(Node#name,Node#value)", "Node com.google.javascript.rhino.IR#var(Node#name)", "Node com.google.javascript.rhino.IR#returnNode()", "Node com.google.javascript.rhino.IR#returnNode(Node#expr)", "Node com.google.javascript.rhino.IR#throwNode(Node#expr)", "Node com.google.javascript.rhino.IR#exprResult(Node#expr)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then,Node#elseNode)", "Node com.google.javascript.rhino.IR#doNode(Node#body,Node#cond)", "Node com.google.javascript.rhino.IR#forIn(Node#target,Node#cond,Node#body)", "Node com.google.javascript.rhino.IR#forNode(Node#init,Node#cond,Node#incr,Node#body)", "Node com.google.javascript.rhino.IR#switchNode(Node#cond,#Node ... cases)", "Node com.google.javascript.rhino.IR#caseNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#defaultCase(Node#body)", "Node com.google.javascript.rhino.IR#label(Node#name,Node#stmt)", "Node com.google.javascript.rhino.IR#labelName(String#name)", "Node com.google.javascript.rhino.IR#tryFinally(Node#tryBody,Node#finallyBody)", "Node com.google.javascript.rhino.IR#tryCatch(Node#tryBody,Node#catchNode)", "Node com.google.javascript.rhino.IR#tryCatchFinally(Node#tryBody,Node#catchNode,Node#finallyBody)", "Node com.google.javascript.rhino.IR#catchNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#breakNode()", "Node com.google.javascript.rhino.IR#breakNode(Node#name)", "Node com.google.javascript.rhino.IR#continueNode()", "Node com.google.javascript.rhino.IR#continueNode(Node#name)", "Node com.google.javascript.rhino.IR#call(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#newNode(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#name(String#name)", "Node com.google.javascript.rhino.IR#getprop(Node#target,Node#prop)", "Node com.google.javascript.rhino.IR#getelem(Node#target,Node#elem)", "Node com.google.javascript.rhino.IR#assign(Node#target,Node#expr)", "Node com.google.javascript.rhino.IR#hook(Node#cond,Node#trueval,Node#falseval)", "Node com.google.javascript.rhino.IR#comma(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#and(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#or(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#not(Node#expr1)", "Node com.google.javascript.rhino.IR#eq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sheq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#voidNode(Node#expr1)", "Node com.google.javascript.rhino.IR#neg(Node#expr1)", "Node com.google.javascript.rhino.IR#pos(Node#expr1)", "Node com.google.javascript.rhino.IR#add(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sub(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#objectlit(#Node ... propdefs)", "Node com.google.javascript.rhino.IR#propdef(Node#string,Node#value)", "Node com.google.javascript.rhino.IR#arraylit(#Node ... exprs)", "Node com.google.javascript.rhino.IR#regexp(Node#expr)", "Node com.google.javascript.rhino.IR#regexp(Node#expr,Node#flags)", "Node com.google.javascript.rhino.IR#string(String#s)", "Node com.google.javascript.rhino.IR#stringKey(String#s)", "Node com.google.javascript.rhino.IR#number(double#d)", "Node com.google.javascript.rhino.IR#thisNode()", "Node com.google.javascript.rhino.IR#trueNode()", "Node com.google.javascript.rhino.IR#falseNode()", "Node com.google.javascript.rhino.IR#nullNode()", "Node com.google.javascript.rhino.IR#binaryOp(int#token,Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#unaryOp(int#token,Node#expr)", "boolean com.google.javascript.rhino.IR#mayBeExpressionOrEmpty(Node#n)", "boolean com.google.javascript.rhino.IR#isAssignmentTarget(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeStatement(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeExpression(Node#n)"], "other_methods": ["public static Node empty();", "public static Node function(Node name,Node params,Node body);", "public static Node paramList();", "public static Node paramList(Node param);", "public static Node paramList( Node ... params);", "public static Node paramList(List<Node> params);", "public static Node block();", "public static Node block(Node stmt);", "public static Node block( Node ... stmts);", "public static Node var(Node name,Node value);", "public static Node var(Node name);", "public static Node returnNode();", "public static Node returnNode(Node expr);", "public static Node throwNode(Node expr);", "public static Node exprResult(Node expr);", "public static Node ifNode(Node cond,Node then);", "public static Node ifNode(Node cond,Node then,Node elseNode);", "public static Node doNode(Node body,Node cond);", "public static Node forIn(Node target,Node cond,Node body);", "public static Node forNode(Node init,Node cond,Node incr,Node body);", "public static Node switchNode(Node cond, Node ... cases);", "public static Node caseNode(Node expr,Node body);", "public static Node defaultCase(Node body);", "public static Node label(Node name,Node stmt);", "public static Node labelName(String name);", "public static Node tryFinally(Node tryBody,Node finallyBody);", "public static Node tryCatch(Node tryBody,Node catchNode);", "public static Node tryCatchFinally(Node tryBody,Node catchNode,Node finallyBody);", "public static Node catchNode(Node expr,Node body);", "public static Node breakNode();", "public static Node breakNode(Node name);", "public static Node continueNode();", "public static Node continueNode(Node name);", "public static Node call(Node target, Node ... args);", "public static Node newNode(Node target, Node ... args);", "public static Node name(String name);", "public static Node getprop(Node target,Node prop);", "public static Node getelem(Node target,Node elem);", "public static Node assign(Node target,Node expr);", "public static Node hook(Node cond,Node trueval,Node falseval);", "public static Node comma(Node expr1,Node expr2);", "public static Node and(Node expr1,Node expr2);", "public static Node or(Node expr1,Node expr2);", "public static Node not(Node expr1);", "public static Node eq(Node expr1,Node expr2);", "public static Node sheq(Node expr1,Node expr2);", "public static Node voidNode(Node expr1);", "public static Node neg(Node expr1);", "public static Node pos(Node expr1);", "public static Node add(Node expr1,Node expr2);", "public static Node sub(Node expr1,Node expr2);", "public static Node objectlit( Node ... propdefs);", "public static Node propdef(Node string,Node value);", "public static Node arraylit( Node ... exprs);", "public static Node regexp(Node expr);", "public static Node regexp(Node expr,Node flags);", "public static Node string(String s);", "public static Node stringKey(String s);", "public static Node number(double d);", "public static Node thisNode();", "public static Node trueNode();", "public static Node falseNode();", "public static Node nullNode();"], "fields_dict": {}, "text": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   John Lenz\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.List;\n\n/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n\n  private IR() {}\n\n  public static Node empty() {\n    return new Node(Token.EMPTY);\n  }\n\n  public static Node function(Node name, Node params, Node body) {\n    Preconditions.checkState(name.isName());\n    Preconditions.checkState(params.isParamList());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FUNCTION, name, params, body);\n  }\n\n  public static Node paramList() {\n    return new Node(Token.PARAM_LIST);\n  }\n\n  public static Node paramList(Node param) {\n    Preconditions.checkState(param.isName());\n    return new Node(Token.PARAM_LIST, param);\n  }\n\n  public static Node paramList(Node ... params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node paramList(List<Node> params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n\n  public static Node block(Node stmt) {\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.BLOCK, stmt);\n    return block;\n  }\n\n  public static Node block(Node ... stmts) {\n    Node block = new Node(Token.BLOCK);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n\n  public static Node script(Node ... stmts) {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  public static Node var(Node name, Node value) {\n    Preconditions.checkState(name.isName() && !name.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    name.addChildToFront(value);\n    return var(name);\n  }\n\n  public static Node var(Node name) {\n    Preconditions.checkState(name.isName());\n    return new Node(Token.VAR, name);\n  }\n\n  public static Node returnNode() {\n    return new Node(Token.RETURN);\n  }\n\n  public static Node returnNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.RETURN, expr);\n  }\n\n  public static Node throwNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.THROW, expr);\n  }\n\n  public static Node exprResult(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.EXPR_RESULT, expr);\n  }\n\n  public static Node ifNode(Node cond, Node then) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    return new Node(Token.IF, cond, then);\n  }\n\n  public static Node ifNode(Node cond, Node then, Node elseNode) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    Preconditions.checkState(elseNode.isBlock());\n    return new Node(Token.IF, cond, then, elseNode);\n  }\n\n  public static Node doNode(Node body, Node cond) {\n    Preconditions.checkState(body.isBlock());\n    Preconditions.checkState(mayBeExpression(cond));\n    return new Node(Token.DO, body, cond);\n  }\n\n  public static Node forIn(Node target, Node cond, Node body) {\n    Preconditions.checkState(target.isVar() || mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, target, cond, body);\n  }\n\n  public static Node forNode(Node init, Node cond, Node incr, Node body) {\n    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, init, cond, incr, body);\n  }\n\n  public static Node switchNode(Node cond, Node ... cases) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Node switchNode = new Node(Token.SWITCH, cond);\n    for (Node caseNode : cases) {\n      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n      switchNode.addChildToBack(caseNode);\n    }\n    return switchNode;\n  }\n\n  public static Node caseNode(Node expr, Node body) {\n    Preconditions.checkState(mayBeExpression(expr));\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.CASE, expr, body);\n  }\n\n  public static Node defaultCase(Node body) {\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.DEFAULT_CASE, body);\n  }\n\n  public static Node label(Node name, Node stmt) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.LABEL, name, stmt);\n    return block;\n  }\n\n  public static Node labelName(String name) {\n    Preconditions.checkState(!name.isEmpty());\n    return Node.newString(Token.LABEL_NAME, name);\n  }\n\n  public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n  }\n\n  public static Node tryCatch(Node tryBody, Node catchNode) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n    return new Node(Token.TRY, tryBody, catchBody);\n  }\n\n  public static Node tryCatchFinally(\n      Node tryBody, Node catchNode, Node finallyBody) {\n    Preconditions.checkState(finallyBody.isBlock());\n    Node tryNode = tryCatch(tryBody, catchNode);\n    tryNode.addChildToBack(finallyBody);\n    return tryNode;\n  }\n\n  public static Node catchNode(Node expr, Node body) {\n    Preconditions.checkState(expr.isName());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.CATCH, expr, body);\n  }\n\n  public static Node breakNode() {\n    return new Node(Token.BREAK);\n  }\n\n  public static Node breakNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.BREAK, name);\n  }\n\n  public static Node continueNode() {\n    return new Node(Token.CONTINUE);\n  }\n\n  public static Node continueNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.CONTINUE, name);\n  }\n\n\n  //\n\n  public static Node call(Node target, Node ... args) {\n    Node call = new Node(Token.CALL, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      call.addChildToBack(arg);\n    }\n    return call;\n  }\n\n  public static Node newNode(Node target, Node ... args) {\n    Node newcall = new Node(Token.NEW, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      newcall.addChildToBack(arg);\n    }\n    return newcall;\n  }\n\n  public static Node name(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n\n  public static Node getprop(Node target, Node prop) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(prop.isString());\n    return new Node(Token.GETPROP, target, prop);\n  }\n\n  public static Node getelem(Node target, Node elem) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(elem));\n    return new Node(Token.GETELEM, target, elem);\n  }\n\n  public static Node assign(Node target, Node expr) {\n    Preconditions.checkState(isAssignmentTarget(target));\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.ASSIGN, target, expr);\n  }\n\n  public static Node hook(Node cond, Node trueval, Node falseval) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(mayBeExpression(trueval));\n    Preconditions.checkState(mayBeExpression(falseval));\n    return new Node(Token.HOOK, cond, trueval, falseval);\n  }\n\n  public static Node comma(Node expr1, Node expr2) {\n    return binaryOp(Token.COMMA, expr1, expr2);\n  }\n\n  public static Node and(Node expr1, Node expr2) {\n    return binaryOp(Token.AND, expr1, expr2);\n  }\n\n  public static Node or(Node expr1, Node expr2) {\n    return binaryOp(Token.OR, expr1, expr2);\n  }\n\n  public static Node not(Node expr1) {\n    return unaryOp(Token.NOT, expr1);\n  }\n\n  /**\n   * \"==\"\n   */\n  public static Node eq(Node expr1, Node expr2) {\n    return binaryOp(Token.EQ, expr1, expr2);\n  }\n\n  /**\n   * \"===\"\n   */\n  public static Node sheq(Node expr1, Node expr2) {\n    return binaryOp(Token.SHEQ, expr1, expr2);\n  }\n\n  public static Node voidNode(Node expr1) {\n    return unaryOp(Token.VOID, expr1);\n  }\n\n  public static Node neg(Node expr1) {\n    return unaryOp(Token.NEG, expr1);\n  }\n\n  public static Node pos(Node expr1) {\n    return unaryOp(Token.POS, expr1);\n  }\n\n  public static Node add(Node expr1, Node expr2) {\n    return binaryOp(Token.ADD, expr1, expr2);\n  }\n\n  public static Node sub(Node expr1, Node expr2) {\n    return binaryOp(Token.SUB, expr1, expr2);\n  }\n\n  // TODO(johnlenz): the rest of the ops\n\n  // literals\n  public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }\n\n  // TODO(johnlenz): quoted props\n\n  public static Node propdef(Node string, Node value) {\n    Preconditions.checkState(string.isStringKey());\n    Preconditions.checkState(!string.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    string.addChildToFront(value);\n    return string;\n  }\n\n  public static Node arraylit(Node ... exprs) {\n    Node arraylit = new Node(Token.ARRAYLIT);\n    for (Node expr : exprs) {\n      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n      arraylit.addChildToBack(expr);\n    }\n    return arraylit;\n  }\n\n  public static Node regexp(Node expr) {\n    Preconditions.checkState(expr.isString());\n    return new Node(Token.REGEXP, expr);\n  }\n\n  public static Node regexp(Node expr, Node flags) {\n    Preconditions.checkState(expr.isString());\n    Preconditions.checkState(flags.isString());\n    return new Node(Token.REGEXP, expr, flags);\n  }\n\n  public static Node string(String s) {\n    return Node.newString(s);\n  }\n\n  public static Node stringKey(String s) {\n    return Node.newString(Token.STRING_KEY, s);\n  }\n\n  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n\n  public static Node thisNode() {\n    return new Node(Token.THIS);\n  }\n\n  public static Node trueNode() {\n    return new Node(Token.TRUE);\n  }\n\n  public static Node falseNode() {\n    return new Node(Token.FALSE);\n  }\n\n  public static Node nullNode() {\n    return new Node(Token.NULL);\n  }\n\n  // helper methods\n\n  private static Node binaryOp(int token, Node expr1, Node expr2) {\n    Preconditions.checkState(mayBeExpression(expr1));\n    Preconditions.checkState(mayBeExpression(expr2));\n    return new Node(token, expr1, expr2);\n  }\n\n  private static Node unaryOp(int token, Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(token, expr);\n  }\n\n  private static boolean mayBeExpressionOrEmpty(Node n) {\n    return n.isEmpty() || mayBeExpression(n);\n  }\n\n  private static boolean isAssignmentTarget(Node n) {\n    return n.isName() || n.isGetProp() || n.isGetElem();\n  }\n\n  // NOTE: some nodes are neither statements nor expression nodes:\n  //   SCRIPT, LABEL_NAME, PARAM_LIST, CASE, DEFAULT_CASE, CATCH\n  //   GETTER_DEF, SETTER_DEF\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeStatement(Node n) {\n    switch (n.getType()) {\n      case Token.EMPTY:\n      case Token.FUNCTION:\n        // EMPTY and FUNCTION are used both in expression and statement\n        // contexts\n        return true;\n\n      case Token.BLOCK:\n      case Token.BREAK:\n      case Token.CONST:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.DO:\n      case Token.EXPR_RESULT:\n      case Token.FOR:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.RETURN:\n      case Token.SWITCH:\n      case Token.THROW:\n      case Token.TRY:\n      case Token.VAR:\n      case Token.WHILE:\n      case Token.WITH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeExpression(Node n) {\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // FUNCTION is used both in expression and statement\n        // contexts.\n        return true;\n\n      case Token.ADD:\n      case Token.AND:\n      case Token.ARRAYLIT:\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITNOT:\n      case Token.BITXOR:\n      case Token.CALL:\n      case Token.COMMA:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FALSE:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.IN:\n      case Token.INC:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TYPEOF:\n      case Token.TRUE:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n"}, "generated_test_class": "Sure, I'll write some unit tests for the `IR.script(Node ... stmts)` method using Java 1.7 and JUnit 4. Given the method's purpose, we need to ensure that it correctly creates a `Node` object of type `SCRIPT` and adds any provided `Node` statements to it. Additionally, we need to verify that it checks if the provided nodes are valid statements.\n\nHere are some unit tests that should maximize both branch and line coverage:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\nimport com.google.common.base.Preconditions;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class IRTest {\n    @Before\n    public void setUp() {\n        // Reset the static mock if necessary or any other setup\n    }\n\n    @Test\n    public void testScriptWithNoStatements() {\n        Node script = IR.script();\n        assertNotNull(script);\n        assertEquals(Token.SCRIPT, script.getType());\n        assertTrue(script.hasMoreThanOneChild());\n        assertEquals(0, script.getChildCount());\n    }\n\n    @Test\n    public void testScriptWithOneStatement() {\n        Node mockStmt = mock(Node.class);\n        when(mockStmt.getType()).thenReturn(Token.LABEL); // Assuming LABEL is a valid statement type\n\n        Node script = IR.script(mockStmt);\n        assertNotNull(script);\n        assertEquals(Token.SCRIPT, script.getType());\n        assertEquals(1, script.getChildCount());\n        assertEquals(mockStmt, script.getFirstChild());\n    }\n\n    @Test\n    public void testScriptWithMultipleStatements() {\n        Node mockStmt1 = mock(Node.class);\n        Node mockStmt2 = mock(Node.class);\n        Node mockStmt3 = mock(Node.class);\n\n        when(mockStmt1.getType()).thenReturn(Token.LABEL);\n        when(mockStmt2.getType()).thenReturn(Token.BLOCK);\n        when(mockStmt3.getType()).thenReturn(Token.IF);\n\n        Node script = IR.script(mockStmt1, mockStmt2, mockStmt3);\n        assertNotNull(script);\n        assertEquals(Token.SCRIPT, script.getType());\n        assertEquals(3, script.getChildCount());\n        assertEquals(mockStmt1, script.getFirstChild());\n        assertEquals(mockStmt2, mockStmt1.getNext());\n        assertEquals(mockStmt3, mockStmt2.getNext());\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testScriptWithInvalidStatement() {\n        Node mockInvalidStmt = mock(Node.class);\n        when(mockInvalidStmt.getType()).thenReturn(Token.NAME); // Assuming NAME is NOT a valid statement type\n\n        IR.script(mockInvalidStmt); // Expect an exception due to invalid statement\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testScriptWithMixedValidAndInvalidStatements() {\n        Node mockValidStmt1 = mock(Node.class);\n        Node mockInvalidStmt = mock(Node.class);\n        Node mockValidStmt2 = mock(Node.class);\n\n        when(mockValidStmt1.getType()).thenReturn(Token.BLOCK);\n        when(mockInvalidStmt.getType()).thenReturn(Token.NAME);\n        when(mockValidStmt2.getType()).thenReturn(Token.IF);\n\n        IR.script(mockValidStmt1, mockInvalidStmt, mockValidStmt2); // Expect an exception due to invalid statement\n    }\n\n    // Mocked class to simulate the behavior of Node\n    public static class Node {\n        public static class Token {\n            public static final int SCRIPT = 0;\n            public static final int LABEL = 1;\n            public static final int BLOCK = 2;\n            public static final int IF = 3;\n            public static final int NAME = 4;\n        }\n\n        private int type;\n        private Node firstChild = null;\n        private Node next = null;\n\n        public Node(int type) {\n            this.type = type;\n        }\n\n        public int getType() {\n            return type;\n        }\n\n        public Node getFirstChild() {\n            return firstChild;\n        }\n\n        public Node getNext() {\n            return next;\n        }\n\n        public void addChildToBack(Node child) {\n            if (firstChild == null) {\n                firstChild = child;\n            } else {\n                Node current = firstChild;\n                while (current.next != null) {\n                    current = current.next;\n                }\n                current.next = child;\n            }\n        }\n\n        public boolean hasMoreThanOneChild() {\n            return firstChild != null && firstChild.next != null;\n        }\n\n        public int getChildCount() {\n            int count = 0;\n            Node current = firstChild;\n            while (current != null) {\n                count++;\n                current = current.next;\n            }\n            return count;\n        }\n    }\n\n    // Mocked method to simulate mayBeStatement behavior\n    private static boolean mayBeStatement(Node node) {\n        switch (node.getType()) {\n            case Node.Token.LABEL:\n            case Node.Token.BLOCK:\n            case Node.Token.IF:\n                return true;\n            default:\n                return false;\n        }\n    }\n}\n```\n\n### Explanation:\n1. **testScriptWithNoStatements**: Tests the `script` method with no statements.\n2. **testScriptWithOneStatement**: Tests the `script` method with one statement.\n3. **testScriptWithMultipleStatements**: Tests the `script` method with multiple statements.\n4. **testScriptWithInvalidStatement**: Tests the `script` method with an invalid statement to ensure it throws an `IllegalStateException`.\n5. **testScriptWithMixedValidAndInvalidStatements**: Tests the `script` method with a mix of valid and invalid statements to ensure it throws an `IllegalStateException`.\n\nThese tests ensure that the `script` method is correctly handling different scenarios, including edge cases and error conditions. The `mayBeStatement` method is also mocked to reflect the behavior of checking if a node is a valid statement."}
{"bug_id": "Closure_27", "version": "fixed", "focal_method_signature": "Node com.google.javascript.rhino.IR#forNode(Node#init,Node#cond,Node#incr,Node#body)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "focal_method": "public static Node forNode(Node init, Node cond, Node incr, Node body) {\n    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, init, cond, incr, body);\n  }", "return_type": "Node", "assertion_subject_candidates": ["int com.google.javascript.rhino.Node#getType()", "boolean com.google.javascript.rhino.Node#hasChildren()", "Node com.google.javascript.rhino.Node#getFirstChild()", "Node com.google.javascript.rhino.Node#getLastChild()", "Node com.google.javascript.rhino.Node#getNext()", "String com.google.javascript.rhino.Node#toString()", "String com.google.javascript.rhino.Node#toStringTree()", "StaticSourceFile com.google.javascript.rhino.Node#getStaticSourceFile()", "InputId com.google.javascript.rhino.Node#getInputId()", "int com.google.javascript.rhino.Node#getLength()", "int com.google.javascript.rhino.Node#getLineno()", "int com.google.javascript.rhino.Node#getCharno()", "int com.google.javascript.rhino.Node#getSourcePosition()", "Iterable<Node> com.google.javascript.rhino.Node#siblings()", "Node com.google.javascript.rhino.Node#getParent()", "AncestorIterable com.google.javascript.rhino.Node#getAncestors()", "boolean com.google.javascript.rhino.Node#hasOneChild()", "boolean com.google.javascript.rhino.Node#hasMoreThanOneChild()", "JSType com.google.javascript.rhino.Node#getJSType()", "FileLevelJsDocBuilder com.google.javascript.rhino.Node#getJsDocBuilderForNode()", "JSDocInfo com.google.javascript.rhino.Node#getJSDocInfo()", "boolean com.google.javascript.rhino.Node#isVarArgs()", "boolean com.google.javascript.rhino.Node#isOptionalArg()", "boolean com.google.javascript.rhino.Node#isSyntheticBlock()", "Set<String> com.google.javascript.rhino.Node#getDirectives()", "boolean com.google.javascript.rhino.Node#wasEmptyNode()", "int com.google.javascript.rhino.Node#getSideEffectFlags()", "boolean com.google.javascript.rhino.Node#isOnlyModifiesThisCall()", "boolean com.google.javascript.rhino.Node#isNoSideEffectsCall()", "boolean com.google.javascript.rhino.Node#isLocalResultCall()", "boolean com.google.javascript.rhino.Node#isQuotedString()", "boolean com.google.javascript.rhino.Node#isAdd()", "boolean com.google.javascript.rhino.Node#isAnd()", "boolean com.google.javascript.rhino.Node#isArrayLit()", "boolean com.google.javascript.rhino.Node#isAssign()", "boolean com.google.javascript.rhino.Node#isAssignAdd()", "boolean com.google.javascript.rhino.Node#isBlock()", "boolean com.google.javascript.rhino.Node#isBreak()", "boolean com.google.javascript.rhino.Node#isCall()", "boolean com.google.javascript.rhino.Node#isCase()", "boolean com.google.javascript.rhino.Node#isCatch()", "boolean com.google.javascript.rhino.Node#isComma()", "boolean com.google.javascript.rhino.Node#isContinue()", "boolean com.google.javascript.rhino.Node#isDebugger()", "boolean com.google.javascript.rhino.Node#isDec()", "boolean com.google.javascript.rhino.Node#isDefaultCase()", "boolean com.google.javascript.rhino.Node#isDelProp()", "boolean com.google.javascript.rhino.Node#isDo()", "boolean com.google.javascript.rhino.Node#isEmpty()", "boolean com.google.javascript.rhino.Node#isExprResult()", "boolean com.google.javascript.rhino.Node#isFalse()", "boolean com.google.javascript.rhino.Node#isFor()", "boolean com.google.javascript.rhino.Node#isFunction()", "boolean com.google.javascript.rhino.Node#isGetterDef()", "boolean com.google.javascript.rhino.Node#isGetElem()", "boolean com.google.javascript.rhino.Node#isGetProp()", "boolean com.google.javascript.rhino.Node#isHook()", "boolean com.google.javascript.rhino.Node#isIf()", "boolean com.google.javascript.rhino.Node#isIn()", "boolean com.google.javascript.rhino.Node#isInc()", "boolean com.google.javascript.rhino.Node#isInstanceOf()", "boolean com.google.javascript.rhino.Node#isLabel()", "boolean com.google.javascript.rhino.Node#isLabelName()", "boolean com.google.javascript.rhino.Node#isName()", "boolean com.google.javascript.rhino.Node#isNE()", "boolean com.google.javascript.rhino.Node#isNew()", "boolean com.google.javascript.rhino.Node#isNot()", "boolean com.google.javascript.rhino.Node#isNull()", "boolean com.google.javascript.rhino.Node#isNumber()", "boolean com.google.javascript.rhino.Node#isObjectLit()", "boolean com.google.javascript.rhino.Node#isOr()", "boolean com.google.javascript.rhino.Node#isParamList()", "boolean com.google.javascript.rhino.Node#isRegExp()", "boolean com.google.javascript.rhino.Node#isReturn()", "boolean com.google.javascript.rhino.Node#isScript()", "boolean com.google.javascript.rhino.Node#isSetterDef()", "boolean com.google.javascript.rhino.Node#isString()", "boolean com.google.javascript.rhino.Node#isStringKey()", "boolean com.google.javascript.rhino.Node#isSwitch()", "boolean com.google.javascript.rhino.Node#isThis()", "boolean com.google.javascript.rhino.Node#isThrow()", "boolean com.google.javascript.rhino.Node#isTrue()", "boolean com.google.javascript.rhino.Node#isTry()", "boolean com.google.javascript.rhino.Node#isTypeOf()", "boolean com.google.javascript.rhino.Node#isVar()", "boolean com.google.javascript.rhino.Node#isVoid()", "boolean com.google.javascript.rhino.Node#isWhile()", "boolean com.google.javascript.rhino.Node#isWith()"], "focal_class": {"name": "IR", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import java.util.List;"], "fields": [], "methods": ["Node com.google.javascript.rhino.IR#empty()", "Node com.google.javascript.rhino.IR#function(Node#name,Node#params,Node#body)", "Node com.google.javascript.rhino.IR#paramList()", "Node com.google.javascript.rhino.IR#paramList(Node#param)", "Node com.google.javascript.rhino.IR#paramList(#Node ... params)", "Node com.google.javascript.rhino.IR#paramList(List<Node>#params)", "Node com.google.javascript.rhino.IR#block()", "Node com.google.javascript.rhino.IR#block(Node#stmt)", "Node com.google.javascript.rhino.IR#block(#Node ... stmts)", "Node com.google.javascript.rhino.IR#blockUnchecked(Node#stmt)", "Node com.google.javascript.rhino.IR#script(#Node ... stmts)", "Node com.google.javascript.rhino.IR#var(Node#name,Node#value)", "Node com.google.javascript.rhino.IR#var(Node#name)", "Node com.google.javascript.rhino.IR#returnNode()", "Node com.google.javascript.rhino.IR#returnNode(Node#expr)", "Node com.google.javascript.rhino.IR#throwNode(Node#expr)", "Node com.google.javascript.rhino.IR#exprResult(Node#expr)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then,Node#elseNode)", "Node com.google.javascript.rhino.IR#doNode(Node#body,Node#cond)", "Node com.google.javascript.rhino.IR#forIn(Node#target,Node#cond,Node#body)", "Node com.google.javascript.rhino.IR#switchNode(Node#cond,#Node ... cases)", "Node com.google.javascript.rhino.IR#caseNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#defaultCase(Node#body)", "Node com.google.javascript.rhino.IR#label(Node#name,Node#stmt)", "Node com.google.javascript.rhino.IR#labelName(String#name)", "Node com.google.javascript.rhino.IR#tryFinally(Node#tryBody,Node#finallyBody)", "Node com.google.javascript.rhino.IR#tryCatch(Node#tryBody,Node#catchNode)", "Node com.google.javascript.rhino.IR#tryCatchFinally(Node#tryBody,Node#catchNode,Node#finallyBody)", "Node com.google.javascript.rhino.IR#catchNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#breakNode()", "Node com.google.javascript.rhino.IR#breakNode(Node#name)", "Node com.google.javascript.rhino.IR#continueNode()", "Node com.google.javascript.rhino.IR#continueNode(Node#name)", "Node com.google.javascript.rhino.IR#call(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#newNode(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#name(String#name)", "Node com.google.javascript.rhino.IR#getprop(Node#target,Node#prop)", "Node com.google.javascript.rhino.IR#getelem(Node#target,Node#elem)", "Node com.google.javascript.rhino.IR#assign(Node#target,Node#expr)", "Node com.google.javascript.rhino.IR#hook(Node#cond,Node#trueval,Node#falseval)", "Node com.google.javascript.rhino.IR#comma(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#and(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#or(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#not(Node#expr1)", "Node com.google.javascript.rhino.IR#eq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sheq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#voidNode(Node#expr1)", "Node com.google.javascript.rhino.IR#neg(Node#expr1)", "Node com.google.javascript.rhino.IR#pos(Node#expr1)", "Node com.google.javascript.rhino.IR#add(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sub(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#objectlit(#Node ... propdefs)", "Node com.google.javascript.rhino.IR#propdef(Node#string,Node#value)", "Node com.google.javascript.rhino.IR#arraylit(#Node ... exprs)", "Node com.google.javascript.rhino.IR#regexp(Node#expr)", "Node com.google.javascript.rhino.IR#regexp(Node#expr,Node#flags)", "Node com.google.javascript.rhino.IR#string(String#s)", "Node com.google.javascript.rhino.IR#stringKey(String#s)", "Node com.google.javascript.rhino.IR#number(double#d)", "Node com.google.javascript.rhino.IR#thisNode()", "Node com.google.javascript.rhino.IR#trueNode()", "Node com.google.javascript.rhino.IR#falseNode()", "Node com.google.javascript.rhino.IR#nullNode()", "Node com.google.javascript.rhino.IR#binaryOp(int#token,Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#unaryOp(int#token,Node#expr)", "boolean com.google.javascript.rhino.IR#mayBeExpressionOrEmpty(Node#n)", "boolean com.google.javascript.rhino.IR#isAssignmentTarget(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeStatement(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeExpression(Node#n)"], "other_methods": ["public static Node empty();", "public static Node function(Node name,Node params,Node body);", "public static Node paramList();", "public static Node paramList(Node param);", "public static Node paramList( Node ... params);", "public static Node paramList(List<Node> params);", "public static Node block();", "public static Node block(Node stmt);", "public static Node block( Node ... stmts);", "public static Node script( Node ... stmts);", "public static Node var(Node name,Node value);", "public static Node var(Node name);", "public static Node returnNode();", "public static Node returnNode(Node expr);", "public static Node throwNode(Node expr);", "public static Node exprResult(Node expr);", "public static Node ifNode(Node cond,Node then);", "public static Node ifNode(Node cond,Node then,Node elseNode);", "public static Node doNode(Node body,Node cond);", "public static Node forIn(Node target,Node cond,Node body);", "public static Node switchNode(Node cond, Node ... cases);", "public static Node caseNode(Node expr,Node body);", "public static Node defaultCase(Node body);", "public static Node label(Node name,Node stmt);", "public static Node labelName(String name);", "public static Node tryFinally(Node tryBody,Node finallyBody);", "public static Node tryCatch(Node tryBody,Node catchNode);", "public static Node tryCatchFinally(Node tryBody,Node catchNode,Node finallyBody);", "public static Node catchNode(Node expr,Node body);", "public static Node breakNode();", "public static Node breakNode(Node name);", "public static Node continueNode();", "public static Node continueNode(Node name);", "public static Node call(Node target, Node ... args);", "public static Node newNode(Node target, Node ... args);", "public static Node name(String name);", "public static Node getprop(Node target,Node prop);", "public static Node getelem(Node target,Node elem);", "public static Node assign(Node target,Node expr);", "public static Node hook(Node cond,Node trueval,Node falseval);", "public static Node comma(Node expr1,Node expr2);", "public static Node and(Node expr1,Node expr2);", "public static Node or(Node expr1,Node expr2);", "public static Node not(Node expr1);", "public static Node eq(Node expr1,Node expr2);", "public static Node sheq(Node expr1,Node expr2);", "public static Node voidNode(Node expr1);", "public static Node neg(Node expr1);", "public static Node pos(Node expr1);", "public static Node add(Node expr1,Node expr2);", "public static Node sub(Node expr1,Node expr2);", "public static Node objectlit( Node ... propdefs);", "public static Node propdef(Node string,Node value);", "public static Node arraylit( Node ... exprs);", "public static Node regexp(Node expr);", "public static Node regexp(Node expr,Node flags);", "public static Node string(String s);", "public static Node stringKey(String s);", "public static Node number(double d);", "public static Node thisNode();", "public static Node trueNode();", "public static Node falseNode();", "public static Node nullNode();"], "fields_dict": {}, "text": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   John Lenz\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.List;\n\n/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n\n  private IR() {}\n\n  public static Node empty() {\n    return new Node(Token.EMPTY);\n  }\n\n  public static Node function(Node name, Node params, Node body) {\n    Preconditions.checkState(name.isName());\n    Preconditions.checkState(params.isParamList());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FUNCTION, name, params, body);\n  }\n\n  public static Node paramList() {\n    return new Node(Token.PARAM_LIST);\n  }\n\n  public static Node paramList(Node param) {\n    Preconditions.checkState(param.isName());\n    return new Node(Token.PARAM_LIST, param);\n  }\n\n  public static Node paramList(Node ... params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node paramList(List<Node> params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n\n  public static Node block(Node stmt) {\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.BLOCK, stmt);\n    return block;\n  }\n\n  public static Node block(Node ... stmts) {\n    Node block = new Node(Token.BLOCK);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n\n  public static Node script(Node ... stmts) {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  public static Node var(Node name, Node value) {\n    Preconditions.checkState(name.isName() && !name.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    name.addChildToFront(value);\n    return var(name);\n  }\n\n  public static Node var(Node name) {\n    Preconditions.checkState(name.isName());\n    return new Node(Token.VAR, name);\n  }\n\n  public static Node returnNode() {\n    return new Node(Token.RETURN);\n  }\n\n  public static Node returnNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.RETURN, expr);\n  }\n\n  public static Node throwNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.THROW, expr);\n  }\n\n  public static Node exprResult(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.EXPR_RESULT, expr);\n  }\n\n  public static Node ifNode(Node cond, Node then) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    return new Node(Token.IF, cond, then);\n  }\n\n  public static Node ifNode(Node cond, Node then, Node elseNode) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    Preconditions.checkState(elseNode.isBlock());\n    return new Node(Token.IF, cond, then, elseNode);\n  }\n\n  public static Node doNode(Node body, Node cond) {\n    Preconditions.checkState(body.isBlock());\n    Preconditions.checkState(mayBeExpression(cond));\n    return new Node(Token.DO, body, cond);\n  }\n\n  public static Node forIn(Node target, Node cond, Node body) {\n    Preconditions.checkState(target.isVar() || mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, target, cond, body);\n  }\n\n  public static Node forNode(Node init, Node cond, Node incr, Node body) {\n    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, init, cond, incr, body);\n  }\n\n  public static Node switchNode(Node cond, Node ... cases) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Node switchNode = new Node(Token.SWITCH, cond);\n    for (Node caseNode : cases) {\n      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n      switchNode.addChildToBack(caseNode);\n    }\n    return switchNode;\n  }\n\n  public static Node caseNode(Node expr, Node body) {\n    Preconditions.checkState(mayBeExpression(expr));\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.CASE, expr, body);\n  }\n\n  public static Node defaultCase(Node body) {\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.DEFAULT_CASE, body);\n  }\n\n  public static Node label(Node name, Node stmt) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.LABEL, name, stmt);\n    return block;\n  }\n\n  public static Node labelName(String name) {\n    Preconditions.checkState(!name.isEmpty());\n    return Node.newString(Token.LABEL_NAME, name);\n  }\n\n  public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n  }\n\n  public static Node tryCatch(Node tryBody, Node catchNode) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n    return new Node(Token.TRY, tryBody, catchBody);\n  }\n\n  public static Node tryCatchFinally(\n      Node tryBody, Node catchNode, Node finallyBody) {\n    Preconditions.checkState(finallyBody.isBlock());\n    Node tryNode = tryCatch(tryBody, catchNode);\n    tryNode.addChildToBack(finallyBody);\n    return tryNode;\n  }\n\n  public static Node catchNode(Node expr, Node body) {\n    Preconditions.checkState(expr.isName());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.CATCH, expr, body);\n  }\n\n  public static Node breakNode() {\n    return new Node(Token.BREAK);\n  }\n\n  public static Node breakNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.BREAK, name);\n  }\n\n  public static Node continueNode() {\n    return new Node(Token.CONTINUE);\n  }\n\n  public static Node continueNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.CONTINUE, name);\n  }\n\n\n  //\n\n  public static Node call(Node target, Node ... args) {\n    Node call = new Node(Token.CALL, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      call.addChildToBack(arg);\n    }\n    return call;\n  }\n\n  public static Node newNode(Node target, Node ... args) {\n    Node newcall = new Node(Token.NEW, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      newcall.addChildToBack(arg);\n    }\n    return newcall;\n  }\n\n  public static Node name(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n\n  public static Node getprop(Node target, Node prop) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(prop.isString());\n    return new Node(Token.GETPROP, target, prop);\n  }\n\n  public static Node getelem(Node target, Node elem) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(elem));\n    return new Node(Token.GETELEM, target, elem);\n  }\n\n  public static Node assign(Node target, Node expr) {\n    Preconditions.checkState(isAssignmentTarget(target));\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.ASSIGN, target, expr);\n  }\n\n  public static Node hook(Node cond, Node trueval, Node falseval) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(mayBeExpression(trueval));\n    Preconditions.checkState(mayBeExpression(falseval));\n    return new Node(Token.HOOK, cond, trueval, falseval);\n  }\n\n  public static Node comma(Node expr1, Node expr2) {\n    return binaryOp(Token.COMMA, expr1, expr2);\n  }\n\n  public static Node and(Node expr1, Node expr2) {\n    return binaryOp(Token.AND, expr1, expr2);\n  }\n\n  public static Node or(Node expr1, Node expr2) {\n    return binaryOp(Token.OR, expr1, expr2);\n  }\n\n  public static Node not(Node expr1) {\n    return unaryOp(Token.NOT, expr1);\n  }\n\n  /**\n   * \"==\"\n   */\n  public static Node eq(Node expr1, Node expr2) {\n    return binaryOp(Token.EQ, expr1, expr2);\n  }\n\n  /**\n   * \"===\"\n   */\n  public static Node sheq(Node expr1, Node expr2) {\n    return binaryOp(Token.SHEQ, expr1, expr2);\n  }\n\n  public static Node voidNode(Node expr1) {\n    return unaryOp(Token.VOID, expr1);\n  }\n\n  public static Node neg(Node expr1) {\n    return unaryOp(Token.NEG, expr1);\n  }\n\n  public static Node pos(Node expr1) {\n    return unaryOp(Token.POS, expr1);\n  }\n\n  public static Node add(Node expr1, Node expr2) {\n    return binaryOp(Token.ADD, expr1, expr2);\n  }\n\n  public static Node sub(Node expr1, Node expr2) {\n    return binaryOp(Token.SUB, expr1, expr2);\n  }\n\n  // TODO(johnlenz): the rest of the ops\n\n  // literals\n  public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }\n\n  // TODO(johnlenz): quoted props\n\n  public static Node propdef(Node string, Node value) {\n    Preconditions.checkState(string.isStringKey());\n    Preconditions.checkState(!string.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    string.addChildToFront(value);\n    return string;\n  }\n\n  public static Node arraylit(Node ... exprs) {\n    Node arraylit = new Node(Token.ARRAYLIT);\n    for (Node expr : exprs) {\n      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n      arraylit.addChildToBack(expr);\n    }\n    return arraylit;\n  }\n\n  public static Node regexp(Node expr) {\n    Preconditions.checkState(expr.isString());\n    return new Node(Token.REGEXP, expr);\n  }\n\n  public static Node regexp(Node expr, Node flags) {\n    Preconditions.checkState(expr.isString());\n    Preconditions.checkState(flags.isString());\n    return new Node(Token.REGEXP, expr, flags);\n  }\n\n  public static Node string(String s) {\n    return Node.newString(s);\n  }\n\n  public static Node stringKey(String s) {\n    return Node.newString(Token.STRING_KEY, s);\n  }\n\n  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n\n  public static Node thisNode() {\n    return new Node(Token.THIS);\n  }\n\n  public static Node trueNode() {\n    return new Node(Token.TRUE);\n  }\n\n  public static Node falseNode() {\n    return new Node(Token.FALSE);\n  }\n\n  public static Node nullNode() {\n    return new Node(Token.NULL);\n  }\n\n  // helper methods\n\n  private static Node binaryOp(int token, Node expr1, Node expr2) {\n    Preconditions.checkState(mayBeExpression(expr1));\n    Preconditions.checkState(mayBeExpression(expr2));\n    return new Node(token, expr1, expr2);\n  }\n\n  private static Node unaryOp(int token, Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(token, expr);\n  }\n\n  private static boolean mayBeExpressionOrEmpty(Node n) {\n    return n.isEmpty() || mayBeExpression(n);\n  }\n\n  private static boolean isAssignmentTarget(Node n) {\n    return n.isName() || n.isGetProp() || n.isGetElem();\n  }\n\n  // NOTE: some nodes are neither statements nor expression nodes:\n  //   SCRIPT, LABEL_NAME, PARAM_LIST, CASE, DEFAULT_CASE, CATCH\n  //   GETTER_DEF, SETTER_DEF\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeStatement(Node n) {\n    switch (n.getType()) {\n      case Token.EMPTY:\n      case Token.FUNCTION:\n        // EMPTY and FUNCTION are used both in expression and statement\n        // contexts\n        return true;\n\n      case Token.BLOCK:\n      case Token.BREAK:\n      case Token.CONST:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.DO:\n      case Token.EXPR_RESULT:\n      case Token.FOR:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.RETURN:\n      case Token.SWITCH:\n      case Token.THROW:\n      case Token.TRY:\n      case Token.VAR:\n      case Token.WHILE:\n      case Token.WITH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeExpression(Node n) {\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // FUNCTION is used both in expression and statement\n        // contexts.\n        return true;\n\n      case Token.ADD:\n      case Token.AND:\n      case Token.ARRAYLIT:\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITNOT:\n      case Token.BITXOR:\n      case Token.CALL:\n      case Token.COMMA:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FALSE:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.IN:\n      case Token.INC:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TYPEOF:\n      case Token.TRUE:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n"}, "generated_test_class": "To write unit tests for the `forNode` method in the `IR` class, we need to ensure that we cover all possible branches and lines. Given the method's structure, we need to test different scenarios for the `init`, `cond`, `incr`, and `body` parameters.\n\nHere's a set of unit tests that should provide good branch and line coverage:\n\n```java\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.Rule;\nimport org.junit.rules.ExpectedException;\nimport com.google.common.base.Preconditions;\n\npublic class IRTest {\n\n    private Node varNode;\n    private Node expressionNode;\n    private Node blockNode;\n\n    @Before\n    public void setUp() {\n        varNode = IR.var(IR.name(\"x\"), IR.number(0));\n        expressionNode = IR.eq(IR.name(\"x\"), IR.number(10));\n        blockNode = IR.block();\n    }\n\n    @Test\n    public void testForNodeWithVarInitExpressionCondExpressionIncrBlock() {\n        Node init = varNode;\n        Node cond = expressionNode;\n        Node incr = IR.add(IR.name(\"x\"), IR.number(1));\n        Node body = blockNode;\n\n        Node forNode = IR.forNode(init, cond, incr, body);\n\n        assertEquals(Token.FOR, forNode.getType());\n        assertEquals(4, forNode.getChildCount());\n        assertEquals(init, forNode.getChildAtIndex(0));\n        assertEquals(cond, forNode.getChildAtIndex(1));\n        assertEquals(incr, forNode.getChildAtIndex(2));\n        assertEquals(body, forNode.getChildAtIndex(3));\n    }\n\n    @Test\n    public void testForNodeWithExpressionInitExpressionCondExpressionIncrBlock() {\n        Node init = IR.assign(IR.name(\"x\"), IR.number(0));\n        Node cond = expressionNode;\n        Node incr = IR.add(IR.name(\"x\"), IR.number(1));\n        Node body = blockNode;\n\n        Node forNode = IR.forNode(init, cond, incr, body);\n\n        assertEquals(Token.FOR, forNode.getType());\n        assertEquals(4, forNode.getChildCount());\n        assertEquals(init, forNode.getChildAtIndex(0));\n        assertEquals(cond, forNode.getChildAtIndex(1));\n        assertEquals(incr, forNode.getChildAtIndex(2));\n        assertEquals(body, forNode.getChildAtIndex(3));\n    }\n\n    @Test\n    public void testForNodeWithEmptyInitExpressionCondExpressionIncrBlock() {\n        Node init = IR.empty();\n        Node cond = expressionNode;\n        Node incr = IR.add(IR.name(\"x\"), IR.number(1));\n        Node body = blockNode;\n\n        Node forNode = IR.forNode(init, cond, incr, body);\n\n        assertEquals(Token.FOR, forNode.getType());\n        assertEquals(4, forNode.getChildCount());\n        assertEquals(init, forNode.getChildAtIndex(0));\n        assertEquals(cond, forNode.getChildAtIndex(1));\n        assertEquals(incr, forNode.getChildAtIndex(2));\n        assertEquals(body, forNode.getChildAtIndex(3));\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testForNodeWithInvalidInitThrows() {\n        Node init = IR.function(IR.name(\"f\"), IR.paramList(), IR.block());\n        Node cond = expressionNode;\n        Node incr = IR.add(IR.name(\"x\"), IR.number(1));\n        Node body = blockNode;\n\n        IR.forNode(init, cond, incr, body);\n    }\n\n    @Test\n    public void testForNodeWithNullCondExpressionIncrBlock() {\n        Node init = varNode;\n        Node cond = IR.nullNode();\n        Node incr = IR.add(IR.name(\"x\"), IR.number(1));\n        Node body = blockNode;\n\n        Node forNode = IR.forNode(init, cond, incr, body);\n\n        assertEquals(Token.FOR, forNode.getType());\n        assertEquals(4, forNode.getChildCount());\n        assertEquals(init, forNode.getChildAtIndex(0));\n        assertEquals(cond, forNode.getChildAtIndex(1));\n        assertEquals(incr, forNode.getChildAtIndex(2));\n        assertEquals(body, forNode.getChildAtIndex(3));\n    }\n\n    @Test\n    public void testForNodeWithNullIncrExpressionCondBlock() {\n        Node init = varNode;\n        Node cond = expressionNode;\n        Node incr = IR.nullNode();\n        Node body = blockNode;\n\n        Node forNode = IR.forNode(init, cond, incr, body);\n\n        assertEquals(Token.FOR, forNode.getType());\n        assertEquals(4, forNode.getChildCount());\n        assertEquals(init, forNode.getChildAtIndex(0));\n        assertEquals(cond, forNode.getChildAtIndex(1));\n        assertEquals(incr, forNode.getChildAtIndex(2));\n        assertEquals(body, forNode.getChildAtIndex(3));\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testForNodeWithInvalidBodyThrows() {\n        Node init = varNode;\n        Node cond = expressionNode;\n        Node incr = IR.add(IR.name(\"x\"), IR.number(1));\n        Node body = IR.exprResult(IR.name(\"x\"));\n\n        IR.forNode(init, cond, incr, body);\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testForNodeWithInvalidExpressionInitThrows() {\n        Node init = IR.function(IR.name(\"f\"), IR.paramList(), IR.block());\n        Node cond = expressionNode;\n        Node incr = IR.add(IR.name(\"x\"), IR.number(1));\n        Node body = blockNode;\n\n        IR.forNode(init, cond, incr, body);\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testForNodeWithInvalidExpressionCondThrows() {\n        Node init = varNode;\n        Node cond = IR.function(IR.name(\"f\"), IR.paramList(), IR.block());\n        Node incr = IR.add(IR.name(\"x\"), IR.number(1));\n        Node body = blockNode;\n\n        IR.forNode(init, cond, incr, body);\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testForNodeWithInvalidExpressionIncrThrows() {\n        Node init = varNode;\n        Node cond = expressionNode;\n        Node incr = IR.function(IR.name(\"f\"), IR.paramList(), IR.block());\n        Node body = blockNode;\n\n        IR.forNode(init, cond, incr, body);\n    }\n}\n```\n\n### Explanation:\n\n- **Test Valid Cases:**\n  - `testForNodeWithVarInitExpressionCondExpressionIncrBlock`: Tests a typical for loop initialization with a variable declaration.\n  - `testForNodeWithExpressionInitExpressionCondExpressionIncrBlock`: Tests a typical for loop initialization with an expression.\n  - `testForNodeWithEmptyInitExpressionCondExpressionIncrBlock`: Tests a for loop with an empty initialization.\n\n- **Test Invalid Cases:**\n  - `testForNodeWithInvalidInitThrows`: Tests that an invalid `init` parameter throws an `IllegalStateException`.\n  - `testForNodeWithInvalidBodyThrows`: Tests that an invalid `body` parameter throws an `IllegalStateException`.\n  - `testForNodeWithInvalidExpressionInitThrows`: Tests that an invalid `init` expression parameter throws an `IllegalStateException`.\n  - `testForNodeWithInvalidExpressionCondThrows`: Tests that an invalid `cond` expression parameter throws an `IllegalStateException`.\n  - `testForNodeWithInvalidExpressionIncrThrows`: Tests that an invalid `incr` expression parameter throws an `IllegalStateException`.\n\nThese tests should maximize both branch and line coverage for the `forNode` method."}
{"bug_id": "Closure_27", "version": "fixed", "focal_method_signature": "Node com.google.javascript.rhino.IR#switchNode(Node#cond,#Node ... cases)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "focal_method": "public static Node switchNode(Node cond, Node ... cases) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Node switchNode = new Node(Token.SWITCH, cond);\n    for (Node caseNode : cases) {\n      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n      switchNode.addChildToBack(caseNode);\n    }\n    return switchNode;\n  }", "return_type": "Node", "assertion_subject_candidates": ["int com.google.javascript.rhino.Node#getType()", "boolean com.google.javascript.rhino.Node#hasChildren()", "Node com.google.javascript.rhino.Node#getFirstChild()", "Node com.google.javascript.rhino.Node#getLastChild()", "Node com.google.javascript.rhino.Node#getNext()", "String com.google.javascript.rhino.Node#toString()", "String com.google.javascript.rhino.Node#toStringTree()", "StaticSourceFile com.google.javascript.rhino.Node#getStaticSourceFile()", "InputId com.google.javascript.rhino.Node#getInputId()", "int com.google.javascript.rhino.Node#getLength()", "int com.google.javascript.rhino.Node#getLineno()", "int com.google.javascript.rhino.Node#getCharno()", "int com.google.javascript.rhino.Node#getSourcePosition()", "Iterable<Node> com.google.javascript.rhino.Node#siblings()", "Node com.google.javascript.rhino.Node#getParent()", "AncestorIterable com.google.javascript.rhino.Node#getAncestors()", "boolean com.google.javascript.rhino.Node#hasOneChild()", "boolean com.google.javascript.rhino.Node#hasMoreThanOneChild()", "JSType com.google.javascript.rhino.Node#getJSType()", "FileLevelJsDocBuilder com.google.javascript.rhino.Node#getJsDocBuilderForNode()", "JSDocInfo com.google.javascript.rhino.Node#getJSDocInfo()", "boolean com.google.javascript.rhino.Node#isVarArgs()", "boolean com.google.javascript.rhino.Node#isOptionalArg()", "boolean com.google.javascript.rhino.Node#isSyntheticBlock()", "Set<String> com.google.javascript.rhino.Node#getDirectives()", "boolean com.google.javascript.rhino.Node#wasEmptyNode()", "int com.google.javascript.rhino.Node#getSideEffectFlags()", "boolean com.google.javascript.rhino.Node#isOnlyModifiesThisCall()", "boolean com.google.javascript.rhino.Node#isNoSideEffectsCall()", "boolean com.google.javascript.rhino.Node#isLocalResultCall()", "boolean com.google.javascript.rhino.Node#isQuotedString()", "boolean com.google.javascript.rhino.Node#isAdd()", "boolean com.google.javascript.rhino.Node#isAnd()", "boolean com.google.javascript.rhino.Node#isArrayLit()", "boolean com.google.javascript.rhino.Node#isAssign()", "boolean com.google.javascript.rhino.Node#isAssignAdd()", "boolean com.google.javascript.rhino.Node#isBlock()", "boolean com.google.javascript.rhino.Node#isBreak()", "boolean com.google.javascript.rhino.Node#isCall()", "boolean com.google.javascript.rhino.Node#isCase()", "boolean com.google.javascript.rhino.Node#isCatch()", "boolean com.google.javascript.rhino.Node#isComma()", "boolean com.google.javascript.rhino.Node#isContinue()", "boolean com.google.javascript.rhino.Node#isDebugger()", "boolean com.google.javascript.rhino.Node#isDec()", "boolean com.google.javascript.rhino.Node#isDefaultCase()", "boolean com.google.javascript.rhino.Node#isDelProp()", "boolean com.google.javascript.rhino.Node#isDo()", "boolean com.google.javascript.rhino.Node#isEmpty()", "boolean com.google.javascript.rhino.Node#isExprResult()", "boolean com.google.javascript.rhino.Node#isFalse()", "boolean com.google.javascript.rhino.Node#isFor()", "boolean com.google.javascript.rhino.Node#isFunction()", "boolean com.google.javascript.rhino.Node#isGetterDef()", "boolean com.google.javascript.rhino.Node#isGetElem()", "boolean com.google.javascript.rhino.Node#isGetProp()", "boolean com.google.javascript.rhino.Node#isHook()", "boolean com.google.javascript.rhino.Node#isIf()", "boolean com.google.javascript.rhino.Node#isIn()", "boolean com.google.javascript.rhino.Node#isInc()", "boolean com.google.javascript.rhino.Node#isInstanceOf()", "boolean com.google.javascript.rhino.Node#isLabel()", "boolean com.google.javascript.rhino.Node#isLabelName()", "boolean com.google.javascript.rhino.Node#isName()", "boolean com.google.javascript.rhino.Node#isNE()", "boolean com.google.javascript.rhino.Node#isNew()", "boolean com.google.javascript.rhino.Node#isNot()", "boolean com.google.javascript.rhino.Node#isNull()", "boolean com.google.javascript.rhino.Node#isNumber()", "boolean com.google.javascript.rhino.Node#isObjectLit()", "boolean com.google.javascript.rhino.Node#isOr()", "boolean com.google.javascript.rhino.Node#isParamList()", "boolean com.google.javascript.rhino.Node#isRegExp()", "boolean com.google.javascript.rhino.Node#isReturn()", "boolean com.google.javascript.rhino.Node#isScript()", "boolean com.google.javascript.rhino.Node#isSetterDef()", "boolean com.google.javascript.rhino.Node#isString()", "boolean com.google.javascript.rhino.Node#isStringKey()", "boolean com.google.javascript.rhino.Node#isSwitch()", "boolean com.google.javascript.rhino.Node#isThis()", "boolean com.google.javascript.rhino.Node#isThrow()", "boolean com.google.javascript.rhino.Node#isTrue()", "boolean com.google.javascript.rhino.Node#isTry()", "boolean com.google.javascript.rhino.Node#isTypeOf()", "boolean com.google.javascript.rhino.Node#isVar()", "boolean com.google.javascript.rhino.Node#isVoid()", "boolean com.google.javascript.rhino.Node#isWhile()", "boolean com.google.javascript.rhino.Node#isWith()"], "focal_class": {"name": "IR", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import java.util.List;"], "fields": [], "methods": ["Node com.google.javascript.rhino.IR#empty()", "Node com.google.javascript.rhino.IR#function(Node#name,Node#params,Node#body)", "Node com.google.javascript.rhino.IR#paramList()", "Node com.google.javascript.rhino.IR#paramList(Node#param)", "Node com.google.javascript.rhino.IR#paramList(#Node ... params)", "Node com.google.javascript.rhino.IR#paramList(List<Node>#params)", "Node com.google.javascript.rhino.IR#block()", "Node com.google.javascript.rhino.IR#block(Node#stmt)", "Node com.google.javascript.rhino.IR#block(#Node ... stmts)", "Node com.google.javascript.rhino.IR#blockUnchecked(Node#stmt)", "Node com.google.javascript.rhino.IR#script(#Node ... stmts)", "Node com.google.javascript.rhino.IR#var(Node#name,Node#value)", "Node com.google.javascript.rhino.IR#var(Node#name)", "Node com.google.javascript.rhino.IR#returnNode()", "Node com.google.javascript.rhino.IR#returnNode(Node#expr)", "Node com.google.javascript.rhino.IR#throwNode(Node#expr)", "Node com.google.javascript.rhino.IR#exprResult(Node#expr)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then,Node#elseNode)", "Node com.google.javascript.rhino.IR#doNode(Node#body,Node#cond)", "Node com.google.javascript.rhino.IR#forIn(Node#target,Node#cond,Node#body)", "Node com.google.javascript.rhino.IR#forNode(Node#init,Node#cond,Node#incr,Node#body)", "Node com.google.javascript.rhino.IR#caseNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#defaultCase(Node#body)", "Node com.google.javascript.rhino.IR#label(Node#name,Node#stmt)", "Node com.google.javascript.rhino.IR#labelName(String#name)", "Node com.google.javascript.rhino.IR#tryFinally(Node#tryBody,Node#finallyBody)", "Node com.google.javascript.rhino.IR#tryCatch(Node#tryBody,Node#catchNode)", "Node com.google.javascript.rhino.IR#tryCatchFinally(Node#tryBody,Node#catchNode,Node#finallyBody)", "Node com.google.javascript.rhino.IR#catchNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#breakNode()", "Node com.google.javascript.rhino.IR#breakNode(Node#name)", "Node com.google.javascript.rhino.IR#continueNode()", "Node com.google.javascript.rhino.IR#continueNode(Node#name)", "Node com.google.javascript.rhino.IR#call(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#newNode(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#name(String#name)", "Node com.google.javascript.rhino.IR#getprop(Node#target,Node#prop)", "Node com.google.javascript.rhino.IR#getelem(Node#target,Node#elem)", "Node com.google.javascript.rhino.IR#assign(Node#target,Node#expr)", "Node com.google.javascript.rhino.IR#hook(Node#cond,Node#trueval,Node#falseval)", "Node com.google.javascript.rhino.IR#comma(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#and(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#or(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#not(Node#expr1)", "Node com.google.javascript.rhino.IR#eq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sheq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#voidNode(Node#expr1)", "Node com.google.javascript.rhino.IR#neg(Node#expr1)", "Node com.google.javascript.rhino.IR#pos(Node#expr1)", "Node com.google.javascript.rhino.IR#add(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sub(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#objectlit(#Node ... propdefs)", "Node com.google.javascript.rhino.IR#propdef(Node#string,Node#value)", "Node com.google.javascript.rhino.IR#arraylit(#Node ... exprs)", "Node com.google.javascript.rhino.IR#regexp(Node#expr)", "Node com.google.javascript.rhino.IR#regexp(Node#expr,Node#flags)", "Node com.google.javascript.rhino.IR#string(String#s)", "Node com.google.javascript.rhino.IR#stringKey(String#s)", "Node com.google.javascript.rhino.IR#number(double#d)", "Node com.google.javascript.rhino.IR#thisNode()", "Node com.google.javascript.rhino.IR#trueNode()", "Node com.google.javascript.rhino.IR#falseNode()", "Node com.google.javascript.rhino.IR#nullNode()", "Node com.google.javascript.rhino.IR#binaryOp(int#token,Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#unaryOp(int#token,Node#expr)", "boolean com.google.javascript.rhino.IR#mayBeExpressionOrEmpty(Node#n)", "boolean com.google.javascript.rhino.IR#isAssignmentTarget(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeStatement(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeExpression(Node#n)"], "other_methods": ["public static Node empty();", "public static Node function(Node name,Node params,Node body);", "public static Node paramList();", "public static Node paramList(Node param);", "public static Node paramList( Node ... params);", "public static Node paramList(List<Node> params);", "public static Node block();", "public static Node block(Node stmt);", "public static Node block( Node ... stmts);", "public static Node script( Node ... stmts);", "public static Node var(Node name,Node value);", "public static Node var(Node name);", "public static Node returnNode();", "public static Node returnNode(Node expr);", "public static Node throwNode(Node expr);", "public static Node exprResult(Node expr);", "public static Node ifNode(Node cond,Node then);", "public static Node ifNode(Node cond,Node then,Node elseNode);", "public static Node doNode(Node body,Node cond);", "public static Node forIn(Node target,Node cond,Node body);", "public static Node forNode(Node init,Node cond,Node incr,Node body);", "public static Node caseNode(Node expr,Node body);", "public static Node defaultCase(Node body);", "public static Node label(Node name,Node stmt);", "public static Node labelName(String name);", "public static Node tryFinally(Node tryBody,Node finallyBody);", "public static Node tryCatch(Node tryBody,Node catchNode);", "public static Node tryCatchFinally(Node tryBody,Node catchNode,Node finallyBody);", "public static Node catchNode(Node expr,Node body);", "public static Node breakNode();", "public static Node breakNode(Node name);", "public static Node continueNode();", "public static Node continueNode(Node name);", "public static Node call(Node target, Node ... args);", "public static Node newNode(Node target, Node ... args);", "public static Node name(String name);", "public static Node getprop(Node target,Node prop);", "public static Node getelem(Node target,Node elem);", "public static Node assign(Node target,Node expr);", "public static Node hook(Node cond,Node trueval,Node falseval);", "public static Node comma(Node expr1,Node expr2);", "public static Node and(Node expr1,Node expr2);", "public static Node or(Node expr1,Node expr2);", "public static Node not(Node expr1);", "public static Node eq(Node expr1,Node expr2);", "public static Node sheq(Node expr1,Node expr2);", "public static Node voidNode(Node expr1);", "public static Node neg(Node expr1);", "public static Node pos(Node expr1);", "public static Node add(Node expr1,Node expr2);", "public static Node sub(Node expr1,Node expr2);", "public static Node objectlit( Node ... propdefs);", "public static Node propdef(Node string,Node value);", "public static Node arraylit( Node ... exprs);", "public static Node regexp(Node expr);", "public static Node regexp(Node expr,Node flags);", "public static Node string(String s);", "public static Node stringKey(String s);", "public static Node number(double d);", "public static Node thisNode();", "public static Node trueNode();", "public static Node falseNode();", "public static Node nullNode();"], "fields_dict": {}, "text": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   John Lenz\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.List;\n\n/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n\n  private IR() {}\n\n  public static Node empty() {\n    return new Node(Token.EMPTY);\n  }\n\n  public static Node function(Node name, Node params, Node body) {\n    Preconditions.checkState(name.isName());\n    Preconditions.checkState(params.isParamList());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FUNCTION, name, params, body);\n  }\n\n  public static Node paramList() {\n    return new Node(Token.PARAM_LIST);\n  }\n\n  public static Node paramList(Node param) {\n    Preconditions.checkState(param.isName());\n    return new Node(Token.PARAM_LIST, param);\n  }\n\n  public static Node paramList(Node ... params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node paramList(List<Node> params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n\n  public static Node block(Node stmt) {\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.BLOCK, stmt);\n    return block;\n  }\n\n  public static Node block(Node ... stmts) {\n    Node block = new Node(Token.BLOCK);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n\n  public static Node script(Node ... stmts) {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  public static Node var(Node name, Node value) {\n    Preconditions.checkState(name.isName() && !name.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    name.addChildToFront(value);\n    return var(name);\n  }\n\n  public static Node var(Node name) {\n    Preconditions.checkState(name.isName());\n    return new Node(Token.VAR, name);\n  }\n\n  public static Node returnNode() {\n    return new Node(Token.RETURN);\n  }\n\n  public static Node returnNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.RETURN, expr);\n  }\n\n  public static Node throwNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.THROW, expr);\n  }\n\n  public static Node exprResult(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.EXPR_RESULT, expr);\n  }\n\n  public static Node ifNode(Node cond, Node then) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    return new Node(Token.IF, cond, then);\n  }\n\n  public static Node ifNode(Node cond, Node then, Node elseNode) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    Preconditions.checkState(elseNode.isBlock());\n    return new Node(Token.IF, cond, then, elseNode);\n  }\n\n  public static Node doNode(Node body, Node cond) {\n    Preconditions.checkState(body.isBlock());\n    Preconditions.checkState(mayBeExpression(cond));\n    return new Node(Token.DO, body, cond);\n  }\n\n  public static Node forIn(Node target, Node cond, Node body) {\n    Preconditions.checkState(target.isVar() || mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, target, cond, body);\n  }\n\n  public static Node forNode(Node init, Node cond, Node incr, Node body) {\n    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, init, cond, incr, body);\n  }\n\n  public static Node switchNode(Node cond, Node ... cases) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Node switchNode = new Node(Token.SWITCH, cond);\n    for (Node caseNode : cases) {\n      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n      switchNode.addChildToBack(caseNode);\n    }\n    return switchNode;\n  }\n\n  public static Node caseNode(Node expr, Node body) {\n    Preconditions.checkState(mayBeExpression(expr));\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.CASE, expr, body);\n  }\n\n  public static Node defaultCase(Node body) {\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.DEFAULT_CASE, body);\n  }\n\n  public static Node label(Node name, Node stmt) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.LABEL, name, stmt);\n    return block;\n  }\n\n  public static Node labelName(String name) {\n    Preconditions.checkState(!name.isEmpty());\n    return Node.newString(Token.LABEL_NAME, name);\n  }\n\n  public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n  }\n\n  public static Node tryCatch(Node tryBody, Node catchNode) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n    return new Node(Token.TRY, tryBody, catchBody);\n  }\n\n  public static Node tryCatchFinally(\n      Node tryBody, Node catchNode, Node finallyBody) {\n    Preconditions.checkState(finallyBody.isBlock());\n    Node tryNode = tryCatch(tryBody, catchNode);\n    tryNode.addChildToBack(finallyBody);\n    return tryNode;\n  }\n\n  public static Node catchNode(Node expr, Node body) {\n    Preconditions.checkState(expr.isName());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.CATCH, expr, body);\n  }\n\n  public static Node breakNode() {\n    return new Node(Token.BREAK);\n  }\n\n  public static Node breakNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.BREAK, name);\n  }\n\n  public static Node continueNode() {\n    return new Node(Token.CONTINUE);\n  }\n\n  public static Node continueNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.CONTINUE, name);\n  }\n\n\n  //\n\n  public static Node call(Node target, Node ... args) {\n    Node call = new Node(Token.CALL, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      call.addChildToBack(arg);\n    }\n    return call;\n  }\n\n  public static Node newNode(Node target, Node ... args) {\n    Node newcall = new Node(Token.NEW, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      newcall.addChildToBack(arg);\n    }\n    return newcall;\n  }\n\n  public static Node name(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n\n  public static Node getprop(Node target, Node prop) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(prop.isString());\n    return new Node(Token.GETPROP, target, prop);\n  }\n\n  public static Node getelem(Node target, Node elem) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(elem));\n    return new Node(Token.GETELEM, target, elem);\n  }\n\n  public static Node assign(Node target, Node expr) {\n    Preconditions.checkState(isAssignmentTarget(target));\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.ASSIGN, target, expr);\n  }\n\n  public static Node hook(Node cond, Node trueval, Node falseval) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(mayBeExpression(trueval));\n    Preconditions.checkState(mayBeExpression(falseval));\n    return new Node(Token.HOOK, cond, trueval, falseval);\n  }\n\n  public static Node comma(Node expr1, Node expr2) {\n    return binaryOp(Token.COMMA, expr1, expr2);\n  }\n\n  public static Node and(Node expr1, Node expr2) {\n    return binaryOp(Token.AND, expr1, expr2);\n  }\n\n  public static Node or(Node expr1, Node expr2) {\n    return binaryOp(Token.OR, expr1, expr2);\n  }\n\n  public static Node not(Node expr1) {\n    return unaryOp(Token.NOT, expr1);\n  }\n\n  /**\n   * \"==\"\n   */\n  public static Node eq(Node expr1, Node expr2) {\n    return binaryOp(Token.EQ, expr1, expr2);\n  }\n\n  /**\n   * \"===\"\n   */\n  public static Node sheq(Node expr1, Node expr2) {\n    return binaryOp(Token.SHEQ, expr1, expr2);\n  }\n\n  public static Node voidNode(Node expr1) {\n    return unaryOp(Token.VOID, expr1);\n  }\n\n  public static Node neg(Node expr1) {\n    return unaryOp(Token.NEG, expr1);\n  }\n\n  public static Node pos(Node expr1) {\n    return unaryOp(Token.POS, expr1);\n  }\n\n  public static Node add(Node expr1, Node expr2) {\n    return binaryOp(Token.ADD, expr1, expr2);\n  }\n\n  public static Node sub(Node expr1, Node expr2) {\n    return binaryOp(Token.SUB, expr1, expr2);\n  }\n\n  // TODO(johnlenz): the rest of the ops\n\n  // literals\n  public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }\n\n  // TODO(johnlenz): quoted props\n\n  public static Node propdef(Node string, Node value) {\n    Preconditions.checkState(string.isStringKey());\n    Preconditions.checkState(!string.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    string.addChildToFront(value);\n    return string;\n  }\n\n  public static Node arraylit(Node ... exprs) {\n    Node arraylit = new Node(Token.ARRAYLIT);\n    for (Node expr : exprs) {\n      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n      arraylit.addChildToBack(expr);\n    }\n    return arraylit;\n  }\n\n  public static Node regexp(Node expr) {\n    Preconditions.checkState(expr.isString());\n    return new Node(Token.REGEXP, expr);\n  }\n\n  public static Node regexp(Node expr, Node flags) {\n    Preconditions.checkState(expr.isString());\n    Preconditions.checkState(flags.isString());\n    return new Node(Token.REGEXP, expr, flags);\n  }\n\n  public static Node string(String s) {\n    return Node.newString(s);\n  }\n\n  public static Node stringKey(String s) {\n    return Node.newString(Token.STRING_KEY, s);\n  }\n\n  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n\n  public static Node thisNode() {\n    return new Node(Token.THIS);\n  }\n\n  public static Node trueNode() {\n    return new Node(Token.TRUE);\n  }\n\n  public static Node falseNode() {\n    return new Node(Token.FALSE);\n  }\n\n  public static Node nullNode() {\n    return new Node(Token.NULL);\n  }\n\n  // helper methods\n\n  private static Node binaryOp(int token, Node expr1, Node expr2) {\n    Preconditions.checkState(mayBeExpression(expr1));\n    Preconditions.checkState(mayBeExpression(expr2));\n    return new Node(token, expr1, expr2);\n  }\n\n  private static Node unaryOp(int token, Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(token, expr);\n  }\n\n  private static boolean mayBeExpressionOrEmpty(Node n) {\n    return n.isEmpty() || mayBeExpression(n);\n  }\n\n  private static boolean isAssignmentTarget(Node n) {\n    return n.isName() || n.isGetProp() || n.isGetElem();\n  }\n\n  // NOTE: some nodes are neither statements nor expression nodes:\n  //   SCRIPT, LABEL_NAME, PARAM_LIST, CASE, DEFAULT_CASE, CATCH\n  //   GETTER_DEF, SETTER_DEF\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeStatement(Node n) {\n    switch (n.getType()) {\n      case Token.EMPTY:\n      case Token.FUNCTION:\n        // EMPTY and FUNCTION are used both in expression and statement\n        // contexts\n        return true;\n\n      case Token.BLOCK:\n      case Token.BREAK:\n      case Token.CONST:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.DO:\n      case Token.EXPR_RESULT:\n      case Token.FOR:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.RETURN:\n      case Token.SWITCH:\n      case Token.THROW:\n      case Token.TRY:\n      case Token.VAR:\n      case Token.WHILE:\n      case Token.WITH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeExpression(Node n) {\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // FUNCTION is used both in expression and statement\n        // contexts.\n        return true;\n\n      case Token.ADD:\n      case Token.AND:\n      case Token.ARRAYLIT:\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITNOT:\n      case Token.BITXOR:\n      case Token.CALL:\n      case Token.COMMA:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FALSE:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.IN:\n      case Token.INC:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TYPEOF:\n      case Token.TRUE:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n"}, "generated_test_class": "To write unit tests for the `switchNode` method in Java 1.7 with JUnit 4, we need to cover various scenarios including the successful creation of switch nodes with different combinations of cases, default cases, and invalid input. Here are the tests:\n\n1. **Test a switch node with no cases**.\n2. **Test a switch node with a single case**.\n3. **Test a switch node with multiple cases**.\n4. **Test a switch node with a single default case**.\n5. **Test a switch node with multiple cases and a default case**.\n6. **Test a switch node with an invalid condition**.\n7. **Test a switch node with an invalid case**.\n\nLet's start by importing the necessary classes and writing the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.Assert;\nimport com.google.common.base.Preconditions;\n\npublic class IRTest {\n\n    private Node condition;\n    private Node case1;\n    private Node case2;\n    private Node defaultCase;\n\n    @Before\n    public void setUp() {\n        condition = IR.name(\"condition\");\n        case1 = IR.caseNode(IR.number(1), IR.block(IR.returnNode()));\n        case2 = IR.caseNode(IR.number(2), IR.block(IR.returnNode()));\n        defaultCase = IR.defaultCase(IR.block(IR.returnNode()));\n    }\n\n    @Test\n    public void testSwitchNodeWithNoCases() {\n        Node switchNode = IR.switchNode(condition);\n        Assert.assertEquals(Token.SWITCH, switchNode.getType());\n        Assert.assertEquals(1, switchNode.getChildCount());\n        Assert.assertSame(condition, switchNode.getFirstChild());\n    }\n\n    @Test\n    public void testSwitchNodeWithSingleCase() {\n        Node switchNode = IR.switchNode(condition, case1);\n        Assert.assertEquals(Token.SWITCH, switchNode.getType());\n        Assert.assertEquals(2, switchNode.getChildCount());\n        Assert.assertSame(condition, switchNode.getFirstChild());\n        Assert.assertSame(case1, switchNode.getLastChild());\n    }\n\n    @Test\n    public void testSwitchNodeWithMultipleCases() {\n        Node switchNode = IR.switchNode(condition, case1, case2);\n        Assert.assertEquals(Token.SWITCH, switchNode.getType());\n        Assert.assertEquals(3, switchNode.getChildCount());\n        Assert.assertSame(condition, switchNode.getFirstChild());\n        Assert.assertSame(case1, switchNode.getChildAtIndex(1));\n        Assert.assertSame(case2, switchNode.getLastChild());\n    }\n\n    @Test\n    public void testSwitchNodeWithSingleDefaultCase() {\n        Node switchNode = IR.switchNode(condition, defaultCase);\n        Assert.assertEquals(Token.SWITCH, switchNode.getType());\n        Assert.assertEquals(2, switchNode.getChildCount());\n        Assert.assertSame(condition, switchNode.getFirstChild());\n        Assert.assertSame(defaultCase, switchNode.getLastChild());\n    }\n\n    @Test\n    public void testSwitchNodeWithMultipleCasesAndDefaultCase() {\n        Node switchNode = IR.switchNode(condition, case1, case2, defaultCase);\n        Assert.assertEquals(Token.SWITCH, switchNode.getType());\n        Assert.assertEquals(4, switchNode.getChildCount());\n        Assert.assertSame(condition, switchNode.getFirstChild());\n        Assert.assertSame(case1, switchNode.getChildAtIndex(1));\n        Assert.assertSame(case2, switchNode.getChildAtIndex(2));\n        Assert.assertSame(defaultCase, switchNode.getLastChild());\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testSwitchNodeWithInvalidCondition() {\n        Node invalidCondition = IR.block(IR.returnNode());\n        IR.switchNode(invalidCondition);\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testSwitchNodeWithInvalidCase() {\n        Node invalidCase = IR.block(IR.returnNode());\n        IR.switchNode(condition, invalidCase);\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testSwitchNodeWithMultipleInvalidCases() {\n        Node invalidCase1 = IR.block(IR.returnNode());\n        Node invalidCase2 = IR.block(IR.returnNode());\n        IR.switchNode(condition, invalidCase1, invalidCase2);\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testSwitchNodeWithValidAndInvalidCases() {\n        Node invalidCase = IR.block(IR.returnNode());\n        IR.switchNode(condition, case1, invalidCase);\n    }\n\n    // Assuming mayBeExpression() in IR checks if the node is an expression\n    private static class Node {\n        private final int type;\n        private final Node[] children;\n        private Node parent;\n\n        private Node(int type, Node... children) {\n            this.type = type;\n            this.children = children;\n            for (Node child : children) {\n                child.parent = this;\n            }\n        }\n\n        public int getType() {\n            return type;\n        }\n\n        public int getChildCount() {\n            return children.length;\n        }\n\n        public Node getFirstChild() {\n            return children.length > 0 ? children[0] : null;\n        }\n\n        public Node getLastChild() {\n            return children.length > 0 ? children[children.length - 1] : null;\n        }\n\n        public Node getChildAtIndex(int index) {\n            return children[index];\n        }\n\n        public boolean isCase() {\n            return type == Token.CASE;\n        }\n\n        public boolean isDefaultCase() {\n            return type == Token.DEFAULT_CASE;\n        }\n\n        public void addChildToBack(Node child) {\n            Node[] newChildren = new Node[children.length + 1];\n            System.arraycopy(children, 0, newChildren, 0, children.length);\n            newChildren[children.length] = child;\n            child.parent = this;\n            children = newChildren;\n        }\n    }\n\n    // Mocking Token class\n    private static class Token {\n        public static final int SWITCH = 1;\n        public static final int CASE = 2;\n        public static final int DEFAULT_CASE = 3;\n    }\n}\n```\n\n### Explanation\n\n1. **Setup Method**: We define a `setUp` method to initialize some common test cases and a condition that can be used across multiple tests.\n2. **Test Methods**: We write multiple test methods to cover various scenarios:\n   - Creating a switch node with no cases.\n   - Creating a switch node with a single case.\n   - Creating a switch node with multiple cases.\n   - Creating a switch node with a single default case.\n   - Creating a switch node with multiple cases and a default case.\n   - Handling invalid conditions and cases.\n3. **Mock Node and Token**: Since the `Node` and `Token` classes are not provided, we mock them here to make the tests self-contained.\n\n### Assumptions\n\n- The `mayBeExpression` method in the `IR` class checks if the node is an expression.\n- The `Token` class has constants for `SWITCH`, `CASE`, and `DEFAULT_CASE`.\n\nThese tests should provide good branch and line coverage for the `switchNode` method."}
{"bug_id": "Closure_27", "version": "fixed", "focal_method_signature": "Node com.google.javascript.rhino.IR#label(Node#name,Node#stmt)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "focal_method": "public static Node label(Node name, Node stmt) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.LABEL, name, stmt);\n    return block;\n  }", "return_type": "Node", "assertion_subject_candidates": ["int com.google.javascript.rhino.Node#getType()", "boolean com.google.javascript.rhino.Node#hasChildren()", "Node com.google.javascript.rhino.Node#getFirstChild()", "Node com.google.javascript.rhino.Node#getLastChild()", "Node com.google.javascript.rhino.Node#getNext()", "String com.google.javascript.rhino.Node#toString()", "String com.google.javascript.rhino.Node#toStringTree()", "StaticSourceFile com.google.javascript.rhino.Node#getStaticSourceFile()", "InputId com.google.javascript.rhino.Node#getInputId()", "int com.google.javascript.rhino.Node#getLength()", "int com.google.javascript.rhino.Node#getLineno()", "int com.google.javascript.rhino.Node#getCharno()", "int com.google.javascript.rhino.Node#getSourcePosition()", "Iterable<Node> com.google.javascript.rhino.Node#siblings()", "Node com.google.javascript.rhino.Node#getParent()", "AncestorIterable com.google.javascript.rhino.Node#getAncestors()", "boolean com.google.javascript.rhino.Node#hasOneChild()", "boolean com.google.javascript.rhino.Node#hasMoreThanOneChild()", "JSType com.google.javascript.rhino.Node#getJSType()", "FileLevelJsDocBuilder com.google.javascript.rhino.Node#getJsDocBuilderForNode()", "JSDocInfo com.google.javascript.rhino.Node#getJSDocInfo()", "boolean com.google.javascript.rhino.Node#isVarArgs()", "boolean com.google.javascript.rhino.Node#isOptionalArg()", "boolean com.google.javascript.rhino.Node#isSyntheticBlock()", "Set<String> com.google.javascript.rhino.Node#getDirectives()", "boolean com.google.javascript.rhino.Node#wasEmptyNode()", "int com.google.javascript.rhino.Node#getSideEffectFlags()", "boolean com.google.javascript.rhino.Node#isOnlyModifiesThisCall()", "boolean com.google.javascript.rhino.Node#isNoSideEffectsCall()", "boolean com.google.javascript.rhino.Node#isLocalResultCall()", "boolean com.google.javascript.rhino.Node#isQuotedString()", "boolean com.google.javascript.rhino.Node#isAdd()", "boolean com.google.javascript.rhino.Node#isAnd()", "boolean com.google.javascript.rhino.Node#isArrayLit()", "boolean com.google.javascript.rhino.Node#isAssign()", "boolean com.google.javascript.rhino.Node#isAssignAdd()", "boolean com.google.javascript.rhino.Node#isBlock()", "boolean com.google.javascript.rhino.Node#isBreak()", "boolean com.google.javascript.rhino.Node#isCall()", "boolean com.google.javascript.rhino.Node#isCase()", "boolean com.google.javascript.rhino.Node#isCatch()", "boolean com.google.javascript.rhino.Node#isComma()", "boolean com.google.javascript.rhino.Node#isContinue()", "boolean com.google.javascript.rhino.Node#isDebugger()", "boolean com.google.javascript.rhino.Node#isDec()", "boolean com.google.javascript.rhino.Node#isDefaultCase()", "boolean com.google.javascript.rhino.Node#isDelProp()", "boolean com.google.javascript.rhino.Node#isDo()", "boolean com.google.javascript.rhino.Node#isEmpty()", "boolean com.google.javascript.rhino.Node#isExprResult()", "boolean com.google.javascript.rhino.Node#isFalse()", "boolean com.google.javascript.rhino.Node#isFor()", "boolean com.google.javascript.rhino.Node#isFunction()", "boolean com.google.javascript.rhino.Node#isGetterDef()", "boolean com.google.javascript.rhino.Node#isGetElem()", "boolean com.google.javascript.rhino.Node#isGetProp()", "boolean com.google.javascript.rhino.Node#isHook()", "boolean com.google.javascript.rhino.Node#isIf()", "boolean com.google.javascript.rhino.Node#isIn()", "boolean com.google.javascript.rhino.Node#isInc()", "boolean com.google.javascript.rhino.Node#isInstanceOf()", "boolean com.google.javascript.rhino.Node#isLabel()", "boolean com.google.javascript.rhino.Node#isLabelName()", "boolean com.google.javascript.rhino.Node#isName()", "boolean com.google.javascript.rhino.Node#isNE()", "boolean com.google.javascript.rhino.Node#isNew()", "boolean com.google.javascript.rhino.Node#isNot()", "boolean com.google.javascript.rhino.Node#isNull()", "boolean com.google.javascript.rhino.Node#isNumber()", "boolean com.google.javascript.rhino.Node#isObjectLit()", "boolean com.google.javascript.rhino.Node#isOr()", "boolean com.google.javascript.rhino.Node#isParamList()", "boolean com.google.javascript.rhino.Node#isRegExp()", "boolean com.google.javascript.rhino.Node#isReturn()", "boolean com.google.javascript.rhino.Node#isScript()", "boolean com.google.javascript.rhino.Node#isSetterDef()", "boolean com.google.javascript.rhino.Node#isString()", "boolean com.google.javascript.rhino.Node#isStringKey()", "boolean com.google.javascript.rhino.Node#isSwitch()", "boolean com.google.javascript.rhino.Node#isThis()", "boolean com.google.javascript.rhino.Node#isThrow()", "boolean com.google.javascript.rhino.Node#isTrue()", "boolean com.google.javascript.rhino.Node#isTry()", "boolean com.google.javascript.rhino.Node#isTypeOf()", "boolean com.google.javascript.rhino.Node#isVar()", "boolean com.google.javascript.rhino.Node#isVoid()", "boolean com.google.javascript.rhino.Node#isWhile()", "boolean com.google.javascript.rhino.Node#isWith()"], "focal_class": {"name": "IR", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import java.util.List;"], "fields": [], "methods": ["Node com.google.javascript.rhino.IR#empty()", "Node com.google.javascript.rhino.IR#function(Node#name,Node#params,Node#body)", "Node com.google.javascript.rhino.IR#paramList()", "Node com.google.javascript.rhino.IR#paramList(Node#param)", "Node com.google.javascript.rhino.IR#paramList(#Node ... params)", "Node com.google.javascript.rhino.IR#paramList(List<Node>#params)", "Node com.google.javascript.rhino.IR#block()", "Node com.google.javascript.rhino.IR#block(Node#stmt)", "Node com.google.javascript.rhino.IR#block(#Node ... stmts)", "Node com.google.javascript.rhino.IR#blockUnchecked(Node#stmt)", "Node com.google.javascript.rhino.IR#script(#Node ... stmts)", "Node com.google.javascript.rhino.IR#var(Node#name,Node#value)", "Node com.google.javascript.rhino.IR#var(Node#name)", "Node com.google.javascript.rhino.IR#returnNode()", "Node com.google.javascript.rhino.IR#returnNode(Node#expr)", "Node com.google.javascript.rhino.IR#throwNode(Node#expr)", "Node com.google.javascript.rhino.IR#exprResult(Node#expr)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then,Node#elseNode)", "Node com.google.javascript.rhino.IR#doNode(Node#body,Node#cond)", "Node com.google.javascript.rhino.IR#forIn(Node#target,Node#cond,Node#body)", "Node com.google.javascript.rhino.IR#forNode(Node#init,Node#cond,Node#incr,Node#body)", "Node com.google.javascript.rhino.IR#switchNode(Node#cond,#Node ... cases)", "Node com.google.javascript.rhino.IR#caseNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#defaultCase(Node#body)", "Node com.google.javascript.rhino.IR#labelName(String#name)", "Node com.google.javascript.rhino.IR#tryFinally(Node#tryBody,Node#finallyBody)", "Node com.google.javascript.rhino.IR#tryCatch(Node#tryBody,Node#catchNode)", "Node com.google.javascript.rhino.IR#tryCatchFinally(Node#tryBody,Node#catchNode,Node#finallyBody)", "Node com.google.javascript.rhino.IR#catchNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#breakNode()", "Node com.google.javascript.rhino.IR#breakNode(Node#name)", "Node com.google.javascript.rhino.IR#continueNode()", "Node com.google.javascript.rhino.IR#continueNode(Node#name)", "Node com.google.javascript.rhino.IR#call(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#newNode(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#name(String#name)", "Node com.google.javascript.rhino.IR#getprop(Node#target,Node#prop)", "Node com.google.javascript.rhino.IR#getelem(Node#target,Node#elem)", "Node com.google.javascript.rhino.IR#assign(Node#target,Node#expr)", "Node com.google.javascript.rhino.IR#hook(Node#cond,Node#trueval,Node#falseval)", "Node com.google.javascript.rhino.IR#comma(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#and(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#or(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#not(Node#expr1)", "Node com.google.javascript.rhino.IR#eq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sheq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#voidNode(Node#expr1)", "Node com.google.javascript.rhino.IR#neg(Node#expr1)", "Node com.google.javascript.rhino.IR#pos(Node#expr1)", "Node com.google.javascript.rhino.IR#add(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sub(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#objectlit(#Node ... propdefs)", "Node com.google.javascript.rhino.IR#propdef(Node#string,Node#value)", "Node com.google.javascript.rhino.IR#arraylit(#Node ... exprs)", "Node com.google.javascript.rhino.IR#regexp(Node#expr)", "Node com.google.javascript.rhino.IR#regexp(Node#expr,Node#flags)", "Node com.google.javascript.rhino.IR#string(String#s)", "Node com.google.javascript.rhino.IR#stringKey(String#s)", "Node com.google.javascript.rhino.IR#number(double#d)", "Node com.google.javascript.rhino.IR#thisNode()", "Node com.google.javascript.rhino.IR#trueNode()", "Node com.google.javascript.rhino.IR#falseNode()", "Node com.google.javascript.rhino.IR#nullNode()", "Node com.google.javascript.rhino.IR#binaryOp(int#token,Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#unaryOp(int#token,Node#expr)", "boolean com.google.javascript.rhino.IR#mayBeExpressionOrEmpty(Node#n)", "boolean com.google.javascript.rhino.IR#isAssignmentTarget(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeStatement(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeExpression(Node#n)"], "other_methods": ["public static Node empty();", "public static Node function(Node name,Node params,Node body);", "public static Node paramList();", "public static Node paramList(Node param);", "public static Node paramList( Node ... params);", "public static Node paramList(List<Node> params);", "public static Node block();", "public static Node block(Node stmt);", "public static Node block( Node ... stmts);", "public static Node script( Node ... stmts);", "public static Node var(Node name,Node value);", "public static Node var(Node name);", "public static Node returnNode();", "public static Node returnNode(Node expr);", "public static Node throwNode(Node expr);", "public static Node exprResult(Node expr);", "public static Node ifNode(Node cond,Node then);", "public static Node ifNode(Node cond,Node then,Node elseNode);", "public static Node doNode(Node body,Node cond);", "public static Node forIn(Node target,Node cond,Node body);", "public static Node forNode(Node init,Node cond,Node incr,Node body);", "public static Node switchNode(Node cond, Node ... cases);", "public static Node caseNode(Node expr,Node body);", "public static Node defaultCase(Node body);", "public static Node labelName(String name);", "public static Node tryFinally(Node tryBody,Node finallyBody);", "public static Node tryCatch(Node tryBody,Node catchNode);", "public static Node tryCatchFinally(Node tryBody,Node catchNode,Node finallyBody);", "public static Node catchNode(Node expr,Node body);", "public static Node breakNode();", "public static Node breakNode(Node name);", "public static Node continueNode();", "public static Node continueNode(Node name);", "public static Node call(Node target, Node ... args);", "public static Node newNode(Node target, Node ... args);", "public static Node name(String name);", "public static Node getprop(Node target,Node prop);", "public static Node getelem(Node target,Node elem);", "public static Node assign(Node target,Node expr);", "public static Node hook(Node cond,Node trueval,Node falseval);", "public static Node comma(Node expr1,Node expr2);", "public static Node and(Node expr1,Node expr2);", "public static Node or(Node expr1,Node expr2);", "public static Node not(Node expr1);", "public static Node eq(Node expr1,Node expr2);", "public static Node sheq(Node expr1,Node expr2);", "public static Node voidNode(Node expr1);", "public static Node neg(Node expr1);", "public static Node pos(Node expr1);", "public static Node add(Node expr1,Node expr2);", "public static Node sub(Node expr1,Node expr2);", "public static Node objectlit( Node ... propdefs);", "public static Node propdef(Node string,Node value);", "public static Node arraylit( Node ... exprs);", "public static Node regexp(Node expr);", "public static Node regexp(Node expr,Node flags);", "public static Node string(String s);", "public static Node stringKey(String s);", "public static Node number(double d);", "public static Node thisNode();", "public static Node trueNode();", "public static Node falseNode();", "public static Node nullNode();"], "fields_dict": {}, "text": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   John Lenz\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.List;\n\n/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n\n  private IR() {}\n\n  public static Node empty() {\n    return new Node(Token.EMPTY);\n  }\n\n  public static Node function(Node name, Node params, Node body) {\n    Preconditions.checkState(name.isName());\n    Preconditions.checkState(params.isParamList());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FUNCTION, name, params, body);\n  }\n\n  public static Node paramList() {\n    return new Node(Token.PARAM_LIST);\n  }\n\n  public static Node paramList(Node param) {\n    Preconditions.checkState(param.isName());\n    return new Node(Token.PARAM_LIST, param);\n  }\n\n  public static Node paramList(Node ... params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node paramList(List<Node> params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n\n  public static Node block(Node stmt) {\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.BLOCK, stmt);\n    return block;\n  }\n\n  public static Node block(Node ... stmts) {\n    Node block = new Node(Token.BLOCK);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n\n  public static Node script(Node ... stmts) {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  public static Node var(Node name, Node value) {\n    Preconditions.checkState(name.isName() && !name.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    name.addChildToFront(value);\n    return var(name);\n  }\n\n  public static Node var(Node name) {\n    Preconditions.checkState(name.isName());\n    return new Node(Token.VAR, name);\n  }\n\n  public static Node returnNode() {\n    return new Node(Token.RETURN);\n  }\n\n  public static Node returnNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.RETURN, expr);\n  }\n\n  public static Node throwNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.THROW, expr);\n  }\n\n  public static Node exprResult(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.EXPR_RESULT, expr);\n  }\n\n  public static Node ifNode(Node cond, Node then) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    return new Node(Token.IF, cond, then);\n  }\n\n  public static Node ifNode(Node cond, Node then, Node elseNode) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    Preconditions.checkState(elseNode.isBlock());\n    return new Node(Token.IF, cond, then, elseNode);\n  }\n\n  public static Node doNode(Node body, Node cond) {\n    Preconditions.checkState(body.isBlock());\n    Preconditions.checkState(mayBeExpression(cond));\n    return new Node(Token.DO, body, cond);\n  }\n\n  public static Node forIn(Node target, Node cond, Node body) {\n    Preconditions.checkState(target.isVar() || mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, target, cond, body);\n  }\n\n  public static Node forNode(Node init, Node cond, Node incr, Node body) {\n    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, init, cond, incr, body);\n  }\n\n  public static Node switchNode(Node cond, Node ... cases) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Node switchNode = new Node(Token.SWITCH, cond);\n    for (Node caseNode : cases) {\n      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n      switchNode.addChildToBack(caseNode);\n    }\n    return switchNode;\n  }\n\n  public static Node caseNode(Node expr, Node body) {\n    Preconditions.checkState(mayBeExpression(expr));\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.CASE, expr, body);\n  }\n\n  public static Node defaultCase(Node body) {\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.DEFAULT_CASE, body);\n  }\n\n  public static Node label(Node name, Node stmt) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.LABEL, name, stmt);\n    return block;\n  }\n\n  public static Node labelName(String name) {\n    Preconditions.checkState(!name.isEmpty());\n    return Node.newString(Token.LABEL_NAME, name);\n  }\n\n  public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n  }\n\n  public static Node tryCatch(Node tryBody, Node catchNode) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n    return new Node(Token.TRY, tryBody, catchBody);\n  }\n\n  public static Node tryCatchFinally(\n      Node tryBody, Node catchNode, Node finallyBody) {\n    Preconditions.checkState(finallyBody.isBlock());\n    Node tryNode = tryCatch(tryBody, catchNode);\n    tryNode.addChildToBack(finallyBody);\n    return tryNode;\n  }\n\n  public static Node catchNode(Node expr, Node body) {\n    Preconditions.checkState(expr.isName());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.CATCH, expr, body);\n  }\n\n  public static Node breakNode() {\n    return new Node(Token.BREAK);\n  }\n\n  public static Node breakNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.BREAK, name);\n  }\n\n  public static Node continueNode() {\n    return new Node(Token.CONTINUE);\n  }\n\n  public static Node continueNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.CONTINUE, name);\n  }\n\n\n  //\n\n  public static Node call(Node target, Node ... args) {\n    Node call = new Node(Token.CALL, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      call.addChildToBack(arg);\n    }\n    return call;\n  }\n\n  public static Node newNode(Node target, Node ... args) {\n    Node newcall = new Node(Token.NEW, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      newcall.addChildToBack(arg);\n    }\n    return newcall;\n  }\n\n  public static Node name(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n\n  public static Node getprop(Node target, Node prop) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(prop.isString());\n    return new Node(Token.GETPROP, target, prop);\n  }\n\n  public static Node getelem(Node target, Node elem) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(elem));\n    return new Node(Token.GETELEM, target, elem);\n  }\n\n  public static Node assign(Node target, Node expr) {\n    Preconditions.checkState(isAssignmentTarget(target));\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.ASSIGN, target, expr);\n  }\n\n  public static Node hook(Node cond, Node trueval, Node falseval) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(mayBeExpression(trueval));\n    Preconditions.checkState(mayBeExpression(falseval));\n    return new Node(Token.HOOK, cond, trueval, falseval);\n  }\n\n  public static Node comma(Node expr1, Node expr2) {\n    return binaryOp(Token.COMMA, expr1, expr2);\n  }\n\n  public static Node and(Node expr1, Node expr2) {\n    return binaryOp(Token.AND, expr1, expr2);\n  }\n\n  public static Node or(Node expr1, Node expr2) {\n    return binaryOp(Token.OR, expr1, expr2);\n  }\n\n  public static Node not(Node expr1) {\n    return unaryOp(Token.NOT, expr1);\n  }\n\n  /**\n   * \"==\"\n   */\n  public static Node eq(Node expr1, Node expr2) {\n    return binaryOp(Token.EQ, expr1, expr2);\n  }\n\n  /**\n   * \"===\"\n   */\n  public static Node sheq(Node expr1, Node expr2) {\n    return binaryOp(Token.SHEQ, expr1, expr2);\n  }\n\n  public static Node voidNode(Node expr1) {\n    return unaryOp(Token.VOID, expr1);\n  }\n\n  public static Node neg(Node expr1) {\n    return unaryOp(Token.NEG, expr1);\n  }\n\n  public static Node pos(Node expr1) {\n    return unaryOp(Token.POS, expr1);\n  }\n\n  public static Node add(Node expr1, Node expr2) {\n    return binaryOp(Token.ADD, expr1, expr2);\n  }\n\n  public static Node sub(Node expr1, Node expr2) {\n    return binaryOp(Token.SUB, expr1, expr2);\n  }\n\n  // TODO(johnlenz): the rest of the ops\n\n  // literals\n  public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }\n\n  // TODO(johnlenz): quoted props\n\n  public static Node propdef(Node string, Node value) {\n    Preconditions.checkState(string.isStringKey());\n    Preconditions.checkState(!string.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    string.addChildToFront(value);\n    return string;\n  }\n\n  public static Node arraylit(Node ... exprs) {\n    Node arraylit = new Node(Token.ARRAYLIT);\n    for (Node expr : exprs) {\n      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n      arraylit.addChildToBack(expr);\n    }\n    return arraylit;\n  }\n\n  public static Node regexp(Node expr) {\n    Preconditions.checkState(expr.isString());\n    return new Node(Token.REGEXP, expr);\n  }\n\n  public static Node regexp(Node expr, Node flags) {\n    Preconditions.checkState(expr.isString());\n    Preconditions.checkState(flags.isString());\n    return new Node(Token.REGEXP, expr, flags);\n  }\n\n  public static Node string(String s) {\n    return Node.newString(s);\n  }\n\n  public static Node stringKey(String s) {\n    return Node.newString(Token.STRING_KEY, s);\n  }\n\n  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n\n  public static Node thisNode() {\n    return new Node(Token.THIS);\n  }\n\n  public static Node trueNode() {\n    return new Node(Token.TRUE);\n  }\n\n  public static Node falseNode() {\n    return new Node(Token.FALSE);\n  }\n\n  public static Node nullNode() {\n    return new Node(Token.NULL);\n  }\n\n  // helper methods\n\n  private static Node binaryOp(int token, Node expr1, Node expr2) {\n    Preconditions.checkState(mayBeExpression(expr1));\n    Preconditions.checkState(mayBeExpression(expr2));\n    return new Node(token, expr1, expr2);\n  }\n\n  private static Node unaryOp(int token, Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(token, expr);\n  }\n\n  private static boolean mayBeExpressionOrEmpty(Node n) {\n    return n.isEmpty() || mayBeExpression(n);\n  }\n\n  private static boolean isAssignmentTarget(Node n) {\n    return n.isName() || n.isGetProp() || n.isGetElem();\n  }\n\n  // NOTE: some nodes are neither statements nor expression nodes:\n  //   SCRIPT, LABEL_NAME, PARAM_LIST, CASE, DEFAULT_CASE, CATCH\n  //   GETTER_DEF, SETTER_DEF\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeStatement(Node n) {\n    switch (n.getType()) {\n      case Token.EMPTY:\n      case Token.FUNCTION:\n        // EMPTY and FUNCTION are used both in expression and statement\n        // contexts\n        return true;\n\n      case Token.BLOCK:\n      case Token.BREAK:\n      case Token.CONST:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.DO:\n      case Token.EXPR_RESULT:\n      case Token.FOR:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.RETURN:\n      case Token.SWITCH:\n      case Token.THROW:\n      case Token.TRY:\n      case Token.VAR:\n      case Token.WHILE:\n      case Token.WITH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeExpression(Node n) {\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // FUNCTION is used both in expression and statement\n        // contexts.\n        return true;\n\n      case Token.ADD:\n      case Token.AND:\n      case Token.ARRAYLIT:\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITNOT:\n      case Token.BITXOR:\n      case Token.CALL:\n      case Token.COMMA:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FALSE:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.IN:\n      case Token.INC:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TYPEOF:\n      case Token.TRUE:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n"}, "generated_test_class": "To write comprehensive unit tests for the `label` method, we need to ensure that both branches and lines are covered. This involves testing the method with valid inputs and also with invalid inputs to check the correctness of the precondition checks. We'll use JUnit 4 for the testing framework.\n\nHere's how you can write these unit tests:\n\n1. **Valid Cases**: Test the method with valid `labelName` and `stmt`.\n2. **Invalid Cases**: Test the method with invalid `labelName` and `stmt` to ensure the `Preconditions.checkState` assertions are working as expected.\n\nBelow is the implementation of these unit tests:\n\n```java\nimport com.google.common.base.Preconditions;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.junit.Assert.fail;\n\npublic class IRTest {\n\n    @Test\n    public void testLabel_ValidLabelAndStmt() {\n        Node labelNameNode = IR.labelName(\"myLabel\");\n        Node stmtNode = IR.var(IR.name(\"x\"), IR.number(10));\n\n        Node labelNode = IR.label(labelNameNode, stmtNode);\n\n        assertNotNull(\"Label node should not be null\", labelNode);\n        assertEquals(\"Label node token type should be Token.LABEL\", Token.LABEL, labelNode.getType());\n        assertEquals(\"Label node first child should be the label name node\", labelNameNode, labelNode.getFirstChild());\n        assertEquals(\"Label node second child should be the statement node\", stmtNode, labelNode.getFirstChild().getNext());\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testLabel_InvalidLabel() {\n        Node invalidLabelNameNode = IR.var(IR.name(\"x\"), IR.number(10));\n        Node stmtNode = IR.var(IR.name(\"y\"), IR.number(20));\n\n        try {\n            IR.label(invalidLabelNameNode, stmtNode);\n        } catch (IllegalStateException e) {\n            assertEquals(\"Exception message should be correct\", \"Precondition failed: name.isLabelName()\", e.getMessage());\n            throw e;\n        }\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testLabel_InvalidStmt() {\n        Node labelNameNode = IR.labelName(\"myLabel\");\n        Node invalidStmtNode = IR.name(\"x\");\n\n        try {\n            IR.label(labelNameNode, invalidStmtNode);\n        } catch (IllegalStateException e) {\n            assertEquals(\"Exception message should be correct\", \"Precondition failed: mayBeStatement(stmt)\", e.getMessage());\n            throw e;\n        }\n    }\n\n    // Mock implementation for Node, Token, and other helper methods\n    // Normally these classes would be part of the IR class library\n\n    static class Node {\n        private int type;\n        private Node firstChild;\n        private Node next;\n\n        public Node(int type) {\n            this.type = type;\n        }\n\n        public Node(int type, Node... children) {\n            this(type);\n            for (Node child : children) {\n                if (this.firstChild == null) {\n                    this.firstChild = child;\n                } else {\n                    Node current = this.firstChild;\n                    while (current.next != null) {\n                        current = current.next;\n                    }\n                    current.next = child;\n                }\n            }\n        }\n\n        public int getType() {\n            return type;\n        }\n\n        public Node getFirstChild() {\n            return firstChild;\n        }\n\n        public Node getNext() {\n            return next;\n        }\n\n        public boolean isLabelName() {\n            return type == Token.LABEL;\n        }\n\n        public static boolean mayBeStatement(Node node) {\n            // Mock implementation for demonstration purposes\n            // Normally this would check if the node is a valid statement\n            return node.getType() != Token.NAME;\n        }\n    }\n\n    static class Token {\n        public static final int LABEL = 1;\n        public static final int NAME = 2;\n        // Add other token types as necessary\n    }\n}\n```\n\n### Explanation:\n1. **`testLabel_ValidLabelAndStmt`**:\n    - Creates a valid `labelName` and `stmt` node.\n    - Calls the `IR.label` method with these nodes.\n    - Asserts that the returned `labelNode` is not null and has the correct type and child nodes.\n\n2. **`testLabel_InvalidLabel`**:\n    - Creates an invalid `labelName` node (a `var` node instead of a `labelName` node).\n    - Expects an `IllegalStateException` to be thrown due to the `name.isLabelName()` precondition check.\n\n3. **`testLabel_InvalidStmt`**:\n    - Creates a valid `labelName` node and an invalid `stmt` node (a `name` node instead of a valid statement).\n    - Expects an `IllegalStateException` to be thrown due to the `mayBeStatement(stmt)` precondition check.\n\nThe `Node` class is mocked here for demonstration purposes, and you should replace it with the actual implementation from your IR library. The `Token` class is also mocked to provide the necessary constants."}
{"bug_id": "Closure_27", "version": "fixed", "focal_method_signature": "Node com.google.javascript.rhino.IR#tryCatchFinally(Node#tryBody,Node#catchNode,Node#finallyBody)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "focal_method": "public static Node tryCatchFinally(\n      Node tryBody, Node catchNode, Node finallyBody) {\n    Preconditions.checkState(finallyBody.isBlock());\n    Node tryNode = tryCatch(tryBody, catchNode);\n    tryNode.addChildToBack(finallyBody);\n    return tryNode;\n  }", "return_type": "Node", "assertion_subject_candidates": ["int com.google.javascript.rhino.Node#getType()", "boolean com.google.javascript.rhino.Node#hasChildren()", "Node com.google.javascript.rhino.Node#getFirstChild()", "Node com.google.javascript.rhino.Node#getLastChild()", "Node com.google.javascript.rhino.Node#getNext()", "String com.google.javascript.rhino.Node#toString()", "String com.google.javascript.rhino.Node#toStringTree()", "StaticSourceFile com.google.javascript.rhino.Node#getStaticSourceFile()", "InputId com.google.javascript.rhino.Node#getInputId()", "int com.google.javascript.rhino.Node#getLength()", "int com.google.javascript.rhino.Node#getLineno()", "int com.google.javascript.rhino.Node#getCharno()", "int com.google.javascript.rhino.Node#getSourcePosition()", "Iterable<Node> com.google.javascript.rhino.Node#siblings()", "Node com.google.javascript.rhino.Node#getParent()", "AncestorIterable com.google.javascript.rhino.Node#getAncestors()", "boolean com.google.javascript.rhino.Node#hasOneChild()", "boolean com.google.javascript.rhino.Node#hasMoreThanOneChild()", "JSType com.google.javascript.rhino.Node#getJSType()", "FileLevelJsDocBuilder com.google.javascript.rhino.Node#getJsDocBuilderForNode()", "JSDocInfo com.google.javascript.rhino.Node#getJSDocInfo()", "boolean com.google.javascript.rhino.Node#isVarArgs()", "boolean com.google.javascript.rhino.Node#isOptionalArg()", "boolean com.google.javascript.rhino.Node#isSyntheticBlock()", "Set<String> com.google.javascript.rhino.Node#getDirectives()", "boolean com.google.javascript.rhino.Node#wasEmptyNode()", "int com.google.javascript.rhino.Node#getSideEffectFlags()", "boolean com.google.javascript.rhino.Node#isOnlyModifiesThisCall()", "boolean com.google.javascript.rhino.Node#isNoSideEffectsCall()", "boolean com.google.javascript.rhino.Node#isLocalResultCall()", "boolean com.google.javascript.rhino.Node#isQuotedString()", "boolean com.google.javascript.rhino.Node#isAdd()", "boolean com.google.javascript.rhino.Node#isAnd()", "boolean com.google.javascript.rhino.Node#isArrayLit()", "boolean com.google.javascript.rhino.Node#isAssign()", "boolean com.google.javascript.rhino.Node#isAssignAdd()", "boolean com.google.javascript.rhino.Node#isBlock()", "boolean com.google.javascript.rhino.Node#isBreak()", "boolean com.google.javascript.rhino.Node#isCall()", "boolean com.google.javascript.rhino.Node#isCase()", "boolean com.google.javascript.rhino.Node#isCatch()", "boolean com.google.javascript.rhino.Node#isComma()", "boolean com.google.javascript.rhino.Node#isContinue()", "boolean com.google.javascript.rhino.Node#isDebugger()", "boolean com.google.javascript.rhino.Node#isDec()", "boolean com.google.javascript.rhino.Node#isDefaultCase()", "boolean com.google.javascript.rhino.Node#isDelProp()", "boolean com.google.javascript.rhino.Node#isDo()", "boolean com.google.javascript.rhino.Node#isEmpty()", "boolean com.google.javascript.rhino.Node#isExprResult()", "boolean com.google.javascript.rhino.Node#isFalse()", "boolean com.google.javascript.rhino.Node#isFor()", "boolean com.google.javascript.rhino.Node#isFunction()", "boolean com.google.javascript.rhino.Node#isGetterDef()", "boolean com.google.javascript.rhino.Node#isGetElem()", "boolean com.google.javascript.rhino.Node#isGetProp()", "boolean com.google.javascript.rhino.Node#isHook()", "boolean com.google.javascript.rhino.Node#isIf()", "boolean com.google.javascript.rhino.Node#isIn()", "boolean com.google.javascript.rhino.Node#isInc()", "boolean com.google.javascript.rhino.Node#isInstanceOf()", "boolean com.google.javascript.rhino.Node#isLabel()", "boolean com.google.javascript.rhino.Node#isLabelName()", "boolean com.google.javascript.rhino.Node#isName()", "boolean com.google.javascript.rhino.Node#isNE()", "boolean com.google.javascript.rhino.Node#isNew()", "boolean com.google.javascript.rhino.Node#isNot()", "boolean com.google.javascript.rhino.Node#isNull()", "boolean com.google.javascript.rhino.Node#isNumber()", "boolean com.google.javascript.rhino.Node#isObjectLit()", "boolean com.google.javascript.rhino.Node#isOr()", "boolean com.google.javascript.rhino.Node#isParamList()", "boolean com.google.javascript.rhino.Node#isRegExp()", "boolean com.google.javascript.rhino.Node#isReturn()", "boolean com.google.javascript.rhino.Node#isScript()", "boolean com.google.javascript.rhino.Node#isSetterDef()", "boolean com.google.javascript.rhino.Node#isString()", "boolean com.google.javascript.rhino.Node#isStringKey()", "boolean com.google.javascript.rhino.Node#isSwitch()", "boolean com.google.javascript.rhino.Node#isThis()", "boolean com.google.javascript.rhino.Node#isThrow()", "boolean com.google.javascript.rhino.Node#isTrue()", "boolean com.google.javascript.rhino.Node#isTry()", "boolean com.google.javascript.rhino.Node#isTypeOf()", "boolean com.google.javascript.rhino.Node#isVar()", "boolean com.google.javascript.rhino.Node#isVoid()", "boolean com.google.javascript.rhino.Node#isWhile()", "boolean com.google.javascript.rhino.Node#isWith()"], "focal_class": {"name": "IR", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import java.util.List;"], "fields": [], "methods": ["Node com.google.javascript.rhino.IR#empty()", "Node com.google.javascript.rhino.IR#function(Node#name,Node#params,Node#body)", "Node com.google.javascript.rhino.IR#paramList()", "Node com.google.javascript.rhino.IR#paramList(Node#param)", "Node com.google.javascript.rhino.IR#paramList(#Node ... params)", "Node com.google.javascript.rhino.IR#paramList(List<Node>#params)", "Node com.google.javascript.rhino.IR#block()", "Node com.google.javascript.rhino.IR#block(Node#stmt)", "Node com.google.javascript.rhino.IR#block(#Node ... stmts)", "Node com.google.javascript.rhino.IR#blockUnchecked(Node#stmt)", "Node com.google.javascript.rhino.IR#script(#Node ... stmts)", "Node com.google.javascript.rhino.IR#var(Node#name,Node#value)", "Node com.google.javascript.rhino.IR#var(Node#name)", "Node com.google.javascript.rhino.IR#returnNode()", "Node com.google.javascript.rhino.IR#returnNode(Node#expr)", "Node com.google.javascript.rhino.IR#throwNode(Node#expr)", "Node com.google.javascript.rhino.IR#exprResult(Node#expr)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then,Node#elseNode)", "Node com.google.javascript.rhino.IR#doNode(Node#body,Node#cond)", "Node com.google.javascript.rhino.IR#forIn(Node#target,Node#cond,Node#body)", "Node com.google.javascript.rhino.IR#forNode(Node#init,Node#cond,Node#incr,Node#body)", "Node com.google.javascript.rhino.IR#switchNode(Node#cond,#Node ... cases)", "Node com.google.javascript.rhino.IR#caseNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#defaultCase(Node#body)", "Node com.google.javascript.rhino.IR#label(Node#name,Node#stmt)", "Node com.google.javascript.rhino.IR#labelName(String#name)", "Node com.google.javascript.rhino.IR#tryFinally(Node#tryBody,Node#finallyBody)", "Node com.google.javascript.rhino.IR#tryCatch(Node#tryBody,Node#catchNode)", "Node com.google.javascript.rhino.IR#catchNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#breakNode()", "Node com.google.javascript.rhino.IR#breakNode(Node#name)", "Node com.google.javascript.rhino.IR#continueNode()", "Node com.google.javascript.rhino.IR#continueNode(Node#name)", "Node com.google.javascript.rhino.IR#call(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#newNode(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#name(String#name)", "Node com.google.javascript.rhino.IR#getprop(Node#target,Node#prop)", "Node com.google.javascript.rhino.IR#getelem(Node#target,Node#elem)", "Node com.google.javascript.rhino.IR#assign(Node#target,Node#expr)", "Node com.google.javascript.rhino.IR#hook(Node#cond,Node#trueval,Node#falseval)", "Node com.google.javascript.rhino.IR#comma(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#and(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#or(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#not(Node#expr1)", "Node com.google.javascript.rhino.IR#eq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sheq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#voidNode(Node#expr1)", "Node com.google.javascript.rhino.IR#neg(Node#expr1)", "Node com.google.javascript.rhino.IR#pos(Node#expr1)", "Node com.google.javascript.rhino.IR#add(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sub(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#objectlit(#Node ... propdefs)", "Node com.google.javascript.rhino.IR#propdef(Node#string,Node#value)", "Node com.google.javascript.rhino.IR#arraylit(#Node ... exprs)", "Node com.google.javascript.rhino.IR#regexp(Node#expr)", "Node com.google.javascript.rhino.IR#regexp(Node#expr,Node#flags)", "Node com.google.javascript.rhino.IR#string(String#s)", "Node com.google.javascript.rhino.IR#stringKey(String#s)", "Node com.google.javascript.rhino.IR#number(double#d)", "Node com.google.javascript.rhino.IR#thisNode()", "Node com.google.javascript.rhino.IR#trueNode()", "Node com.google.javascript.rhino.IR#falseNode()", "Node com.google.javascript.rhino.IR#nullNode()", "Node com.google.javascript.rhino.IR#binaryOp(int#token,Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#unaryOp(int#token,Node#expr)", "boolean com.google.javascript.rhino.IR#mayBeExpressionOrEmpty(Node#n)", "boolean com.google.javascript.rhino.IR#isAssignmentTarget(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeStatement(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeExpression(Node#n)"], "other_methods": ["public static Node empty();", "public static Node function(Node name,Node params,Node body);", "public static Node paramList();", "public static Node paramList(Node param);", "public static Node paramList( Node ... params);", "public static Node paramList(List<Node> params);", "public static Node block();", "public static Node block(Node stmt);", "public static Node block( Node ... stmts);", "public static Node script( Node ... stmts);", "public static Node var(Node name,Node value);", "public static Node var(Node name);", "public static Node returnNode();", "public static Node returnNode(Node expr);", "public static Node throwNode(Node expr);", "public static Node exprResult(Node expr);", "public static Node ifNode(Node cond,Node then);", "public static Node ifNode(Node cond,Node then,Node elseNode);", "public static Node doNode(Node body,Node cond);", "public static Node forIn(Node target,Node cond,Node body);", "public static Node forNode(Node init,Node cond,Node incr,Node body);", "public static Node switchNode(Node cond, Node ... cases);", "public static Node caseNode(Node expr,Node body);", "public static Node defaultCase(Node body);", "public static Node label(Node name,Node stmt);", "public static Node labelName(String name);", "public static Node tryFinally(Node tryBody,Node finallyBody);", "public static Node tryCatch(Node tryBody,Node catchNode);", "public static Node catchNode(Node expr,Node body);", "public static Node breakNode();", "public static Node breakNode(Node name);", "public static Node continueNode();", "public static Node continueNode(Node name);", "public static Node call(Node target, Node ... args);", "public static Node newNode(Node target, Node ... args);", "public static Node name(String name);", "public static Node getprop(Node target,Node prop);", "public static Node getelem(Node target,Node elem);", "public static Node assign(Node target,Node expr);", "public static Node hook(Node cond,Node trueval,Node falseval);", "public static Node comma(Node expr1,Node expr2);", "public static Node and(Node expr1,Node expr2);", "public static Node or(Node expr1,Node expr2);", "public static Node not(Node expr1);", "public static Node eq(Node expr1,Node expr2);", "public static Node sheq(Node expr1,Node expr2);", "public static Node voidNode(Node expr1);", "public static Node neg(Node expr1);", "public static Node pos(Node expr1);", "public static Node add(Node expr1,Node expr2);", "public static Node sub(Node expr1,Node expr2);", "public static Node objectlit( Node ... propdefs);", "public static Node propdef(Node string,Node value);", "public static Node arraylit( Node ... exprs);", "public static Node regexp(Node expr);", "public static Node regexp(Node expr,Node flags);", "public static Node string(String s);", "public static Node stringKey(String s);", "public static Node number(double d);", "public static Node thisNode();", "public static Node trueNode();", "public static Node falseNode();", "public static Node nullNode();"], "fields_dict": {}, "text": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   John Lenz\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.List;\n\n/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n\n  private IR() {}\n\n  public static Node empty() {\n    return new Node(Token.EMPTY);\n  }\n\n  public static Node function(Node name, Node params, Node body) {\n    Preconditions.checkState(name.isName());\n    Preconditions.checkState(params.isParamList());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FUNCTION, name, params, body);\n  }\n\n  public static Node paramList() {\n    return new Node(Token.PARAM_LIST);\n  }\n\n  public static Node paramList(Node param) {\n    Preconditions.checkState(param.isName());\n    return new Node(Token.PARAM_LIST, param);\n  }\n\n  public static Node paramList(Node ... params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node paramList(List<Node> params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n\n  public static Node block(Node stmt) {\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.BLOCK, stmt);\n    return block;\n  }\n\n  public static Node block(Node ... stmts) {\n    Node block = new Node(Token.BLOCK);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n\n  public static Node script(Node ... stmts) {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  public static Node var(Node name, Node value) {\n    Preconditions.checkState(name.isName() && !name.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    name.addChildToFront(value);\n    return var(name);\n  }\n\n  public static Node var(Node name) {\n    Preconditions.checkState(name.isName());\n    return new Node(Token.VAR, name);\n  }\n\n  public static Node returnNode() {\n    return new Node(Token.RETURN);\n  }\n\n  public static Node returnNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.RETURN, expr);\n  }\n\n  public static Node throwNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.THROW, expr);\n  }\n\n  public static Node exprResult(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.EXPR_RESULT, expr);\n  }\n\n  public static Node ifNode(Node cond, Node then) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    return new Node(Token.IF, cond, then);\n  }\n\n  public static Node ifNode(Node cond, Node then, Node elseNode) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    Preconditions.checkState(elseNode.isBlock());\n    return new Node(Token.IF, cond, then, elseNode);\n  }\n\n  public static Node doNode(Node body, Node cond) {\n    Preconditions.checkState(body.isBlock());\n    Preconditions.checkState(mayBeExpression(cond));\n    return new Node(Token.DO, body, cond);\n  }\n\n  public static Node forIn(Node target, Node cond, Node body) {\n    Preconditions.checkState(target.isVar() || mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, target, cond, body);\n  }\n\n  public static Node forNode(Node init, Node cond, Node incr, Node body) {\n    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, init, cond, incr, body);\n  }\n\n  public static Node switchNode(Node cond, Node ... cases) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Node switchNode = new Node(Token.SWITCH, cond);\n    for (Node caseNode : cases) {\n      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n      switchNode.addChildToBack(caseNode);\n    }\n    return switchNode;\n  }\n\n  public static Node caseNode(Node expr, Node body) {\n    Preconditions.checkState(mayBeExpression(expr));\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.CASE, expr, body);\n  }\n\n  public static Node defaultCase(Node body) {\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.DEFAULT_CASE, body);\n  }\n\n  public static Node label(Node name, Node stmt) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.LABEL, name, stmt);\n    return block;\n  }\n\n  public static Node labelName(String name) {\n    Preconditions.checkState(!name.isEmpty());\n    return Node.newString(Token.LABEL_NAME, name);\n  }\n\n  public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n  }\n\n  public static Node tryCatch(Node tryBody, Node catchNode) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n    return new Node(Token.TRY, tryBody, catchBody);\n  }\n\n  public static Node tryCatchFinally(\n      Node tryBody, Node catchNode, Node finallyBody) {\n    Preconditions.checkState(finallyBody.isBlock());\n    Node tryNode = tryCatch(tryBody, catchNode);\n    tryNode.addChildToBack(finallyBody);\n    return tryNode;\n  }\n\n  public static Node catchNode(Node expr, Node body) {\n    Preconditions.checkState(expr.isName());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.CATCH, expr, body);\n  }\n\n  public static Node breakNode() {\n    return new Node(Token.BREAK);\n  }\n\n  public static Node breakNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.BREAK, name);\n  }\n\n  public static Node continueNode() {\n    return new Node(Token.CONTINUE);\n  }\n\n  public static Node continueNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.CONTINUE, name);\n  }\n\n\n  //\n\n  public static Node call(Node target, Node ... args) {\n    Node call = new Node(Token.CALL, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      call.addChildToBack(arg);\n    }\n    return call;\n  }\n\n  public static Node newNode(Node target, Node ... args) {\n    Node newcall = new Node(Token.NEW, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      newcall.addChildToBack(arg);\n    }\n    return newcall;\n  }\n\n  public static Node name(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n\n  public static Node getprop(Node target, Node prop) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(prop.isString());\n    return new Node(Token.GETPROP, target, prop);\n  }\n\n  public static Node getelem(Node target, Node elem) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(elem));\n    return new Node(Token.GETELEM, target, elem);\n  }\n\n  public static Node assign(Node target, Node expr) {\n    Preconditions.checkState(isAssignmentTarget(target));\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.ASSIGN, target, expr);\n  }\n\n  public static Node hook(Node cond, Node trueval, Node falseval) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(mayBeExpression(trueval));\n    Preconditions.checkState(mayBeExpression(falseval));\n    return new Node(Token.HOOK, cond, trueval, falseval);\n  }\n\n  public static Node comma(Node expr1, Node expr2) {\n    return binaryOp(Token.COMMA, expr1, expr2);\n  }\n\n  public static Node and(Node expr1, Node expr2) {\n    return binaryOp(Token.AND, expr1, expr2);\n  }\n\n  public static Node or(Node expr1, Node expr2) {\n    return binaryOp(Token.OR, expr1, expr2);\n  }\n\n  public static Node not(Node expr1) {\n    return unaryOp(Token.NOT, expr1);\n  }\n\n  /**\n   * \"==\"\n   */\n  public static Node eq(Node expr1, Node expr2) {\n    return binaryOp(Token.EQ, expr1, expr2);\n  }\n\n  /**\n   * \"===\"\n   */\n  public static Node sheq(Node expr1, Node expr2) {\n    return binaryOp(Token.SHEQ, expr1, expr2);\n  }\n\n  public static Node voidNode(Node expr1) {\n    return unaryOp(Token.VOID, expr1);\n  }\n\n  public static Node neg(Node expr1) {\n    return unaryOp(Token.NEG, expr1);\n  }\n\n  public static Node pos(Node expr1) {\n    return unaryOp(Token.POS, expr1);\n  }\n\n  public static Node add(Node expr1, Node expr2) {\n    return binaryOp(Token.ADD, expr1, expr2);\n  }\n\n  public static Node sub(Node expr1, Node expr2) {\n    return binaryOp(Token.SUB, expr1, expr2);\n  }\n\n  // TODO(johnlenz): the rest of the ops\n\n  // literals\n  public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }\n\n  // TODO(johnlenz): quoted props\n\n  public static Node propdef(Node string, Node value) {\n    Preconditions.checkState(string.isStringKey());\n    Preconditions.checkState(!string.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    string.addChildToFront(value);\n    return string;\n  }\n\n  public static Node arraylit(Node ... exprs) {\n    Node arraylit = new Node(Token.ARRAYLIT);\n    for (Node expr : exprs) {\n      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n      arraylit.addChildToBack(expr);\n    }\n    return arraylit;\n  }\n\n  public static Node regexp(Node expr) {\n    Preconditions.checkState(expr.isString());\n    return new Node(Token.REGEXP, expr);\n  }\n\n  public static Node regexp(Node expr, Node flags) {\n    Preconditions.checkState(expr.isString());\n    Preconditions.checkState(flags.isString());\n    return new Node(Token.REGEXP, expr, flags);\n  }\n\n  public static Node string(String s) {\n    return Node.newString(s);\n  }\n\n  public static Node stringKey(String s) {\n    return Node.newString(Token.STRING_KEY, s);\n  }\n\n  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n\n  public static Node thisNode() {\n    return new Node(Token.THIS);\n  }\n\n  public static Node trueNode() {\n    return new Node(Token.TRUE);\n  }\n\n  public static Node falseNode() {\n    return new Node(Token.FALSE);\n  }\n\n  public static Node nullNode() {\n    return new Node(Token.NULL);\n  }\n\n  // helper methods\n\n  private static Node binaryOp(int token, Node expr1, Node expr2) {\n    Preconditions.checkState(mayBeExpression(expr1));\n    Preconditions.checkState(mayBeExpression(expr2));\n    return new Node(token, expr1, expr2);\n  }\n\n  private static Node unaryOp(int token, Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(token, expr);\n  }\n\n  private static boolean mayBeExpressionOrEmpty(Node n) {\n    return n.isEmpty() || mayBeExpression(n);\n  }\n\n  private static boolean isAssignmentTarget(Node n) {\n    return n.isName() || n.isGetProp() || n.isGetElem();\n  }\n\n  // NOTE: some nodes are neither statements nor expression nodes:\n  //   SCRIPT, LABEL_NAME, PARAM_LIST, CASE, DEFAULT_CASE, CATCH\n  //   GETTER_DEF, SETTER_DEF\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeStatement(Node n) {\n    switch (n.getType()) {\n      case Token.EMPTY:\n      case Token.FUNCTION:\n        // EMPTY and FUNCTION are used both in expression and statement\n        // contexts\n        return true;\n\n      case Token.BLOCK:\n      case Token.BREAK:\n      case Token.CONST:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.DO:\n      case Token.EXPR_RESULT:\n      case Token.FOR:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.RETURN:\n      case Token.SWITCH:\n      case Token.THROW:\n      case Token.TRY:\n      case Token.VAR:\n      case Token.WHILE:\n      case Token.WITH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeExpression(Node n) {\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // FUNCTION is used both in expression and statement\n        // contexts.\n        return true;\n\n      case Token.ADD:\n      case Token.AND:\n      case Token.ARRAYLIT:\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITNOT:\n      case Token.BITXOR:\n      case Token.CALL:\n      case Token.COMMA:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FALSE:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.IN:\n      case Token.INC:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TYPEOF:\n      case Token.TRUE:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `tryCatchFinally` method using JUnit 4. These tests aim to maximize both branch and line coverage.\n\nFirst, let's assume that the `Node` class has the following necessary methods for testing:\n- `isBlock()`: Checks if the node is a block node.\n- `addChildToBack(Node child)`: Adds a child node to the back of the current node.\n- `getChildAt(int index)`: Retrieves a child node at a specific index.\n- `getChildCount()`: Returns the number of children the node has.\n\nHere are the unit tests:\n\n```java\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport com.google.common.base.Preconditions;\n\npublic class IRTest {\n    private Node tryBody;\n    private Node catchNode;\n    private Node finallyBody;\n\n    @Before\n    public void setUp() {\n        tryBody = mock(Node.class);\n        catchNode = mock(Node.class);\n        finallyBody = mock(Node.class);\n    }\n\n    @Test\n    public void testTryCatchFinally_ValidFinallyBlock() {\n        when(finallyBody.isBlock()).thenReturn(true);\n        Node tryCatchNode = mock(Node.class);\n        when(IR.tryCatch(tryBody, catchNode)).thenReturn(tryCatchNode);\n\n        Node result = IR.tryCatchFinally(tryBody, catchNode, finallyBody);\n\n        assertNotNull(result);\n        assertSame(tryCatchNode, result);\n        verify(tryCatchNode).addChildToBack(finallyBody);\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testTryCatchFinally_InvalidFinallyBlock() {\n        when(finallyBody.isBlock()).thenReturn(false);\n\n        IR.tryCatchFinally(tryBody, catchNode, finallyBody);\n    }\n\n    @Test\n    public void testTryCatchFinally_TryCatchNodeIsUsed() {\n        when(finallyBody.isBlock()).thenReturn(true);\n        Node tryCatchNode = mock(Node.class);\n        when(IR.tryCatch(tryBody, catchNode)).thenReturn(tryCatchNode);\n\n        Node result = IR.tryCatchFinally(tryBody, catchNode, finallyBody);\n\n        verify(IR.class).tryCatch(tryBody, catchNode);\n        verify(tryCatchNode).addChildToBack(finallyBody);\n    }\n\n    @Test\n    public void testTryCatchFinally_ChildCountAfterAddingFinally() {\n        when(finallyBody.isBlock()).thenReturn(true);\n        Node tryCatchNode = mock(Node.class);\n        when(tryCatchNode.getChildCount()).thenReturn(1); // Simulate tryCatchNode having one child\n        when(IR.tryCatch(tryBody, catchNode)).thenReturn(tryCatchNode);\n\n        Node result = IR.tryCatchFinally(tryBody, catchNode, finallyBody);\n\n        verify(tryCatchNode).addChildToBack(finallyBody);\n        assertEquals(2, result.getChildCount());\n    }\n}\n```\n\n### Explanation of the Tests:\n\n1. **`testTryCatchFinally_ValidFinallyBlock`**:\n   - **Given**: A valid `finallyBody` that is a block.\n   - **When**: Calling `tryCatchFinally` with valid arguments.\n   - **Then**: It should return a `Node` object that is the result of `tryCatch` with `finallyBody` added to the back.\n\n2. **`testTryCatchFinally_InvalidFinallyBlock`**:\n   - **Given**: An invalid `finallyBody` that is not a block.\n   - **When**: Calling `tryCatchFinally` with invalid `finallyBody`.\n   - **Then**: It should throw an `IllegalStateException`.\n\n3. **`testTryCatchFinally_TryCatchNodeIsUsed`**:\n   - **Given**: A valid `finallyBody`.\n   - **When**: Calling `tryCatchFinally`.\n   - **Then**: It should use the `tryCatch` method and add `finallyBody` to the result.\n\n4. **`testTryCatchFinally_ChildCountAfterAddingFinally`**:\n   - **Given**: A valid `finallyBody` and a `tryCatchNode` that already has one child.\n   - **When**: Calling `tryCatchFinally`.\n   - **Then**: The resulting node should have two children after adding `finallyBody`.\n\nThese tests should provide good coverage for the `tryCatchFinally` method."}
{"bug_id": "Closure_27", "version": "fixed", "focal_method_signature": "Node com.google.javascript.rhino.IR#call(Node#target,#Node ... args)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "focal_method": "public static Node call(Node target, Node ... args) {\n    Node call = new Node(Token.CALL, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      call.addChildToBack(arg);\n    }\n    return call;\n  }", "return_type": "Node", "assertion_subject_candidates": ["int com.google.javascript.rhino.Node#getType()", "boolean com.google.javascript.rhino.Node#hasChildren()", "Node com.google.javascript.rhino.Node#getFirstChild()", "Node com.google.javascript.rhino.Node#getLastChild()", "Node com.google.javascript.rhino.Node#getNext()", "String com.google.javascript.rhino.Node#toString()", "String com.google.javascript.rhino.Node#toStringTree()", "StaticSourceFile com.google.javascript.rhino.Node#getStaticSourceFile()", "InputId com.google.javascript.rhino.Node#getInputId()", "int com.google.javascript.rhino.Node#getLength()", "int com.google.javascript.rhino.Node#getLineno()", "int com.google.javascript.rhino.Node#getCharno()", "int com.google.javascript.rhino.Node#getSourcePosition()", "Iterable<Node> com.google.javascript.rhino.Node#siblings()", "Node com.google.javascript.rhino.Node#getParent()", "AncestorIterable com.google.javascript.rhino.Node#getAncestors()", "boolean com.google.javascript.rhino.Node#hasOneChild()", "boolean com.google.javascript.rhino.Node#hasMoreThanOneChild()", "JSType com.google.javascript.rhino.Node#getJSType()", "FileLevelJsDocBuilder com.google.javascript.rhino.Node#getJsDocBuilderForNode()", "JSDocInfo com.google.javascript.rhino.Node#getJSDocInfo()", "boolean com.google.javascript.rhino.Node#isVarArgs()", "boolean com.google.javascript.rhino.Node#isOptionalArg()", "boolean com.google.javascript.rhino.Node#isSyntheticBlock()", "Set<String> com.google.javascript.rhino.Node#getDirectives()", "boolean com.google.javascript.rhino.Node#wasEmptyNode()", "int com.google.javascript.rhino.Node#getSideEffectFlags()", "boolean com.google.javascript.rhino.Node#isOnlyModifiesThisCall()", "boolean com.google.javascript.rhino.Node#isNoSideEffectsCall()", "boolean com.google.javascript.rhino.Node#isLocalResultCall()", "boolean com.google.javascript.rhino.Node#isQuotedString()", "boolean com.google.javascript.rhino.Node#isAdd()", "boolean com.google.javascript.rhino.Node#isAnd()", "boolean com.google.javascript.rhino.Node#isArrayLit()", "boolean com.google.javascript.rhino.Node#isAssign()", "boolean com.google.javascript.rhino.Node#isAssignAdd()", "boolean com.google.javascript.rhino.Node#isBlock()", "boolean com.google.javascript.rhino.Node#isBreak()", "boolean com.google.javascript.rhino.Node#isCall()", "boolean com.google.javascript.rhino.Node#isCase()", "boolean com.google.javascript.rhino.Node#isCatch()", "boolean com.google.javascript.rhino.Node#isComma()", "boolean com.google.javascript.rhino.Node#isContinue()", "boolean com.google.javascript.rhino.Node#isDebugger()", "boolean com.google.javascript.rhino.Node#isDec()", "boolean com.google.javascript.rhino.Node#isDefaultCase()", "boolean com.google.javascript.rhino.Node#isDelProp()", "boolean com.google.javascript.rhino.Node#isDo()", "boolean com.google.javascript.rhino.Node#isEmpty()", "boolean com.google.javascript.rhino.Node#isExprResult()", "boolean com.google.javascript.rhino.Node#isFalse()", "boolean com.google.javascript.rhino.Node#isFor()", "boolean com.google.javascript.rhino.Node#isFunction()", "boolean com.google.javascript.rhino.Node#isGetterDef()", "boolean com.google.javascript.rhino.Node#isGetElem()", "boolean com.google.javascript.rhino.Node#isGetProp()", "boolean com.google.javascript.rhino.Node#isHook()", "boolean com.google.javascript.rhino.Node#isIf()", "boolean com.google.javascript.rhino.Node#isIn()", "boolean com.google.javascript.rhino.Node#isInc()", "boolean com.google.javascript.rhino.Node#isInstanceOf()", "boolean com.google.javascript.rhino.Node#isLabel()", "boolean com.google.javascript.rhino.Node#isLabelName()", "boolean com.google.javascript.rhino.Node#isName()", "boolean com.google.javascript.rhino.Node#isNE()", "boolean com.google.javascript.rhino.Node#isNew()", "boolean com.google.javascript.rhino.Node#isNot()", "boolean com.google.javascript.rhino.Node#isNull()", "boolean com.google.javascript.rhino.Node#isNumber()", "boolean com.google.javascript.rhino.Node#isObjectLit()", "boolean com.google.javascript.rhino.Node#isOr()", "boolean com.google.javascript.rhino.Node#isParamList()", "boolean com.google.javascript.rhino.Node#isRegExp()", "boolean com.google.javascript.rhino.Node#isReturn()", "boolean com.google.javascript.rhino.Node#isScript()", "boolean com.google.javascript.rhino.Node#isSetterDef()", "boolean com.google.javascript.rhino.Node#isString()", "boolean com.google.javascript.rhino.Node#isStringKey()", "boolean com.google.javascript.rhino.Node#isSwitch()", "boolean com.google.javascript.rhino.Node#isThis()", "boolean com.google.javascript.rhino.Node#isThrow()", "boolean com.google.javascript.rhino.Node#isTrue()", "boolean com.google.javascript.rhino.Node#isTry()", "boolean com.google.javascript.rhino.Node#isTypeOf()", "boolean com.google.javascript.rhino.Node#isVar()", "boolean com.google.javascript.rhino.Node#isVoid()", "boolean com.google.javascript.rhino.Node#isWhile()", "boolean com.google.javascript.rhino.Node#isWith()"], "focal_class": {"name": "IR", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import java.util.List;"], "fields": [], "methods": ["Node com.google.javascript.rhino.IR#empty()", "Node com.google.javascript.rhino.IR#function(Node#name,Node#params,Node#body)", "Node com.google.javascript.rhino.IR#paramList()", "Node com.google.javascript.rhino.IR#paramList(Node#param)", "Node com.google.javascript.rhino.IR#paramList(#Node ... params)", "Node com.google.javascript.rhino.IR#paramList(List<Node>#params)", "Node com.google.javascript.rhino.IR#block()", "Node com.google.javascript.rhino.IR#block(Node#stmt)", "Node com.google.javascript.rhino.IR#block(#Node ... stmts)", "Node com.google.javascript.rhino.IR#blockUnchecked(Node#stmt)", "Node com.google.javascript.rhino.IR#script(#Node ... stmts)", "Node com.google.javascript.rhino.IR#var(Node#name,Node#value)", "Node com.google.javascript.rhino.IR#var(Node#name)", "Node com.google.javascript.rhino.IR#returnNode()", "Node com.google.javascript.rhino.IR#returnNode(Node#expr)", "Node com.google.javascript.rhino.IR#throwNode(Node#expr)", "Node com.google.javascript.rhino.IR#exprResult(Node#expr)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then,Node#elseNode)", "Node com.google.javascript.rhino.IR#doNode(Node#body,Node#cond)", "Node com.google.javascript.rhino.IR#forIn(Node#target,Node#cond,Node#body)", "Node com.google.javascript.rhino.IR#forNode(Node#init,Node#cond,Node#incr,Node#body)", "Node com.google.javascript.rhino.IR#switchNode(Node#cond,#Node ... cases)", "Node com.google.javascript.rhino.IR#caseNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#defaultCase(Node#body)", "Node com.google.javascript.rhino.IR#label(Node#name,Node#stmt)", "Node com.google.javascript.rhino.IR#labelName(String#name)", "Node com.google.javascript.rhino.IR#tryFinally(Node#tryBody,Node#finallyBody)", "Node com.google.javascript.rhino.IR#tryCatch(Node#tryBody,Node#catchNode)", "Node com.google.javascript.rhino.IR#tryCatchFinally(Node#tryBody,Node#catchNode,Node#finallyBody)", "Node com.google.javascript.rhino.IR#catchNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#breakNode()", "Node com.google.javascript.rhino.IR#breakNode(Node#name)", "Node com.google.javascript.rhino.IR#continueNode()", "Node com.google.javascript.rhino.IR#continueNode(Node#name)", "Node com.google.javascript.rhino.IR#newNode(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#name(String#name)", "Node com.google.javascript.rhino.IR#getprop(Node#target,Node#prop)", "Node com.google.javascript.rhino.IR#getelem(Node#target,Node#elem)", "Node com.google.javascript.rhino.IR#assign(Node#target,Node#expr)", "Node com.google.javascript.rhino.IR#hook(Node#cond,Node#trueval,Node#falseval)", "Node com.google.javascript.rhino.IR#comma(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#and(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#or(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#not(Node#expr1)", "Node com.google.javascript.rhino.IR#eq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sheq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#voidNode(Node#expr1)", "Node com.google.javascript.rhino.IR#neg(Node#expr1)", "Node com.google.javascript.rhino.IR#pos(Node#expr1)", "Node com.google.javascript.rhino.IR#add(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sub(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#objectlit(#Node ... propdefs)", "Node com.google.javascript.rhino.IR#propdef(Node#string,Node#value)", "Node com.google.javascript.rhino.IR#arraylit(#Node ... exprs)", "Node com.google.javascript.rhino.IR#regexp(Node#expr)", "Node com.google.javascript.rhino.IR#regexp(Node#expr,Node#flags)", "Node com.google.javascript.rhino.IR#string(String#s)", "Node com.google.javascript.rhino.IR#stringKey(String#s)", "Node com.google.javascript.rhino.IR#number(double#d)", "Node com.google.javascript.rhino.IR#thisNode()", "Node com.google.javascript.rhino.IR#trueNode()", "Node com.google.javascript.rhino.IR#falseNode()", "Node com.google.javascript.rhino.IR#nullNode()", "Node com.google.javascript.rhino.IR#binaryOp(int#token,Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#unaryOp(int#token,Node#expr)", "boolean com.google.javascript.rhino.IR#mayBeExpressionOrEmpty(Node#n)", "boolean com.google.javascript.rhino.IR#isAssignmentTarget(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeStatement(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeExpression(Node#n)"], "other_methods": ["public static Node empty();", "public static Node function(Node name,Node params,Node body);", "public static Node paramList();", "public static Node paramList(Node param);", "public static Node paramList( Node ... params);", "public static Node paramList(List<Node> params);", "public static Node block();", "public static Node block(Node stmt);", "public static Node block( Node ... stmts);", "public static Node script( Node ... stmts);", "public static Node var(Node name,Node value);", "public static Node var(Node name);", "public static Node returnNode();", "public static Node returnNode(Node expr);", "public static Node throwNode(Node expr);", "public static Node exprResult(Node expr);", "public static Node ifNode(Node cond,Node then);", "public static Node ifNode(Node cond,Node then,Node elseNode);", "public static Node doNode(Node body,Node cond);", "public static Node forIn(Node target,Node cond,Node body);", "public static Node forNode(Node init,Node cond,Node incr,Node body);", "public static Node switchNode(Node cond, Node ... cases);", "public static Node caseNode(Node expr,Node body);", "public static Node defaultCase(Node body);", "public static Node label(Node name,Node stmt);", "public static Node labelName(String name);", "public static Node tryFinally(Node tryBody,Node finallyBody);", "public static Node tryCatch(Node tryBody,Node catchNode);", "public static Node tryCatchFinally(Node tryBody,Node catchNode,Node finallyBody);", "public static Node catchNode(Node expr,Node body);", "public static Node breakNode();", "public static Node breakNode(Node name);", "public static Node continueNode();", "public static Node continueNode(Node name);", "public static Node newNode(Node target, Node ... args);", "public static Node name(String name);", "public static Node getprop(Node target,Node prop);", "public static Node getelem(Node target,Node elem);", "public static Node assign(Node target,Node expr);", "public static Node hook(Node cond,Node trueval,Node falseval);", "public static Node comma(Node expr1,Node expr2);", "public static Node and(Node expr1,Node expr2);", "public static Node or(Node expr1,Node expr2);", "public static Node not(Node expr1);", "public static Node eq(Node expr1,Node expr2);", "public static Node sheq(Node expr1,Node expr2);", "public static Node voidNode(Node expr1);", "public static Node neg(Node expr1);", "public static Node pos(Node expr1);", "public static Node add(Node expr1,Node expr2);", "public static Node sub(Node expr1,Node expr2);", "public static Node objectlit( Node ... propdefs);", "public static Node propdef(Node string,Node value);", "public static Node arraylit( Node ... exprs);", "public static Node regexp(Node expr);", "public static Node regexp(Node expr,Node flags);", "public static Node string(String s);", "public static Node stringKey(String s);", "public static Node number(double d);", "public static Node thisNode();", "public static Node trueNode();", "public static Node falseNode();", "public static Node nullNode();"], "fields_dict": {}, "text": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   John Lenz\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.List;\n\n/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n\n  private IR() {}\n\n  public static Node empty() {\n    return new Node(Token.EMPTY);\n  }\n\n  public static Node function(Node name, Node params, Node body) {\n    Preconditions.checkState(name.isName());\n    Preconditions.checkState(params.isParamList());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FUNCTION, name, params, body);\n  }\n\n  public static Node paramList() {\n    return new Node(Token.PARAM_LIST);\n  }\n\n  public static Node paramList(Node param) {\n    Preconditions.checkState(param.isName());\n    return new Node(Token.PARAM_LIST, param);\n  }\n\n  public static Node paramList(Node ... params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node paramList(List<Node> params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n\n  public static Node block(Node stmt) {\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.BLOCK, stmt);\n    return block;\n  }\n\n  public static Node block(Node ... stmts) {\n    Node block = new Node(Token.BLOCK);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n\n  public static Node script(Node ... stmts) {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  public static Node var(Node name, Node value) {\n    Preconditions.checkState(name.isName() && !name.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    name.addChildToFront(value);\n    return var(name);\n  }\n\n  public static Node var(Node name) {\n    Preconditions.checkState(name.isName());\n    return new Node(Token.VAR, name);\n  }\n\n  public static Node returnNode() {\n    return new Node(Token.RETURN);\n  }\n\n  public static Node returnNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.RETURN, expr);\n  }\n\n  public static Node throwNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.THROW, expr);\n  }\n\n  public static Node exprResult(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.EXPR_RESULT, expr);\n  }\n\n  public static Node ifNode(Node cond, Node then) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    return new Node(Token.IF, cond, then);\n  }\n\n  public static Node ifNode(Node cond, Node then, Node elseNode) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    Preconditions.checkState(elseNode.isBlock());\n    return new Node(Token.IF, cond, then, elseNode);\n  }\n\n  public static Node doNode(Node body, Node cond) {\n    Preconditions.checkState(body.isBlock());\n    Preconditions.checkState(mayBeExpression(cond));\n    return new Node(Token.DO, body, cond);\n  }\n\n  public static Node forIn(Node target, Node cond, Node body) {\n    Preconditions.checkState(target.isVar() || mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, target, cond, body);\n  }\n\n  public static Node forNode(Node init, Node cond, Node incr, Node body) {\n    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, init, cond, incr, body);\n  }\n\n  public static Node switchNode(Node cond, Node ... cases) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Node switchNode = new Node(Token.SWITCH, cond);\n    for (Node caseNode : cases) {\n      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n      switchNode.addChildToBack(caseNode);\n    }\n    return switchNode;\n  }\n\n  public static Node caseNode(Node expr, Node body) {\n    Preconditions.checkState(mayBeExpression(expr));\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.CASE, expr, body);\n  }\n\n  public static Node defaultCase(Node body) {\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.DEFAULT_CASE, body);\n  }\n\n  public static Node label(Node name, Node stmt) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.LABEL, name, stmt);\n    return block;\n  }\n\n  public static Node labelName(String name) {\n    Preconditions.checkState(!name.isEmpty());\n    return Node.newString(Token.LABEL_NAME, name);\n  }\n\n  public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n  }\n\n  public static Node tryCatch(Node tryBody, Node catchNode) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n    return new Node(Token.TRY, tryBody, catchBody);\n  }\n\n  public static Node tryCatchFinally(\n      Node tryBody, Node catchNode, Node finallyBody) {\n    Preconditions.checkState(finallyBody.isBlock());\n    Node tryNode = tryCatch(tryBody, catchNode);\n    tryNode.addChildToBack(finallyBody);\n    return tryNode;\n  }\n\n  public static Node catchNode(Node expr, Node body) {\n    Preconditions.checkState(expr.isName());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.CATCH, expr, body);\n  }\n\n  public static Node breakNode() {\n    return new Node(Token.BREAK);\n  }\n\n  public static Node breakNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.BREAK, name);\n  }\n\n  public static Node continueNode() {\n    return new Node(Token.CONTINUE);\n  }\n\n  public static Node continueNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.CONTINUE, name);\n  }\n\n\n  //\n\n  public static Node call(Node target, Node ... args) {\n    Node call = new Node(Token.CALL, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      call.addChildToBack(arg);\n    }\n    return call;\n  }\n\n  public static Node newNode(Node target, Node ... args) {\n    Node newcall = new Node(Token.NEW, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      newcall.addChildToBack(arg);\n    }\n    return newcall;\n  }\n\n  public static Node name(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n\n  public static Node getprop(Node target, Node prop) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(prop.isString());\n    return new Node(Token.GETPROP, target, prop);\n  }\n\n  public static Node getelem(Node target, Node elem) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(elem));\n    return new Node(Token.GETELEM, target, elem);\n  }\n\n  public static Node assign(Node target, Node expr) {\n    Preconditions.checkState(isAssignmentTarget(target));\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.ASSIGN, target, expr);\n  }\n\n  public static Node hook(Node cond, Node trueval, Node falseval) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(mayBeExpression(trueval));\n    Preconditions.checkState(mayBeExpression(falseval));\n    return new Node(Token.HOOK, cond, trueval, falseval);\n  }\n\n  public static Node comma(Node expr1, Node expr2) {\n    return binaryOp(Token.COMMA, expr1, expr2);\n  }\n\n  public static Node and(Node expr1, Node expr2) {\n    return binaryOp(Token.AND, expr1, expr2);\n  }\n\n  public static Node or(Node expr1, Node expr2) {\n    return binaryOp(Token.OR, expr1, expr2);\n  }\n\n  public static Node not(Node expr1) {\n    return unaryOp(Token.NOT, expr1);\n  }\n\n  /**\n   * \"==\"\n   */\n  public static Node eq(Node expr1, Node expr2) {\n    return binaryOp(Token.EQ, expr1, expr2);\n  }\n\n  /**\n   * \"===\"\n   */\n  public static Node sheq(Node expr1, Node expr2) {\n    return binaryOp(Token.SHEQ, expr1, expr2);\n  }\n\n  public static Node voidNode(Node expr1) {\n    return unaryOp(Token.VOID, expr1);\n  }\n\n  public static Node neg(Node expr1) {\n    return unaryOp(Token.NEG, expr1);\n  }\n\n  public static Node pos(Node expr1) {\n    return unaryOp(Token.POS, expr1);\n  }\n\n  public static Node add(Node expr1, Node expr2) {\n    return binaryOp(Token.ADD, expr1, expr2);\n  }\n\n  public static Node sub(Node expr1, Node expr2) {\n    return binaryOp(Token.SUB, expr1, expr2);\n  }\n\n  // TODO(johnlenz): the rest of the ops\n\n  // literals\n  public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }\n\n  // TODO(johnlenz): quoted props\n\n  public static Node propdef(Node string, Node value) {\n    Preconditions.checkState(string.isStringKey());\n    Preconditions.checkState(!string.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    string.addChildToFront(value);\n    return string;\n  }\n\n  public static Node arraylit(Node ... exprs) {\n    Node arraylit = new Node(Token.ARRAYLIT);\n    for (Node expr : exprs) {\n      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n      arraylit.addChildToBack(expr);\n    }\n    return arraylit;\n  }\n\n  public static Node regexp(Node expr) {\n    Preconditions.checkState(expr.isString());\n    return new Node(Token.REGEXP, expr);\n  }\n\n  public static Node regexp(Node expr, Node flags) {\n    Preconditions.checkState(expr.isString());\n    Preconditions.checkState(flags.isString());\n    return new Node(Token.REGEXP, expr, flags);\n  }\n\n  public static Node string(String s) {\n    return Node.newString(s);\n  }\n\n  public static Node stringKey(String s) {\n    return Node.newString(Token.STRING_KEY, s);\n  }\n\n  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n\n  public static Node thisNode() {\n    return new Node(Token.THIS);\n  }\n\n  public static Node trueNode() {\n    return new Node(Token.TRUE);\n  }\n\n  public static Node falseNode() {\n    return new Node(Token.FALSE);\n  }\n\n  public static Node nullNode() {\n    return new Node(Token.NULL);\n  }\n\n  // helper methods\n\n  private static Node binaryOp(int token, Node expr1, Node expr2) {\n    Preconditions.checkState(mayBeExpression(expr1));\n    Preconditions.checkState(mayBeExpression(expr2));\n    return new Node(token, expr1, expr2);\n  }\n\n  private static Node unaryOp(int token, Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(token, expr);\n  }\n\n  private static boolean mayBeExpressionOrEmpty(Node n) {\n    return n.isEmpty() || mayBeExpression(n);\n  }\n\n  private static boolean isAssignmentTarget(Node n) {\n    return n.isName() || n.isGetProp() || n.isGetElem();\n  }\n\n  // NOTE: some nodes are neither statements nor expression nodes:\n  //   SCRIPT, LABEL_NAME, PARAM_LIST, CASE, DEFAULT_CASE, CATCH\n  //   GETTER_DEF, SETTER_DEF\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeStatement(Node n) {\n    switch (n.getType()) {\n      case Token.EMPTY:\n      case Token.FUNCTION:\n        // EMPTY and FUNCTION are used both in expression and statement\n        // contexts\n        return true;\n\n      case Token.BLOCK:\n      case Token.BREAK:\n      case Token.CONST:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.DO:\n      case Token.EXPR_RESULT:\n      case Token.FOR:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.RETURN:\n      case Token.SWITCH:\n      case Token.THROW:\n      case Token.TRY:\n      case Token.VAR:\n      case Token.WHILE:\n      case Token.WITH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeExpression(Node n) {\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // FUNCTION is used both in expression and statement\n        // contexts.\n        return true;\n\n      case Token.ADD:\n      case Token.AND:\n      case Token.ARRAYLIT:\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITNOT:\n      case Token.BITXOR:\n      case Token.CALL:\n      case Token.COMMA:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FALSE:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.IN:\n      case Token.INC:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TYPEOF:\n      case Token.TRUE:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n"}, "generated_test_class": "Sure, I'll write some unit tests for the `call` method in the `IR` class using JUnit 4. To maximize branch and line coverage, I'll ensure that different scenarios are tested, including edge cases and typical use cases.\n\nFirst, let's ensure you have the necessary dependencies for JUnit 4 in your `pom.xml` if you're using Maven:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.13.2</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\nNow, let's write the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class IRTest {\n\n    private Node target;\n\n    @Before\n    public void setUp() {\n        target = IR.name(\"myFunction\");\n    }\n\n    @Test\n    public void testCallWithNoArgs() {\n        Node call = IR.call(target);\n        assertEquals(Token.CALL, call.getType());\n        assertEquals(target, call.getFirstChild());\n        assertNull(call.getFirstChild().getNext());\n    }\n\n    @Test\n    public void testCallWithOneArg() {\n        Node arg1 = IR.number(10);\n        Node call = IR.call(target, arg1);\n        assertEquals(Token.CALL, call.getType());\n        assertEquals(target, call.getFirstChild());\n        Node next = call.getFirstChild().getNext();\n        assertEquals(arg1, next);\n        assertNull(next.getNext());\n    }\n\n    @Test\n    public void testCallWithMultipleArgs() {\n        Node arg1 = IR.number(10);\n        Node arg2 = IR.string(\"hello\");\n        Node call = IR.call(target, arg1, arg2);\n        assertEquals(Token.CALL, call.getType());\n        assertEquals(target, call.getFirstChild());\n        Node next = call.getFirstChild().getNext();\n        assertEquals(arg1, next);\n        next = next.getNext();\n        assertEquals(arg2, next);\n        assertNull(next.getNext());\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testCallWithInvalidArg() {\n        Node invalidArg = IR.block(); // Invalid argument as it's not an expression\n        IR.call(target, invalidArg);\n    }\n\n    // Assuming mayBeExpression() checks if a node is an expression\n    // This is a mock check to ensure we cover the invalid case\n    // In a real scenario, you might need to mock the Preconditions class or override it\n    private static class Node {\n        public static final int CALL = 1;\n\n        private final int type;\n        private Node firstChild;\n        private Node next;\n\n        public Node(int type) {\n            this.type = type;\n        }\n\n        public Node(int type, Node firstChild) {\n            this(type);\n            this.firstChild = firstChild;\n        }\n\n        public int getType() {\n            return type;\n        }\n\n        public Node getFirstChild() {\n            return firstChild;\n        }\n\n        public Node getNext() {\n            return next;\n        }\n\n        public void addChildToBack(Node arg) {\n            if (firstChild == null) {\n                firstChild = arg;\n            } else {\n                Node current = firstChild;\n                while (current.getNext() != null) {\n                    current = current.getNext();\n                }\n                current.next = arg;\n            }\n        }\n\n        public static Node name(String name) {\n            return new Node(2); // Arbitrary type for name\n        }\n\n        public static Node number(double d) {\n            return new Node(3); // Arbitrary type for number\n        }\n\n        public static Node string(String s) {\n            return new Node(4); // Arbitrary type for string\n        }\n\n        public static Node block() {\n            return new Node(5); // Arbitrary type for block\n        }\n    }\n\n    // Mock method to check if a node is an expression\n    private static class Preconditions {\n        public static void checkState(boolean expression) {\n            if (!expression) {\n                throw new IllegalStateException();\n            }\n        }\n    }\n\n    private static class Token {\n        public static final int CALL = 1;\n    }\n}\n```\n\n### Explanation:\n\n1. **Setup**: The `setUp` method initializes a `target` node which is used in all test cases.\n2. **testCallWithNoArgs**: Tests calling a function with no arguments.\n3. **testCallWithOneArg**: Tests calling a function with one argument.\n4. **testCallWithMultipleArgs**: Tests calling a function with multiple arguments.\n5. **testCallWithInvalidArg**: Tests calling a function with an invalid argument to ensure the `Preconditions.checkState` throws an `IllegalStateException`.\n\n### Notes:\n\n- The `Node` class, `Preconditions` class, and `Token` class are simplified for testing purposes. In a real scenario, you would use the actual classes provided by your project.\n- The `mayBeExpression` method is assumed to check if a node is an expression. The `Preconditions.checkState` method is mocked to throw an exception if the node is not an expression.\n- This setup ensures that we have good branch and line coverage for the `call` method."}
{"bug_id": "Closure_27", "version": "fixed", "focal_method_signature": "Node com.google.javascript.rhino.IR#newNode(Node#target,#Node ... args)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "focal_method": "public static Node newNode(Node target, Node ... args) {\n    Node newcall = new Node(Token.NEW, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      newcall.addChildToBack(arg);\n    }\n    return newcall;\n  }", "return_type": "Node", "assertion_subject_candidates": ["int com.google.javascript.rhino.Node#getType()", "boolean com.google.javascript.rhino.Node#hasChildren()", "Node com.google.javascript.rhino.Node#getFirstChild()", "Node com.google.javascript.rhino.Node#getLastChild()", "Node com.google.javascript.rhino.Node#getNext()", "String com.google.javascript.rhino.Node#toString()", "String com.google.javascript.rhino.Node#toStringTree()", "StaticSourceFile com.google.javascript.rhino.Node#getStaticSourceFile()", "InputId com.google.javascript.rhino.Node#getInputId()", "int com.google.javascript.rhino.Node#getLength()", "int com.google.javascript.rhino.Node#getLineno()", "int com.google.javascript.rhino.Node#getCharno()", "int com.google.javascript.rhino.Node#getSourcePosition()", "Iterable<Node> com.google.javascript.rhino.Node#siblings()", "Node com.google.javascript.rhino.Node#getParent()", "AncestorIterable com.google.javascript.rhino.Node#getAncestors()", "boolean com.google.javascript.rhino.Node#hasOneChild()", "boolean com.google.javascript.rhino.Node#hasMoreThanOneChild()", "JSType com.google.javascript.rhino.Node#getJSType()", "FileLevelJsDocBuilder com.google.javascript.rhino.Node#getJsDocBuilderForNode()", "JSDocInfo com.google.javascript.rhino.Node#getJSDocInfo()", "boolean com.google.javascript.rhino.Node#isVarArgs()", "boolean com.google.javascript.rhino.Node#isOptionalArg()", "boolean com.google.javascript.rhino.Node#isSyntheticBlock()", "Set<String> com.google.javascript.rhino.Node#getDirectives()", "boolean com.google.javascript.rhino.Node#wasEmptyNode()", "int com.google.javascript.rhino.Node#getSideEffectFlags()", "boolean com.google.javascript.rhino.Node#isOnlyModifiesThisCall()", "boolean com.google.javascript.rhino.Node#isNoSideEffectsCall()", "boolean com.google.javascript.rhino.Node#isLocalResultCall()", "boolean com.google.javascript.rhino.Node#isQuotedString()", "boolean com.google.javascript.rhino.Node#isAdd()", "boolean com.google.javascript.rhino.Node#isAnd()", "boolean com.google.javascript.rhino.Node#isArrayLit()", "boolean com.google.javascript.rhino.Node#isAssign()", "boolean com.google.javascript.rhino.Node#isAssignAdd()", "boolean com.google.javascript.rhino.Node#isBlock()", "boolean com.google.javascript.rhino.Node#isBreak()", "boolean com.google.javascript.rhino.Node#isCall()", "boolean com.google.javascript.rhino.Node#isCase()", "boolean com.google.javascript.rhino.Node#isCatch()", "boolean com.google.javascript.rhino.Node#isComma()", "boolean com.google.javascript.rhino.Node#isContinue()", "boolean com.google.javascript.rhino.Node#isDebugger()", "boolean com.google.javascript.rhino.Node#isDec()", "boolean com.google.javascript.rhino.Node#isDefaultCase()", "boolean com.google.javascript.rhino.Node#isDelProp()", "boolean com.google.javascript.rhino.Node#isDo()", "boolean com.google.javascript.rhino.Node#isEmpty()", "boolean com.google.javascript.rhino.Node#isExprResult()", "boolean com.google.javascript.rhino.Node#isFalse()", "boolean com.google.javascript.rhino.Node#isFor()", "boolean com.google.javascript.rhino.Node#isFunction()", "boolean com.google.javascript.rhino.Node#isGetterDef()", "boolean com.google.javascript.rhino.Node#isGetElem()", "boolean com.google.javascript.rhino.Node#isGetProp()", "boolean com.google.javascript.rhino.Node#isHook()", "boolean com.google.javascript.rhino.Node#isIf()", "boolean com.google.javascript.rhino.Node#isIn()", "boolean com.google.javascript.rhino.Node#isInc()", "boolean com.google.javascript.rhino.Node#isInstanceOf()", "boolean com.google.javascript.rhino.Node#isLabel()", "boolean com.google.javascript.rhino.Node#isLabelName()", "boolean com.google.javascript.rhino.Node#isName()", "boolean com.google.javascript.rhino.Node#isNE()", "boolean com.google.javascript.rhino.Node#isNew()", "boolean com.google.javascript.rhino.Node#isNot()", "boolean com.google.javascript.rhino.Node#isNull()", "boolean com.google.javascript.rhino.Node#isNumber()", "boolean com.google.javascript.rhino.Node#isObjectLit()", "boolean com.google.javascript.rhino.Node#isOr()", "boolean com.google.javascript.rhino.Node#isParamList()", "boolean com.google.javascript.rhino.Node#isRegExp()", "boolean com.google.javascript.rhino.Node#isReturn()", "boolean com.google.javascript.rhino.Node#isScript()", "boolean com.google.javascript.rhino.Node#isSetterDef()", "boolean com.google.javascript.rhino.Node#isString()", "boolean com.google.javascript.rhino.Node#isStringKey()", "boolean com.google.javascript.rhino.Node#isSwitch()", "boolean com.google.javascript.rhino.Node#isThis()", "boolean com.google.javascript.rhino.Node#isThrow()", "boolean com.google.javascript.rhino.Node#isTrue()", "boolean com.google.javascript.rhino.Node#isTry()", "boolean com.google.javascript.rhino.Node#isTypeOf()", "boolean com.google.javascript.rhino.Node#isVar()", "boolean com.google.javascript.rhino.Node#isVoid()", "boolean com.google.javascript.rhino.Node#isWhile()", "boolean com.google.javascript.rhino.Node#isWith()"], "focal_class": {"name": "IR", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import java.util.List;"], "fields": [], "methods": ["Node com.google.javascript.rhino.IR#empty()", "Node com.google.javascript.rhino.IR#function(Node#name,Node#params,Node#body)", "Node com.google.javascript.rhino.IR#paramList()", "Node com.google.javascript.rhino.IR#paramList(Node#param)", "Node com.google.javascript.rhino.IR#paramList(#Node ... params)", "Node com.google.javascript.rhino.IR#paramList(List<Node>#params)", "Node com.google.javascript.rhino.IR#block()", "Node com.google.javascript.rhino.IR#block(Node#stmt)", "Node com.google.javascript.rhino.IR#block(#Node ... stmts)", "Node com.google.javascript.rhino.IR#blockUnchecked(Node#stmt)", "Node com.google.javascript.rhino.IR#script(#Node ... stmts)", "Node com.google.javascript.rhino.IR#var(Node#name,Node#value)", "Node com.google.javascript.rhino.IR#var(Node#name)", "Node com.google.javascript.rhino.IR#returnNode()", "Node com.google.javascript.rhino.IR#returnNode(Node#expr)", "Node com.google.javascript.rhino.IR#throwNode(Node#expr)", "Node com.google.javascript.rhino.IR#exprResult(Node#expr)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then,Node#elseNode)", "Node com.google.javascript.rhino.IR#doNode(Node#body,Node#cond)", "Node com.google.javascript.rhino.IR#forIn(Node#target,Node#cond,Node#body)", "Node com.google.javascript.rhino.IR#forNode(Node#init,Node#cond,Node#incr,Node#body)", "Node com.google.javascript.rhino.IR#switchNode(Node#cond,#Node ... cases)", "Node com.google.javascript.rhino.IR#caseNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#defaultCase(Node#body)", "Node com.google.javascript.rhino.IR#label(Node#name,Node#stmt)", "Node com.google.javascript.rhino.IR#labelName(String#name)", "Node com.google.javascript.rhino.IR#tryFinally(Node#tryBody,Node#finallyBody)", "Node com.google.javascript.rhino.IR#tryCatch(Node#tryBody,Node#catchNode)", "Node com.google.javascript.rhino.IR#tryCatchFinally(Node#tryBody,Node#catchNode,Node#finallyBody)", "Node com.google.javascript.rhino.IR#catchNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#breakNode()", "Node com.google.javascript.rhino.IR#breakNode(Node#name)", "Node com.google.javascript.rhino.IR#continueNode()", "Node com.google.javascript.rhino.IR#continueNode(Node#name)", "Node com.google.javascript.rhino.IR#call(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#name(String#name)", "Node com.google.javascript.rhino.IR#getprop(Node#target,Node#prop)", "Node com.google.javascript.rhino.IR#getelem(Node#target,Node#elem)", "Node com.google.javascript.rhino.IR#assign(Node#target,Node#expr)", "Node com.google.javascript.rhino.IR#hook(Node#cond,Node#trueval,Node#falseval)", "Node com.google.javascript.rhino.IR#comma(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#and(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#or(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#not(Node#expr1)", "Node com.google.javascript.rhino.IR#eq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sheq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#voidNode(Node#expr1)", "Node com.google.javascript.rhino.IR#neg(Node#expr1)", "Node com.google.javascript.rhino.IR#pos(Node#expr1)", "Node com.google.javascript.rhino.IR#add(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sub(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#objectlit(#Node ... propdefs)", "Node com.google.javascript.rhino.IR#propdef(Node#string,Node#value)", "Node com.google.javascript.rhino.IR#arraylit(#Node ... exprs)", "Node com.google.javascript.rhino.IR#regexp(Node#expr)", "Node com.google.javascript.rhino.IR#regexp(Node#expr,Node#flags)", "Node com.google.javascript.rhino.IR#string(String#s)", "Node com.google.javascript.rhino.IR#stringKey(String#s)", "Node com.google.javascript.rhino.IR#number(double#d)", "Node com.google.javascript.rhino.IR#thisNode()", "Node com.google.javascript.rhino.IR#trueNode()", "Node com.google.javascript.rhino.IR#falseNode()", "Node com.google.javascript.rhino.IR#nullNode()", "Node com.google.javascript.rhino.IR#binaryOp(int#token,Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#unaryOp(int#token,Node#expr)", "boolean com.google.javascript.rhino.IR#mayBeExpressionOrEmpty(Node#n)", "boolean com.google.javascript.rhino.IR#isAssignmentTarget(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeStatement(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeExpression(Node#n)"], "other_methods": ["public static Node empty();", "public static Node function(Node name,Node params,Node body);", "public static Node paramList();", "public static Node paramList(Node param);", "public static Node paramList( Node ... params);", "public static Node paramList(List<Node> params);", "public static Node block();", "public static Node block(Node stmt);", "public static Node block( Node ... stmts);", "public static Node script( Node ... stmts);", "public static Node var(Node name,Node value);", "public static Node var(Node name);", "public static Node returnNode();", "public static Node returnNode(Node expr);", "public static Node throwNode(Node expr);", "public static Node exprResult(Node expr);", "public static Node ifNode(Node cond,Node then);", "public static Node ifNode(Node cond,Node then,Node elseNode);", "public static Node doNode(Node body,Node cond);", "public static Node forIn(Node target,Node cond,Node body);", "public static Node forNode(Node init,Node cond,Node incr,Node body);", "public static Node switchNode(Node cond, Node ... cases);", "public static Node caseNode(Node expr,Node body);", "public static Node defaultCase(Node body);", "public static Node label(Node name,Node stmt);", "public static Node labelName(String name);", "public static Node tryFinally(Node tryBody,Node finallyBody);", "public static Node tryCatch(Node tryBody,Node catchNode);", "public static Node tryCatchFinally(Node tryBody,Node catchNode,Node finallyBody);", "public static Node catchNode(Node expr,Node body);", "public static Node breakNode();", "public static Node breakNode(Node name);", "public static Node continueNode();", "public static Node continueNode(Node name);", "public static Node call(Node target, Node ... args);", "public static Node name(String name);", "public static Node getprop(Node target,Node prop);", "public static Node getelem(Node target,Node elem);", "public static Node assign(Node target,Node expr);", "public static Node hook(Node cond,Node trueval,Node falseval);", "public static Node comma(Node expr1,Node expr2);", "public static Node and(Node expr1,Node expr2);", "public static Node or(Node expr1,Node expr2);", "public static Node not(Node expr1);", "public static Node eq(Node expr1,Node expr2);", "public static Node sheq(Node expr1,Node expr2);", "public static Node voidNode(Node expr1);", "public static Node neg(Node expr1);", "public static Node pos(Node expr1);", "public static Node add(Node expr1,Node expr2);", "public static Node sub(Node expr1,Node expr2);", "public static Node objectlit( Node ... propdefs);", "public static Node propdef(Node string,Node value);", "public static Node arraylit( Node ... exprs);", "public static Node regexp(Node expr);", "public static Node regexp(Node expr,Node flags);", "public static Node string(String s);", "public static Node stringKey(String s);", "public static Node number(double d);", "public static Node thisNode();", "public static Node trueNode();", "public static Node falseNode();", "public static Node nullNode();"], "fields_dict": {}, "text": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   John Lenz\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.List;\n\n/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n\n  private IR() {}\n\n  public static Node empty() {\n    return new Node(Token.EMPTY);\n  }\n\n  public static Node function(Node name, Node params, Node body) {\n    Preconditions.checkState(name.isName());\n    Preconditions.checkState(params.isParamList());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FUNCTION, name, params, body);\n  }\n\n  public static Node paramList() {\n    return new Node(Token.PARAM_LIST);\n  }\n\n  public static Node paramList(Node param) {\n    Preconditions.checkState(param.isName());\n    return new Node(Token.PARAM_LIST, param);\n  }\n\n  public static Node paramList(Node ... params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node paramList(List<Node> params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n\n  public static Node block(Node stmt) {\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.BLOCK, stmt);\n    return block;\n  }\n\n  public static Node block(Node ... stmts) {\n    Node block = new Node(Token.BLOCK);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n\n  public static Node script(Node ... stmts) {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  public static Node var(Node name, Node value) {\n    Preconditions.checkState(name.isName() && !name.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    name.addChildToFront(value);\n    return var(name);\n  }\n\n  public static Node var(Node name) {\n    Preconditions.checkState(name.isName());\n    return new Node(Token.VAR, name);\n  }\n\n  public static Node returnNode() {\n    return new Node(Token.RETURN);\n  }\n\n  public static Node returnNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.RETURN, expr);\n  }\n\n  public static Node throwNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.THROW, expr);\n  }\n\n  public static Node exprResult(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.EXPR_RESULT, expr);\n  }\n\n  public static Node ifNode(Node cond, Node then) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    return new Node(Token.IF, cond, then);\n  }\n\n  public static Node ifNode(Node cond, Node then, Node elseNode) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    Preconditions.checkState(elseNode.isBlock());\n    return new Node(Token.IF, cond, then, elseNode);\n  }\n\n  public static Node doNode(Node body, Node cond) {\n    Preconditions.checkState(body.isBlock());\n    Preconditions.checkState(mayBeExpression(cond));\n    return new Node(Token.DO, body, cond);\n  }\n\n  public static Node forIn(Node target, Node cond, Node body) {\n    Preconditions.checkState(target.isVar() || mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, target, cond, body);\n  }\n\n  public static Node forNode(Node init, Node cond, Node incr, Node body) {\n    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, init, cond, incr, body);\n  }\n\n  public static Node switchNode(Node cond, Node ... cases) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Node switchNode = new Node(Token.SWITCH, cond);\n    for (Node caseNode : cases) {\n      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n      switchNode.addChildToBack(caseNode);\n    }\n    return switchNode;\n  }\n\n  public static Node caseNode(Node expr, Node body) {\n    Preconditions.checkState(mayBeExpression(expr));\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.CASE, expr, body);\n  }\n\n  public static Node defaultCase(Node body) {\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.DEFAULT_CASE, body);\n  }\n\n  public static Node label(Node name, Node stmt) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.LABEL, name, stmt);\n    return block;\n  }\n\n  public static Node labelName(String name) {\n    Preconditions.checkState(!name.isEmpty());\n    return Node.newString(Token.LABEL_NAME, name);\n  }\n\n  public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n  }\n\n  public static Node tryCatch(Node tryBody, Node catchNode) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n    return new Node(Token.TRY, tryBody, catchBody);\n  }\n\n  public static Node tryCatchFinally(\n      Node tryBody, Node catchNode, Node finallyBody) {\n    Preconditions.checkState(finallyBody.isBlock());\n    Node tryNode = tryCatch(tryBody, catchNode);\n    tryNode.addChildToBack(finallyBody);\n    return tryNode;\n  }\n\n  public static Node catchNode(Node expr, Node body) {\n    Preconditions.checkState(expr.isName());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.CATCH, expr, body);\n  }\n\n  public static Node breakNode() {\n    return new Node(Token.BREAK);\n  }\n\n  public static Node breakNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.BREAK, name);\n  }\n\n  public static Node continueNode() {\n    return new Node(Token.CONTINUE);\n  }\n\n  public static Node continueNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.CONTINUE, name);\n  }\n\n\n  //\n\n  public static Node call(Node target, Node ... args) {\n    Node call = new Node(Token.CALL, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      call.addChildToBack(arg);\n    }\n    return call;\n  }\n\n  public static Node newNode(Node target, Node ... args) {\n    Node newcall = new Node(Token.NEW, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      newcall.addChildToBack(arg);\n    }\n    return newcall;\n  }\n\n  public static Node name(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n\n  public static Node getprop(Node target, Node prop) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(prop.isString());\n    return new Node(Token.GETPROP, target, prop);\n  }\n\n  public static Node getelem(Node target, Node elem) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(elem));\n    return new Node(Token.GETELEM, target, elem);\n  }\n\n  public static Node assign(Node target, Node expr) {\n    Preconditions.checkState(isAssignmentTarget(target));\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.ASSIGN, target, expr);\n  }\n\n  public static Node hook(Node cond, Node trueval, Node falseval) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(mayBeExpression(trueval));\n    Preconditions.checkState(mayBeExpression(falseval));\n    return new Node(Token.HOOK, cond, trueval, falseval);\n  }\n\n  public static Node comma(Node expr1, Node expr2) {\n    return binaryOp(Token.COMMA, expr1, expr2);\n  }\n\n  public static Node and(Node expr1, Node expr2) {\n    return binaryOp(Token.AND, expr1, expr2);\n  }\n\n  public static Node or(Node expr1, Node expr2) {\n    return binaryOp(Token.OR, expr1, expr2);\n  }\n\n  public static Node not(Node expr1) {\n    return unaryOp(Token.NOT, expr1);\n  }\n\n  /**\n   * \"==\"\n   */\n  public static Node eq(Node expr1, Node expr2) {\n    return binaryOp(Token.EQ, expr1, expr2);\n  }\n\n  /**\n   * \"===\"\n   */\n  public static Node sheq(Node expr1, Node expr2) {\n    return binaryOp(Token.SHEQ, expr1, expr2);\n  }\n\n  public static Node voidNode(Node expr1) {\n    return unaryOp(Token.VOID, expr1);\n  }\n\n  public static Node neg(Node expr1) {\n    return unaryOp(Token.NEG, expr1);\n  }\n\n  public static Node pos(Node expr1) {\n    return unaryOp(Token.POS, expr1);\n  }\n\n  public static Node add(Node expr1, Node expr2) {\n    return binaryOp(Token.ADD, expr1, expr2);\n  }\n\n  public static Node sub(Node expr1, Node expr2) {\n    return binaryOp(Token.SUB, expr1, expr2);\n  }\n\n  // TODO(johnlenz): the rest of the ops\n\n  // literals\n  public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }\n\n  // TODO(johnlenz): quoted props\n\n  public static Node propdef(Node string, Node value) {\n    Preconditions.checkState(string.isStringKey());\n    Preconditions.checkState(!string.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    string.addChildToFront(value);\n    return string;\n  }\n\n  public static Node arraylit(Node ... exprs) {\n    Node arraylit = new Node(Token.ARRAYLIT);\n    for (Node expr : exprs) {\n      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n      arraylit.addChildToBack(expr);\n    }\n    return arraylit;\n  }\n\n  public static Node regexp(Node expr) {\n    Preconditions.checkState(expr.isString());\n    return new Node(Token.REGEXP, expr);\n  }\n\n  public static Node regexp(Node expr, Node flags) {\n    Preconditions.checkState(expr.isString());\n    Preconditions.checkState(flags.isString());\n    return new Node(Token.REGEXP, expr, flags);\n  }\n\n  public static Node string(String s) {\n    return Node.newString(s);\n  }\n\n  public static Node stringKey(String s) {\n    return Node.newString(Token.STRING_KEY, s);\n  }\n\n  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n\n  public static Node thisNode() {\n    return new Node(Token.THIS);\n  }\n\n  public static Node trueNode() {\n    return new Node(Token.TRUE);\n  }\n\n  public static Node falseNode() {\n    return new Node(Token.FALSE);\n  }\n\n  public static Node nullNode() {\n    return new Node(Token.NULL);\n  }\n\n  // helper methods\n\n  private static Node binaryOp(int token, Node expr1, Node expr2) {\n    Preconditions.checkState(mayBeExpression(expr1));\n    Preconditions.checkState(mayBeExpression(expr2));\n    return new Node(token, expr1, expr2);\n  }\n\n  private static Node unaryOp(int token, Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(token, expr);\n  }\n\n  private static boolean mayBeExpressionOrEmpty(Node n) {\n    return n.isEmpty() || mayBeExpression(n);\n  }\n\n  private static boolean isAssignmentTarget(Node n) {\n    return n.isName() || n.isGetProp() || n.isGetElem();\n  }\n\n  // NOTE: some nodes are neither statements nor expression nodes:\n  //   SCRIPT, LABEL_NAME, PARAM_LIST, CASE, DEFAULT_CASE, CATCH\n  //   GETTER_DEF, SETTER_DEF\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeStatement(Node n) {\n    switch (n.getType()) {\n      case Token.EMPTY:\n      case Token.FUNCTION:\n        // EMPTY and FUNCTION are used both in expression and statement\n        // contexts\n        return true;\n\n      case Token.BLOCK:\n      case Token.BREAK:\n      case Token.CONST:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.DO:\n      case Token.EXPR_RESULT:\n      case Token.FOR:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.RETURN:\n      case Token.SWITCH:\n      case Token.THROW:\n      case Token.TRY:\n      case Token.VAR:\n      case Token.WHILE:\n      case Token.WITH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeExpression(Node n) {\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // FUNCTION is used both in expression and statement\n        // contexts.\n        return true;\n\n      case Token.ADD:\n      case Token.AND:\n      case Token.ARRAYLIT:\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITNOT:\n      case Token.BITXOR:\n      case Token.CALL:\n      case Token.COMMA:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FALSE:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.IN:\n      case Token.INC:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TYPEOF:\n      case Token.TRUE:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n"}, "generated_test_class": "To write unit tests for the `newNode` method, we need to consider various scenarios including:\n\n1. Testing with a valid target node and no arguments.\n2. Testing with a valid target node and one argument.\n3. Testing with a valid target node and multiple arguments.\n4. Testing with invalid arguments that violate the precondition.\n\nGiven that the method `newNode` uses `Preconditions.checkState` from Google Guava, if the precondition is not met, it will throw an `IllegalArgumentException`. Hence, we also need to test for this exception.\n\nHere are the unit tests:\n\n```java\nimport com.google.common.base.Preconditions;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.Assert;\nimport org.junit.Rule;\nimport org.junit.rules.ExpectedException;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.*;\n\npublic class IRTest {\n\n    @Rule\n    public ExpectedException thrown = ExpectedException.none();\n\n    private Node mockNode;\n\n    @Before\n    public void setUp() {\n        mockNode = mock(Node.class);\n    }\n\n    @Test\n    public void testNewNodeWithNoArgs() {\n        Node targetNode = new Node(Token.NEW, mockNode);\n\n        Node result = IR.newNode(mockNode);\n\n        assertEquals(Token.NEW, result.getType());\n        assertEquals(mockNode, result.getFirstChild());\n        assertEquals(1, result.getChildCount());\n    }\n\n    @Test\n    public void testNewNodeWithOneArg() {\n        Node targetNode = new Node(Token.NEW, mockNode);\n        Node argNode = mock(Node.class);\n        when(IR.mayBeExpression(argNode)).thenReturn(true);\n\n        Node result = IR.newNode(mockNode, argNode);\n\n        assertEquals(Token.NEW, result.getType());\n        assertEquals(mockNode, result.getFirstChild());\n        assertEquals(2, result.getChildCount());\n        assertEquals(argNode, result.getLastChild());\n    }\n\n    @Test\n    public void testNewNodeWithMultipleArgs() {\n        Node targetNode = new Node(Token.NEW, mockNode);\n        Node argNode1 = mock(Node.class);\n        Node argNode2 = mock(Node.class);\n        when(IR.mayBeExpression(argNode1)).thenReturn(true);\n        when(IR.mayBeExpression(argNode2)).thenReturn(true);\n\n        Node result = IR.newNode(mockNode, argNode1, argNode2);\n\n        assertEquals(Token.NEW, result.getType());\n        assertEquals(mockNode, result.getFirstChild());\n        assertEquals(3, result.getChildCount());\n        assertEquals(argNode2, result.getLastChild());\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testNewNodeWithInvalidArg() {\n        Node argNode = mock(Node.class);\n        when(IR.mayBeExpression(argNode)).thenReturn(false);\n\n        IR.newNode(mockNode, argNode);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testNewNodeWithMultipleInvalidArgs() {\n        Node argNode1 = mock(Node.class);\n        Node argNode2 = mock(Node.class);\n        when(IR.mayBeExpression(argNode1)).thenReturn(true);\n        when(IR.mayBeExpression(argNode2)).thenReturn(false);\n\n        IR.newNode(mockNode, argNode1, argNode2);\n    }\n}\n```\n\n### Explanation:\n\n1. **Setup**:\n   - We use `@Before` to setup a mock `Node` which is used as a target in `newNode`.\n\n2. **Test NewNode with No Args**:\n   - We check if the node created has the `Token.NEW` type and the correct target node as its child.\n\n3. **Test NewNode with One Arg**:\n   - We check if the node created has the `Token.NEW` type, the correct target node, and the provided argument node as its children.\n\n4. **Test NewNode with Multiple Args**:\n   - We check if the node created has the `Token.NEW` type, the correct target node, and all provided argument nodes as its children.\n\n5. **Test NewNode with Invalid Arg**:\n   - We mock the `mayBeExpression` method to return false and check if an `IllegalArgumentException` is thrown.\n\n6. **Test NewNode with Multiple Invalid Args**:\n   - We mock the `mayBeExpression` method to return false for at least one argument and check if an `IllegalArgumentException` is thrown.\n\nBy writing these tests, we ensure that `newNode` method is robust and handles all expected scenarios correctly."}
{"bug_id": "Closure_27", "version": "fixed", "focal_method_signature": "Node com.google.javascript.rhino.IR#objectlit(#Node ... propdefs)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "focal_method": "public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }", "return_type": "Node", "assertion_subject_candidates": ["int com.google.javascript.rhino.Node#getType()", "boolean com.google.javascript.rhino.Node#hasChildren()", "Node com.google.javascript.rhino.Node#getFirstChild()", "Node com.google.javascript.rhino.Node#getLastChild()", "Node com.google.javascript.rhino.Node#getNext()", "String com.google.javascript.rhino.Node#toString()", "String com.google.javascript.rhino.Node#toStringTree()", "StaticSourceFile com.google.javascript.rhino.Node#getStaticSourceFile()", "InputId com.google.javascript.rhino.Node#getInputId()", "int com.google.javascript.rhino.Node#getLength()", "int com.google.javascript.rhino.Node#getLineno()", "int com.google.javascript.rhino.Node#getCharno()", "int com.google.javascript.rhino.Node#getSourcePosition()", "Iterable<Node> com.google.javascript.rhino.Node#siblings()", "Node com.google.javascript.rhino.Node#getParent()", "AncestorIterable com.google.javascript.rhino.Node#getAncestors()", "boolean com.google.javascript.rhino.Node#hasOneChild()", "boolean com.google.javascript.rhino.Node#hasMoreThanOneChild()", "JSType com.google.javascript.rhino.Node#getJSType()", "FileLevelJsDocBuilder com.google.javascript.rhino.Node#getJsDocBuilderForNode()", "JSDocInfo com.google.javascript.rhino.Node#getJSDocInfo()", "boolean com.google.javascript.rhino.Node#isVarArgs()", "boolean com.google.javascript.rhino.Node#isOptionalArg()", "boolean com.google.javascript.rhino.Node#isSyntheticBlock()", "Set<String> com.google.javascript.rhino.Node#getDirectives()", "boolean com.google.javascript.rhino.Node#wasEmptyNode()", "int com.google.javascript.rhino.Node#getSideEffectFlags()", "boolean com.google.javascript.rhino.Node#isOnlyModifiesThisCall()", "boolean com.google.javascript.rhino.Node#isNoSideEffectsCall()", "boolean com.google.javascript.rhino.Node#isLocalResultCall()", "boolean com.google.javascript.rhino.Node#isQuotedString()", "boolean com.google.javascript.rhino.Node#isAdd()", "boolean com.google.javascript.rhino.Node#isAnd()", "boolean com.google.javascript.rhino.Node#isArrayLit()", "boolean com.google.javascript.rhino.Node#isAssign()", "boolean com.google.javascript.rhino.Node#isAssignAdd()", "boolean com.google.javascript.rhino.Node#isBlock()", "boolean com.google.javascript.rhino.Node#isBreak()", "boolean com.google.javascript.rhino.Node#isCall()", "boolean com.google.javascript.rhino.Node#isCase()", "boolean com.google.javascript.rhino.Node#isCatch()", "boolean com.google.javascript.rhino.Node#isComma()", "boolean com.google.javascript.rhino.Node#isContinue()", "boolean com.google.javascript.rhino.Node#isDebugger()", "boolean com.google.javascript.rhino.Node#isDec()", "boolean com.google.javascript.rhino.Node#isDefaultCase()", "boolean com.google.javascript.rhino.Node#isDelProp()", "boolean com.google.javascript.rhino.Node#isDo()", "boolean com.google.javascript.rhino.Node#isEmpty()", "boolean com.google.javascript.rhino.Node#isExprResult()", "boolean com.google.javascript.rhino.Node#isFalse()", "boolean com.google.javascript.rhino.Node#isFor()", "boolean com.google.javascript.rhino.Node#isFunction()", "boolean com.google.javascript.rhino.Node#isGetterDef()", "boolean com.google.javascript.rhino.Node#isGetElem()", "boolean com.google.javascript.rhino.Node#isGetProp()", "boolean com.google.javascript.rhino.Node#isHook()", "boolean com.google.javascript.rhino.Node#isIf()", "boolean com.google.javascript.rhino.Node#isIn()", "boolean com.google.javascript.rhino.Node#isInc()", "boolean com.google.javascript.rhino.Node#isInstanceOf()", "boolean com.google.javascript.rhino.Node#isLabel()", "boolean com.google.javascript.rhino.Node#isLabelName()", "boolean com.google.javascript.rhino.Node#isName()", "boolean com.google.javascript.rhino.Node#isNE()", "boolean com.google.javascript.rhino.Node#isNew()", "boolean com.google.javascript.rhino.Node#isNot()", "boolean com.google.javascript.rhino.Node#isNull()", "boolean com.google.javascript.rhino.Node#isNumber()", "boolean com.google.javascript.rhino.Node#isObjectLit()", "boolean com.google.javascript.rhino.Node#isOr()", "boolean com.google.javascript.rhino.Node#isParamList()", "boolean com.google.javascript.rhino.Node#isRegExp()", "boolean com.google.javascript.rhino.Node#isReturn()", "boolean com.google.javascript.rhino.Node#isScript()", "boolean com.google.javascript.rhino.Node#isSetterDef()", "boolean com.google.javascript.rhino.Node#isString()", "boolean com.google.javascript.rhino.Node#isStringKey()", "boolean com.google.javascript.rhino.Node#isSwitch()", "boolean com.google.javascript.rhino.Node#isThis()", "boolean com.google.javascript.rhino.Node#isThrow()", "boolean com.google.javascript.rhino.Node#isTrue()", "boolean com.google.javascript.rhino.Node#isTry()", "boolean com.google.javascript.rhino.Node#isTypeOf()", "boolean com.google.javascript.rhino.Node#isVar()", "boolean com.google.javascript.rhino.Node#isVoid()", "boolean com.google.javascript.rhino.Node#isWhile()", "boolean com.google.javascript.rhino.Node#isWith()"], "focal_class": {"name": "IR", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import java.util.List;"], "fields": [], "methods": ["Node com.google.javascript.rhino.IR#empty()", "Node com.google.javascript.rhino.IR#function(Node#name,Node#params,Node#body)", "Node com.google.javascript.rhino.IR#paramList()", "Node com.google.javascript.rhino.IR#paramList(Node#param)", "Node com.google.javascript.rhino.IR#paramList(#Node ... params)", "Node com.google.javascript.rhino.IR#paramList(List<Node>#params)", "Node com.google.javascript.rhino.IR#block()", "Node com.google.javascript.rhino.IR#block(Node#stmt)", "Node com.google.javascript.rhino.IR#block(#Node ... stmts)", "Node com.google.javascript.rhino.IR#blockUnchecked(Node#stmt)", "Node com.google.javascript.rhino.IR#script(#Node ... stmts)", "Node com.google.javascript.rhino.IR#var(Node#name,Node#value)", "Node com.google.javascript.rhino.IR#var(Node#name)", "Node com.google.javascript.rhino.IR#returnNode()", "Node com.google.javascript.rhino.IR#returnNode(Node#expr)", "Node com.google.javascript.rhino.IR#throwNode(Node#expr)", "Node com.google.javascript.rhino.IR#exprResult(Node#expr)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then,Node#elseNode)", "Node com.google.javascript.rhino.IR#doNode(Node#body,Node#cond)", "Node com.google.javascript.rhino.IR#forIn(Node#target,Node#cond,Node#body)", "Node com.google.javascript.rhino.IR#forNode(Node#init,Node#cond,Node#incr,Node#body)", "Node com.google.javascript.rhino.IR#switchNode(Node#cond,#Node ... cases)", "Node com.google.javascript.rhino.IR#caseNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#defaultCase(Node#body)", "Node com.google.javascript.rhino.IR#label(Node#name,Node#stmt)", "Node com.google.javascript.rhino.IR#labelName(String#name)", "Node com.google.javascript.rhino.IR#tryFinally(Node#tryBody,Node#finallyBody)", "Node com.google.javascript.rhino.IR#tryCatch(Node#tryBody,Node#catchNode)", "Node com.google.javascript.rhino.IR#tryCatchFinally(Node#tryBody,Node#catchNode,Node#finallyBody)", "Node com.google.javascript.rhino.IR#catchNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#breakNode()", "Node com.google.javascript.rhino.IR#breakNode(Node#name)", "Node com.google.javascript.rhino.IR#continueNode()", "Node com.google.javascript.rhino.IR#continueNode(Node#name)", "Node com.google.javascript.rhino.IR#call(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#newNode(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#name(String#name)", "Node com.google.javascript.rhino.IR#getprop(Node#target,Node#prop)", "Node com.google.javascript.rhino.IR#getelem(Node#target,Node#elem)", "Node com.google.javascript.rhino.IR#assign(Node#target,Node#expr)", "Node com.google.javascript.rhino.IR#hook(Node#cond,Node#trueval,Node#falseval)", "Node com.google.javascript.rhino.IR#comma(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#and(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#or(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#not(Node#expr1)", "Node com.google.javascript.rhino.IR#eq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sheq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#voidNode(Node#expr1)", "Node com.google.javascript.rhino.IR#neg(Node#expr1)", "Node com.google.javascript.rhino.IR#pos(Node#expr1)", "Node com.google.javascript.rhino.IR#add(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sub(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#propdef(Node#string,Node#value)", "Node com.google.javascript.rhino.IR#arraylit(#Node ... exprs)", "Node com.google.javascript.rhino.IR#regexp(Node#expr)", "Node com.google.javascript.rhino.IR#regexp(Node#expr,Node#flags)", "Node com.google.javascript.rhino.IR#string(String#s)", "Node com.google.javascript.rhino.IR#stringKey(String#s)", "Node com.google.javascript.rhino.IR#number(double#d)", "Node com.google.javascript.rhino.IR#thisNode()", "Node com.google.javascript.rhino.IR#trueNode()", "Node com.google.javascript.rhino.IR#falseNode()", "Node com.google.javascript.rhino.IR#nullNode()", "Node com.google.javascript.rhino.IR#binaryOp(int#token,Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#unaryOp(int#token,Node#expr)", "boolean com.google.javascript.rhino.IR#mayBeExpressionOrEmpty(Node#n)", "boolean com.google.javascript.rhino.IR#isAssignmentTarget(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeStatement(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeExpression(Node#n)"], "other_methods": ["public static Node empty();", "public static Node function(Node name,Node params,Node body);", "public static Node paramList();", "public static Node paramList(Node param);", "public static Node paramList( Node ... params);", "public static Node paramList(List<Node> params);", "public static Node block();", "public static Node block(Node stmt);", "public static Node block( Node ... stmts);", "public static Node script( Node ... stmts);", "public static Node var(Node name,Node value);", "public static Node var(Node name);", "public static Node returnNode();", "public static Node returnNode(Node expr);", "public static Node throwNode(Node expr);", "public static Node exprResult(Node expr);", "public static Node ifNode(Node cond,Node then);", "public static Node ifNode(Node cond,Node then,Node elseNode);", "public static Node doNode(Node body,Node cond);", "public static Node forIn(Node target,Node cond,Node body);", "public static Node forNode(Node init,Node cond,Node incr,Node body);", "public static Node switchNode(Node cond, Node ... cases);", "public static Node caseNode(Node expr,Node body);", "public static Node defaultCase(Node body);", "public static Node label(Node name,Node stmt);", "public static Node labelName(String name);", "public static Node tryFinally(Node tryBody,Node finallyBody);", "public static Node tryCatch(Node tryBody,Node catchNode);", "public static Node tryCatchFinally(Node tryBody,Node catchNode,Node finallyBody);", "public static Node catchNode(Node expr,Node body);", "public static Node breakNode();", "public static Node breakNode(Node name);", "public static Node continueNode();", "public static Node continueNode(Node name);", "public static Node call(Node target, Node ... args);", "public static Node newNode(Node target, Node ... args);", "public static Node name(String name);", "public static Node getprop(Node target,Node prop);", "public static Node getelem(Node target,Node elem);", "public static Node assign(Node target,Node expr);", "public static Node hook(Node cond,Node trueval,Node falseval);", "public static Node comma(Node expr1,Node expr2);", "public static Node and(Node expr1,Node expr2);", "public static Node or(Node expr1,Node expr2);", "public static Node not(Node expr1);", "public static Node eq(Node expr1,Node expr2);", "public static Node sheq(Node expr1,Node expr2);", "public static Node voidNode(Node expr1);", "public static Node neg(Node expr1);", "public static Node pos(Node expr1);", "public static Node add(Node expr1,Node expr2);", "public static Node sub(Node expr1,Node expr2);", "public static Node propdef(Node string,Node value);", "public static Node arraylit( Node ... exprs);", "public static Node regexp(Node expr);", "public static Node regexp(Node expr,Node flags);", "public static Node string(String s);", "public static Node stringKey(String s);", "public static Node number(double d);", "public static Node thisNode();", "public static Node trueNode();", "public static Node falseNode();", "public static Node nullNode();"], "fields_dict": {}, "text": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   John Lenz\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.List;\n\n/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n\n  private IR() {}\n\n  public static Node empty() {\n    return new Node(Token.EMPTY);\n  }\n\n  public static Node function(Node name, Node params, Node body) {\n    Preconditions.checkState(name.isName());\n    Preconditions.checkState(params.isParamList());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FUNCTION, name, params, body);\n  }\n\n  public static Node paramList() {\n    return new Node(Token.PARAM_LIST);\n  }\n\n  public static Node paramList(Node param) {\n    Preconditions.checkState(param.isName());\n    return new Node(Token.PARAM_LIST, param);\n  }\n\n  public static Node paramList(Node ... params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node paramList(List<Node> params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n\n  public static Node block(Node stmt) {\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.BLOCK, stmt);\n    return block;\n  }\n\n  public static Node block(Node ... stmts) {\n    Node block = new Node(Token.BLOCK);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n\n  public static Node script(Node ... stmts) {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  public static Node var(Node name, Node value) {\n    Preconditions.checkState(name.isName() && !name.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    name.addChildToFront(value);\n    return var(name);\n  }\n\n  public static Node var(Node name) {\n    Preconditions.checkState(name.isName());\n    return new Node(Token.VAR, name);\n  }\n\n  public static Node returnNode() {\n    return new Node(Token.RETURN);\n  }\n\n  public static Node returnNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.RETURN, expr);\n  }\n\n  public static Node throwNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.THROW, expr);\n  }\n\n  public static Node exprResult(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.EXPR_RESULT, expr);\n  }\n\n  public static Node ifNode(Node cond, Node then) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    return new Node(Token.IF, cond, then);\n  }\n\n  public static Node ifNode(Node cond, Node then, Node elseNode) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    Preconditions.checkState(elseNode.isBlock());\n    return new Node(Token.IF, cond, then, elseNode);\n  }\n\n  public static Node doNode(Node body, Node cond) {\n    Preconditions.checkState(body.isBlock());\n    Preconditions.checkState(mayBeExpression(cond));\n    return new Node(Token.DO, body, cond);\n  }\n\n  public static Node forIn(Node target, Node cond, Node body) {\n    Preconditions.checkState(target.isVar() || mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, target, cond, body);\n  }\n\n  public static Node forNode(Node init, Node cond, Node incr, Node body) {\n    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, init, cond, incr, body);\n  }\n\n  public static Node switchNode(Node cond, Node ... cases) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Node switchNode = new Node(Token.SWITCH, cond);\n    for (Node caseNode : cases) {\n      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n      switchNode.addChildToBack(caseNode);\n    }\n    return switchNode;\n  }\n\n  public static Node caseNode(Node expr, Node body) {\n    Preconditions.checkState(mayBeExpression(expr));\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.CASE, expr, body);\n  }\n\n  public static Node defaultCase(Node body) {\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.DEFAULT_CASE, body);\n  }\n\n  public static Node label(Node name, Node stmt) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.LABEL, name, stmt);\n    return block;\n  }\n\n  public static Node labelName(String name) {\n    Preconditions.checkState(!name.isEmpty());\n    return Node.newString(Token.LABEL_NAME, name);\n  }\n\n  public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n  }\n\n  public static Node tryCatch(Node tryBody, Node catchNode) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n    return new Node(Token.TRY, tryBody, catchBody);\n  }\n\n  public static Node tryCatchFinally(\n      Node tryBody, Node catchNode, Node finallyBody) {\n    Preconditions.checkState(finallyBody.isBlock());\n    Node tryNode = tryCatch(tryBody, catchNode);\n    tryNode.addChildToBack(finallyBody);\n    return tryNode;\n  }\n\n  public static Node catchNode(Node expr, Node body) {\n    Preconditions.checkState(expr.isName());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.CATCH, expr, body);\n  }\n\n  public static Node breakNode() {\n    return new Node(Token.BREAK);\n  }\n\n  public static Node breakNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.BREAK, name);\n  }\n\n  public static Node continueNode() {\n    return new Node(Token.CONTINUE);\n  }\n\n  public static Node continueNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.CONTINUE, name);\n  }\n\n\n  //\n\n  public static Node call(Node target, Node ... args) {\n    Node call = new Node(Token.CALL, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      call.addChildToBack(arg);\n    }\n    return call;\n  }\n\n  public static Node newNode(Node target, Node ... args) {\n    Node newcall = new Node(Token.NEW, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      newcall.addChildToBack(arg);\n    }\n    return newcall;\n  }\n\n  public static Node name(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n\n  public static Node getprop(Node target, Node prop) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(prop.isString());\n    return new Node(Token.GETPROP, target, prop);\n  }\n\n  public static Node getelem(Node target, Node elem) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(elem));\n    return new Node(Token.GETELEM, target, elem);\n  }\n\n  public static Node assign(Node target, Node expr) {\n    Preconditions.checkState(isAssignmentTarget(target));\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.ASSIGN, target, expr);\n  }\n\n  public static Node hook(Node cond, Node trueval, Node falseval) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(mayBeExpression(trueval));\n    Preconditions.checkState(mayBeExpression(falseval));\n    return new Node(Token.HOOK, cond, trueval, falseval);\n  }\n\n  public static Node comma(Node expr1, Node expr2) {\n    return binaryOp(Token.COMMA, expr1, expr2);\n  }\n\n  public static Node and(Node expr1, Node expr2) {\n    return binaryOp(Token.AND, expr1, expr2);\n  }\n\n  public static Node or(Node expr1, Node expr2) {\n    return binaryOp(Token.OR, expr1, expr2);\n  }\n\n  public static Node not(Node expr1) {\n    return unaryOp(Token.NOT, expr1);\n  }\n\n  /**\n   * \"==\"\n   */\n  public static Node eq(Node expr1, Node expr2) {\n    return binaryOp(Token.EQ, expr1, expr2);\n  }\n\n  /**\n   * \"===\"\n   */\n  public static Node sheq(Node expr1, Node expr2) {\n    return binaryOp(Token.SHEQ, expr1, expr2);\n  }\n\n  public static Node voidNode(Node expr1) {\n    return unaryOp(Token.VOID, expr1);\n  }\n\n  public static Node neg(Node expr1) {\n    return unaryOp(Token.NEG, expr1);\n  }\n\n  public static Node pos(Node expr1) {\n    return unaryOp(Token.POS, expr1);\n  }\n\n  public static Node add(Node expr1, Node expr2) {\n    return binaryOp(Token.ADD, expr1, expr2);\n  }\n\n  public static Node sub(Node expr1, Node expr2) {\n    return binaryOp(Token.SUB, expr1, expr2);\n  }\n\n  // TODO(johnlenz): the rest of the ops\n\n  // literals\n  public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }\n\n  // TODO(johnlenz): quoted props\n\n  public static Node propdef(Node string, Node value) {\n    Preconditions.checkState(string.isStringKey());\n    Preconditions.checkState(!string.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    string.addChildToFront(value);\n    return string;\n  }\n\n  public static Node arraylit(Node ... exprs) {\n    Node arraylit = new Node(Token.ARRAYLIT);\n    for (Node expr : exprs) {\n      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n      arraylit.addChildToBack(expr);\n    }\n    return arraylit;\n  }\n\n  public static Node regexp(Node expr) {\n    Preconditions.checkState(expr.isString());\n    return new Node(Token.REGEXP, expr);\n  }\n\n  public static Node regexp(Node expr, Node flags) {\n    Preconditions.checkState(expr.isString());\n    Preconditions.checkState(flags.isString());\n    return new Node(Token.REGEXP, expr, flags);\n  }\n\n  public static Node string(String s) {\n    return Node.newString(s);\n  }\n\n  public static Node stringKey(String s) {\n    return Node.newString(Token.STRING_KEY, s);\n  }\n\n  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n\n  public static Node thisNode() {\n    return new Node(Token.THIS);\n  }\n\n  public static Node trueNode() {\n    return new Node(Token.TRUE);\n  }\n\n  public static Node falseNode() {\n    return new Node(Token.FALSE);\n  }\n\n  public static Node nullNode() {\n    return new Node(Token.NULL);\n  }\n\n  // helper methods\n\n  private static Node binaryOp(int token, Node expr1, Node expr2) {\n    Preconditions.checkState(mayBeExpression(expr1));\n    Preconditions.checkState(mayBeExpression(expr2));\n    return new Node(token, expr1, expr2);\n  }\n\n  private static Node unaryOp(int token, Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(token, expr);\n  }\n\n  private static boolean mayBeExpressionOrEmpty(Node n) {\n    return n.isEmpty() || mayBeExpression(n);\n  }\n\n  private static boolean isAssignmentTarget(Node n) {\n    return n.isName() || n.isGetProp() || n.isGetElem();\n  }\n\n  // NOTE: some nodes are neither statements nor expression nodes:\n  //   SCRIPT, LABEL_NAME, PARAM_LIST, CASE, DEFAULT_CASE, CATCH\n  //   GETTER_DEF, SETTER_DEF\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeStatement(Node n) {\n    switch (n.getType()) {\n      case Token.EMPTY:\n      case Token.FUNCTION:\n        // EMPTY and FUNCTION are used both in expression and statement\n        // contexts\n        return true;\n\n      case Token.BLOCK:\n      case Token.BREAK:\n      case Token.CONST:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.DO:\n      case Token.EXPR_RESULT:\n      case Token.FOR:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.RETURN:\n      case Token.SWITCH:\n      case Token.THROW:\n      case Token.TRY:\n      case Token.VAR:\n      case Token.WHILE:\n      case Token.WITH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeExpression(Node n) {\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // FUNCTION is used both in expression and statement\n        // contexts.\n        return true;\n\n      case Token.ADD:\n      case Token.AND:\n      case Token.ARRAYLIT:\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITNOT:\n      case Token.BITXOR:\n      case Token.CALL:\n      case Token.COMMA:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FALSE:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.IN:\n      case Token.INC:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TYPEOF:\n      case Token.TRUE:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `objectlit` method in Java 1.7 using JUnit 4. These tests aim to maximize both branch and line coverage by testing various scenarios, including valid and invalid inputs.\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.Assert;\nimport com.google.common.base.Preconditions;\nimport java.util.List;\n\npublic class IRTest {\n\n    private IR.Node node;\n\n    @Before\n    public void setUp() {\n        node = new IR.Node(Token.OBJECTLIT);\n    }\n\n    @Test\n    public void testObjectlitWithNoPropdefs() {\n        IR.Node result = IR.objectlit();\n        Assert.assertEquals(Token.OBJECTLIT, result.getType());\n        Assert.assertTrue(result.getChildCount() == 0);\n    }\n\n    @Test\n    public void testObjectlitWithOnePropdef() {\n        IR.Node propdef = IR.propdef(\"key\", IR.string(\"value\"));\n        IR.Node result = IR.objectlit(propdef);\n        Assert.assertEquals(Token.OBJECTLIT, result.getType());\n        Assert.assertTrue(result.getChildCount() == 1);\n        Assert.assertEquals(propdef, result.getFirstChild());\n    }\n\n    @Test\n    public void testObjectlitWithMultiplePropdefs() {\n        IR.Node propdef1 = IR.propdef(\"key1\", IR.string(\"value1\"));\n        IR.Node propdef2 = IR.propdef(\"key2\", IR.string(\"value2\"));\n        IR.Node result = IR.objectlit(propdef1, propdef2);\n        Assert.assertEquals(Token.OBJECTLIT, result.getType());\n        Assert.assertTrue(result.getChildCount() == 2);\n        Assert.assertEquals(propdef1, result.getFirstChild());\n        Assert.assertEquals(propdef2, result.getFirstChild().getNext());\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testObjectlitWithInvalidPropdef() {\n        IR.Node invalidPropdef = IR.string(\"invalidKey\");\n        IR.objectlit(invalidPropdef);\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testObjectlitWithPropdefHavingNoChild() {\n        IR.Node propdef = new IR.Node(Token.STRING_KEY);\n        IR.objectlit(propdef);\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testObjectlitWithPropdefHavingMultipleChildren() {\n        IR.Node propdef = IR.propdef(\"key\", IR.string(\"value\"));\n        propdef.addChildToBack(IR.string(\"additionalValue\"));\n        IR.objectlit(propdef);\n    }\n\n    // Inner class to represent Node for testing purposes\n    public static class IR {\n        public enum Token {\n            OBJECTLIT, STRING_KEY\n        }\n\n        public static class Node {\n            private Token type;\n            private Node firstChild;\n            private Node next;\n\n            public Node(Token type) {\n                this.type = type;\n            }\n\n            public Token getType() {\n                return type;\n            }\n\n            public boolean isStringKey() {\n                return type == Token.STRING_KEY;\n            }\n\n            public boolean isGetterDef() {\n                return false;\n            }\n\n            public boolean isSetterDef() {\n                return false;\n            }\n\n            public boolean hasOneChild() {\n                return firstChild != null && firstChild.next == null;\n            }\n\n            public void addChildToBack(Node child) {\n                if (firstChild == null) {\n                    firstChild = child;\n                } else {\n                    Node current = firstChild;\n                    while (current.next != null) {\n                        current = current.next;\n                    }\n                    current.next = child;\n                }\n            }\n\n            public Node getFirstChild() {\n                return firstChild;\n            }\n\n            public Node getNext() {\n                return next;\n            }\n\n            public int getChildCount() {\n                int count = 0;\n                Node current = firstChild;\n                while (current != null) {\n                    count++;\n                    current = current.next;\n                }\n                return count;\n            }\n        }\n\n        public static Node propdef(String key, Node value) {\n            Node propdefNode = new Node(Token.STRING_KEY);\n            propdefNode.addChildToBack(value);\n            return propdefNode;\n        }\n\n        public static Node string(String s) {\n            return new Node(Token.STRING_KEY);\n        }\n    }\n}\n```\n\n### Explanation of the Tests:\n\n1. **testObjectlitWithNoPropdefs**:\n   - Tests creating an object literal with no property definitions.\n   - Verifies that the resulting node is of type `OBJECTLIT` and has no children.\n\n2. **testObjectlitWithOnePropdef**:\n   - Tests creating an object literal with one property definition.\n   - Verifies that the resulting node is of type `OBJECTLIT`, has one child, and the child is the provided property definition.\n\n3. **testObjectlitWithMultiplePropdefs**:\n   - Tests creating an object literal with multiple property definitions.\n   - Verifies that the resulting node is of type `OBJECTLIT`, has the correct number of children, and the children are in the correct order.\n\n4. **testObjectlitWithInvalidPropdef**:\n   - Tests creating an object literal with an invalid property definition (e.g., a string node instead of a propdef).\n   - Expects an `IllegalStateException` to be thrown.\n\n5. **testObjectlitWithPropdefHavingNoChild**:\n   - Tests creating an object literal with a property definition that has no children.\n   - Expects an `IllegalStateException` to be thrown.\n\n6. **testObjectlitWithPropdefHavingMultipleChildren**:\n   - Tests creating an object literal with a property definition that has multiple children.\n   - Expects an `IllegalStateException` to be thrown.\n\n### Note:\nThe `IR.Node` class and `Token` enum are simplified for testing purposes. In a real-world scenario, you would use the actual implementations. The `Preconditions` class from Guava is used to check the conditions, and we are mocking this behavior in the test environment."}
{"bug_id": "Closure_27", "version": "fixed", "focal_method_signature": "Node com.google.javascript.rhino.IR#propdef(Node#string,Node#value)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "focal_method": "public static Node propdef(Node string, Node value) {\n    Preconditions.checkState(string.isStringKey());\n    Preconditions.checkState(!string.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    string.addChildToFront(value);\n    return string;\n  }", "return_type": "Node", "assertion_subject_candidates": ["int com.google.javascript.rhino.Node#getType()", "boolean com.google.javascript.rhino.Node#hasChildren()", "Node com.google.javascript.rhino.Node#getFirstChild()", "Node com.google.javascript.rhino.Node#getLastChild()", "Node com.google.javascript.rhino.Node#getNext()", "String com.google.javascript.rhino.Node#toString()", "String com.google.javascript.rhino.Node#toStringTree()", "StaticSourceFile com.google.javascript.rhino.Node#getStaticSourceFile()", "InputId com.google.javascript.rhino.Node#getInputId()", "int com.google.javascript.rhino.Node#getLength()", "int com.google.javascript.rhino.Node#getLineno()", "int com.google.javascript.rhino.Node#getCharno()", "int com.google.javascript.rhino.Node#getSourcePosition()", "Iterable<Node> com.google.javascript.rhino.Node#siblings()", "Node com.google.javascript.rhino.Node#getParent()", "AncestorIterable com.google.javascript.rhino.Node#getAncestors()", "boolean com.google.javascript.rhino.Node#hasOneChild()", "boolean com.google.javascript.rhino.Node#hasMoreThanOneChild()", "JSType com.google.javascript.rhino.Node#getJSType()", "FileLevelJsDocBuilder com.google.javascript.rhino.Node#getJsDocBuilderForNode()", "JSDocInfo com.google.javascript.rhino.Node#getJSDocInfo()", "boolean com.google.javascript.rhino.Node#isVarArgs()", "boolean com.google.javascript.rhino.Node#isOptionalArg()", "boolean com.google.javascript.rhino.Node#isSyntheticBlock()", "Set<String> com.google.javascript.rhino.Node#getDirectives()", "boolean com.google.javascript.rhino.Node#wasEmptyNode()", "int com.google.javascript.rhino.Node#getSideEffectFlags()", "boolean com.google.javascript.rhino.Node#isOnlyModifiesThisCall()", "boolean com.google.javascript.rhino.Node#isNoSideEffectsCall()", "boolean com.google.javascript.rhino.Node#isLocalResultCall()", "boolean com.google.javascript.rhino.Node#isQuotedString()", "boolean com.google.javascript.rhino.Node#isAdd()", "boolean com.google.javascript.rhino.Node#isAnd()", "boolean com.google.javascript.rhino.Node#isArrayLit()", "boolean com.google.javascript.rhino.Node#isAssign()", "boolean com.google.javascript.rhino.Node#isAssignAdd()", "boolean com.google.javascript.rhino.Node#isBlock()", "boolean com.google.javascript.rhino.Node#isBreak()", "boolean com.google.javascript.rhino.Node#isCall()", "boolean com.google.javascript.rhino.Node#isCase()", "boolean com.google.javascript.rhino.Node#isCatch()", "boolean com.google.javascript.rhino.Node#isComma()", "boolean com.google.javascript.rhino.Node#isContinue()", "boolean com.google.javascript.rhino.Node#isDebugger()", "boolean com.google.javascript.rhino.Node#isDec()", "boolean com.google.javascript.rhino.Node#isDefaultCase()", "boolean com.google.javascript.rhino.Node#isDelProp()", "boolean com.google.javascript.rhino.Node#isDo()", "boolean com.google.javascript.rhino.Node#isEmpty()", "boolean com.google.javascript.rhino.Node#isExprResult()", "boolean com.google.javascript.rhino.Node#isFalse()", "boolean com.google.javascript.rhino.Node#isFor()", "boolean com.google.javascript.rhino.Node#isFunction()", "boolean com.google.javascript.rhino.Node#isGetterDef()", "boolean com.google.javascript.rhino.Node#isGetElem()", "boolean com.google.javascript.rhino.Node#isGetProp()", "boolean com.google.javascript.rhino.Node#isHook()", "boolean com.google.javascript.rhino.Node#isIf()", "boolean com.google.javascript.rhino.Node#isIn()", "boolean com.google.javascript.rhino.Node#isInc()", "boolean com.google.javascript.rhino.Node#isInstanceOf()", "boolean com.google.javascript.rhino.Node#isLabel()", "boolean com.google.javascript.rhino.Node#isLabelName()", "boolean com.google.javascript.rhino.Node#isName()", "boolean com.google.javascript.rhino.Node#isNE()", "boolean com.google.javascript.rhino.Node#isNew()", "boolean com.google.javascript.rhino.Node#isNot()", "boolean com.google.javascript.rhino.Node#isNull()", "boolean com.google.javascript.rhino.Node#isNumber()", "boolean com.google.javascript.rhino.Node#isObjectLit()", "boolean com.google.javascript.rhino.Node#isOr()", "boolean com.google.javascript.rhino.Node#isParamList()", "boolean com.google.javascript.rhino.Node#isRegExp()", "boolean com.google.javascript.rhino.Node#isReturn()", "boolean com.google.javascript.rhino.Node#isScript()", "boolean com.google.javascript.rhino.Node#isSetterDef()", "boolean com.google.javascript.rhino.Node#isString()", "boolean com.google.javascript.rhino.Node#isStringKey()", "boolean com.google.javascript.rhino.Node#isSwitch()", "boolean com.google.javascript.rhino.Node#isThis()", "boolean com.google.javascript.rhino.Node#isThrow()", "boolean com.google.javascript.rhino.Node#isTrue()", "boolean com.google.javascript.rhino.Node#isTry()", "boolean com.google.javascript.rhino.Node#isTypeOf()", "boolean com.google.javascript.rhino.Node#isVar()", "boolean com.google.javascript.rhino.Node#isVoid()", "boolean com.google.javascript.rhino.Node#isWhile()", "boolean com.google.javascript.rhino.Node#isWith()"], "focal_class": {"name": "IR", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import java.util.List;"], "fields": [], "methods": ["Node com.google.javascript.rhino.IR#empty()", "Node com.google.javascript.rhino.IR#function(Node#name,Node#params,Node#body)", "Node com.google.javascript.rhino.IR#paramList()", "Node com.google.javascript.rhino.IR#paramList(Node#param)", "Node com.google.javascript.rhino.IR#paramList(#Node ... params)", "Node com.google.javascript.rhino.IR#paramList(List<Node>#params)", "Node com.google.javascript.rhino.IR#block()", "Node com.google.javascript.rhino.IR#block(Node#stmt)", "Node com.google.javascript.rhino.IR#block(#Node ... stmts)", "Node com.google.javascript.rhino.IR#blockUnchecked(Node#stmt)", "Node com.google.javascript.rhino.IR#script(#Node ... stmts)", "Node com.google.javascript.rhino.IR#var(Node#name,Node#value)", "Node com.google.javascript.rhino.IR#var(Node#name)", "Node com.google.javascript.rhino.IR#returnNode()", "Node com.google.javascript.rhino.IR#returnNode(Node#expr)", "Node com.google.javascript.rhino.IR#throwNode(Node#expr)", "Node com.google.javascript.rhino.IR#exprResult(Node#expr)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then,Node#elseNode)", "Node com.google.javascript.rhino.IR#doNode(Node#body,Node#cond)", "Node com.google.javascript.rhino.IR#forIn(Node#target,Node#cond,Node#body)", "Node com.google.javascript.rhino.IR#forNode(Node#init,Node#cond,Node#incr,Node#body)", "Node com.google.javascript.rhino.IR#switchNode(Node#cond,#Node ... cases)", "Node com.google.javascript.rhino.IR#caseNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#defaultCase(Node#body)", "Node com.google.javascript.rhino.IR#label(Node#name,Node#stmt)", "Node com.google.javascript.rhino.IR#labelName(String#name)", "Node com.google.javascript.rhino.IR#tryFinally(Node#tryBody,Node#finallyBody)", "Node com.google.javascript.rhino.IR#tryCatch(Node#tryBody,Node#catchNode)", "Node com.google.javascript.rhino.IR#tryCatchFinally(Node#tryBody,Node#catchNode,Node#finallyBody)", "Node com.google.javascript.rhino.IR#catchNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#breakNode()", "Node com.google.javascript.rhino.IR#breakNode(Node#name)", "Node com.google.javascript.rhino.IR#continueNode()", "Node com.google.javascript.rhino.IR#continueNode(Node#name)", "Node com.google.javascript.rhino.IR#call(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#newNode(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#name(String#name)", "Node com.google.javascript.rhino.IR#getprop(Node#target,Node#prop)", "Node com.google.javascript.rhino.IR#getelem(Node#target,Node#elem)", "Node com.google.javascript.rhino.IR#assign(Node#target,Node#expr)", "Node com.google.javascript.rhino.IR#hook(Node#cond,Node#trueval,Node#falseval)", "Node com.google.javascript.rhino.IR#comma(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#and(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#or(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#not(Node#expr1)", "Node com.google.javascript.rhino.IR#eq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sheq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#voidNode(Node#expr1)", "Node com.google.javascript.rhino.IR#neg(Node#expr1)", "Node com.google.javascript.rhino.IR#pos(Node#expr1)", "Node com.google.javascript.rhino.IR#add(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sub(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#objectlit(#Node ... propdefs)", "Node com.google.javascript.rhino.IR#arraylit(#Node ... exprs)", "Node com.google.javascript.rhino.IR#regexp(Node#expr)", "Node com.google.javascript.rhino.IR#regexp(Node#expr,Node#flags)", "Node com.google.javascript.rhino.IR#string(String#s)", "Node com.google.javascript.rhino.IR#stringKey(String#s)", "Node com.google.javascript.rhino.IR#number(double#d)", "Node com.google.javascript.rhino.IR#thisNode()", "Node com.google.javascript.rhino.IR#trueNode()", "Node com.google.javascript.rhino.IR#falseNode()", "Node com.google.javascript.rhino.IR#nullNode()", "Node com.google.javascript.rhino.IR#binaryOp(int#token,Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#unaryOp(int#token,Node#expr)", "boolean com.google.javascript.rhino.IR#mayBeExpressionOrEmpty(Node#n)", "boolean com.google.javascript.rhino.IR#isAssignmentTarget(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeStatement(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeExpression(Node#n)"], "other_methods": ["public static Node empty();", "public static Node function(Node name,Node params,Node body);", "public static Node paramList();", "public static Node paramList(Node param);", "public static Node paramList( Node ... params);", "public static Node paramList(List<Node> params);", "public static Node block();", "public static Node block(Node stmt);", "public static Node block( Node ... stmts);", "public static Node script( Node ... stmts);", "public static Node var(Node name,Node value);", "public static Node var(Node name);", "public static Node returnNode();", "public static Node returnNode(Node expr);", "public static Node throwNode(Node expr);", "public static Node exprResult(Node expr);", "public static Node ifNode(Node cond,Node then);", "public static Node ifNode(Node cond,Node then,Node elseNode);", "public static Node doNode(Node body,Node cond);", "public static Node forIn(Node target,Node cond,Node body);", "public static Node forNode(Node init,Node cond,Node incr,Node body);", "public static Node switchNode(Node cond, Node ... cases);", "public static Node caseNode(Node expr,Node body);", "public static Node defaultCase(Node body);", "public static Node label(Node name,Node stmt);", "public static Node labelName(String name);", "public static Node tryFinally(Node tryBody,Node finallyBody);", "public static Node tryCatch(Node tryBody,Node catchNode);", "public static Node tryCatchFinally(Node tryBody,Node catchNode,Node finallyBody);", "public static Node catchNode(Node expr,Node body);", "public static Node breakNode();", "public static Node breakNode(Node name);", "public static Node continueNode();", "public static Node continueNode(Node name);", "public static Node call(Node target, Node ... args);", "public static Node newNode(Node target, Node ... args);", "public static Node name(String name);", "public static Node getprop(Node target,Node prop);", "public static Node getelem(Node target,Node elem);", "public static Node assign(Node target,Node expr);", "public static Node hook(Node cond,Node trueval,Node falseval);", "public static Node comma(Node expr1,Node expr2);", "public static Node and(Node expr1,Node expr2);", "public static Node or(Node expr1,Node expr2);", "public static Node not(Node expr1);", "public static Node eq(Node expr1,Node expr2);", "public static Node sheq(Node expr1,Node expr2);", "public static Node voidNode(Node expr1);", "public static Node neg(Node expr1);", "public static Node pos(Node expr1);", "public static Node add(Node expr1,Node expr2);", "public static Node sub(Node expr1,Node expr2);", "public static Node objectlit( Node ... propdefs);", "public static Node arraylit( Node ... exprs);", "public static Node regexp(Node expr);", "public static Node regexp(Node expr,Node flags);", "public static Node string(String s);", "public static Node stringKey(String s);", "public static Node number(double d);", "public static Node thisNode();", "public static Node trueNode();", "public static Node falseNode();", "public static Node nullNode();"], "fields_dict": {}, "text": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   John Lenz\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.List;\n\n/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n\n  private IR() {}\n\n  public static Node empty() {\n    return new Node(Token.EMPTY);\n  }\n\n  public static Node function(Node name, Node params, Node body) {\n    Preconditions.checkState(name.isName());\n    Preconditions.checkState(params.isParamList());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FUNCTION, name, params, body);\n  }\n\n  public static Node paramList() {\n    return new Node(Token.PARAM_LIST);\n  }\n\n  public static Node paramList(Node param) {\n    Preconditions.checkState(param.isName());\n    return new Node(Token.PARAM_LIST, param);\n  }\n\n  public static Node paramList(Node ... params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node paramList(List<Node> params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n\n  public static Node block(Node stmt) {\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.BLOCK, stmt);\n    return block;\n  }\n\n  public static Node block(Node ... stmts) {\n    Node block = new Node(Token.BLOCK);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n\n  public static Node script(Node ... stmts) {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  public static Node var(Node name, Node value) {\n    Preconditions.checkState(name.isName() && !name.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    name.addChildToFront(value);\n    return var(name);\n  }\n\n  public static Node var(Node name) {\n    Preconditions.checkState(name.isName());\n    return new Node(Token.VAR, name);\n  }\n\n  public static Node returnNode() {\n    return new Node(Token.RETURN);\n  }\n\n  public static Node returnNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.RETURN, expr);\n  }\n\n  public static Node throwNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.THROW, expr);\n  }\n\n  public static Node exprResult(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.EXPR_RESULT, expr);\n  }\n\n  public static Node ifNode(Node cond, Node then) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    return new Node(Token.IF, cond, then);\n  }\n\n  public static Node ifNode(Node cond, Node then, Node elseNode) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    Preconditions.checkState(elseNode.isBlock());\n    return new Node(Token.IF, cond, then, elseNode);\n  }\n\n  public static Node doNode(Node body, Node cond) {\n    Preconditions.checkState(body.isBlock());\n    Preconditions.checkState(mayBeExpression(cond));\n    return new Node(Token.DO, body, cond);\n  }\n\n  public static Node forIn(Node target, Node cond, Node body) {\n    Preconditions.checkState(target.isVar() || mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, target, cond, body);\n  }\n\n  public static Node forNode(Node init, Node cond, Node incr, Node body) {\n    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, init, cond, incr, body);\n  }\n\n  public static Node switchNode(Node cond, Node ... cases) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Node switchNode = new Node(Token.SWITCH, cond);\n    for (Node caseNode : cases) {\n      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n      switchNode.addChildToBack(caseNode);\n    }\n    return switchNode;\n  }\n\n  public static Node caseNode(Node expr, Node body) {\n    Preconditions.checkState(mayBeExpression(expr));\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.CASE, expr, body);\n  }\n\n  public static Node defaultCase(Node body) {\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.DEFAULT_CASE, body);\n  }\n\n  public static Node label(Node name, Node stmt) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.LABEL, name, stmt);\n    return block;\n  }\n\n  public static Node labelName(String name) {\n    Preconditions.checkState(!name.isEmpty());\n    return Node.newString(Token.LABEL_NAME, name);\n  }\n\n  public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n  }\n\n  public static Node tryCatch(Node tryBody, Node catchNode) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n    return new Node(Token.TRY, tryBody, catchBody);\n  }\n\n  public static Node tryCatchFinally(\n      Node tryBody, Node catchNode, Node finallyBody) {\n    Preconditions.checkState(finallyBody.isBlock());\n    Node tryNode = tryCatch(tryBody, catchNode);\n    tryNode.addChildToBack(finallyBody);\n    return tryNode;\n  }\n\n  public static Node catchNode(Node expr, Node body) {\n    Preconditions.checkState(expr.isName());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.CATCH, expr, body);\n  }\n\n  public static Node breakNode() {\n    return new Node(Token.BREAK);\n  }\n\n  public static Node breakNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.BREAK, name);\n  }\n\n  public static Node continueNode() {\n    return new Node(Token.CONTINUE);\n  }\n\n  public static Node continueNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.CONTINUE, name);\n  }\n\n\n  //\n\n  public static Node call(Node target, Node ... args) {\n    Node call = new Node(Token.CALL, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      call.addChildToBack(arg);\n    }\n    return call;\n  }\n\n  public static Node newNode(Node target, Node ... args) {\n    Node newcall = new Node(Token.NEW, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      newcall.addChildToBack(arg);\n    }\n    return newcall;\n  }\n\n  public static Node name(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n\n  public static Node getprop(Node target, Node prop) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(prop.isString());\n    return new Node(Token.GETPROP, target, prop);\n  }\n\n  public static Node getelem(Node target, Node elem) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(elem));\n    return new Node(Token.GETELEM, target, elem);\n  }\n\n  public static Node assign(Node target, Node expr) {\n    Preconditions.checkState(isAssignmentTarget(target));\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.ASSIGN, target, expr);\n  }\n\n  public static Node hook(Node cond, Node trueval, Node falseval) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(mayBeExpression(trueval));\n    Preconditions.checkState(mayBeExpression(falseval));\n    return new Node(Token.HOOK, cond, trueval, falseval);\n  }\n\n  public static Node comma(Node expr1, Node expr2) {\n    return binaryOp(Token.COMMA, expr1, expr2);\n  }\n\n  public static Node and(Node expr1, Node expr2) {\n    return binaryOp(Token.AND, expr1, expr2);\n  }\n\n  public static Node or(Node expr1, Node expr2) {\n    return binaryOp(Token.OR, expr1, expr2);\n  }\n\n  public static Node not(Node expr1) {\n    return unaryOp(Token.NOT, expr1);\n  }\n\n  /**\n   * \"==\"\n   */\n  public static Node eq(Node expr1, Node expr2) {\n    return binaryOp(Token.EQ, expr1, expr2);\n  }\n\n  /**\n   * \"===\"\n   */\n  public static Node sheq(Node expr1, Node expr2) {\n    return binaryOp(Token.SHEQ, expr1, expr2);\n  }\n\n  public static Node voidNode(Node expr1) {\n    return unaryOp(Token.VOID, expr1);\n  }\n\n  public static Node neg(Node expr1) {\n    return unaryOp(Token.NEG, expr1);\n  }\n\n  public static Node pos(Node expr1) {\n    return unaryOp(Token.POS, expr1);\n  }\n\n  public static Node add(Node expr1, Node expr2) {\n    return binaryOp(Token.ADD, expr1, expr2);\n  }\n\n  public static Node sub(Node expr1, Node expr2) {\n    return binaryOp(Token.SUB, expr1, expr2);\n  }\n\n  // TODO(johnlenz): the rest of the ops\n\n  // literals\n  public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }\n\n  // TODO(johnlenz): quoted props\n\n  public static Node propdef(Node string, Node value) {\n    Preconditions.checkState(string.isStringKey());\n    Preconditions.checkState(!string.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    string.addChildToFront(value);\n    return string;\n  }\n\n  public static Node arraylit(Node ... exprs) {\n    Node arraylit = new Node(Token.ARRAYLIT);\n    for (Node expr : exprs) {\n      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n      arraylit.addChildToBack(expr);\n    }\n    return arraylit;\n  }\n\n  public static Node regexp(Node expr) {\n    Preconditions.checkState(expr.isString());\n    return new Node(Token.REGEXP, expr);\n  }\n\n  public static Node regexp(Node expr, Node flags) {\n    Preconditions.checkState(expr.isString());\n    Preconditions.checkState(flags.isString());\n    return new Node(Token.REGEXP, expr, flags);\n  }\n\n  public static Node string(String s) {\n    return Node.newString(s);\n  }\n\n  public static Node stringKey(String s) {\n    return Node.newString(Token.STRING_KEY, s);\n  }\n\n  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n\n  public static Node thisNode() {\n    return new Node(Token.THIS);\n  }\n\n  public static Node trueNode() {\n    return new Node(Token.TRUE);\n  }\n\n  public static Node falseNode() {\n    return new Node(Token.FALSE);\n  }\n\n  public static Node nullNode() {\n    return new Node(Token.NULL);\n  }\n\n  // helper methods\n\n  private static Node binaryOp(int token, Node expr1, Node expr2) {\n    Preconditions.checkState(mayBeExpression(expr1));\n    Preconditions.checkState(mayBeExpression(expr2));\n    return new Node(token, expr1, expr2);\n  }\n\n  private static Node unaryOp(int token, Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(token, expr);\n  }\n\n  private static boolean mayBeExpressionOrEmpty(Node n) {\n    return n.isEmpty() || mayBeExpression(n);\n  }\n\n  private static boolean isAssignmentTarget(Node n) {\n    return n.isName() || n.isGetProp() || n.isGetElem();\n  }\n\n  // NOTE: some nodes are neither statements nor expression nodes:\n  //   SCRIPT, LABEL_NAME, PARAM_LIST, CASE, DEFAULT_CASE, CATCH\n  //   GETTER_DEF, SETTER_DEF\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeStatement(Node n) {\n    switch (n.getType()) {\n      case Token.EMPTY:\n      case Token.FUNCTION:\n        // EMPTY and FUNCTION are used both in expression and statement\n        // contexts\n        return true;\n\n      case Token.BLOCK:\n      case Token.BREAK:\n      case Token.CONST:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.DO:\n      case Token.EXPR_RESULT:\n      case Token.FOR:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.RETURN:\n      case Token.SWITCH:\n      case Token.THROW:\n      case Token.TRY:\n      case Token.VAR:\n      case Token.WHILE:\n      case Token.WITH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeExpression(Node n) {\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // FUNCTION is used both in expression and statement\n        // contexts.\n        return true;\n\n      case Token.ADD:\n      case Token.AND:\n      case Token.ARRAYLIT:\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITNOT:\n      case Token.BITXOR:\n      case Token.CALL:\n      case Token.COMMA:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FALSE:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.IN:\n      case Token.INC:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TYPEOF:\n      case Token.TRUE:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n"}, "generated_test_class": "Sure! Below are some unit tests for the `propdef` method in the `IR` class using Java 1.7 and JUnit 4. These tests aim to maximize both branch and line coverage.\n\nFirst, ensure you have the necessary JUnit dependency in your `pom.xml` if you're using Maven:\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\nNow, here are the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\npublic class IRTest {\n\n    private IR ir;\n\n    @Before\n    public void setUp() {\n        ir = new IR();\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testPropdef_stringNotStringKey() {\n        Node nonStringKeyNode = mock(Node.class);\n        when(nonStringKeyNode.isStringKey()).thenReturn(false);\n\n        ir.propdef(nonStringKeyNode, mock(Node.class));\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testPropdef_stringHasChildren() {\n        Node stringKeyNode = mock(Node.class);\n        when(stringKeyNode.isStringKey()).thenReturn(true);\n        when(stringKeyNode.hasChildren()).thenReturn(true);\n\n        ir.propdef(stringKeyNode, mock(Node.class));\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testPropdef_valueNotExpression() {\n        Node stringKeyNode = mock(Node.class);\n        when(stringKeyNode.isStringKey()).thenReturn(true);\n        when(stringKeyNode.hasChildren()).thenReturn(false);\n\n        Node nonExpressionValue = mock(Node.class);\n        when(IR.mayBeExpression(nonExpressionValue)).thenReturn(false);\n\n        ir.propdef(stringKeyNode, nonExpressionValue);\n    }\n\n    @Test\n    public void testPropdef_validInputs() {\n        Node stringKeyNode = mock(Node.class);\n        when(stringKeyNode.isStringKey()).thenReturn(true);\n        when(stringKeyNode.hasChildren()).thenReturn(false);\n\n        Node validValueNode = mock(Node.class);\n        when(IR.mayBeExpression(validValueNode)).thenReturn(true);\n\n        Node result = ir.propdef(stringKeyNode, validValueNode);\n\n        verify(stringKeyNode).addChildToFront(validValueNode);\n        assertSame(stringKeyNode, result);\n    }\n\n    // Mock implementation of mayBeExpression\n    static class IR extends IRBase {\n        public static boolean mayBeExpression(Node expr) {\n            return expr != null; // Simplified mock implementation\n        }\n    }\n\n    // Mock Node class\n    static class Node {\n        private boolean isStringKeyFlag = false;\n        private boolean hasChildrenFlag = false;\n\n        public boolean isStringKey() {\n            return isStringKeyFlag;\n        }\n\n        public boolean hasChildren() {\n            return hasChildrenFlag;\n        }\n\n        public void addChildToFront(Node child) {\n            // Mock implementation\n        }\n    }\n\n    // IRBase class to allow mocking of static methods\n    static class IRBase extends IR {\n        public static boolean mayBeExpression(Node expr) {\n            return super.mayBeExpression(expr);\n        }\n    }\n}\n```\n\n### Explanation:\n\n1. **Test `propdef` with a non-string key node**:\n   - This test ensures that an `IllegalStateException` is thrown when the first argument is not a string key.\n\n2. **Test `propdef` with a string key node that has children**:\n   - This test ensures that an `IllegalStateException` is thrown when the first argument is a string key but has children.\n\n3. **Test `propdef` with a valid string key and an invalid value**:\n   - This test ensures that an `IllegalStateException` is thrown when the second argument is not an expression.\n\n4. **Test `propdef` with valid inputs**:\n   - This test ensures that the method correctly adds the value node to the string key node and returns the string key node.\n\n5. **Mock implementation of `mayBeExpression`**:\n   - This provides a mock implementation of the static method `mayBeExpression` to control its behavior in tests.\n\n6. **Mock `Node` class**:\n   - This provides a mock implementation of the `Node` class to control its behavior in tests.\n\n7. **IRBase class**:\n   - This class is used to allow mocking of the static `mayBeExpression` method.\n\nThese tests should cover the necessary branches and lines in the `propdef` method."}
{"bug_id": "Closure_27", "version": "fixed", "focal_method_signature": "Node com.google.javascript.rhino.IR#arraylit(#Node ... exprs)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "focal_method": "public static Node arraylit(Node ... exprs) {\n    Node arraylit = new Node(Token.ARRAYLIT);\n    for (Node expr : exprs) {\n      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n      arraylit.addChildToBack(expr);\n    }\n    return arraylit;\n  }", "return_type": "Node", "assertion_subject_candidates": ["int com.google.javascript.rhino.Node#getType()", "boolean com.google.javascript.rhino.Node#hasChildren()", "Node com.google.javascript.rhino.Node#getFirstChild()", "Node com.google.javascript.rhino.Node#getLastChild()", "Node com.google.javascript.rhino.Node#getNext()", "String com.google.javascript.rhino.Node#toString()", "String com.google.javascript.rhino.Node#toStringTree()", "StaticSourceFile com.google.javascript.rhino.Node#getStaticSourceFile()", "InputId com.google.javascript.rhino.Node#getInputId()", "int com.google.javascript.rhino.Node#getLength()", "int com.google.javascript.rhino.Node#getLineno()", "int com.google.javascript.rhino.Node#getCharno()", "int com.google.javascript.rhino.Node#getSourcePosition()", "Iterable<Node> com.google.javascript.rhino.Node#siblings()", "Node com.google.javascript.rhino.Node#getParent()", "AncestorIterable com.google.javascript.rhino.Node#getAncestors()", "boolean com.google.javascript.rhino.Node#hasOneChild()", "boolean com.google.javascript.rhino.Node#hasMoreThanOneChild()", "JSType com.google.javascript.rhino.Node#getJSType()", "FileLevelJsDocBuilder com.google.javascript.rhino.Node#getJsDocBuilderForNode()", "JSDocInfo com.google.javascript.rhino.Node#getJSDocInfo()", "boolean com.google.javascript.rhino.Node#isVarArgs()", "boolean com.google.javascript.rhino.Node#isOptionalArg()", "boolean com.google.javascript.rhino.Node#isSyntheticBlock()", "Set<String> com.google.javascript.rhino.Node#getDirectives()", "boolean com.google.javascript.rhino.Node#wasEmptyNode()", "int com.google.javascript.rhino.Node#getSideEffectFlags()", "boolean com.google.javascript.rhino.Node#isOnlyModifiesThisCall()", "boolean com.google.javascript.rhino.Node#isNoSideEffectsCall()", "boolean com.google.javascript.rhino.Node#isLocalResultCall()", "boolean com.google.javascript.rhino.Node#isQuotedString()", "boolean com.google.javascript.rhino.Node#isAdd()", "boolean com.google.javascript.rhino.Node#isAnd()", "boolean com.google.javascript.rhino.Node#isArrayLit()", "boolean com.google.javascript.rhino.Node#isAssign()", "boolean com.google.javascript.rhino.Node#isAssignAdd()", "boolean com.google.javascript.rhino.Node#isBlock()", "boolean com.google.javascript.rhino.Node#isBreak()", "boolean com.google.javascript.rhino.Node#isCall()", "boolean com.google.javascript.rhino.Node#isCase()", "boolean com.google.javascript.rhino.Node#isCatch()", "boolean com.google.javascript.rhino.Node#isComma()", "boolean com.google.javascript.rhino.Node#isContinue()", "boolean com.google.javascript.rhino.Node#isDebugger()", "boolean com.google.javascript.rhino.Node#isDec()", "boolean com.google.javascript.rhino.Node#isDefaultCase()", "boolean com.google.javascript.rhino.Node#isDelProp()", "boolean com.google.javascript.rhino.Node#isDo()", "boolean com.google.javascript.rhino.Node#isEmpty()", "boolean com.google.javascript.rhino.Node#isExprResult()", "boolean com.google.javascript.rhino.Node#isFalse()", "boolean com.google.javascript.rhino.Node#isFor()", "boolean com.google.javascript.rhino.Node#isFunction()", "boolean com.google.javascript.rhino.Node#isGetterDef()", "boolean com.google.javascript.rhino.Node#isGetElem()", "boolean com.google.javascript.rhino.Node#isGetProp()", "boolean com.google.javascript.rhino.Node#isHook()", "boolean com.google.javascript.rhino.Node#isIf()", "boolean com.google.javascript.rhino.Node#isIn()", "boolean com.google.javascript.rhino.Node#isInc()", "boolean com.google.javascript.rhino.Node#isInstanceOf()", "boolean com.google.javascript.rhino.Node#isLabel()", "boolean com.google.javascript.rhino.Node#isLabelName()", "boolean com.google.javascript.rhino.Node#isName()", "boolean com.google.javascript.rhino.Node#isNE()", "boolean com.google.javascript.rhino.Node#isNew()", "boolean com.google.javascript.rhino.Node#isNot()", "boolean com.google.javascript.rhino.Node#isNull()", "boolean com.google.javascript.rhino.Node#isNumber()", "boolean com.google.javascript.rhino.Node#isObjectLit()", "boolean com.google.javascript.rhino.Node#isOr()", "boolean com.google.javascript.rhino.Node#isParamList()", "boolean com.google.javascript.rhino.Node#isRegExp()", "boolean com.google.javascript.rhino.Node#isReturn()", "boolean com.google.javascript.rhino.Node#isScript()", "boolean com.google.javascript.rhino.Node#isSetterDef()", "boolean com.google.javascript.rhino.Node#isString()", "boolean com.google.javascript.rhino.Node#isStringKey()", "boolean com.google.javascript.rhino.Node#isSwitch()", "boolean com.google.javascript.rhino.Node#isThis()", "boolean com.google.javascript.rhino.Node#isThrow()", "boolean com.google.javascript.rhino.Node#isTrue()", "boolean com.google.javascript.rhino.Node#isTry()", "boolean com.google.javascript.rhino.Node#isTypeOf()", "boolean com.google.javascript.rhino.Node#isVar()", "boolean com.google.javascript.rhino.Node#isVoid()", "boolean com.google.javascript.rhino.Node#isWhile()", "boolean com.google.javascript.rhino.Node#isWith()"], "focal_class": {"name": "IR", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_27/fixed/src/com/google/javascript/rhino/IR.java", "superclass": "", "interface": "", "imports": ["import com.google.common.base.Preconditions;", "import java.util.List;"], "fields": [], "methods": ["Node com.google.javascript.rhino.IR#empty()", "Node com.google.javascript.rhino.IR#function(Node#name,Node#params,Node#body)", "Node com.google.javascript.rhino.IR#paramList()", "Node com.google.javascript.rhino.IR#paramList(Node#param)", "Node com.google.javascript.rhino.IR#paramList(#Node ... params)", "Node com.google.javascript.rhino.IR#paramList(List<Node>#params)", "Node com.google.javascript.rhino.IR#block()", "Node com.google.javascript.rhino.IR#block(Node#stmt)", "Node com.google.javascript.rhino.IR#block(#Node ... stmts)", "Node com.google.javascript.rhino.IR#blockUnchecked(Node#stmt)", "Node com.google.javascript.rhino.IR#script(#Node ... stmts)", "Node com.google.javascript.rhino.IR#var(Node#name,Node#value)", "Node com.google.javascript.rhino.IR#var(Node#name)", "Node com.google.javascript.rhino.IR#returnNode()", "Node com.google.javascript.rhino.IR#returnNode(Node#expr)", "Node com.google.javascript.rhino.IR#throwNode(Node#expr)", "Node com.google.javascript.rhino.IR#exprResult(Node#expr)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then)", "Node com.google.javascript.rhino.IR#ifNode(Node#cond,Node#then,Node#elseNode)", "Node com.google.javascript.rhino.IR#doNode(Node#body,Node#cond)", "Node com.google.javascript.rhino.IR#forIn(Node#target,Node#cond,Node#body)", "Node com.google.javascript.rhino.IR#forNode(Node#init,Node#cond,Node#incr,Node#body)", "Node com.google.javascript.rhino.IR#switchNode(Node#cond,#Node ... cases)", "Node com.google.javascript.rhino.IR#caseNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#defaultCase(Node#body)", "Node com.google.javascript.rhino.IR#label(Node#name,Node#stmt)", "Node com.google.javascript.rhino.IR#labelName(String#name)", "Node com.google.javascript.rhino.IR#tryFinally(Node#tryBody,Node#finallyBody)", "Node com.google.javascript.rhino.IR#tryCatch(Node#tryBody,Node#catchNode)", "Node com.google.javascript.rhino.IR#tryCatchFinally(Node#tryBody,Node#catchNode,Node#finallyBody)", "Node com.google.javascript.rhino.IR#catchNode(Node#expr,Node#body)", "Node com.google.javascript.rhino.IR#breakNode()", "Node com.google.javascript.rhino.IR#breakNode(Node#name)", "Node com.google.javascript.rhino.IR#continueNode()", "Node com.google.javascript.rhino.IR#continueNode(Node#name)", "Node com.google.javascript.rhino.IR#call(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#newNode(Node#target,#Node ... args)", "Node com.google.javascript.rhino.IR#name(String#name)", "Node com.google.javascript.rhino.IR#getprop(Node#target,Node#prop)", "Node com.google.javascript.rhino.IR#getelem(Node#target,Node#elem)", "Node com.google.javascript.rhino.IR#assign(Node#target,Node#expr)", "Node com.google.javascript.rhino.IR#hook(Node#cond,Node#trueval,Node#falseval)", "Node com.google.javascript.rhino.IR#comma(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#and(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#or(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#not(Node#expr1)", "Node com.google.javascript.rhino.IR#eq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sheq(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#voidNode(Node#expr1)", "Node com.google.javascript.rhino.IR#neg(Node#expr1)", "Node com.google.javascript.rhino.IR#pos(Node#expr1)", "Node com.google.javascript.rhino.IR#add(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#sub(Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#objectlit(#Node ... propdefs)", "Node com.google.javascript.rhino.IR#propdef(Node#string,Node#value)", "Node com.google.javascript.rhino.IR#regexp(Node#expr)", "Node com.google.javascript.rhino.IR#regexp(Node#expr,Node#flags)", "Node com.google.javascript.rhino.IR#string(String#s)", "Node com.google.javascript.rhino.IR#stringKey(String#s)", "Node com.google.javascript.rhino.IR#number(double#d)", "Node com.google.javascript.rhino.IR#thisNode()", "Node com.google.javascript.rhino.IR#trueNode()", "Node com.google.javascript.rhino.IR#falseNode()", "Node com.google.javascript.rhino.IR#nullNode()", "Node com.google.javascript.rhino.IR#binaryOp(int#token,Node#expr1,Node#expr2)", "Node com.google.javascript.rhino.IR#unaryOp(int#token,Node#expr)", "boolean com.google.javascript.rhino.IR#mayBeExpressionOrEmpty(Node#n)", "boolean com.google.javascript.rhino.IR#isAssignmentTarget(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeStatement(Node#n)", "boolean com.google.javascript.rhino.IR#mayBeExpression(Node#n)"], "other_methods": ["public static Node empty();", "public static Node function(Node name,Node params,Node body);", "public static Node paramList();", "public static Node paramList(Node param);", "public static Node paramList( Node ... params);", "public static Node paramList(List<Node> params);", "public static Node block();", "public static Node block(Node stmt);", "public static Node block( Node ... stmts);", "public static Node script( Node ... stmts);", "public static Node var(Node name,Node value);", "public static Node var(Node name);", "public static Node returnNode();", "public static Node returnNode(Node expr);", "public static Node throwNode(Node expr);", "public static Node exprResult(Node expr);", "public static Node ifNode(Node cond,Node then);", "public static Node ifNode(Node cond,Node then,Node elseNode);", "public static Node doNode(Node body,Node cond);", "public static Node forIn(Node target,Node cond,Node body);", "public static Node forNode(Node init,Node cond,Node incr,Node body);", "public static Node switchNode(Node cond, Node ... cases);", "public static Node caseNode(Node expr,Node body);", "public static Node defaultCase(Node body);", "public static Node label(Node name,Node stmt);", "public static Node labelName(String name);", "public static Node tryFinally(Node tryBody,Node finallyBody);", "public static Node tryCatch(Node tryBody,Node catchNode);", "public static Node tryCatchFinally(Node tryBody,Node catchNode,Node finallyBody);", "public static Node catchNode(Node expr,Node body);", "public static Node breakNode();", "public static Node breakNode(Node name);", "public static Node continueNode();", "public static Node continueNode(Node name);", "public static Node call(Node target, Node ... args);", "public static Node newNode(Node target, Node ... args);", "public static Node name(String name);", "public static Node getprop(Node target,Node prop);", "public static Node getelem(Node target,Node elem);", "public static Node assign(Node target,Node expr);", "public static Node hook(Node cond,Node trueval,Node falseval);", "public static Node comma(Node expr1,Node expr2);", "public static Node and(Node expr1,Node expr2);", "public static Node or(Node expr1,Node expr2);", "public static Node not(Node expr1);", "public static Node eq(Node expr1,Node expr2);", "public static Node sheq(Node expr1,Node expr2);", "public static Node voidNode(Node expr1);", "public static Node neg(Node expr1);", "public static Node pos(Node expr1);", "public static Node add(Node expr1,Node expr2);", "public static Node sub(Node expr1,Node expr2);", "public static Node objectlit( Node ... propdefs);", "public static Node propdef(Node string,Node value);", "public static Node regexp(Node expr);", "public static Node regexp(Node expr,Node flags);", "public static Node string(String s);", "public static Node stringKey(String s);", "public static Node number(double d);", "public static Node thisNode();", "public static Node trueNode();", "public static Node falseNode();", "public static Node nullNode();"], "fields_dict": {}, "text": "/*\n *\n * ***** BEGIN LICENSE BLOCK *****\n * Version: MPL 1.1/GPL 2.0\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   John Lenz\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\nimport com.google.common.base.Preconditions;\n\nimport java.util.List;\n\n/**\n * An AST construction helper class\n * @author johnlenz@google.com (John Lenz)\n */\npublic class IR {\n\n  private IR() {}\n\n  public static Node empty() {\n    return new Node(Token.EMPTY);\n  }\n\n  public static Node function(Node name, Node params, Node body) {\n    Preconditions.checkState(name.isName());\n    Preconditions.checkState(params.isParamList());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FUNCTION, name, params, body);\n  }\n\n  public static Node paramList() {\n    return new Node(Token.PARAM_LIST);\n  }\n\n  public static Node paramList(Node param) {\n    Preconditions.checkState(param.isName());\n    return new Node(Token.PARAM_LIST, param);\n  }\n\n  public static Node paramList(Node ... params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node paramList(List<Node> params) {\n    Node paramList = paramList();\n    for (Node param : params) {\n      Preconditions.checkState(param.isName());\n      paramList.addChildToBack(param);\n    }\n    return paramList;\n  }\n\n  public static Node block() {\n    Node block = new Node(Token.BLOCK);\n    return block;\n  }\n\n  public static Node block(Node stmt) {\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.BLOCK, stmt);\n    return block;\n  }\n\n  public static Node block(Node ... stmts) {\n    Node block = new Node(Token.BLOCK);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  private static Node blockUnchecked(Node stmt) {\n    return new Node(Token.BLOCK, stmt);\n  }\n\n  public static Node script(Node ... stmts) {\n    // TODO(johnlenz): finish setting up the SCRIPT node\n    Node block = new Node(Token.SCRIPT);\n    for (Node stmt : stmts) {\n      Preconditions.checkState(mayBeStatement(stmt));\n      block.addChildToBack(stmt);\n    }\n    return block;\n  }\n\n  public static Node var(Node name, Node value) {\n    Preconditions.checkState(name.isName() && !name.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    name.addChildToFront(value);\n    return var(name);\n  }\n\n  public static Node var(Node name) {\n    Preconditions.checkState(name.isName());\n    return new Node(Token.VAR, name);\n  }\n\n  public static Node returnNode() {\n    return new Node(Token.RETURN);\n  }\n\n  public static Node returnNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.RETURN, expr);\n  }\n\n  public static Node throwNode(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.THROW, expr);\n  }\n\n  public static Node exprResult(Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.EXPR_RESULT, expr);\n  }\n\n  public static Node ifNode(Node cond, Node then) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    return new Node(Token.IF, cond, then);\n  }\n\n  public static Node ifNode(Node cond, Node then, Node elseNode) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(then.isBlock());\n    Preconditions.checkState(elseNode.isBlock());\n    return new Node(Token.IF, cond, then, elseNode);\n  }\n\n  public static Node doNode(Node body, Node cond) {\n    Preconditions.checkState(body.isBlock());\n    Preconditions.checkState(mayBeExpression(cond));\n    return new Node(Token.DO, body, cond);\n  }\n\n  public static Node forIn(Node target, Node cond, Node body) {\n    Preconditions.checkState(target.isVar() || mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, target, cond, body);\n  }\n\n  public static Node forNode(Node init, Node cond, Node incr, Node body) {\n    Preconditions.checkState(init.isVar() || mayBeExpressionOrEmpty(init));\n    Preconditions.checkState(mayBeExpressionOrEmpty(cond));\n    Preconditions.checkState(mayBeExpressionOrEmpty(incr));\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.FOR, init, cond, incr, body);\n  }\n\n  public static Node switchNode(Node cond, Node ... cases) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Node switchNode = new Node(Token.SWITCH, cond);\n    for (Node caseNode : cases) {\n      Preconditions.checkState(caseNode.isCase() || caseNode.isDefaultCase());\n      switchNode.addChildToBack(caseNode);\n    }\n    return switchNode;\n  }\n\n  public static Node caseNode(Node expr, Node body) {\n    Preconditions.checkState(mayBeExpression(expr));\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.CASE, expr, body);\n  }\n\n  public static Node defaultCase(Node body) {\n    Preconditions.checkState(body.isBlock());\n    body.putBooleanProp(Node.SYNTHETIC_BLOCK_PROP, true);\n    return new Node(Token.DEFAULT_CASE, body);\n  }\n\n  public static Node label(Node name, Node stmt) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    Preconditions.checkState(mayBeStatement(stmt));\n    Node block = new Node(Token.LABEL, name, stmt);\n    return block;\n  }\n\n  public static Node labelName(String name) {\n    Preconditions.checkState(!name.isEmpty());\n    return Node.newString(Token.LABEL_NAME, name);\n  }\n\n  public static Node tryFinally(Node tryBody, Node finallyBody) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(finallyBody.isBlock());\n    Node catchBody = block().copyInformationFrom(tryBody);\n    return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n  }\n\n  public static Node tryCatch(Node tryBody, Node catchNode) {\n    Preconditions.checkState(tryBody.isBlock());\n    Preconditions.checkState(catchNode.isCatch());\n    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n    return new Node(Token.TRY, tryBody, catchBody);\n  }\n\n  public static Node tryCatchFinally(\n      Node tryBody, Node catchNode, Node finallyBody) {\n    Preconditions.checkState(finallyBody.isBlock());\n    Node tryNode = tryCatch(tryBody, catchNode);\n    tryNode.addChildToBack(finallyBody);\n    return tryNode;\n  }\n\n  public static Node catchNode(Node expr, Node body) {\n    Preconditions.checkState(expr.isName());\n    Preconditions.checkState(body.isBlock());\n    return new Node(Token.CATCH, expr, body);\n  }\n\n  public static Node breakNode() {\n    return new Node(Token.BREAK);\n  }\n\n  public static Node breakNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.BREAK, name);\n  }\n\n  public static Node continueNode() {\n    return new Node(Token.CONTINUE);\n  }\n\n  public static Node continueNode(Node name) {\n    // TODO(johnlenz): additional validation here.\n    Preconditions.checkState(name.isLabelName());\n    return new Node(Token.CONTINUE, name);\n  }\n\n\n  //\n\n  public static Node call(Node target, Node ... args) {\n    Node call = new Node(Token.CALL, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      call.addChildToBack(arg);\n    }\n    return call;\n  }\n\n  public static Node newNode(Node target, Node ... args) {\n    Node newcall = new Node(Token.NEW, target);\n    for (Node arg : args) {\n      Preconditions.checkState(mayBeExpression(arg));\n      newcall.addChildToBack(arg);\n    }\n    return newcall;\n  }\n\n  public static Node name(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n\n  public static Node getprop(Node target, Node prop) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(prop.isString());\n    return new Node(Token.GETPROP, target, prop);\n  }\n\n  public static Node getelem(Node target, Node elem) {\n    Preconditions.checkState(mayBeExpression(target));\n    Preconditions.checkState(mayBeExpression(elem));\n    return new Node(Token.GETELEM, target, elem);\n  }\n\n  public static Node assign(Node target, Node expr) {\n    Preconditions.checkState(isAssignmentTarget(target));\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(Token.ASSIGN, target, expr);\n  }\n\n  public static Node hook(Node cond, Node trueval, Node falseval) {\n    Preconditions.checkState(mayBeExpression(cond));\n    Preconditions.checkState(mayBeExpression(trueval));\n    Preconditions.checkState(mayBeExpression(falseval));\n    return new Node(Token.HOOK, cond, trueval, falseval);\n  }\n\n  public static Node comma(Node expr1, Node expr2) {\n    return binaryOp(Token.COMMA, expr1, expr2);\n  }\n\n  public static Node and(Node expr1, Node expr2) {\n    return binaryOp(Token.AND, expr1, expr2);\n  }\n\n  public static Node or(Node expr1, Node expr2) {\n    return binaryOp(Token.OR, expr1, expr2);\n  }\n\n  public static Node not(Node expr1) {\n    return unaryOp(Token.NOT, expr1);\n  }\n\n  /**\n   * \"==\"\n   */\n  public static Node eq(Node expr1, Node expr2) {\n    return binaryOp(Token.EQ, expr1, expr2);\n  }\n\n  /**\n   * \"===\"\n   */\n  public static Node sheq(Node expr1, Node expr2) {\n    return binaryOp(Token.SHEQ, expr1, expr2);\n  }\n\n  public static Node voidNode(Node expr1) {\n    return unaryOp(Token.VOID, expr1);\n  }\n\n  public static Node neg(Node expr1) {\n    return unaryOp(Token.NEG, expr1);\n  }\n\n  public static Node pos(Node expr1) {\n    return unaryOp(Token.POS, expr1);\n  }\n\n  public static Node add(Node expr1, Node expr2) {\n    return binaryOp(Token.ADD, expr1, expr2);\n  }\n\n  public static Node sub(Node expr1, Node expr2) {\n    return binaryOp(Token.SUB, expr1, expr2);\n  }\n\n  // TODO(johnlenz): the rest of the ops\n\n  // literals\n  public static Node objectlit(Node ... propdefs) {\n    Node objectlit = new Node(Token.OBJECTLIT);\n    for (Node propdef : propdefs) {\n      Preconditions.checkState(\n          propdef.isStringKey() ||\n          propdef.isGetterDef() || propdef.isSetterDef());\n      Preconditions.checkState(propdef.hasOneChild());\n      objectlit.addChildToBack(propdef);\n    }\n    return objectlit;\n  }\n\n  // TODO(johnlenz): quoted props\n\n  public static Node propdef(Node string, Node value) {\n    Preconditions.checkState(string.isStringKey());\n    Preconditions.checkState(!string.hasChildren());\n    Preconditions.checkState(mayBeExpression(value));\n    string.addChildToFront(value);\n    return string;\n  }\n\n  public static Node arraylit(Node ... exprs) {\n    Node arraylit = new Node(Token.ARRAYLIT);\n    for (Node expr : exprs) {\n      Preconditions.checkState(mayBeExpressionOrEmpty(expr));\n      arraylit.addChildToBack(expr);\n    }\n    return arraylit;\n  }\n\n  public static Node regexp(Node expr) {\n    Preconditions.checkState(expr.isString());\n    return new Node(Token.REGEXP, expr);\n  }\n\n  public static Node regexp(Node expr, Node flags) {\n    Preconditions.checkState(expr.isString());\n    Preconditions.checkState(flags.isString());\n    return new Node(Token.REGEXP, expr, flags);\n  }\n\n  public static Node string(String s) {\n    return Node.newString(s);\n  }\n\n  public static Node stringKey(String s) {\n    return Node.newString(Token.STRING_KEY, s);\n  }\n\n  public static Node number(double d) {\n    return Node.newNumber(d);\n  }\n\n  public static Node thisNode() {\n    return new Node(Token.THIS);\n  }\n\n  public static Node trueNode() {\n    return new Node(Token.TRUE);\n  }\n\n  public static Node falseNode() {\n    return new Node(Token.FALSE);\n  }\n\n  public static Node nullNode() {\n    return new Node(Token.NULL);\n  }\n\n  // helper methods\n\n  private static Node binaryOp(int token, Node expr1, Node expr2) {\n    Preconditions.checkState(mayBeExpression(expr1));\n    Preconditions.checkState(mayBeExpression(expr2));\n    return new Node(token, expr1, expr2);\n  }\n\n  private static Node unaryOp(int token, Node expr) {\n    Preconditions.checkState(mayBeExpression(expr));\n    return new Node(token, expr);\n  }\n\n  private static boolean mayBeExpressionOrEmpty(Node n) {\n    return n.isEmpty() || mayBeExpression(n);\n  }\n\n  private static boolean isAssignmentTarget(Node n) {\n    return n.isName() || n.isGetProp() || n.isGetElem();\n  }\n\n  // NOTE: some nodes are neither statements nor expression nodes:\n  //   SCRIPT, LABEL_NAME, PARAM_LIST, CASE, DEFAULT_CASE, CATCH\n  //   GETTER_DEF, SETTER_DEF\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeStatement(Node n) {\n    switch (n.getType()) {\n      case Token.EMPTY:\n      case Token.FUNCTION:\n        // EMPTY and FUNCTION are used both in expression and statement\n        // contexts\n        return true;\n\n      case Token.BLOCK:\n      case Token.BREAK:\n      case Token.CONST:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.DO:\n      case Token.EXPR_RESULT:\n      case Token.FOR:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.RETURN:\n      case Token.SWITCH:\n      case Token.THROW:\n      case Token.TRY:\n      case Token.VAR:\n      case Token.WHILE:\n      case Token.WITH:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * It isn't possible to always determine if a detached node is a expression,\n   * so make a best guess.\n   */\n  private static boolean mayBeExpression(Node n) {\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // FUNCTION is used both in expression and statement\n        // contexts.\n        return true;\n\n      case Token.ADD:\n      case Token.AND:\n      case Token.ARRAYLIT:\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITNOT:\n      case Token.BITXOR:\n      case Token.CALL:\n      case Token.COMMA:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FALSE:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.IN:\n      case Token.INC:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.OBJECTLIT:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TYPEOF:\n      case Token.TRUE:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n}\n"}, "generated_test_class": "To ensure comprehensive branch and line coverage for the `arraylit` method in the `IR` class, we need to consider various scenarios, including:\n\n1. **No arguments**: Testing the method when no arguments are passed.\n2. **Single argument**: Testing with a single expression.\n3. **Multiple arguments**: Testing with multiple expressions.\n4. **Edge case**: Testing with `null` or invalid arguments to ensure that the method handles these gracefully.\n\nBelow are the unit tests in Java 1.7 using JUnit 4:\n\n```java\nimport static org.junit.Assert.*;\nimport org.junit.Test;\nimport org.junit.Rule;\nimport org.junit.rules.ExpectedException;\n\npublic class IRTest {\n\n    @Rule\n    public ExpectedException thrown = ExpectedException.none();\n\n    @Test\n    public void testArraylit_NoArguments() {\n        Node arraylit = IR.arraylit();\n        assertEquals(Token.ARRAYLIT, arraylit.getType());\n        assertTrue(arraylit.getChildren().isEmpty());\n    }\n\n    @Test\n    public void testArraylit_SingleArgument() {\n        Node expr = IR.number(10);\n        Node arraylit = IR.arraylit(expr);\n        assertEquals(Token.ARRAYLIT, arraylit.getType());\n        assertEquals(1, arraylit.getChildCount());\n        assertEquals(expr, arraylit.getChildAtIndex(0));\n    }\n\n    @Test\n    public void testArraylit_MultipleArguments() {\n        Node expr1 = IR.number(10);\n        Node expr2 = IR.string(\"test\");\n        Node arraylit = IR.arraylit(expr1, expr2);\n        assertEquals(Token.ARRAYLIT, arraylit.getType());\n        assertEquals(2, arraylit.getChildCount());\n        assertEquals(expr1, arraylit.getChildAtIndex(0));\n        assertEquals(expr2, arraylit.getChildAtIndex(1));\n    }\n\n    @Test\n    public void testArraylit_WithNullArgument() {\n        thrown.expect(IllegalArgumentException.class);\n        IR.arraylit(null);\n    }\n\n    // This test assumes that the precondition check will fail if an invalid node type is passed\n    @Test\n    public void testArraylit_WithInvalidArgument() {\n        Node invalidNode = new Node(Token.BLOCK);\n        thrown.expect(IllegalArgumentException.class);\n        IR.arraylit(invalidNode);\n    }\n\n    // Helper method to check if a node can be an expression or empty\n    private static boolean mayBeExpressionOrEmpty(Node node) {\n        // This is a simplified version. In actual implementation, it should check the valid node types.\n        return node == null || node.getType() != Token.BLOCK;\n    }\n}\n```\n\n### Explanation:\n\n1. **testArraylit_NoArguments**: Verifies that calling `arraylit` with no arguments creates an `ARRAYLIT` node with no children.\n2. **testArraylit_SingleArgument**: Verifies that calling `arraylit` with a single argument creates an `ARRAYLIT` node with that argument as its only child.\n3. **testArraylit_MultipleArguments**: Verifies that calling `arraylit` with multiple arguments creates an `ARRAYLIT` node with all the arguments as children.\n4. **testArraylit_WithNullArgument**: Verifies that calling `arraylit` with a `null` argument throws an `IllegalArgumentException`.\n5. **testArraylit_WithInvalidArgument**: Verifies that calling `arraylit` with an invalid node type argument (e.g., a `BLOCK` node) throws an `IllegalArgumentException`.\n\n### Notes:\n\n- The `mayBeExpressionOrEmpty` method is a placeholder for the actual precondition check in the `arraylit` method. You should replace it with the actual logic used in your codebase.\n- The `thrown` rule from JUnit 4 is used to assert that exceptions are thrown as expected.\n\nThese tests should provide good branch and line coverage for the `arraylit` method."}
{"bug_id": "Closure_31", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.Compiler#initOptions(CompilerOptions#options)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "focal_method": "public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }", "return_type": "void", "assertion_subject_candidates": ["JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "double com.google.javascript.jscomp.Compiler#getProgress()", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()"], "focal_class": {"name": "Compiler", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "superclass": "extends AbstractCompiler", "interface": "", "imports": ["import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.Charsets;", "import com.google.common.base.Preconditions;", "import com.google.common.base.Supplier;", "import com.google.common.base.Throwables;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.common.io.CharStreams;", "import com.google.javascript.jscomp.CompilerOptions.DevMode;", "import com.google.javascript.jscomp.CompilerOptions.LanguageMode;", "import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;", "import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;", "import com.google.javascript.jscomp.parsing.Config;", "import com.google.javascript.jscomp.parsing.ParserRunner;", "import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;", "import com.google.javascript.rhino.IR;", "import com.google.javascript.rhino.InputId;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import com.google.javascript.rhino.head.ErrorReporter;", "import com.google.javascript.rhino.jstype.JSTypeRegistry;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.PrintStream;", "import java.io.Serializable;", "import java.nio.charset.Charset;", "import java.util.Collections;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;", "import java.util.concurrent.Callable;", "import java.util.logging.Level;", "import java.util.logging.Logger;", "import java.util.regex.Matcher;"], "fields": ["static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions options = null", "private PassConfig passes = null", "private List<CompilerInput> externs", "private List<JSModule> modules", "private JSModuleGraph moduleGraph", "private List<CompilerInput> inputs", "private ErrorManager errorManager", "private WarningsGuard warningsGuard", "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node externsRoot", "Node jsRoot", "Node externAndJsRoot", "private Map<InputId, CompilerInput> inputsById", "private SourceMap sourceMap", "private String externExports = null", "private int uniqueNameId = 0", "private boolean useThreads = true", "private boolean hasRegExpGlobalReferences = true", "private FunctionInformationMap functionInformationMap", "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "private JSTypeRegistry typeRegistry", "private Config parserConfig = null", "private ReverseAbstractInterpreter abstractInterpreter", "private TypeValidator typeValidator", "public PerformanceTracker tracker", "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "private static final long COMPILER_STACK_SIZE = 1048576L", "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "private final PrintStream outStream", "private GlobalVarReferenceMap globalRefMap = null", "private volatile double progress = 0.0", "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "private Tracer currentTracer = null", "private String currentPassName = null", "private int syntheticCodeId = 0", "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "private CompilerInput synthesizedExternsInput = null"], "methods": ["void com.google.javascript.jscomp.Compiler#setErrorManager(ErrorManager#errorManager)", "MessageFormatter com.google.javascript.jscomp.Compiler#createMessageFormatter()", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initBasedOnOptions()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#makeCompilerInput(List<T>#files,boolean#isExtern)", "void com.google.javascript.jscomp.Compiler#checkFirstModule(List<JSModule>#modules)", "String com.google.javascript.jscomp.Compiler#createFillFileName(String#moduleName)", "void com.google.javascript.jscomp.Compiler#fillEmptyModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#rebuildInputsFromModules()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getAllInputsFromModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#initInputsByIdMap()", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,SourceFile#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,JSSourceFile[]#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile#extern,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compileModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile()", "void com.google.javascript.jscomp.Compiler#disableThreads()", "T com.google.javascript.jscomp.Compiler#runInCompilerThread(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallableWithLargeStack(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallable(Callable<T>#callable,boolean#useLargeStackThread,boolean#trace)", "void com.google.javascript.jscomp.Compiler#compileInternal()", "void com.google.javascript.jscomp.Compiler#parse()", "PassConfig com.google.javascript.jscomp.Compiler#getPassConfig()", "PassConfig com.google.javascript.jscomp.Compiler#createPassConfigInternal()", "void com.google.javascript.jscomp.Compiler#setPassConfig(PassConfig#passes)", "boolean com.google.javascript.jscomp.Compiler#precheck()", "void com.google.javascript.jscomp.Compiler#check()", "void com.google.javascript.jscomp.Compiler#externExports()", "void com.google.javascript.jscomp.Compiler#process(CompilerPass#p)", "void com.google.javascript.jscomp.Compiler#maybeSanityCheck()", "void com.google.javascript.jscomp.Compiler#runSanityCheck()", "void com.google.javascript.jscomp.Compiler#removeTryCatchFinally()", "void com.google.javascript.jscomp.Compiler#stripCode(Set<String>#stripTypes,Set<String>#stripNameSuffixes,Set<String>#stripTypePrefixes,Set<String>#stripNamePrefixes)", "void com.google.javascript.jscomp.Compiler#runCustomPasses(CustomPassExecutionTime#executionTime)", "void com.google.javascript.jscomp.Compiler#startPass(String#passName)", "void com.google.javascript.jscomp.Compiler#endPass()", "Tracer com.google.javascript.jscomp.Compiler#newTracer(String#passName)", "void com.google.javascript.jscomp.Compiler#stopTracer(Tracer#t,String#passName)", "Result com.google.javascript.jscomp.Compiler#getResult()", "JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "int com.google.javascript.jscomp.Compiler#nextUniqueNameId()", "void com.google.javascript.jscomp.Compiler#resetUniqueNameId()", "Supplier<String> com.google.javascript.jscomp.Compiler#getUniqueNameIdSupplier()", "boolean com.google.javascript.jscomp.Compiler#areNodesEqualForInlining(Node#n1,Node#n2)", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "void com.google.javascript.jscomp.Compiler#removeExternInput(InputId#id)", "CompilerInput com.google.javascript.jscomp.Compiler#newExternInput(String#name)", "CompilerInput com.google.javascript.jscomp.Compiler#putCompilerInput(InputId#id,CompilerInput#input)", "void com.google.javascript.jscomp.Compiler#addIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#replaceIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#addNewSourceAst(JsAst#ast)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "JSTypeRegistry com.google.javascript.jscomp.Compiler#getTypeRegistry()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "DefaultPassConfig com.google.javascript.jscomp.Compiler#ensureDefaultPassConfig()", "SymbolTable com.google.javascript.jscomp.Compiler#buildKnownSymbolTable()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ReverseAbstractInterpreter com.google.javascript.jscomp.Compiler#getReverseAbstractInterpreter()", "TypeValidator com.google.javascript.jscomp.Compiler#getTypeValidator()", "Node com.google.javascript.jscomp.Compiler#parseInputs()", "void com.google.javascript.jscomp.Compiler#processAMDAndCommonJSModules()", "Node com.google.javascript.jscomp.Compiler#parse(SourceFile#file)", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#js)", "CompilerOptions com.google.javascript.jscomp.Compiler#newCompilerOptions()", "void com.google.javascript.jscomp.Compiler#initCompilerOptionsIfTesting()", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#fileName,String#js)", "Node com.google.javascript.jscomp.Compiler#parseTestCode(String#js)", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "String com.google.javascript.jscomp.Compiler#toSource()", "String[] com.google.javascript.jscomp.Compiler#toSourceArray()", "String com.google.javascript.jscomp.Compiler#toSource(JSModule#module)", "String[] com.google.javascript.jscomp.Compiler#toSourceArray(JSModule#module)", "void com.google.javascript.jscomp.Compiler#toSource(CodeBuilder#cb,int#inputSeqNum,Node#root)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n,SourceMap#sourceMap,boolean#firstOutput)", "void com.google.javascript.jscomp.Compiler#optimize()", "void com.google.javascript.jscomp.Compiler#setCssRenamingMap(CssRenamingMap#map)", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "void com.google.javascript.jscomp.Compiler#processDefines()", "boolean com.google.javascript.jscomp.Compiler#isInliningForbidden()", "ControlFlowGraph<Node> com.google.javascript.jscomp.Compiler#computeCFG()", "void com.google.javascript.jscomp.Compiler#normalize()", "void com.google.javascript.jscomp.Compiler#prepareAst(Node#root)", "void com.google.javascript.jscomp.Compiler#recordFunctionInformation()", "void com.google.javascript.jscomp.Compiler#addChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#removeChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#reportCodeChange()", "CodingConvention com.google.javascript.jscomp.Compiler#getCodingConvention()", "boolean com.google.javascript.jscomp.Compiler#isIdeMode()", "boolean com.google.javascript.jscomp.Compiler#acceptEcmaScript5()", "LanguageMode com.google.javascript.jscomp.Compiler#languageMode()", "boolean com.google.javascript.jscomp.Compiler#acceptConstKeyword()", "Config com.google.javascript.jscomp.Compiler#getParserConfig()", "boolean com.google.javascript.jscomp.Compiler#isTypeCheckingEnabled()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "void com.google.javascript.jscomp.Compiler#report(JSError#error)", "CheckLevel com.google.javascript.jscomp.Compiler#getErrorLevel(JSError#error)", "void com.google.javascript.jscomp.Compiler#throwInternalError(String#message,Exception#cause)", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "boolean com.google.javascript.jscomp.Compiler#hasHaltingErrors()", "boolean com.google.javascript.jscomp.Compiler#hasErrors()", "void com.google.javascript.jscomp.Compiler#addToDebugLog(String#str)", "SourceFile com.google.javascript.jscomp.Compiler#getSourceFileByName(String#sourceName)", "String com.google.javascript.jscomp.Compiler#getSourceLine(String#sourceName,int#lineNumber)", "Region com.google.javascript.jscomp.Compiler#getSourceRegion(String#sourceName,int#lineNumber)", "Node com.google.javascript.jscomp.Compiler#getNodeForCodeInsertion(JSModule#module)", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "void com.google.javascript.jscomp.Compiler#setLoggingLevel(Level#level)", "String com.google.javascript.jscomp.Compiler#getAstDotGraph()", "ErrorManager com.google.javascript.jscomp.Compiler#getErrorManager()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "IntermediateState com.google.javascript.jscomp.Compiler#getState()", "void com.google.javascript.jscomp.Compiler#setState(IntermediateState#state)", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "boolean com.google.javascript.jscomp.Compiler#hasRegExpGlobalReferences()", "void com.google.javascript.jscomp.Compiler#setHasRegExpGlobalReferences(boolean#references)", "void com.google.javascript.jscomp.Compiler#updateGlobalVarReferences(Map<Var, ReferenceCollection>#refMapPatch,Node#collectionRoot)", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "CompilerInput com.google.javascript.jscomp.Compiler#getSynthesizedExternsInput()", "double com.google.javascript.jscomp.Compiler#getProgress()", "void com.google.javascript.jscomp.Compiler#setProgress(double#newProgress)", "void com.google.javascript.jscomp.Compiler#replaceScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#addNewScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#processNewScript(JsAst#ast,Node#originalRoot)", "void com.google.javascript.jscomp.Compiler#runHotSwap(Node#originalRoot,Node#js,PassConfig#passConfig)", "void com.google.javascript.jscomp.Compiler#runHotSwapPass(Node#originalRoot,Node#js,PassFactory#passFactory)", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()", "void com.google.javascript.jscomp.Compiler#removeSyntheticVarsInput()", "Node com.google.javascript.jscomp.Compiler#ensureLibraryInjected(String#resourceName)", "Node com.google.javascript.jscomp.Compiler#loadLibraryCode(String#resourceName)"], "other_methods": ["public void setErrorManager(ErrorManager errorManager);", "public void init(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public void init(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public void init(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public void initModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void rebuildInputsFromModules();", "public Result compile(SourceFile extern,SourceFile input,CompilerOptions options);", "public Result compile(SourceFile extern,JSSourceFile[] input,CompilerOptions options);", "public Result compile(JSSourceFile extern,JSModule[] modules,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public Result compile(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public Result compileModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void disableThreads();", "public void parse();", "public void setPassConfig(PassConfig passes);", "public void check();", "public Result getResult();", "public JSError[] getMessages();", "public JSError[] getErrors();", "public JSError[] getWarnings();", "@Override\n  public Node getRoot();", "@Override\n  public CompilerInput getInput(InputId id);", "@Override\n  public CompilerInput newExternInput(String name);", "@Override\n  public JSTypeRegistry getTypeRegistry();", "@Override\n  public MemoizedScopeCreator getTypedScopeCreator();", "public SymbolTable buildKnownSymbolTable();", "@Override\n  public Scope getTopScope();", "@Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter();", "public Node parse(SourceFile file);", "public String toSource();", "public String[] toSourceArray();", "public String toSource(JSModule module);", "public String[] toSourceArray(JSModule module);", "public void toSource(CodeBuilder cb,int inputSeqNum,Node root);", "public void optimize();", "public void processDefines();", "public void normalize();", "@Override\n  public void reportCodeChange();", "@Override\n  public CodingConvention getCodingConvention();", "@Override\n  public boolean isIdeMode();", "@Override\n  public boolean acceptEcmaScript5();", "public LanguageMode languageMode();", "@Override\n  public boolean acceptConstKeyword();", "@Override\n  public boolean isTypeCheckingEnabled();", "@Override\n  public void report(JSError error);", "@Override\n  public CheckLevel getErrorLevel(JSError error);", "public int getErrorCount();", "public int getWarningCount();", "public boolean hasErrors();", "@Override\n  public String getSourceLine(String sourceName,int lineNumber);", "@Override\n  public Region getSourceRegion(String sourceName,int lineNumber);", "public SourceMap getSourceMap();", "public static void setLoggingLevel(Level level);", "public String getAstDotGraph();", "@Override\n  public ErrorManager getErrorManager();", "public Map<InputId, CompilerInput> getInputsById();", "public IntermediateState getState();", "public void setState(IntermediateState state);", "@Override\n  public double getProgress();", "public void replaceScript(JsAst ast);", "public void addNewScript(JsAst ast);"], "fields_dict": {"String#SINGLETON_MODULE_NAME": "static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "DiagnosticType#MODULE_DEPENDENCY_ERROR": "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "DiagnosticType#MISSING_ENTRY_ERROR": "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions#options": "CompilerOptions options = null", "PassConfig#passes": "private PassConfig passes = null", "List<CompilerInput>#externs": "private List<CompilerInput> externs", "List<JSModule>#modules": "private List<JSModule> modules", "JSModuleGraph#moduleGraph": "private JSModuleGraph moduleGraph", "List<CompilerInput>#inputs": "private List<CompilerInput> inputs", "ErrorManager#errorManager": "private ErrorManager errorManager", "WarningsGuard#warningsGuard": "private WarningsGuard warningsGuard", "Map<String, Node>#injectedLibraries": "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node#externsRoot": "Node externsRoot", "Node#jsRoot": "Node jsRoot", "Node#externAndJsRoot": "Node externAndJsRoot", "Map<InputId, CompilerInput>#inputsById": "private Map<InputId, CompilerInput> inputsById", "SourceMap#sourceMap": "private SourceMap sourceMap", "String#externExports": "private String externExports = null", "int#uniqueNameId": "private int uniqueNameId = 0", "boolean#useThreads": "private boolean useThreads = true", "boolean#hasRegExpGlobalReferences": "private boolean hasRegExpGlobalReferences = true", "FunctionInformationMap#functionInformationMap": "private FunctionInformationMap functionInformationMap", "StringBuilder#debugLog": "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention#defaultCodingConvention": "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "JSTypeRegistry#typeRegistry": "private JSTypeRegistry typeRegistry", "Config#parserConfig": "private Config parserConfig = null", "ReverseAbstractInterpreter#abstractInterpreter": "private ReverseAbstractInterpreter abstractInterpreter", "TypeValidator#typeValidator": "private TypeValidator typeValidator", "PerformanceTracker#tracker": "public PerformanceTracker tracker", "com.google.javascript.rhino.ErrorReporter#oldErrorReporter": "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "ErrorReporter#defaultErrorReporter": "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "DiagnosticType#OPTIMIZE_LOOP_ERROR": "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "DiagnosticType#MOTION_ITERATIONS_ERROR": "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "long#COMPILER_STACK_SIZE": "private static final long COMPILER_STACK_SIZE = 1048576L", "Logger#logger": "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "PrintStream#outStream": "private final PrintStream outStream", "GlobalVarReferenceMap#globalRefMap": "private GlobalVarReferenceMap globalRefMap = null", "double#progress": "private volatile double progress = 0.0", "DiagnosticType#EMPTY_MODULE_LIST_ERROR": "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "DiagnosticType#EMPTY_ROOT_MODULE_ERROR": "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "DiagnosticType#DUPLICATE_INPUT": "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "DiagnosticType#DUPLICATE_EXTERN_INPUT": "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "PassFactory#sanityCheck": "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "Tracer#currentTracer": "private Tracer currentTracer = null", "String#currentPassName": "private String currentPassName = null", "int#syntheticCodeId": "private int syntheticCodeId = 0", "CodeChangeHandler.RecentChange#recentChange": "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "List<CodeChangeHandler>#codeChangeHandlers": "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "String#SYNTHETIC_EXTERNS": "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "CompilerInput#synthesizedExternsInput": "private CompilerInput synthesizedExternsInput = null"}, "text": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Charsets;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.io.CharStreams;\nimport com.google.javascript.jscomp.CompilerOptions.DevMode;\nimport com.google.javascript.jscomp.CompilerOptions.LanguageMode;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\nimport com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\nimport com.google.javascript.jscomp.parsing.Config;\nimport com.google.javascript.jscomp.parsing.ParserRunner;\nimport com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.head.ErrorReporter;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\n\n/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  static final String SINGLETON_MODULE_NAME = \"[singleton]\";\n\n  static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\");\n\n  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\");\n\n  CompilerOptions options = null;\n\n  private PassConfig passes = null;\n\n  // The externs inputs\n  private List<CompilerInput> externs;\n\n  // The JS source modules\n  private List<JSModule> modules;\n\n  // The graph of the JS source modules. Must be null if there are less than\n  // 2 modules, because we use this as a signal for which passes to run.\n  private JSModuleGraph moduleGraph;\n\n  // The JS source inputs\n  private List<CompilerInput> inputs;\n\n  // error manager to which error management is delegated\n  private ErrorManager errorManager;\n\n  // Warnings guard for filtering warnings.\n  private WarningsGuard warningsGuard;\n\n  // Compile-time injected libraries. The node points to the last node of\n  // the library, so code can be inserted after.\n  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n\n  // Parse tree root nodes\n  Node externsRoot;\n  Node jsRoot;\n  Node externAndJsRoot;\n\n  private Map<InputId, CompilerInput> inputsById;\n\n  /** The source code map */\n  private SourceMap sourceMap;\n\n  /** The externs created from the exports.  */\n  private String externExports = null;\n\n  /**\n   * Ids for function inlining so that each declared name remains\n   * unique.\n   */\n  private int uniqueNameId = 0;\n\n  /** Whether to use threads. */\n  private boolean useThreads = true;\n\n  /**\n   * Whether to assume there are references to the RegExp Global object\n   * properties.\n   */\n  private boolean hasRegExpGlobalReferences = true;\n\n  /** The function information map */\n  private FunctionInformationMap functionInformationMap;\n\n  /** Debugging information */\n  private final StringBuilder debugLog = new StringBuilder();\n\n  /** Detects Google-specific coding conventions. */\n  CodingConvention defaultCodingConvention = new ClosureCodingConvention();\n\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n\n  public PerformanceTracker tracker;\n\n  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.\n  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =\n      RhinoErrorReporter.forOldRhino(this);\n\n  // This error reporter gets the messages from the current Rhino parser.\n  private final ErrorReporter defaultErrorReporter =\n      RhinoErrorReporter.forNewRhino(this);\n\n  /** Error strings used for reporting JSErrors */\n  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\");\n  public static final DiagnosticType MOTION_ITERATIONS_ERROR =\n      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\");\n\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n\n\n  /**\n   * Logger for the whole com.google.javascript.jscomp domain -\n   * setting configuration for this logger affects all loggers\n   *  in other classes within the compiler.\n   */\n  private static final Logger logger =\n      Logger.getLogger(\"com.google.javascript.jscomp\");\n\n  private final PrintStream outStream;\n\n  private GlobalVarReferenceMap globalRefMap = null;\n\n  private volatile double progress = 0.0;\n\n  /**\n   * Creates a Compiler that reports errors and warnings to its logger.\n   */\n  public Compiler() {\n    this((PrintStream) null);\n  }\n\n  /**\n   * Creates n Compiler that reports errors and warnings to an output\n   * stream.\n   */\n  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }\n\n  /**\n   * Creates a Compiler that uses a custom error manager.\n   */\n  public Compiler(ErrorManager errorManager) {\n    this();\n    setErrorManager(errorManager);\n  }\n\n  /**\n   * Sets the error manager.\n   *\n   * @param errorManager the error manager, it cannot be {@code null}\n   */\n  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }\n\n  /**\n   * Creates a message formatter instance corresponding to the value of\n   * {@link CompilerOptions}.\n   */\n  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }\n\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    init(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n    for (SourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options) {\n    initModules(Lists.<SourceFile>newArrayList(externs),\n         Lists.<JSModule>newArrayList(modules), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }\n\n  /**\n   * Do any initialization that is dependent on the compiler options.\n   */\n  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }\n\n  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n      List<T> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (T file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }\n\n  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\");\n\n  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\");\n\n  /**\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   */\n  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }\n\n  /**\n   * Empty modules get an empty \"fill\" file, so that we can move code into\n   * an empty module.\n   */\n  static String createFillFileName(String moduleName) {\n    return \"[\" + moduleName + \"]\";\n  }\n\n  /**\n   * Fill any empty modules with a place holder file. It makes any cross module\n   * motion easier.\n   */\n  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(SourceFile.fromCode(\n            createFillFileName(module.getName()), \"\"));\n      }\n    }\n  }\n\n  /**\n   * Rebuilds the internal list of inputs by iterating over all modules.\n   * This is necessary if inputs have been added to or removed from a module\n   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n   */\n  public void rebuildInputsFromModules() {\n    inputs = getAllInputsFromModules(modules);\n    initInputsByIdMap();\n  }\n\n  /**\n   * Builds a single list of all module inputs. Verifies that it contains no\n   * duplicates.\n   */\n  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }\n\n  static final DiagnosticType DUPLICATE_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");\n  static final DiagnosticType DUPLICATE_EXTERN_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\");\n\n  /**\n   * Creates a map to make looking up an input by name fast. Also checks for\n   * duplicate inputs.\n   */\n  void initInputsByIdMap() {\n    inputsById = new HashMap<InputId, CompilerInput>();\n    for (CompilerInput input : externs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n      }\n    }\n  }\n\n  public Result compile(\n      SourceFile extern, SourceFile input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      SourceFile extern, JSSourceFile[] input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {\n     return compileModules(\n         Lists.newArrayList(extern), Lists.newArrayList(modules), options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options) {\n    return compile(Lists.<SourceFile>newArrayList(externs),\n        Lists.<SourceFile>newArrayList(inputs),\n        options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n      List<T1> externs, List<T2> inputs, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, inputs, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options) {\n    return compileModules(Lists.<SourceFile>newArrayList(externs),\n        Lists.<JSModule>newArrayList(modules),\n        options);\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public <T extends SourceFile> Result compileModules(List<T> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      @Override\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }\n\n  /**\n   * Disable threads. This is for clients that run on AppEngine and\n   * don't have threads.\n   */\n  public void disableThreads() {\n    useThreads = false;\n  }\n\n  private <T> T runInCompilerThread(final Callable<T> callable) {\n    return runCallable(callable, useThreads, options.tracer.isOn());\n  }\n\n  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n    return runCallable(callable, true, false);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n\n    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n    // large or complex js code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = trace;\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useLargeStackThread) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }\n\n  private void compileInternal() {\n    setProgress(0.0);\n    parse();\n    // 15 percent of the work is assumed to be for parsing (based on some\n    // minimal analysis on big JS projects, of course this depends on options)\n    setProgress(0.15);\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n    setProgress(1.0);\n  }\n\n  public void parse() {\n    parseInputs();\n  }\n\n  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }\n\n  /**\n   * Create the passes object. Clients should use setPassConfig instead of\n   * overriding this.\n   */\n  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }\n\n  /**\n   * @param passes The PassConfig to use with this Compiler.\n   * @throws NullPointerException if passes is null\n   * @throws IllegalStateException if this.passes has already been assigned\n   */\n  public void setPassConfig(PassConfig passes) {\n    // Important to check for null because if setPassConfig(null) is\n    // called before this.passes is set, getPassConfig() will create a\n    // new PassConfig object and use that, which is probably not what\n    // the client wanted since he or she probably meant to use their\n    // own PassConfig object.\n    Preconditions.checkNotNull(passes);\n\n    if (this.passes != null) {\n      throw new IllegalStateException(\"this.passes has already been assigned\");\n    }\n    this.passes = passes;\n  }\n\n  /**\n   * Carry out any special checks or procedures that need to be done before\n   * proceeding with rest of the compilation process.\n   *\n   * @return true, to continue with compilation\n   */\n  boolean precheck() {\n    return true;\n  }\n\n  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    // We are currently only interested in check-passes for progress reporting\n    // as it is used for IDEs, that's why the maximum progress is set to 1.0.\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,\n        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }\n\n  private void externExports() {\n    logger.fine(\"Creating extern file for exports\");\n    startPass(\"externExports\");\n\n    ExternExportsPass pass = new ExternExportsPass(this);\n    process(pass);\n\n    externExports = pass.getGeneratedExterns();\n\n    endPass();\n  }\n\n  @Override\n  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }\n\n  private final PassFactory sanityCheck =\n      new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  };\n\n  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }\n\n  private void runSanityCheck() {\n    sanityCheck.create(this).process(externsRoot, jsRoot);\n  }\n\n  /**\n   * Removes try/catch/finally statements for easier debugging.\n   */\n  void removeTryCatchFinally() {\n    logger.fine(\"Remove try/catch/finally\");\n    startPass(\"removeTryCatchFinally\");\n    RemoveTryCatch r = new RemoveTryCatch(this);\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Strips code for smaller compiled code. This is useful for removing debug\n   * statements to prevent leaking them publicly.\n   */\n  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n    logger.fine(\"Strip code\");\n    startPass(\"stripCode\");\n    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n        stripTypePrefixes, stripNamePrefixes);\n    if (options.getTweakProcessing().shouldStrip()) {\n      r.enableTweakStripping();\n    }\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Runs custom passes that are designated to run at a particular time.\n   */\n  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }\n\n  private Tracer currentTracer = null;\n  private String currentPassName = null;\n\n  /**\n   * Marks the beginning of a pass.\n   */\n  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }\n\n  /**\n   * Marks the end of a pass.\n   */\n  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }\n\n  /**\n   * Returns a new tracer for the given pass name.\n   */\n  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }\n\n  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }\n\n  /**\n   * Returns the result of the compilation.\n   */\n  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }\n\n  /**\n   * Returns an array constructed from errors + temporary warnings.\n   */\n  public JSError[] getMessages() {\n    return getErrors();\n  }\n\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }\n\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }\n\n  @Override\n  public Node getRoot() {\n    return externAndJsRoot;\n  }\n\n  /**\n   * Creates a new id for making unique names.\n   */\n  private int nextUniqueNameId() {\n    return uniqueNameId++;\n  }\n\n  /**\n   * Resets the unique name id counter\n   */\n  @VisibleForTesting\n  void resetUniqueNameId() {\n    uniqueNameId = 0;\n  }\n\n  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      @Override\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }\n\n  @Override\n  boolean areNodesEqualForInlining(Node n1, Node n2) {\n    if (options.ambiguateProperties ||\n        options.disambiguateProperties) {\n      // The type based optimizations require that type information is preserved\n      // during other optimizations.\n      return n1.isEquivalentToTyped(n2);\n    } else {\n      return n1.isEquivalentTo(n2);\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Inputs\n  //------------------------------------------------------------------------\n\n  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler\n  // interface, and which ones should always be injected.\n\n  @Override\n  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }\n\n  /**\n   * Removes an input file from AST.\n   * @param id The id of the input to be removed.\n   */\n  protected void removeExternInput(InputId id) {\n    CompilerInput input = getInput(id);\n    if (input == null) {\n      return;\n    }\n    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());\n    inputsById.remove(id);\n    externs.remove(input);\n    Node root = input.getAstRoot(this);\n    if (root != null) {\n      root.detachFromParent();\n    }\n  }\n\n  @Override\n  public CompilerInput newExternInput(String name) {\n    SourceAst ast = new SyntheticAst(name);\n    if (inputsById.containsKey(ast.getInputId())) {\n      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n    }\n    CompilerInput input = new CompilerInput(ast, true);\n    putCompilerInput(input.getInputId(), input);\n    externsRoot.addChildToFront(ast.getAstRoot(this));\n    externs.add(0, input);\n    return input;\n  }\n\n  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }\n\n  /** Add a source input dynamically. Intended for incremental compilation. */\n  void addIncrementalSourceAst(JsAst ast) {\n    InputId id = ast.getInputId();\n    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());\n    putCompilerInput(id, new CompilerInput(ast));\n  }\n\n  /**\n   * Replace a source input dynamically. Intended for incremental\n   * re-compilation.\n   *\n   * If the new source input doesn't parse, then keep the old input\n   * in the AST and return false.\n   *\n   * @return Whether the new AST was attached successfully.\n   */\n  boolean replaceIncrementalSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    Node oldRoot = oldInput.getAstRoot(this);\n    if (oldRoot != null) {\n      oldRoot.getParent().replaceChild(oldRoot, newRoot);\n    } else {\n      getRoot().getLastChild().addChildToBack(newRoot);\n    }\n\n    CompilerInput newInput = new CompilerInput(ast);\n    putCompilerInput(ast.getInputId(), newInput);\n\n    JSModule module = oldInput.getModule();\n    if (module != null) {\n      module.addAfter(newInput, oldInput);\n      module.remove(oldInput);\n    }\n\n    // Verify the input id is set properly.\n    Preconditions.checkState(\n        newInput.getInputId().equals(oldInput.getInputId()));\n    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();\n    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));\n\n    inputs.remove(oldInput);\n    return true;\n  }\n\n  /**\n   * Add a new source input dynamically. Intended for incremental compilation.\n   * <p>\n   * If the new source input doesn't parse, it will not be added, and a false\n   * will be returned.\n   *\n   * @param ast the JS Source to add.\n   * @return true if the source was added successfully, false otherwise.\n   * @throws IllegalStateException if an input for this ast already exists.\n   */\n  boolean addNewSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    if (oldInput != null) {\n      throw new IllegalStateException(\n          \"Input already exists: \" + ast.getInputId().getIdName());\n    }\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    getRoot().getLastChild().addChildToBack(newRoot);\n\n    CompilerInput newInput = new CompilerInput(ast);\n\n    // TODO(tylerg): handle this for multiple modules at some point.\n    if (moduleGraph == null && !modules.isEmpty()) {\n      // singleton module\n      modules.get(0).add(newInput);\n    }\n\n    putCompilerInput(ast.getInputId(), newInput);\n\n    return true;\n  }\n\n  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }\n\n  /**\n   * Gets a module graph. This will always return a module graph, even\n   * in the degenerate case when there's only one module.\n   */\n  JSModuleGraph getDegenerateModuleGraph() {\n    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;\n  }\n\n  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }\n\n  @Override\n  public MemoizedScopeCreator getTypedScopeCreator() {\n    return getPassConfig().getTypedScopeCreator();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  DefaultPassConfig ensureDefaultPassConfig() {\n    PassConfig passes = getPassConfig().getBasePassConfig();\n    Preconditions.checkState(passes instanceof DefaultPassConfig,\n        \"PassConfigs must eventually delegate to the DefaultPassConfig\");\n    return (DefaultPassConfig) passes;\n  }\n\n  public SymbolTable buildKnownSymbolTable() {\n    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());\n\n    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();\n    if (typedScopeCreator != null) {\n      symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());\n      symbolTable.addSymbolsFrom(typedScopeCreator);\n    } else {\n      symbolTable.findScopes(this, externsRoot, jsRoot);\n    }\n\n    GlobalNamespace globalNamespace =\n        ensureDefaultPassConfig().getGlobalNamespace();\n    if (globalNamespace != null) {\n      symbolTable.addSymbolsFrom(globalNamespace);\n    }\n\n    ReferenceCollectingCallback refCollector =\n        new ReferenceCollectingCallback(\n            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n    NodeTraversal.traverse(this, getRoot(), refCollector);\n    symbolTable.addSymbolsFrom(refCollector);\n\n    PreprocessorSymbolTable preprocessorSymbolTable =\n        ensureDefaultPassConfig().getPreprocessorSymbolTable();\n    if (preprocessorSymbolTable != null) {\n      symbolTable.addSymbolsFrom(preprocessorSymbolTable);\n    }\n\n    symbolTable.fillNamespaceReferences();\n    symbolTable.fillPropertyScopes();\n    symbolTable.fillThisReferences(this, externsRoot, jsRoot);\n    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);\n\n    return symbolTable;\n  }\n\n  @Override\n  public Scope getTopScope() {\n    return getPassConfig().getTopScope();\n  }\n\n  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }\n\n  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }\n\n  //------------------------------------------------------------------------\n  // Parsing\n  //------------------------------------------------------------------------\n\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n\n  /**\n   * Transforms AMD and CJS modules to something closure compiler can\n   * process and creates JSModules and the corresponding dependency tree\n   * on the way.\n   */\n  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n      if (!modules.isEmpty()) {\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }\n\n  public Node parse(SourceFile file) {\n    initCompilerOptionsIfTesting();\n    addToDebugLog(\"Parsing: \" + file.getName());\n    return new JsAst(file).getAstRoot(this);\n  }\n\n  private int syntheticCodeId = 0;\n\n  @Override\n  Node parseSyntheticCode(String js) {\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  /**\n   * Allow subclasses to override the default CompileOptions object.\n   */\n  protected CompilerOptions newCompilerOptions() {\n    return new CompilerOptions();\n  }\n\n  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(newCompilerOptions());\n    }\n  }\n\n  @Override\n  Node parseSyntheticCode(String fileName, String js) {\n    initCompilerOptionsIfTesting();\n    return parse(SourceFile.fromCode(fileName, js));\n  }\n\n  @Override\n  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\"[testcode]\", js));\n    if (inputsById == null) {\n      inputsById = Maps.newHashMap();\n    }\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }\n\n  //------------------------------------------------------------------------\n  // Convert back to source code\n  //------------------------------------------------------------------------\n\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource() {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for each input back to js code.\n   */\n  public String[] toSourceArray() {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        Tracer tracer = newTracer(\"toSourceArray\");\n        try {\n          int numInputs = inputs.size();\n          String[] sources = new String[numInputs];\n          CodeBuilder cb = new CodeBuilder();\n          for (int i = 0; i < numInputs; i++) {\n            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n            cb.reset();\n            toSource(cb, i, scriptNode);\n            sources[i] = cb.toString();\n          }\n          return sources;\n        } finally {\n          stopTracer(tracer, \"toSourceArray\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module) {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return \"\";\n        }\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module: \" + module.getName());\n          }\n          toSource(cb, i, scriptNode);\n        }\n        return cb.toString();\n      }\n    });\n  }\n\n\n  /**\n   * Converts the parse tree for each input in a module back to js code.\n   */\n  public String[] toSourceArray(final JSModule module) {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return new String[0];\n        }\n\n        String[] sources = new String[numInputs];\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module input: \" + inputs.get(i).getName());\n          }\n\n          cb.reset();\n          toSource(cb, i, scriptNode);\n          sources[i] = cb.toString();\n        }\n        return sources;\n      }\n    });\n  }\n\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n      @Override\n      public Void call() throws Exception {\n        if (options.printInputDelimiter) {\n          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            cb.append(\"\\n\");  // Make sure that the label starts on a new line\n          }\n          Preconditions.checkState(root.isScript());\n\n          String delimiter = options.inputDelimiter;\n\n          String inputName = root.getInputId().getIdName();\n          String sourceName = root.getSourceFileName();\n          Preconditions.checkState(sourceName != null);\n          Preconditions.checkState(!sourceName.isEmpty());\n\n          delimiter = delimiter\n              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))\n              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n          cb.append(delimiter)\n            .append(\"\\n\");\n        }\n        if (root.getJSDocInfo() != null &&\n            root.getJSDocInfo().getLicense() != null) {\n          cb.append(\"/*\\n\")\n            .append(root.getJSDocInfo().getLicense())\n            .append(\"*/\\n\");\n        }\n\n        // If there is a valid source map, then indicate to it that the current\n        // root node's mappings are offset by the given string builder buffer.\n        if (options.sourceMapOutputPath != null) {\n          sourceMap.setStartingPosition(\n              cb.getLineIndex(), cb.getColumnIndex());\n        }\n\n        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n        // for the first input file\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n        if (!code.isEmpty()) {\n          cb.append(code);\n\n          // In order to avoid parse ambiguity when files are concatenated\n          // together, all files should end in a semi-colon. Do a quick\n          // heuristic check if there's an obvious semi-colon already there.\n          int length = code.length();\n          char lastChar = code.charAt(length - 1);\n          char secondLastChar = length >= 2 ?\n              code.charAt(length - 2) : '\\0';\n          boolean hasSemiColon = lastChar == ';' ||\n              (lastChar == '\\n' && secondLastChar == ';');\n          if (!hasSemiColon) {\n            cb.append(\";\");\n          }\n        }\n        return null;\n      }\n    });\n  }\n\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n  }\n\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }\n\n  /**\n   * Stores a buffer of text to which more can be appended.  This is just like a\n   * StringBuilder except that we also track the number of lines.\n   */\n  public static class CodeBuilder {\n    private final StringBuilder sb = new StringBuilder();\n    private int lineCount = 0;\n    private int colCount = 0;\n\n    /** Removes all text, but leaves the line count unchanged. */\n    void reset() {\n      sb.setLength(0);\n    }\n\n    /** Appends the given string to the text buffer. */\n    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }\n\n    /** Returns all text in the text buffer. */\n    @Override\n    public String toString() {\n      return sb.toString();\n    }\n\n    /** Returns the length of the text buffer. */\n    public int getLength() {\n      return sb.length();\n    }\n\n    /** Returns the (zero-based) index of the last line in the text buffer. */\n    int getLineIndex() {\n      return lineCount;\n    }\n\n    /** Returns the (zero-based) index of the last column in the text buffer. */\n    int getColumnIndex() {\n      return colCount;\n    }\n\n    /** Determines whether the text ends with the given suffix. */\n    boolean endsWith(String suffix) {\n      return (sb.length() > suffix.length())\n          && suffix.equals(sb.substring(sb.length() - suffix.length()));\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Optimizations\n  //------------------------------------------------------------------------\n\n  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }\n\n  @Override\n  void setCssRenamingMap(CssRenamingMap map) {\n    options.cssRenamingMap = map;\n  }\n\n  @Override\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }\n\n  /**\n   * Reprocesses the current defines over the AST.  This is used by GwtCompiler\n   * to generate N outputs for different targets from the same (checked) AST.\n   * For each target, we apply the target-specific defines by calling\n   * {@code processDefines} and then {@code optimize} to optimize the AST\n   * specifically for that target.\n   */\n  public void processDefines() {\n    (new DefaultPassConfig(options)).processDefines.create(this)\n        .process(externsRoot, jsRoot);\n  }\n\n  boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }\n\n  /** Control Flow Analysis. */\n  ControlFlowGraph<Node> computeCFG() {\n    logger.fine(\"Computing Control Flow Graph\");\n    Tracer tracer = newTracer(\"computeCFG\");\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n    process(cfa);\n    stopTracer(tracer, \"computeCFG\");\n    return cfa.getCfg();\n  }\n\n  public void normalize() {\n    logger.fine(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }\n\n  @Override\n  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }\n\n  void recordFunctionInformation() {\n    logger.fine(\"Recording function information\");\n    startPass(\"recordFunctionInformation\");\n    RecordFunctionInformation recordFunctionInfoPass =\n        new RecordFunctionInformation(\n            this, getPassConfig().getIntermediateState().functionNames);\n    process(recordFunctionInfoPass);\n    functionInformationMap = recordFunctionInfoPass.getMap();\n    endPass();\n  }\n\n  protected final CodeChangeHandler.RecentChange recentChange =\n      new CodeChangeHandler.RecentChange();\n  private final List<CodeChangeHandler> codeChangeHandlers =\n      Lists.<CodeChangeHandler>newArrayList();\n\n  /** Name of the synthetic input that holds synthesized externs. */\n  static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\";\n\n  private CompilerInput synthesizedExternsInput = null;\n\n  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }\n\n  @Override\n  void removeChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.remove(handler);\n  }\n\n  /**\n   * All passes should call reportCodeChange() when they alter\n   * the JS tree structure. This is verified by CompilerTestCase.\n   * This allows us to optimize to a fixed point.\n   */\n  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }\n\n  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }\n\n  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }\n\n  @Override\n  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n    }\n    return false;\n  }\n\n  public LanguageMode languageMode() {\n    return options.getLanguageIn();\n  }\n\n  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }\n\n  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }\n\n  @Override\n  public boolean isTypeCheckingEnabled() {\n    return options.checkTypes;\n  }\n\n\n  //------------------------------------------------------------------------\n  // Error reporting\n  //------------------------------------------------------------------------\n\n  /**\n   * The warning classes that are available from the command-line, and\n   * are suppressable by the {@code @suppress} annotation.\n   */\n  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }\n\n  @Override\n  public void report(JSError error) {\n    CheckLevel level = error.getDefaultLevel();\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      if (getOptions().errorHandler != null) {\n        getOptions().errorHandler.report(level, error);\n      }\n      errorManager.report(level, error);\n    }\n  }\n\n  @Override\n  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }\n\n  /**\n   * Report an internal error.\n   */\n  @Override\n  void throwInternalError(String message, Exception cause) {\n    String finalMessage =\n      \"INTERNAL COMPILER ERROR.\\n\" +\n      \"Please report this problem.\\n\" + message;\n\n    RuntimeException e = new RuntimeException(finalMessage, cause);\n    if (cause != null) {\n      e.setStackTrace(cause.getStackTrace());\n    }\n    throw e;\n  }\n\n\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }\n\n  /**\n   * Gets the number of warnings.\n   */\n  public int getWarningCount() {\n    return errorManager.getWarningCount();\n  }\n\n  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }\n\n  /**\n   * Consults the {@link ErrorManager} to see if we've encountered errors\n   * that should halt compilation. <p>\n   *\n   * If {@link CompilerOptions#ideMode} is {@code true}, this function\n   * always returns {@code false} without consulting the error manager. The\n   * error manager will continue to be told about new errors and warnings, but\n   * the compiler will complete compilation of all inputs.<p>\n   */\n  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }\n\n  /** Called from the compiler passes, adds debug info */\n  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }\n\n  private SourceFile getSourceFileByName(String sourceName) {\n    // Here we assume that the source name is the input name, this\n    // is try of javascript parsed from source.\n    if (sourceName != null) {\n      CompilerInput input = inputsById.get(new InputId(sourceName));\n      if (input != null) {\n        return input.getSourceFile();\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }\n\n  @Override\n  public Region getSourceRegion(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getRegion(lineNumber);\n    }\n    return null;\n  }\n\n  //------------------------------------------------------------------------\n  // Package-private helpers\n  //------------------------------------------------------------------------\n\n  @Override\n  Node getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n      if (inputs.isEmpty()) {\n        throw new IllegalStateException(\"No inputs\");\n      }\n\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    List<CompilerInput> moduleInputs = module.getInputs();\n    if (moduleInputs.size() > 0) {\n      return moduleInputs.get(0).getAstRoot(this);\n    }\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }\n\n  public SourceMap getSourceMap() {\n    return sourceMap;\n  }\n\n  VariableMap getVariableMap() {\n    return getPassConfig().getIntermediateState().variableMap;\n  }\n\n  VariableMap getPropertyMap() {\n    return getPassConfig().getIntermediateState().propertyMap;\n  }\n\n  CompilerOptions getOptions() {\n    return options;\n  }\n\n  FunctionInformationMap getFunctionalInformationMap() {\n    return functionInformationMap;\n  }\n\n  /**\n   * Sets the logging level for the com.google.javascript.jscomp package.\n   */\n  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }\n\n  /** Gets the DOT graph of the AST generated at the end of compilation. */\n  public String getAstDotGraph() throws IOException {\n    if (jsRoot != null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n      cfa.process(null, jsRoot);\n      return DotFormatter.toDot(jsRoot, cfa.getCfg());\n    } else {\n      return \"\";\n    }\n  }\n\n  @Override\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(newCompilerOptions());\n    }\n    return errorManager;\n  }\n\n  @Override\n  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }\n\n  /**\n   * Returns an unmodifiable view of the compiler inputs indexed by id.\n   */\n  public Map<InputId, CompilerInput> getInputsById() {\n    return Collections.unmodifiableMap(inputsById);\n  }\n\n  /**\n   * Gets the externs in the order in which they are being processed.\n   */\n  List<CompilerInput> getExternsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(externs);\n  }\n\n  /**\n   * Stores the internal compiler state just before optimization is performed.\n   * This can be saved and restored in order to efficiently optimize multiple\n   * different output targets without having to perform checking multiple times.\n   *\n   * NOTE: This does not include all parts of the compiler's internal state. In\n   * particular, SourceFiles and CompilerOptions are not recorded. In\n   * order to recreate a Compiler instance from scratch, you would need to\n   * call {@code init} with the same arguments as in the initial creation before\n   * restoring intermediate state.\n   */\n  public static class IntermediateState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    Node externsRoot;\n    private Node jsRoot;\n    private List<CompilerInput> externs;\n    private List<CompilerInput> inputs;\n    private List<JSModule> modules;\n    private PassConfig.State passConfigState;\n    private JSTypeRegistry typeRegistry;\n    private AbstractCompiler.LifeCycleStage lifeCycleStage;\n    private Map<String, Node> injectedLibraries;\n\n    private IntermediateState() {}\n  }\n\n  /**\n   * Returns the current internal state, excluding the input files and modules.\n   */\n  public IntermediateState getState() {\n    IntermediateState state = new IntermediateState();\n    state.externsRoot = externsRoot;\n    state.jsRoot = jsRoot;\n    state.externs = externs;\n    state.inputs = inputs;\n    state.modules = modules;\n    state.passConfigState = getPassConfig().getIntermediateState();\n    state.typeRegistry = typeRegistry;\n    state.lifeCycleStage = getLifeCycleStage();\n    state.injectedLibraries = Maps.newLinkedHashMap(injectedLibraries);\n\n    return state;\n  }\n\n  /**\n   * Sets the internal state to the capture given.  Note that this assumes that\n   * the input files are already set up.\n   */\n  public void setState(IntermediateState state) {\n    externsRoot = state.externsRoot;\n    jsRoot = state.jsRoot;\n    externs = state.externs;\n    inputs = state.inputs;\n    modules = state.modules;\n    passes = createPassConfigInternal();\n    getPassConfig().setIntermediateState(state.passConfigState);\n    typeRegistry = state.typeRegistry;\n    setLifeCycleStage(state.lifeCycleStage);\n\n    injectedLibraries.clear();\n    injectedLibraries.putAll(state.injectedLibraries);\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getInputsForTesting() {\n    return inputs;\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getExternsForTesting() {\n    return externs;\n  }\n\n  @Override\n  boolean hasRegExpGlobalReferences() {\n    return hasRegExpGlobalReferences;\n  }\n\n  @Override\n  void setHasRegExpGlobalReferences(boolean references) {\n    hasRegExpGlobalReferences = references;\n  }\n\n  @Override\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.isScript()\n        || collectionRoot.isBlock());\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n          getExternsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }\n\n  @Override\n  GlobalVarReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }\n\n  @Override\n  CompilerInput getSynthesizedExternsInput() {\n    if (synthesizedExternsInput == null) {\n      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);\n    }\n    return synthesizedExternsInput;\n  }\n\n  @Override\n  public double getProgress() {\n    return progress;\n  }\n\n  @Override\n  void setProgress(double newProgress) {\n    if (newProgress > 1.0) {\n      progress = 1.0;\n    } else if (newProgress < 0.0) {\n      progress = 0.0;\n    } else {\n      progress = newProgress;\n    }\n  }\n\n  /**\n   * Replaces one file in a hot-swap mode. The given JsAst should be made\n   * from a new version of a file that already was present in the last compile\n   * call. If the file is new, this will silently ignored.\n   *\n   * @param ast the ast of the file that is being replaced\n   */\n  public void replaceScript(JsAst ast) {\n    CompilerInput input = this.getInput(ast.getInputId());\n    if (!replaceIncrementalSourceAst(ast)) {\n      return;\n    }\n    Node originalRoot = input.getAstRoot(this);\n\n    processNewScript(ast, originalRoot);\n  }\n\n  /**\n   * Adds a new Script AST to the compile state. If a script for the same file\n   * already exists the script will not be added, instead a call to\n   * #replaceScript should be used.\n   *\n   * @param ast the ast of the new file\n   */\n  public void addNewScript(JsAst ast) {\n    if (!addNewSourceAst(ast)) {\n      return;\n    }\n    Node emptyScript = new Node(Token.SCRIPT);\n    InputId inputId = ast.getInputId();\n    emptyScript.setInputId(inputId);\n    emptyScript.setStaticSourceFile(\n        SourceFile.fromCode(inputId.getIdName(), \"\"));\n\n    processNewScript(ast, emptyScript);\n  }\n\n  private void processNewScript(JsAst ast, Node originalRoot) {\n    Node js = ast.getAstRoot(this);\n    Preconditions.checkNotNull(js);\n\n    runHotSwap(originalRoot, js, this.getCleanupPassConfig());\n    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need\n    // to revisit this approach to clearing GlobalNamespaces\n    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);\n\n    this.getTypeRegistry().clearNamedTypes();\n    this.removeSyntheticVarsInput();\n\n    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());\n  }\n\n  /**\n   * Execute the passes from a PassConfig instance over a single replaced file.\n   */\n  private void runHotSwap(\n      Node originalRoot, Node js, PassConfig passConfig) {\n    for (PassFactory passFactory : passConfig.getChecks()) {\n      runHotSwapPass(originalRoot, js, passFactory);\n    }\n  }\n\n  private void runHotSwapPass(\n      Node originalRoot, Node js, PassFactory passFactory) {\n    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);\n    if (pass != null) {\n      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());\n      pass.hotSwapScript(js, originalRoot);\n    }\n  }\n\n  private PassConfig getCleanupPassConfig() {\n    return new CleanupPasses(getOptions());\n  }\n\n  private void removeSyntheticVarsInput() {\n    String sourceName = Compiler.SYNTHETIC_EXTERNS;\n    removeExternInput(new InputId(sourceName));\n  }\n\n  @Override\n  Node ensureLibraryInjected(String resourceName) {\n    if (injectedLibraries.containsKey(resourceName)) {\n      return null;\n    }\n\n    // All libraries depend on js/base.js\n    boolean isBase = \"base\".equals(resourceName);\n    if (!isBase) {\n      ensureLibraryInjected(\"base\");\n    }\n\n    Node firstChild = loadLibraryCode(resourceName).removeChildren();\n    Node lastChild = firstChild.getLastSibling();\n\n    Node parent = getNodeForCodeInsertion(null);\n    if (isBase) {\n      parent.addChildrenToFront(firstChild);\n    } else {\n      parent.addChildrenAfter(\n          firstChild, injectedLibraries.get(\"base\"));\n    }\n    reportCodeChange();\n\n    injectedLibraries.put(resourceName, lastChild);\n    return lastChild;\n  }\n\n  /** Load a library as a resource */\n  @VisibleForTesting\n  Node loadLibraryCode(String resourceName) {\n    String originalCode;\n    try {\n      originalCode = CharStreams.toString(new InputStreamReader(\n          Compiler.class.getResourceAsStream(\n              String.format(\"js/%s.js\", resourceName)),\n          Charsets.UTF_8));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    return Normalize.parseAndNormalizeSyntheticCode(\n        this, originalCode,\n        String.format(\"jscomp_%s_\", resourceName));\n  }\n}\n"}, "generated_test_class": "Certainly! Below are unit tests designed to maximize both branch and line coverage for the `initOptions` method in the `Compiler` class. The tests cover various scenarios, including different configurations of `CompilerOptions` to exercise all branches in the method.\n\n```java\nimport com.google.javascript.jscomp.*;\nimport com.google.javascript.jscomp.CompilerOptions.LanguageMode;\nimport com.google.javascript.jscomp.CompilerOptions.WarningLevel;\nimport com.google.javascript.jscomp.DiagnosticGroups;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\n\nimport static org.junit.Assert.*;\n\npublic class CompilerTest {\n\n    private Compiler compiler;\n    private CompilerOptions options;\n    private PrintStream originalOut;\n\n    @Before\n    public void setUp() {\n        compiler = new Compiler();\n        options = new CompilerOptions();\n        originalOut = System.out;\n        System.setOut(new PrintStream(new ByteArrayOutputStream()));\n    }\n\n    @Test\n    public void testInitOptions_withDefaultOptions() {\n        compiler.initOptions(options);\n        assertNotNull(compiler.options);\n        assertNotNull(compiler.errorManager);\n        assertTrue(compiler.errorManager instanceof LoggerErrorManager);\n        assertNotNull(compiler.warningsGuard);\n    }\n\n    @Test\n    public void testInitOptions_withPrintStreamErrorManager() {\n        PrintStream printStream = new PrintStream(new ByteArrayOutputStream());\n        compiler.outStream = printStream;\n        compiler.initOptions(options);\n        assertNotNull(compiler.options);\n        assertNotNull(compiler.errorManager);\n        assertTrue(compiler.errorManager instanceof PrintStreamErrorManager);\n        assertEquals(options.summaryDetailLevel, ((PrintStreamErrorManager) compiler.errorManager).getSummaryDetailLevel());\n        assertNotNull(compiler.warningsGuard);\n    }\n\n    @Test\n    public void testInitOptions_withCheckTypesEnabled() {\n        options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.ERROR);\n        compiler.initOptions(options);\n        assertTrue(compiler.options.checkTypes);\n    }\n\n    @Test\n    public void testInitOptions_withCheckTypesDisabled() {\n        options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.OFF);\n        compiler.initOptions(options);\n        assertFalse(compiler.options.checkTypes);\n    }\n\n    @Test\n    public void testInitOptions_withCheckTypesNotSet() {\n        compiler.initOptions(options);\n        assertFalse(compiler.options.checkTypes);\n    }\n\n    @Test\n    public void testInitOptions_withCheckGlobalThisEnabled() {\n        options.setWarningLevel(DiagnosticGroups.GLOBAL_THIS, CheckLevel.ERROR);\n        compiler.initOptions(options);\n        assertEquals(CheckLevel.ERROR, compiler.options.checkGlobalThisLevel);\n    }\n\n    @Test\n    public void testInitOptions_withECMAScript5Strict() {\n        options.setLanguageIn(LanguageMode.ECMASCRIPT5_STRICT);\n        compiler.initOptions(options);\n        assertEquals(CheckLevel.ERROR, compiler.options.getWarningLevel(DiagnosticGroups.ES5_STRICT));\n    }\n\n    @Test\n    public void testInitOptions_withCheckSymbolsEnabled() {\n        options.checkSymbols = true;\n        compiler.initOptions(options);\n        assertFalse(compiler.warningsGuard.enables(DiagnosticGroups.CHECK_VARIABLES));\n    }\n\n    @Test\n    public void testInitOptions_withCheckSymbolsDisabled() {\n        options.checkSymbols = false;\n        compiler.initOptions(options);\n        assertTrue(compiler.warningsGuard.enables(DiagnosticGroups.CHECK_VARIABLES));\n    }\n\n    @Test\n    public void testInitOptions_withCustomWarningsGuard() {\n        WarningsGuard customGuard = new DiagnosticGroupWarningsGuard(DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF);\n        options.setWarningsGuard(customGuard);\n        compiler.initOptions(options);\n        assertNotNull(compiler.warningsGuard);\n        assertTrue(compiler.warningsGuard.getWarningsGuards().contains(customGuard));\n    }\n\n    @After\n    public void tearDown() {\n        System.setOut(originalOut);\n    }\n}\n```\n\n### Explanation of Test Cases:\n\n1. **testInitOptions_withDefaultOptions**: Tests the default initialization without any specific options set.\n2. **testInitOptions_withPrintStreamErrorManager**: Tests the initialization with a `PrintStreamErrorManager` when `outStream` is set.\n3. **testInitOptions_withCheckTypesEnabled**: Tests the initialization when `CHECK_TYPES` is enabled via `DiagnosticGroups`.\n4. **testInitOptions_withCheckTypesDisabled**: Tests the initialization when `CHECK_TYPES` is disabled via `DiagnosticGroups`.\n5. **testInitOptions_withCheckTypesNotSet**: Tests the initialization when `CHECK_TYPES` is not set via `DiagnosticGroups`.\n6. **testInitOptions_withCheckGlobalThisEnabled**: Tests the initialization when `checkGlobalThisLevel` is set.\n7. **testInitOptions_withECMAScript5Strict**: Tests the initialization when the language input is set to `ECMASCRIPT5_STRICT`.\n8. **testInitOptions_withCheckSymbolsEnabled**: Tests the initialization when `checkSymbols` is enabled.\n9. **testInitOptions_withCheckSymbolsDisabled**: Tests the initialization when `checkSymbols` is disabled.\n10. **testInitOptions_withCustomWarningsGuard**: Tests the initialization with a custom `WarningsGuard`.\n\nThese tests cover the various conditional branches in the `initOptions` method, ensuring a high degree of both branch and line coverage."}
{"bug_id": "Closure_31", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.Compiler#init(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "focal_method": "public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n    for (SourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }", "return_type": "void", "assertion_subject_candidates": ["JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "double com.google.javascript.jscomp.Compiler#getProgress()", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()"], "focal_class": {"name": "Compiler", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "superclass": "extends AbstractCompiler", "interface": "", "imports": ["import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.Charsets;", "import com.google.common.base.Preconditions;", "import com.google.common.base.Supplier;", "import com.google.common.base.Throwables;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.common.io.CharStreams;", "import com.google.javascript.jscomp.CompilerOptions.DevMode;", "import com.google.javascript.jscomp.CompilerOptions.LanguageMode;", "import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;", "import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;", "import com.google.javascript.jscomp.parsing.Config;", "import com.google.javascript.jscomp.parsing.ParserRunner;", "import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;", "import com.google.javascript.rhino.IR;", "import com.google.javascript.rhino.InputId;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import com.google.javascript.rhino.head.ErrorReporter;", "import com.google.javascript.rhino.jstype.JSTypeRegistry;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.PrintStream;", "import java.io.Serializable;", "import java.nio.charset.Charset;", "import java.util.Collections;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;", "import java.util.concurrent.Callable;", "import java.util.logging.Level;", "import java.util.logging.Logger;", "import java.util.regex.Matcher;"], "fields": ["static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions options = null", "private PassConfig passes = null", "private List<CompilerInput> externs", "private List<JSModule> modules", "private JSModuleGraph moduleGraph", "private List<CompilerInput> inputs", "private ErrorManager errorManager", "private WarningsGuard warningsGuard", "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node externsRoot", "Node jsRoot", "Node externAndJsRoot", "private Map<InputId, CompilerInput> inputsById", "private SourceMap sourceMap", "private String externExports = null", "private int uniqueNameId = 0", "private boolean useThreads = true", "private boolean hasRegExpGlobalReferences = true", "private FunctionInformationMap functionInformationMap", "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "private JSTypeRegistry typeRegistry", "private Config parserConfig = null", "private ReverseAbstractInterpreter abstractInterpreter", "private TypeValidator typeValidator", "public PerformanceTracker tracker", "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "private static final long COMPILER_STACK_SIZE = 1048576L", "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "private final PrintStream outStream", "private GlobalVarReferenceMap globalRefMap = null", "private volatile double progress = 0.0", "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "private Tracer currentTracer = null", "private String currentPassName = null", "private int syntheticCodeId = 0", "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "private CompilerInput synthesizedExternsInput = null"], "methods": ["void com.google.javascript.jscomp.Compiler#setErrorManager(ErrorManager#errorManager)", "MessageFormatter com.google.javascript.jscomp.Compiler#createMessageFormatter()", "void com.google.javascript.jscomp.Compiler#initOptions(CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initBasedOnOptions()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#makeCompilerInput(List<T>#files,boolean#isExtern)", "void com.google.javascript.jscomp.Compiler#checkFirstModule(List<JSModule>#modules)", "String com.google.javascript.jscomp.Compiler#createFillFileName(String#moduleName)", "void com.google.javascript.jscomp.Compiler#fillEmptyModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#rebuildInputsFromModules()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getAllInputsFromModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#initInputsByIdMap()", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,SourceFile#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,JSSourceFile[]#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile#extern,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compileModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile()", "void com.google.javascript.jscomp.Compiler#disableThreads()", "T com.google.javascript.jscomp.Compiler#runInCompilerThread(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallableWithLargeStack(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallable(Callable<T>#callable,boolean#useLargeStackThread,boolean#trace)", "void com.google.javascript.jscomp.Compiler#compileInternal()", "void com.google.javascript.jscomp.Compiler#parse()", "PassConfig com.google.javascript.jscomp.Compiler#getPassConfig()", "PassConfig com.google.javascript.jscomp.Compiler#createPassConfigInternal()", "void com.google.javascript.jscomp.Compiler#setPassConfig(PassConfig#passes)", "boolean com.google.javascript.jscomp.Compiler#precheck()", "void com.google.javascript.jscomp.Compiler#check()", "void com.google.javascript.jscomp.Compiler#externExports()", "void com.google.javascript.jscomp.Compiler#process(CompilerPass#p)", "void com.google.javascript.jscomp.Compiler#maybeSanityCheck()", "void com.google.javascript.jscomp.Compiler#runSanityCheck()", "void com.google.javascript.jscomp.Compiler#removeTryCatchFinally()", "void com.google.javascript.jscomp.Compiler#stripCode(Set<String>#stripTypes,Set<String>#stripNameSuffixes,Set<String>#stripTypePrefixes,Set<String>#stripNamePrefixes)", "void com.google.javascript.jscomp.Compiler#runCustomPasses(CustomPassExecutionTime#executionTime)", "void com.google.javascript.jscomp.Compiler#startPass(String#passName)", "void com.google.javascript.jscomp.Compiler#endPass()", "Tracer com.google.javascript.jscomp.Compiler#newTracer(String#passName)", "void com.google.javascript.jscomp.Compiler#stopTracer(Tracer#t,String#passName)", "Result com.google.javascript.jscomp.Compiler#getResult()", "JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "int com.google.javascript.jscomp.Compiler#nextUniqueNameId()", "void com.google.javascript.jscomp.Compiler#resetUniqueNameId()", "Supplier<String> com.google.javascript.jscomp.Compiler#getUniqueNameIdSupplier()", "boolean com.google.javascript.jscomp.Compiler#areNodesEqualForInlining(Node#n1,Node#n2)", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "void com.google.javascript.jscomp.Compiler#removeExternInput(InputId#id)", "CompilerInput com.google.javascript.jscomp.Compiler#newExternInput(String#name)", "CompilerInput com.google.javascript.jscomp.Compiler#putCompilerInput(InputId#id,CompilerInput#input)", "void com.google.javascript.jscomp.Compiler#addIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#replaceIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#addNewSourceAst(JsAst#ast)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "JSTypeRegistry com.google.javascript.jscomp.Compiler#getTypeRegistry()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "DefaultPassConfig com.google.javascript.jscomp.Compiler#ensureDefaultPassConfig()", "SymbolTable com.google.javascript.jscomp.Compiler#buildKnownSymbolTable()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ReverseAbstractInterpreter com.google.javascript.jscomp.Compiler#getReverseAbstractInterpreter()", "TypeValidator com.google.javascript.jscomp.Compiler#getTypeValidator()", "Node com.google.javascript.jscomp.Compiler#parseInputs()", "void com.google.javascript.jscomp.Compiler#processAMDAndCommonJSModules()", "Node com.google.javascript.jscomp.Compiler#parse(SourceFile#file)", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#js)", "CompilerOptions com.google.javascript.jscomp.Compiler#newCompilerOptions()", "void com.google.javascript.jscomp.Compiler#initCompilerOptionsIfTesting()", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#fileName,String#js)", "Node com.google.javascript.jscomp.Compiler#parseTestCode(String#js)", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "String com.google.javascript.jscomp.Compiler#toSource()", "String[] com.google.javascript.jscomp.Compiler#toSourceArray()", "String com.google.javascript.jscomp.Compiler#toSource(JSModule#module)", "String[] com.google.javascript.jscomp.Compiler#toSourceArray(JSModule#module)", "void com.google.javascript.jscomp.Compiler#toSource(CodeBuilder#cb,int#inputSeqNum,Node#root)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n,SourceMap#sourceMap,boolean#firstOutput)", "void com.google.javascript.jscomp.Compiler#optimize()", "void com.google.javascript.jscomp.Compiler#setCssRenamingMap(CssRenamingMap#map)", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "void com.google.javascript.jscomp.Compiler#processDefines()", "boolean com.google.javascript.jscomp.Compiler#isInliningForbidden()", "ControlFlowGraph<Node> com.google.javascript.jscomp.Compiler#computeCFG()", "void com.google.javascript.jscomp.Compiler#normalize()", "void com.google.javascript.jscomp.Compiler#prepareAst(Node#root)", "void com.google.javascript.jscomp.Compiler#recordFunctionInformation()", "void com.google.javascript.jscomp.Compiler#addChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#removeChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#reportCodeChange()", "CodingConvention com.google.javascript.jscomp.Compiler#getCodingConvention()", "boolean com.google.javascript.jscomp.Compiler#isIdeMode()", "boolean com.google.javascript.jscomp.Compiler#acceptEcmaScript5()", "LanguageMode com.google.javascript.jscomp.Compiler#languageMode()", "boolean com.google.javascript.jscomp.Compiler#acceptConstKeyword()", "Config com.google.javascript.jscomp.Compiler#getParserConfig()", "boolean com.google.javascript.jscomp.Compiler#isTypeCheckingEnabled()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "void com.google.javascript.jscomp.Compiler#report(JSError#error)", "CheckLevel com.google.javascript.jscomp.Compiler#getErrorLevel(JSError#error)", "void com.google.javascript.jscomp.Compiler#throwInternalError(String#message,Exception#cause)", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "boolean com.google.javascript.jscomp.Compiler#hasHaltingErrors()", "boolean com.google.javascript.jscomp.Compiler#hasErrors()", "void com.google.javascript.jscomp.Compiler#addToDebugLog(String#str)", "SourceFile com.google.javascript.jscomp.Compiler#getSourceFileByName(String#sourceName)", "String com.google.javascript.jscomp.Compiler#getSourceLine(String#sourceName,int#lineNumber)", "Region com.google.javascript.jscomp.Compiler#getSourceRegion(String#sourceName,int#lineNumber)", "Node com.google.javascript.jscomp.Compiler#getNodeForCodeInsertion(JSModule#module)", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "void com.google.javascript.jscomp.Compiler#setLoggingLevel(Level#level)", "String com.google.javascript.jscomp.Compiler#getAstDotGraph()", "ErrorManager com.google.javascript.jscomp.Compiler#getErrorManager()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "IntermediateState com.google.javascript.jscomp.Compiler#getState()", "void com.google.javascript.jscomp.Compiler#setState(IntermediateState#state)", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "boolean com.google.javascript.jscomp.Compiler#hasRegExpGlobalReferences()", "void com.google.javascript.jscomp.Compiler#setHasRegExpGlobalReferences(boolean#references)", "void com.google.javascript.jscomp.Compiler#updateGlobalVarReferences(Map<Var, ReferenceCollection>#refMapPatch,Node#collectionRoot)", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "CompilerInput com.google.javascript.jscomp.Compiler#getSynthesizedExternsInput()", "double com.google.javascript.jscomp.Compiler#getProgress()", "void com.google.javascript.jscomp.Compiler#setProgress(double#newProgress)", "void com.google.javascript.jscomp.Compiler#replaceScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#addNewScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#processNewScript(JsAst#ast,Node#originalRoot)", "void com.google.javascript.jscomp.Compiler#runHotSwap(Node#originalRoot,Node#js,PassConfig#passConfig)", "void com.google.javascript.jscomp.Compiler#runHotSwapPass(Node#originalRoot,Node#js,PassFactory#passFactory)", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()", "void com.google.javascript.jscomp.Compiler#removeSyntheticVarsInput()", "Node com.google.javascript.jscomp.Compiler#ensureLibraryInjected(String#resourceName)", "Node com.google.javascript.jscomp.Compiler#loadLibraryCode(String#resourceName)"], "other_methods": ["public void setErrorManager(ErrorManager errorManager);", "public void initOptions(CompilerOptions options);", "public void init(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public void init(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public void initModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void rebuildInputsFromModules();", "public Result compile(SourceFile extern,SourceFile input,CompilerOptions options);", "public Result compile(SourceFile extern,JSSourceFile[] input,CompilerOptions options);", "public Result compile(JSSourceFile extern,JSModule[] modules,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public Result compile(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public Result compileModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void disableThreads();", "public void parse();", "public void setPassConfig(PassConfig passes);", "public void check();", "public Result getResult();", "public JSError[] getMessages();", "public JSError[] getErrors();", "public JSError[] getWarnings();", "@Override\n  public Node getRoot();", "@Override\n  public CompilerInput getInput(InputId id);", "@Override\n  public CompilerInput newExternInput(String name);", "@Override\n  public JSTypeRegistry getTypeRegistry();", "@Override\n  public MemoizedScopeCreator getTypedScopeCreator();", "public SymbolTable buildKnownSymbolTable();", "@Override\n  public Scope getTopScope();", "@Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter();", "public Node parse(SourceFile file);", "public String toSource();", "public String[] toSourceArray();", "public String toSource(JSModule module);", "public String[] toSourceArray(JSModule module);", "public void toSource(CodeBuilder cb,int inputSeqNum,Node root);", "public void optimize();", "public void processDefines();", "public void normalize();", "@Override\n  public void reportCodeChange();", "@Override\n  public CodingConvention getCodingConvention();", "@Override\n  public boolean isIdeMode();", "@Override\n  public boolean acceptEcmaScript5();", "public LanguageMode languageMode();", "@Override\n  public boolean acceptConstKeyword();", "@Override\n  public boolean isTypeCheckingEnabled();", "@Override\n  public void report(JSError error);", "@Override\n  public CheckLevel getErrorLevel(JSError error);", "public int getErrorCount();", "public int getWarningCount();", "public boolean hasErrors();", "@Override\n  public String getSourceLine(String sourceName,int lineNumber);", "@Override\n  public Region getSourceRegion(String sourceName,int lineNumber);", "public SourceMap getSourceMap();", "public static void setLoggingLevel(Level level);", "public String getAstDotGraph();", "@Override\n  public ErrorManager getErrorManager();", "public Map<InputId, CompilerInput> getInputsById();", "public IntermediateState getState();", "public void setState(IntermediateState state);", "@Override\n  public double getProgress();", "public void replaceScript(JsAst ast);", "public void addNewScript(JsAst ast);"], "fields_dict": {"String#SINGLETON_MODULE_NAME": "static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "DiagnosticType#MODULE_DEPENDENCY_ERROR": "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "DiagnosticType#MISSING_ENTRY_ERROR": "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions#options": "CompilerOptions options = null", "PassConfig#passes": "private PassConfig passes = null", "List<CompilerInput>#externs": "private List<CompilerInput> externs", "List<JSModule>#modules": "private List<JSModule> modules", "JSModuleGraph#moduleGraph": "private JSModuleGraph moduleGraph", "List<CompilerInput>#inputs": "private List<CompilerInput> inputs", "ErrorManager#errorManager": "private ErrorManager errorManager", "WarningsGuard#warningsGuard": "private WarningsGuard warningsGuard", "Map<String, Node>#injectedLibraries": "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node#externsRoot": "Node externsRoot", "Node#jsRoot": "Node jsRoot", "Node#externAndJsRoot": "Node externAndJsRoot", "Map<InputId, CompilerInput>#inputsById": "private Map<InputId, CompilerInput> inputsById", "SourceMap#sourceMap": "private SourceMap sourceMap", "String#externExports": "private String externExports = null", "int#uniqueNameId": "private int uniqueNameId = 0", "boolean#useThreads": "private boolean useThreads = true", "boolean#hasRegExpGlobalReferences": "private boolean hasRegExpGlobalReferences = true", "FunctionInformationMap#functionInformationMap": "private FunctionInformationMap functionInformationMap", "StringBuilder#debugLog": "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention#defaultCodingConvention": "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "JSTypeRegistry#typeRegistry": "private JSTypeRegistry typeRegistry", "Config#parserConfig": "private Config parserConfig = null", "ReverseAbstractInterpreter#abstractInterpreter": "private ReverseAbstractInterpreter abstractInterpreter", "TypeValidator#typeValidator": "private TypeValidator typeValidator", "PerformanceTracker#tracker": "public PerformanceTracker tracker", "com.google.javascript.rhino.ErrorReporter#oldErrorReporter": "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "ErrorReporter#defaultErrorReporter": "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "DiagnosticType#OPTIMIZE_LOOP_ERROR": "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "DiagnosticType#MOTION_ITERATIONS_ERROR": "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "long#COMPILER_STACK_SIZE": "private static final long COMPILER_STACK_SIZE = 1048576L", "Logger#logger": "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "PrintStream#outStream": "private final PrintStream outStream", "GlobalVarReferenceMap#globalRefMap": "private GlobalVarReferenceMap globalRefMap = null", "double#progress": "private volatile double progress = 0.0", "DiagnosticType#EMPTY_MODULE_LIST_ERROR": "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "DiagnosticType#EMPTY_ROOT_MODULE_ERROR": "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "DiagnosticType#DUPLICATE_INPUT": "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "DiagnosticType#DUPLICATE_EXTERN_INPUT": "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "PassFactory#sanityCheck": "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "Tracer#currentTracer": "private Tracer currentTracer = null", "String#currentPassName": "private String currentPassName = null", "int#syntheticCodeId": "private int syntheticCodeId = 0", "CodeChangeHandler.RecentChange#recentChange": "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "List<CodeChangeHandler>#codeChangeHandlers": "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "String#SYNTHETIC_EXTERNS": "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "CompilerInput#synthesizedExternsInput": "private CompilerInput synthesizedExternsInput = null"}, "text": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Charsets;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.io.CharStreams;\nimport com.google.javascript.jscomp.CompilerOptions.DevMode;\nimport com.google.javascript.jscomp.CompilerOptions.LanguageMode;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\nimport com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\nimport com.google.javascript.jscomp.parsing.Config;\nimport com.google.javascript.jscomp.parsing.ParserRunner;\nimport com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.head.ErrorReporter;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\n\n/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  static final String SINGLETON_MODULE_NAME = \"[singleton]\";\n\n  static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\");\n\n  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\");\n\n  CompilerOptions options = null;\n\n  private PassConfig passes = null;\n\n  // The externs inputs\n  private List<CompilerInput> externs;\n\n  // The JS source modules\n  private List<JSModule> modules;\n\n  // The graph of the JS source modules. Must be null if there are less than\n  // 2 modules, because we use this as a signal for which passes to run.\n  private JSModuleGraph moduleGraph;\n\n  // The JS source inputs\n  private List<CompilerInput> inputs;\n\n  // error manager to which error management is delegated\n  private ErrorManager errorManager;\n\n  // Warnings guard for filtering warnings.\n  private WarningsGuard warningsGuard;\n\n  // Compile-time injected libraries. The node points to the last node of\n  // the library, so code can be inserted after.\n  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n\n  // Parse tree root nodes\n  Node externsRoot;\n  Node jsRoot;\n  Node externAndJsRoot;\n\n  private Map<InputId, CompilerInput> inputsById;\n\n  /** The source code map */\n  private SourceMap sourceMap;\n\n  /** The externs created from the exports.  */\n  private String externExports = null;\n\n  /**\n   * Ids for function inlining so that each declared name remains\n   * unique.\n   */\n  private int uniqueNameId = 0;\n\n  /** Whether to use threads. */\n  private boolean useThreads = true;\n\n  /**\n   * Whether to assume there are references to the RegExp Global object\n   * properties.\n   */\n  private boolean hasRegExpGlobalReferences = true;\n\n  /** The function information map */\n  private FunctionInformationMap functionInformationMap;\n\n  /** Debugging information */\n  private final StringBuilder debugLog = new StringBuilder();\n\n  /** Detects Google-specific coding conventions. */\n  CodingConvention defaultCodingConvention = new ClosureCodingConvention();\n\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n\n  public PerformanceTracker tracker;\n\n  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.\n  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =\n      RhinoErrorReporter.forOldRhino(this);\n\n  // This error reporter gets the messages from the current Rhino parser.\n  private final ErrorReporter defaultErrorReporter =\n      RhinoErrorReporter.forNewRhino(this);\n\n  /** Error strings used for reporting JSErrors */\n  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\");\n  public static final DiagnosticType MOTION_ITERATIONS_ERROR =\n      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\");\n\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n\n\n  /**\n   * Logger for the whole com.google.javascript.jscomp domain -\n   * setting configuration for this logger affects all loggers\n   *  in other classes within the compiler.\n   */\n  private static final Logger logger =\n      Logger.getLogger(\"com.google.javascript.jscomp\");\n\n  private final PrintStream outStream;\n\n  private GlobalVarReferenceMap globalRefMap = null;\n\n  private volatile double progress = 0.0;\n\n  /**\n   * Creates a Compiler that reports errors and warnings to its logger.\n   */\n  public Compiler() {\n    this((PrintStream) null);\n  }\n\n  /**\n   * Creates n Compiler that reports errors and warnings to an output\n   * stream.\n   */\n  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }\n\n  /**\n   * Creates a Compiler that uses a custom error manager.\n   */\n  public Compiler(ErrorManager errorManager) {\n    this();\n    setErrorManager(errorManager);\n  }\n\n  /**\n   * Sets the error manager.\n   *\n   * @param errorManager the error manager, it cannot be {@code null}\n   */\n  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }\n\n  /**\n   * Creates a message formatter instance corresponding to the value of\n   * {@link CompilerOptions}.\n   */\n  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }\n\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    init(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n    for (SourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options) {\n    initModules(Lists.<SourceFile>newArrayList(externs),\n         Lists.<JSModule>newArrayList(modules), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }\n\n  /**\n   * Do any initialization that is dependent on the compiler options.\n   */\n  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }\n\n  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n      List<T> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (T file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }\n\n  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\");\n\n  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\");\n\n  /**\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   */\n  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }\n\n  /**\n   * Empty modules get an empty \"fill\" file, so that we can move code into\n   * an empty module.\n   */\n  static String createFillFileName(String moduleName) {\n    return \"[\" + moduleName + \"]\";\n  }\n\n  /**\n   * Fill any empty modules with a place holder file. It makes any cross module\n   * motion easier.\n   */\n  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(SourceFile.fromCode(\n            createFillFileName(module.getName()), \"\"));\n      }\n    }\n  }\n\n  /**\n   * Rebuilds the internal list of inputs by iterating over all modules.\n   * This is necessary if inputs have been added to or removed from a module\n   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n   */\n  public void rebuildInputsFromModules() {\n    inputs = getAllInputsFromModules(modules);\n    initInputsByIdMap();\n  }\n\n  /**\n   * Builds a single list of all module inputs. Verifies that it contains no\n   * duplicates.\n   */\n  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }\n\n  static final DiagnosticType DUPLICATE_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");\n  static final DiagnosticType DUPLICATE_EXTERN_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\");\n\n  /**\n   * Creates a map to make looking up an input by name fast. Also checks for\n   * duplicate inputs.\n   */\n  void initInputsByIdMap() {\n    inputsById = new HashMap<InputId, CompilerInput>();\n    for (CompilerInput input : externs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n      }\n    }\n  }\n\n  public Result compile(\n      SourceFile extern, SourceFile input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      SourceFile extern, JSSourceFile[] input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {\n     return compileModules(\n         Lists.newArrayList(extern), Lists.newArrayList(modules), options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options) {\n    return compile(Lists.<SourceFile>newArrayList(externs),\n        Lists.<SourceFile>newArrayList(inputs),\n        options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n      List<T1> externs, List<T2> inputs, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, inputs, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options) {\n    return compileModules(Lists.<SourceFile>newArrayList(externs),\n        Lists.<JSModule>newArrayList(modules),\n        options);\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public <T extends SourceFile> Result compileModules(List<T> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      @Override\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }\n\n  /**\n   * Disable threads. This is for clients that run on AppEngine and\n   * don't have threads.\n   */\n  public void disableThreads() {\n    useThreads = false;\n  }\n\n  private <T> T runInCompilerThread(final Callable<T> callable) {\n    return runCallable(callable, useThreads, options.tracer.isOn());\n  }\n\n  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n    return runCallable(callable, true, false);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n\n    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n    // large or complex js code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = trace;\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useLargeStackThread) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }\n\n  private void compileInternal() {\n    setProgress(0.0);\n    parse();\n    // 15 percent of the work is assumed to be for parsing (based on some\n    // minimal analysis on big JS projects, of course this depends on options)\n    setProgress(0.15);\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n    setProgress(1.0);\n  }\n\n  public void parse() {\n    parseInputs();\n  }\n\n  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }\n\n  /**\n   * Create the passes object. Clients should use setPassConfig instead of\n   * overriding this.\n   */\n  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }\n\n  /**\n   * @param passes The PassConfig to use with this Compiler.\n   * @throws NullPointerException if passes is null\n   * @throws IllegalStateException if this.passes has already been assigned\n   */\n  public void setPassConfig(PassConfig passes) {\n    // Important to check for null because if setPassConfig(null) is\n    // called before this.passes is set, getPassConfig() will create a\n    // new PassConfig object and use that, which is probably not what\n    // the client wanted since he or she probably meant to use their\n    // own PassConfig object.\n    Preconditions.checkNotNull(passes);\n\n    if (this.passes != null) {\n      throw new IllegalStateException(\"this.passes has already been assigned\");\n    }\n    this.passes = passes;\n  }\n\n  /**\n   * Carry out any special checks or procedures that need to be done before\n   * proceeding with rest of the compilation process.\n   *\n   * @return true, to continue with compilation\n   */\n  boolean precheck() {\n    return true;\n  }\n\n  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    // We are currently only interested in check-passes for progress reporting\n    // as it is used for IDEs, that's why the maximum progress is set to 1.0.\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,\n        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }\n\n  private void externExports() {\n    logger.fine(\"Creating extern file for exports\");\n    startPass(\"externExports\");\n\n    ExternExportsPass pass = new ExternExportsPass(this);\n    process(pass);\n\n    externExports = pass.getGeneratedExterns();\n\n    endPass();\n  }\n\n  @Override\n  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }\n\n  private final PassFactory sanityCheck =\n      new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  };\n\n  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }\n\n  private void runSanityCheck() {\n    sanityCheck.create(this).process(externsRoot, jsRoot);\n  }\n\n  /**\n   * Removes try/catch/finally statements for easier debugging.\n   */\n  void removeTryCatchFinally() {\n    logger.fine(\"Remove try/catch/finally\");\n    startPass(\"removeTryCatchFinally\");\n    RemoveTryCatch r = new RemoveTryCatch(this);\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Strips code for smaller compiled code. This is useful for removing debug\n   * statements to prevent leaking them publicly.\n   */\n  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n    logger.fine(\"Strip code\");\n    startPass(\"stripCode\");\n    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n        stripTypePrefixes, stripNamePrefixes);\n    if (options.getTweakProcessing().shouldStrip()) {\n      r.enableTweakStripping();\n    }\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Runs custom passes that are designated to run at a particular time.\n   */\n  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }\n\n  private Tracer currentTracer = null;\n  private String currentPassName = null;\n\n  /**\n   * Marks the beginning of a pass.\n   */\n  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }\n\n  /**\n   * Marks the end of a pass.\n   */\n  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }\n\n  /**\n   * Returns a new tracer for the given pass name.\n   */\n  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }\n\n  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }\n\n  /**\n   * Returns the result of the compilation.\n   */\n  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }\n\n  /**\n   * Returns an array constructed from errors + temporary warnings.\n   */\n  public JSError[] getMessages() {\n    return getErrors();\n  }\n\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }\n\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }\n\n  @Override\n  public Node getRoot() {\n    return externAndJsRoot;\n  }\n\n  /**\n   * Creates a new id for making unique names.\n   */\n  private int nextUniqueNameId() {\n    return uniqueNameId++;\n  }\n\n  /**\n   * Resets the unique name id counter\n   */\n  @VisibleForTesting\n  void resetUniqueNameId() {\n    uniqueNameId = 0;\n  }\n\n  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      @Override\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }\n\n  @Override\n  boolean areNodesEqualForInlining(Node n1, Node n2) {\n    if (options.ambiguateProperties ||\n        options.disambiguateProperties) {\n      // The type based optimizations require that type information is preserved\n      // during other optimizations.\n      return n1.isEquivalentToTyped(n2);\n    } else {\n      return n1.isEquivalentTo(n2);\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Inputs\n  //------------------------------------------------------------------------\n\n  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler\n  // interface, and which ones should always be injected.\n\n  @Override\n  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }\n\n  /**\n   * Removes an input file from AST.\n   * @param id The id of the input to be removed.\n   */\n  protected void removeExternInput(InputId id) {\n    CompilerInput input = getInput(id);\n    if (input == null) {\n      return;\n    }\n    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());\n    inputsById.remove(id);\n    externs.remove(input);\n    Node root = input.getAstRoot(this);\n    if (root != null) {\n      root.detachFromParent();\n    }\n  }\n\n  @Override\n  public CompilerInput newExternInput(String name) {\n    SourceAst ast = new SyntheticAst(name);\n    if (inputsById.containsKey(ast.getInputId())) {\n      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n    }\n    CompilerInput input = new CompilerInput(ast, true);\n    putCompilerInput(input.getInputId(), input);\n    externsRoot.addChildToFront(ast.getAstRoot(this));\n    externs.add(0, input);\n    return input;\n  }\n\n  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }\n\n  /** Add a source input dynamically. Intended for incremental compilation. */\n  void addIncrementalSourceAst(JsAst ast) {\n    InputId id = ast.getInputId();\n    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());\n    putCompilerInput(id, new CompilerInput(ast));\n  }\n\n  /**\n   * Replace a source input dynamically. Intended for incremental\n   * re-compilation.\n   *\n   * If the new source input doesn't parse, then keep the old input\n   * in the AST and return false.\n   *\n   * @return Whether the new AST was attached successfully.\n   */\n  boolean replaceIncrementalSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    Node oldRoot = oldInput.getAstRoot(this);\n    if (oldRoot != null) {\n      oldRoot.getParent().replaceChild(oldRoot, newRoot);\n    } else {\n      getRoot().getLastChild().addChildToBack(newRoot);\n    }\n\n    CompilerInput newInput = new CompilerInput(ast);\n    putCompilerInput(ast.getInputId(), newInput);\n\n    JSModule module = oldInput.getModule();\n    if (module != null) {\n      module.addAfter(newInput, oldInput);\n      module.remove(oldInput);\n    }\n\n    // Verify the input id is set properly.\n    Preconditions.checkState(\n        newInput.getInputId().equals(oldInput.getInputId()));\n    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();\n    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));\n\n    inputs.remove(oldInput);\n    return true;\n  }\n\n  /**\n   * Add a new source input dynamically. Intended for incremental compilation.\n   * <p>\n   * If the new source input doesn't parse, it will not be added, and a false\n   * will be returned.\n   *\n   * @param ast the JS Source to add.\n   * @return true if the source was added successfully, false otherwise.\n   * @throws IllegalStateException if an input for this ast already exists.\n   */\n  boolean addNewSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    if (oldInput != null) {\n      throw new IllegalStateException(\n          \"Input already exists: \" + ast.getInputId().getIdName());\n    }\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    getRoot().getLastChild().addChildToBack(newRoot);\n\n    CompilerInput newInput = new CompilerInput(ast);\n\n    // TODO(tylerg): handle this for multiple modules at some point.\n    if (moduleGraph == null && !modules.isEmpty()) {\n      // singleton module\n      modules.get(0).add(newInput);\n    }\n\n    putCompilerInput(ast.getInputId(), newInput);\n\n    return true;\n  }\n\n  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }\n\n  /**\n   * Gets a module graph. This will always return a module graph, even\n   * in the degenerate case when there's only one module.\n   */\n  JSModuleGraph getDegenerateModuleGraph() {\n    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;\n  }\n\n  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }\n\n  @Override\n  public MemoizedScopeCreator getTypedScopeCreator() {\n    return getPassConfig().getTypedScopeCreator();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  DefaultPassConfig ensureDefaultPassConfig() {\n    PassConfig passes = getPassConfig().getBasePassConfig();\n    Preconditions.checkState(passes instanceof DefaultPassConfig,\n        \"PassConfigs must eventually delegate to the DefaultPassConfig\");\n    return (DefaultPassConfig) passes;\n  }\n\n  public SymbolTable buildKnownSymbolTable() {\n    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());\n\n    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();\n    if (typedScopeCreator != null) {\n      symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());\n      symbolTable.addSymbolsFrom(typedScopeCreator);\n    } else {\n      symbolTable.findScopes(this, externsRoot, jsRoot);\n    }\n\n    GlobalNamespace globalNamespace =\n        ensureDefaultPassConfig().getGlobalNamespace();\n    if (globalNamespace != null) {\n      symbolTable.addSymbolsFrom(globalNamespace);\n    }\n\n    ReferenceCollectingCallback refCollector =\n        new ReferenceCollectingCallback(\n            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n    NodeTraversal.traverse(this, getRoot(), refCollector);\n    symbolTable.addSymbolsFrom(refCollector);\n\n    PreprocessorSymbolTable preprocessorSymbolTable =\n        ensureDefaultPassConfig().getPreprocessorSymbolTable();\n    if (preprocessorSymbolTable != null) {\n      symbolTable.addSymbolsFrom(preprocessorSymbolTable);\n    }\n\n    symbolTable.fillNamespaceReferences();\n    symbolTable.fillPropertyScopes();\n    symbolTable.fillThisReferences(this, externsRoot, jsRoot);\n    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);\n\n    return symbolTable;\n  }\n\n  @Override\n  public Scope getTopScope() {\n    return getPassConfig().getTopScope();\n  }\n\n  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }\n\n  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }\n\n  //------------------------------------------------------------------------\n  // Parsing\n  //------------------------------------------------------------------------\n\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n\n  /**\n   * Transforms AMD and CJS modules to something closure compiler can\n   * process and creates JSModules and the corresponding dependency tree\n   * on the way.\n   */\n  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n      if (!modules.isEmpty()) {\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }\n\n  public Node parse(SourceFile file) {\n    initCompilerOptionsIfTesting();\n    addToDebugLog(\"Parsing: \" + file.getName());\n    return new JsAst(file).getAstRoot(this);\n  }\n\n  private int syntheticCodeId = 0;\n\n  @Override\n  Node parseSyntheticCode(String js) {\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  /**\n   * Allow subclasses to override the default CompileOptions object.\n   */\n  protected CompilerOptions newCompilerOptions() {\n    return new CompilerOptions();\n  }\n\n  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(newCompilerOptions());\n    }\n  }\n\n  @Override\n  Node parseSyntheticCode(String fileName, String js) {\n    initCompilerOptionsIfTesting();\n    return parse(SourceFile.fromCode(fileName, js));\n  }\n\n  @Override\n  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\"[testcode]\", js));\n    if (inputsById == null) {\n      inputsById = Maps.newHashMap();\n    }\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }\n\n  //------------------------------------------------------------------------\n  // Convert back to source code\n  //------------------------------------------------------------------------\n\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource() {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for each input back to js code.\n   */\n  public String[] toSourceArray() {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        Tracer tracer = newTracer(\"toSourceArray\");\n        try {\n          int numInputs = inputs.size();\n          String[] sources = new String[numInputs];\n          CodeBuilder cb = new CodeBuilder();\n          for (int i = 0; i < numInputs; i++) {\n            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n            cb.reset();\n            toSource(cb, i, scriptNode);\n            sources[i] = cb.toString();\n          }\n          return sources;\n        } finally {\n          stopTracer(tracer, \"toSourceArray\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module) {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return \"\";\n        }\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module: \" + module.getName());\n          }\n          toSource(cb, i, scriptNode);\n        }\n        return cb.toString();\n      }\n    });\n  }\n\n\n  /**\n   * Converts the parse tree for each input in a module back to js code.\n   */\n  public String[] toSourceArray(final JSModule module) {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return new String[0];\n        }\n\n        String[] sources = new String[numInputs];\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module input: \" + inputs.get(i).getName());\n          }\n\n          cb.reset();\n          toSource(cb, i, scriptNode);\n          sources[i] = cb.toString();\n        }\n        return sources;\n      }\n    });\n  }\n\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n      @Override\n      public Void call() throws Exception {\n        if (options.printInputDelimiter) {\n          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            cb.append(\"\\n\");  // Make sure that the label starts on a new line\n          }\n          Preconditions.checkState(root.isScript());\n\n          String delimiter = options.inputDelimiter;\n\n          String inputName = root.getInputId().getIdName();\n          String sourceName = root.getSourceFileName();\n          Preconditions.checkState(sourceName != null);\n          Preconditions.checkState(!sourceName.isEmpty());\n\n          delimiter = delimiter\n              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))\n              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n          cb.append(delimiter)\n            .append(\"\\n\");\n        }\n        if (root.getJSDocInfo() != null &&\n            root.getJSDocInfo().getLicense() != null) {\n          cb.append(\"/*\\n\")\n            .append(root.getJSDocInfo().getLicense())\n            .append(\"*/\\n\");\n        }\n\n        // If there is a valid source map, then indicate to it that the current\n        // root node's mappings are offset by the given string builder buffer.\n        if (options.sourceMapOutputPath != null) {\n          sourceMap.setStartingPosition(\n              cb.getLineIndex(), cb.getColumnIndex());\n        }\n\n        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n        // for the first input file\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n        if (!code.isEmpty()) {\n          cb.append(code);\n\n          // In order to avoid parse ambiguity when files are concatenated\n          // together, all files should end in a semi-colon. Do a quick\n          // heuristic check if there's an obvious semi-colon already there.\n          int length = code.length();\n          char lastChar = code.charAt(length - 1);\n          char secondLastChar = length >= 2 ?\n              code.charAt(length - 2) : '\\0';\n          boolean hasSemiColon = lastChar == ';' ||\n              (lastChar == '\\n' && secondLastChar == ';');\n          if (!hasSemiColon) {\n            cb.append(\";\");\n          }\n        }\n        return null;\n      }\n    });\n  }\n\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n  }\n\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }\n\n  /**\n   * Stores a buffer of text to which more can be appended.  This is just like a\n   * StringBuilder except that we also track the number of lines.\n   */\n  public static class CodeBuilder {\n    private final StringBuilder sb = new StringBuilder();\n    private int lineCount = 0;\n    private int colCount = 0;\n\n    /** Removes all text, but leaves the line count unchanged. */\n    void reset() {\n      sb.setLength(0);\n    }\n\n    /** Appends the given string to the text buffer. */\n    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }\n\n    /** Returns all text in the text buffer. */\n    @Override\n    public String toString() {\n      return sb.toString();\n    }\n\n    /** Returns the length of the text buffer. */\n    public int getLength() {\n      return sb.length();\n    }\n\n    /** Returns the (zero-based) index of the last line in the text buffer. */\n    int getLineIndex() {\n      return lineCount;\n    }\n\n    /** Returns the (zero-based) index of the last column in the text buffer. */\n    int getColumnIndex() {\n      return colCount;\n    }\n\n    /** Determines whether the text ends with the given suffix. */\n    boolean endsWith(String suffix) {\n      return (sb.length() > suffix.length())\n          && suffix.equals(sb.substring(sb.length() - suffix.length()));\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Optimizations\n  //------------------------------------------------------------------------\n\n  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }\n\n  @Override\n  void setCssRenamingMap(CssRenamingMap map) {\n    options.cssRenamingMap = map;\n  }\n\n  @Override\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }\n\n  /**\n   * Reprocesses the current defines over the AST.  This is used by GwtCompiler\n   * to generate N outputs for different targets from the same (checked) AST.\n   * For each target, we apply the target-specific defines by calling\n   * {@code processDefines} and then {@code optimize} to optimize the AST\n   * specifically for that target.\n   */\n  public void processDefines() {\n    (new DefaultPassConfig(options)).processDefines.create(this)\n        .process(externsRoot, jsRoot);\n  }\n\n  boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }\n\n  /** Control Flow Analysis. */\n  ControlFlowGraph<Node> computeCFG() {\n    logger.fine(\"Computing Control Flow Graph\");\n    Tracer tracer = newTracer(\"computeCFG\");\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n    process(cfa);\n    stopTracer(tracer, \"computeCFG\");\n    return cfa.getCfg();\n  }\n\n  public void normalize() {\n    logger.fine(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }\n\n  @Override\n  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }\n\n  void recordFunctionInformation() {\n    logger.fine(\"Recording function information\");\n    startPass(\"recordFunctionInformation\");\n    RecordFunctionInformation recordFunctionInfoPass =\n        new RecordFunctionInformation(\n            this, getPassConfig().getIntermediateState().functionNames);\n    process(recordFunctionInfoPass);\n    functionInformationMap = recordFunctionInfoPass.getMap();\n    endPass();\n  }\n\n  protected final CodeChangeHandler.RecentChange recentChange =\n      new CodeChangeHandler.RecentChange();\n  private final List<CodeChangeHandler> codeChangeHandlers =\n      Lists.<CodeChangeHandler>newArrayList();\n\n  /** Name of the synthetic input that holds synthesized externs. */\n  static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\";\n\n  private CompilerInput synthesizedExternsInput = null;\n\n  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }\n\n  @Override\n  void removeChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.remove(handler);\n  }\n\n  /**\n   * All passes should call reportCodeChange() when they alter\n   * the JS tree structure. This is verified by CompilerTestCase.\n   * This allows us to optimize to a fixed point.\n   */\n  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }\n\n  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }\n\n  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }\n\n  @Override\n  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n    }\n    return false;\n  }\n\n  public LanguageMode languageMode() {\n    return options.getLanguageIn();\n  }\n\n  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }\n\n  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }\n\n  @Override\n  public boolean isTypeCheckingEnabled() {\n    return options.checkTypes;\n  }\n\n\n  //------------------------------------------------------------------------\n  // Error reporting\n  //------------------------------------------------------------------------\n\n  /**\n   * The warning classes that are available from the command-line, and\n   * are suppressable by the {@code @suppress} annotation.\n   */\n  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }\n\n  @Override\n  public void report(JSError error) {\n    CheckLevel level = error.getDefaultLevel();\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      if (getOptions().errorHandler != null) {\n        getOptions().errorHandler.report(level, error);\n      }\n      errorManager.report(level, error);\n    }\n  }\n\n  @Override\n  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }\n\n  /**\n   * Report an internal error.\n   */\n  @Override\n  void throwInternalError(String message, Exception cause) {\n    String finalMessage =\n      \"INTERNAL COMPILER ERROR.\\n\" +\n      \"Please report this problem.\\n\" + message;\n\n    RuntimeException e = new RuntimeException(finalMessage, cause);\n    if (cause != null) {\n      e.setStackTrace(cause.getStackTrace());\n    }\n    throw e;\n  }\n\n\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }\n\n  /**\n   * Gets the number of warnings.\n   */\n  public int getWarningCount() {\n    return errorManager.getWarningCount();\n  }\n\n  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }\n\n  /**\n   * Consults the {@link ErrorManager} to see if we've encountered errors\n   * that should halt compilation. <p>\n   *\n   * If {@link CompilerOptions#ideMode} is {@code true}, this function\n   * always returns {@code false} without consulting the error manager. The\n   * error manager will continue to be told about new errors and warnings, but\n   * the compiler will complete compilation of all inputs.<p>\n   */\n  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }\n\n  /** Called from the compiler passes, adds debug info */\n  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }\n\n  private SourceFile getSourceFileByName(String sourceName) {\n    // Here we assume that the source name is the input name, this\n    // is try of javascript parsed from source.\n    if (sourceName != null) {\n      CompilerInput input = inputsById.get(new InputId(sourceName));\n      if (input != null) {\n        return input.getSourceFile();\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }\n\n  @Override\n  public Region getSourceRegion(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getRegion(lineNumber);\n    }\n    return null;\n  }\n\n  //------------------------------------------------------------------------\n  // Package-private helpers\n  //------------------------------------------------------------------------\n\n  @Override\n  Node getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n      if (inputs.isEmpty()) {\n        throw new IllegalStateException(\"No inputs\");\n      }\n\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    List<CompilerInput> moduleInputs = module.getInputs();\n    if (moduleInputs.size() > 0) {\n      return moduleInputs.get(0).getAstRoot(this);\n    }\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }\n\n  public SourceMap getSourceMap() {\n    return sourceMap;\n  }\n\n  VariableMap getVariableMap() {\n    return getPassConfig().getIntermediateState().variableMap;\n  }\n\n  VariableMap getPropertyMap() {\n    return getPassConfig().getIntermediateState().propertyMap;\n  }\n\n  CompilerOptions getOptions() {\n    return options;\n  }\n\n  FunctionInformationMap getFunctionalInformationMap() {\n    return functionInformationMap;\n  }\n\n  /**\n   * Sets the logging level for the com.google.javascript.jscomp package.\n   */\n  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }\n\n  /** Gets the DOT graph of the AST generated at the end of compilation. */\n  public String getAstDotGraph() throws IOException {\n    if (jsRoot != null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n      cfa.process(null, jsRoot);\n      return DotFormatter.toDot(jsRoot, cfa.getCfg());\n    } else {\n      return \"\";\n    }\n  }\n\n  @Override\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(newCompilerOptions());\n    }\n    return errorManager;\n  }\n\n  @Override\n  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }\n\n  /**\n   * Returns an unmodifiable view of the compiler inputs indexed by id.\n   */\n  public Map<InputId, CompilerInput> getInputsById() {\n    return Collections.unmodifiableMap(inputsById);\n  }\n\n  /**\n   * Gets the externs in the order in which they are being processed.\n   */\n  List<CompilerInput> getExternsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(externs);\n  }\n\n  /**\n   * Stores the internal compiler state just before optimization is performed.\n   * This can be saved and restored in order to efficiently optimize multiple\n   * different output targets without having to perform checking multiple times.\n   *\n   * NOTE: This does not include all parts of the compiler's internal state. In\n   * particular, SourceFiles and CompilerOptions are not recorded. In\n   * order to recreate a Compiler instance from scratch, you would need to\n   * call {@code init} with the same arguments as in the initial creation before\n   * restoring intermediate state.\n   */\n  public static class IntermediateState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    Node externsRoot;\n    private Node jsRoot;\n    private List<CompilerInput> externs;\n    private List<CompilerInput> inputs;\n    private List<JSModule> modules;\n    private PassConfig.State passConfigState;\n    private JSTypeRegistry typeRegistry;\n    private AbstractCompiler.LifeCycleStage lifeCycleStage;\n    private Map<String, Node> injectedLibraries;\n\n    private IntermediateState() {}\n  }\n\n  /**\n   * Returns the current internal state, excluding the input files and modules.\n   */\n  public IntermediateState getState() {\n    IntermediateState state = new IntermediateState();\n    state.externsRoot = externsRoot;\n    state.jsRoot = jsRoot;\n    state.externs = externs;\n    state.inputs = inputs;\n    state.modules = modules;\n    state.passConfigState = getPassConfig().getIntermediateState();\n    state.typeRegistry = typeRegistry;\n    state.lifeCycleStage = getLifeCycleStage();\n    state.injectedLibraries = Maps.newLinkedHashMap(injectedLibraries);\n\n    return state;\n  }\n\n  /**\n   * Sets the internal state to the capture given.  Note that this assumes that\n   * the input files are already set up.\n   */\n  public void setState(IntermediateState state) {\n    externsRoot = state.externsRoot;\n    jsRoot = state.jsRoot;\n    externs = state.externs;\n    inputs = state.inputs;\n    modules = state.modules;\n    passes = createPassConfigInternal();\n    getPassConfig().setIntermediateState(state.passConfigState);\n    typeRegistry = state.typeRegistry;\n    setLifeCycleStage(state.lifeCycleStage);\n\n    injectedLibraries.clear();\n    injectedLibraries.putAll(state.injectedLibraries);\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getInputsForTesting() {\n    return inputs;\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getExternsForTesting() {\n    return externs;\n  }\n\n  @Override\n  boolean hasRegExpGlobalReferences() {\n    return hasRegExpGlobalReferences;\n  }\n\n  @Override\n  void setHasRegExpGlobalReferences(boolean references) {\n    hasRegExpGlobalReferences = references;\n  }\n\n  @Override\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.isScript()\n        || collectionRoot.isBlock());\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n          getExternsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }\n\n  @Override\n  GlobalVarReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }\n\n  @Override\n  CompilerInput getSynthesizedExternsInput() {\n    if (synthesizedExternsInput == null) {\n      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);\n    }\n    return synthesizedExternsInput;\n  }\n\n  @Override\n  public double getProgress() {\n    return progress;\n  }\n\n  @Override\n  void setProgress(double newProgress) {\n    if (newProgress > 1.0) {\n      progress = 1.0;\n    } else if (newProgress < 0.0) {\n      progress = 0.0;\n    } else {\n      progress = newProgress;\n    }\n  }\n\n  /**\n   * Replaces one file in a hot-swap mode. The given JsAst should be made\n   * from a new version of a file that already was present in the last compile\n   * call. If the file is new, this will silently ignored.\n   *\n   * @param ast the ast of the file that is being replaced\n   */\n  public void replaceScript(JsAst ast) {\n    CompilerInput input = this.getInput(ast.getInputId());\n    if (!replaceIncrementalSourceAst(ast)) {\n      return;\n    }\n    Node originalRoot = input.getAstRoot(this);\n\n    processNewScript(ast, originalRoot);\n  }\n\n  /**\n   * Adds a new Script AST to the compile state. If a script for the same file\n   * already exists the script will not be added, instead a call to\n   * #replaceScript should be used.\n   *\n   * @param ast the ast of the new file\n   */\n  public void addNewScript(JsAst ast) {\n    if (!addNewSourceAst(ast)) {\n      return;\n    }\n    Node emptyScript = new Node(Token.SCRIPT);\n    InputId inputId = ast.getInputId();\n    emptyScript.setInputId(inputId);\n    emptyScript.setStaticSourceFile(\n        SourceFile.fromCode(inputId.getIdName(), \"\"));\n\n    processNewScript(ast, emptyScript);\n  }\n\n  private void processNewScript(JsAst ast, Node originalRoot) {\n    Node js = ast.getAstRoot(this);\n    Preconditions.checkNotNull(js);\n\n    runHotSwap(originalRoot, js, this.getCleanupPassConfig());\n    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need\n    // to revisit this approach to clearing GlobalNamespaces\n    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);\n\n    this.getTypeRegistry().clearNamedTypes();\n    this.removeSyntheticVarsInput();\n\n    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());\n  }\n\n  /**\n   * Execute the passes from a PassConfig instance over a single replaced file.\n   */\n  private void runHotSwap(\n      Node originalRoot, Node js, PassConfig passConfig) {\n    for (PassFactory passFactory : passConfig.getChecks()) {\n      runHotSwapPass(originalRoot, js, passFactory);\n    }\n  }\n\n  private void runHotSwapPass(\n      Node originalRoot, Node js, PassFactory passFactory) {\n    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);\n    if (pass != null) {\n      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());\n      pass.hotSwapScript(js, originalRoot);\n    }\n  }\n\n  private PassConfig getCleanupPassConfig() {\n    return new CleanupPasses(getOptions());\n  }\n\n  private void removeSyntheticVarsInput() {\n    String sourceName = Compiler.SYNTHETIC_EXTERNS;\n    removeExternInput(new InputId(sourceName));\n  }\n\n  @Override\n  Node ensureLibraryInjected(String resourceName) {\n    if (injectedLibraries.containsKey(resourceName)) {\n      return null;\n    }\n\n    // All libraries depend on js/base.js\n    boolean isBase = \"base\".equals(resourceName);\n    if (!isBase) {\n      ensureLibraryInjected(\"base\");\n    }\n\n    Node firstChild = loadLibraryCode(resourceName).removeChildren();\n    Node lastChild = firstChild.getLastSibling();\n\n    Node parent = getNodeForCodeInsertion(null);\n    if (isBase) {\n      parent.addChildrenToFront(firstChild);\n    } else {\n      parent.addChildrenAfter(\n          firstChild, injectedLibraries.get(\"base\"));\n    }\n    reportCodeChange();\n\n    injectedLibraries.put(resourceName, lastChild);\n    return lastChild;\n  }\n\n  /** Load a library as a resource */\n  @VisibleForTesting\n  Node loadLibraryCode(String resourceName) {\n    String originalCode;\n    try {\n      originalCode = CharStreams.toString(new InputStreamReader(\n          Compiler.class.getResourceAsStream(\n              String.format(\"js/%s.js\", resourceName)),\n          Charsets.UTF_8));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    return Normalize.parseAndNormalizeSyntheticCode(\n        this, originalCode,\n        String.format(\"jscomp_%s_\", resourceName));\n  }\n}\n"}, "generated_test_class": "Certainly! To write comprehensive unit tests for the `init` method in the `Compiler` class, we need to ensure that various scenarios are covered, including edge cases. Below are unit tests that aim to maximize both branch and line coverage.\n\n```java\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.Compiler;\nimport com.google.javascript.jscomp.CompilerOptions;\nimport com.google.javascript.jscomp.JSModule;\nimport com.google.javascript.jscomp.SourceFile;\nimport com.google.javascript.jscomp.DiagnosticType;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mockito;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.*;\n\npublic class CompilerTest {\n\n    private Compiler compiler;\n    private CompilerOptions options;\n    private SourceFile externSourceFile;\n    private SourceFile inputSourceFile;\n    private JSModule jsModule;\n\n    @Before\n    public void setUp() {\n        compiler = new Compiler();\n        options = new CompilerOptions();\n        externSourceFile = SourceFile.fromCode(\"externs.js\", \"\");\n        inputSourceFile = SourceFile.fromCode(\"input.js\", \"\");\n        jsModule = new JSModule(Compiler.SINGLETON_MODULE_NAME);\n    }\n\n    @Test\n    public void testInitWithSingleExternAndInput() {\n        List<SourceFile> externs = Lists.newArrayList(externSourceFile);\n        List<SourceFile> inputs = Lists.newArrayList(inputSourceFile);\n\n        compiler.init(externs, inputs, options);\n\n        // Capture the module passed to initModules\n        ArgumentCaptor<List<JSModule>> moduleCaptor = ArgumentCaptor.forClass(List.class);\n        verify(compiler, times(1)).initModules(anyList(), moduleCaptor.capture(), eq(options));\n\n        List<JSModule> capturedModules = moduleCaptor.getValue();\n        assertEquals(1, capturedModules.size());\n        JSModule module = capturedModules.get(0);\n        assertEquals(Compiler.SINGLETON_MODULE_NAME, module.getName());\n        assertEquals(1, module.getInputs().size());\n        assertTrue(module.getInputs().contains(inputSourceFile));\n    }\n\n    @Test\n    public void testInitWithMultipleExternsAndInputs() {\n        SourceFile externSourceFile2 = SourceFile.fromCode(\"externs2.js\", \"\");\n        SourceFile inputSourceFile2 = SourceFile.fromCode(\"input2.js\", \"\");\n\n        List<SourceFile> externs = Lists.newArrayList(externSourceFile, externSourceFile2);\n        List<SourceFile> inputs = Lists.newArrayList(inputSourceFile, inputSourceFile2);\n\n        compiler.init(externs, inputs, options);\n\n        // Capture the module passed to initModules\n        ArgumentCaptor<List<JSModule>> moduleCaptor = ArgumentCaptor.forClass(List.class);\n        verify(compiler, times(1)).initModules(anyList(), moduleCaptor.capture(), eq(options));\n\n        List<JSModule> capturedModules = moduleCaptor.getValue();\n        assertEquals(1, capturedModules.size());\n        JSModule module = capturedModules.get(0);\n        assertEquals(Compiler.SINGLETON_MODULE_NAME, module.getName());\n        assertEquals(2, module.getInputs().size());\n        assertTrue(module.getInputs().contains(inputSourceFile));\n        assertTrue(module.getInputs().contains(inputSourceFile2));\n    }\n\n    @Test\n    public void testInitWithNoExterns() {\n        List<SourceFile> externs = new ArrayList<>();\n        List<SourceFile> inputs = Lists.newArrayList(inputSourceFile);\n\n        compiler.init(externs, inputs, options);\n\n        // Capture the module passed to initModules\n        ArgumentCaptor<List<JSModule>> moduleCaptor = ArgumentCaptor.forClass(List.class);\n        verify(compiler, times(1)).initModules(anyList(), moduleCaptor.capture(), eq(options));\n\n        List<JSModule> capturedModules = moduleCaptor.getValue();\n        assertEquals(1, capturedModules.size());\n        JSModule module = capturedModules.get(0);\n        assertEquals(Compiler.SINGLETON_MODULE_NAME, module.getName());\n        assertEquals(1, module.getInputs().size());\n        assertTrue(module.getInputs().contains(inputSourceFile));\n    }\n\n    @Test\n    public void testInitWithNoInputs() {\n        List<SourceFile> externs = Lists.newArrayList(externSourceFile);\n        List<SourceFile> inputs = new ArrayList<>();\n\n        compiler.init(externs, inputs, options);\n\n        // Capture the module passed to initModules\n        ArgumentCaptor<List<JSModule>> moduleCaptor = ArgumentCaptor.forClass(List.class);\n        verify(compiler, times(1)).initModules(anyList(), moduleCaptor.capture(), eq(options));\n\n        List<JSModule> capturedModules = moduleCaptor.getValue();\n        assertEquals(1, capturedModules.size());\n        JSModule module = capturedModules.get(0);\n        assertEquals(Compiler.SINGLETON_MODULE_NAME, module.getName());\n        assertEquals(0, module.getInputs().size());\n    }\n\n    @Test\n    public void testInitWithNoExternsAndNoInputs() {\n        List<SourceFile> externs = new ArrayList<>();\n        List<SourceFile> inputs = new ArrayList<>();\n\n        compiler.init(externs, inputs, options);\n\n        // Capture the module passed to initModules\n        ArgumentCaptor<List<JSModule>> moduleCaptor = ArgumentCaptor.forClass(List.class);\n        verify(compiler, times(1)).initModules(anyList(), moduleCaptor.capture(), eq(options));\n\n        List<JSModule> capturedModules = moduleCaptor.getValue();\n        assertEquals(1, capturedModules.size());\n        JSModule module = capturedModules.get(0);\n        assertEquals(Compiler.SINGLETON_MODULE_NAME, module.getName());\n        assertEquals(0, module.getInputs().size());\n    }\n}\n```\n\n### Explanation:\n\n1. **Test with Single Extern and Input:**\n   - Tests the method with one extern file and one input file.\n   - Verifies that the module is created with the correct name and contains the input file.\n\n2. **Test with Multiple Externs and Inputs:**\n   - Tests the method with multiple extern and input files.\n   - Verifies that the module is created with the correct name and contains all input files.\n\n3. **Test with No Externs:**\n   - Tests the method with no extern files and one input file.\n   - Verifies that the module is created with the correct name and contains the input file.\n\n4. **Test with No Inputs:**\n   - Tests the method with one extern file and no input files.\n   - Verifies that the module is created with the correct name and contains no input files.\n\n5. **Test with No Externs and No Inputs:**\n   - Tests the method with no extern files and no input files.\n   - Verifies that the module is created with the correct name and contains no input files.\n\nThese tests cover the different combinations of extern and input files, ensuring that the `init` method behaves as expected in various scenarios."}
{"bug_id": "Closure_31", "version": "fixed", "focal_method_signature": "void com.google.javascript.jscomp.Compiler#initModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "focal_method": "public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }", "return_type": "void", "assertion_subject_candidates": ["JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "double com.google.javascript.jscomp.Compiler#getProgress()", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()"], "focal_class": {"name": "Compiler", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "superclass": "extends AbstractCompiler", "interface": "", "imports": ["import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.Charsets;", "import com.google.common.base.Preconditions;", "import com.google.common.base.Supplier;", "import com.google.common.base.Throwables;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.common.io.CharStreams;", "import com.google.javascript.jscomp.CompilerOptions.DevMode;", "import com.google.javascript.jscomp.CompilerOptions.LanguageMode;", "import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;", "import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;", "import com.google.javascript.jscomp.parsing.Config;", "import com.google.javascript.jscomp.parsing.ParserRunner;", "import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;", "import com.google.javascript.rhino.IR;", "import com.google.javascript.rhino.InputId;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import com.google.javascript.rhino.head.ErrorReporter;", "import com.google.javascript.rhino.jstype.JSTypeRegistry;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.PrintStream;", "import java.io.Serializable;", "import java.nio.charset.Charset;", "import java.util.Collections;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;", "import java.util.concurrent.Callable;", "import java.util.logging.Level;", "import java.util.logging.Logger;", "import java.util.regex.Matcher;"], "fields": ["static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions options = null", "private PassConfig passes = null", "private List<CompilerInput> externs", "private List<JSModule> modules", "private JSModuleGraph moduleGraph", "private List<CompilerInput> inputs", "private ErrorManager errorManager", "private WarningsGuard warningsGuard", "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node externsRoot", "Node jsRoot", "Node externAndJsRoot", "private Map<InputId, CompilerInput> inputsById", "private SourceMap sourceMap", "private String externExports = null", "private int uniqueNameId = 0", "private boolean useThreads = true", "private boolean hasRegExpGlobalReferences = true", "private FunctionInformationMap functionInformationMap", "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "private JSTypeRegistry typeRegistry", "private Config parserConfig = null", "private ReverseAbstractInterpreter abstractInterpreter", "private TypeValidator typeValidator", "public PerformanceTracker tracker", "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "private static final long COMPILER_STACK_SIZE = 1048576L", "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "private final PrintStream outStream", "private GlobalVarReferenceMap globalRefMap = null", "private volatile double progress = 0.0", "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "private Tracer currentTracer = null", "private String currentPassName = null", "private int syntheticCodeId = 0", "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "private CompilerInput synthesizedExternsInput = null"], "methods": ["void com.google.javascript.jscomp.Compiler#setErrorManager(ErrorManager#errorManager)", "MessageFormatter com.google.javascript.jscomp.Compiler#createMessageFormatter()", "void com.google.javascript.jscomp.Compiler#initOptions(CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initBasedOnOptions()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#makeCompilerInput(List<T>#files,boolean#isExtern)", "void com.google.javascript.jscomp.Compiler#checkFirstModule(List<JSModule>#modules)", "String com.google.javascript.jscomp.Compiler#createFillFileName(String#moduleName)", "void com.google.javascript.jscomp.Compiler#fillEmptyModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#rebuildInputsFromModules()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getAllInputsFromModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#initInputsByIdMap()", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,SourceFile#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,JSSourceFile[]#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile#extern,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compileModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile()", "void com.google.javascript.jscomp.Compiler#disableThreads()", "T com.google.javascript.jscomp.Compiler#runInCompilerThread(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallableWithLargeStack(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallable(Callable<T>#callable,boolean#useLargeStackThread,boolean#trace)", "void com.google.javascript.jscomp.Compiler#compileInternal()", "void com.google.javascript.jscomp.Compiler#parse()", "PassConfig com.google.javascript.jscomp.Compiler#getPassConfig()", "PassConfig com.google.javascript.jscomp.Compiler#createPassConfigInternal()", "void com.google.javascript.jscomp.Compiler#setPassConfig(PassConfig#passes)", "boolean com.google.javascript.jscomp.Compiler#precheck()", "void com.google.javascript.jscomp.Compiler#check()", "void com.google.javascript.jscomp.Compiler#externExports()", "void com.google.javascript.jscomp.Compiler#process(CompilerPass#p)", "void com.google.javascript.jscomp.Compiler#maybeSanityCheck()", "void com.google.javascript.jscomp.Compiler#runSanityCheck()", "void com.google.javascript.jscomp.Compiler#removeTryCatchFinally()", "void com.google.javascript.jscomp.Compiler#stripCode(Set<String>#stripTypes,Set<String>#stripNameSuffixes,Set<String>#stripTypePrefixes,Set<String>#stripNamePrefixes)", "void com.google.javascript.jscomp.Compiler#runCustomPasses(CustomPassExecutionTime#executionTime)", "void com.google.javascript.jscomp.Compiler#startPass(String#passName)", "void com.google.javascript.jscomp.Compiler#endPass()", "Tracer com.google.javascript.jscomp.Compiler#newTracer(String#passName)", "void com.google.javascript.jscomp.Compiler#stopTracer(Tracer#t,String#passName)", "Result com.google.javascript.jscomp.Compiler#getResult()", "JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "int com.google.javascript.jscomp.Compiler#nextUniqueNameId()", "void com.google.javascript.jscomp.Compiler#resetUniqueNameId()", "Supplier<String> com.google.javascript.jscomp.Compiler#getUniqueNameIdSupplier()", "boolean com.google.javascript.jscomp.Compiler#areNodesEqualForInlining(Node#n1,Node#n2)", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "void com.google.javascript.jscomp.Compiler#removeExternInput(InputId#id)", "CompilerInput com.google.javascript.jscomp.Compiler#newExternInput(String#name)", "CompilerInput com.google.javascript.jscomp.Compiler#putCompilerInput(InputId#id,CompilerInput#input)", "void com.google.javascript.jscomp.Compiler#addIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#replaceIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#addNewSourceAst(JsAst#ast)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "JSTypeRegistry com.google.javascript.jscomp.Compiler#getTypeRegistry()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "DefaultPassConfig com.google.javascript.jscomp.Compiler#ensureDefaultPassConfig()", "SymbolTable com.google.javascript.jscomp.Compiler#buildKnownSymbolTable()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ReverseAbstractInterpreter com.google.javascript.jscomp.Compiler#getReverseAbstractInterpreter()", "TypeValidator com.google.javascript.jscomp.Compiler#getTypeValidator()", "Node com.google.javascript.jscomp.Compiler#parseInputs()", "void com.google.javascript.jscomp.Compiler#processAMDAndCommonJSModules()", "Node com.google.javascript.jscomp.Compiler#parse(SourceFile#file)", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#js)", "CompilerOptions com.google.javascript.jscomp.Compiler#newCompilerOptions()", "void com.google.javascript.jscomp.Compiler#initCompilerOptionsIfTesting()", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#fileName,String#js)", "Node com.google.javascript.jscomp.Compiler#parseTestCode(String#js)", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "String com.google.javascript.jscomp.Compiler#toSource()", "String[] com.google.javascript.jscomp.Compiler#toSourceArray()", "String com.google.javascript.jscomp.Compiler#toSource(JSModule#module)", "String[] com.google.javascript.jscomp.Compiler#toSourceArray(JSModule#module)", "void com.google.javascript.jscomp.Compiler#toSource(CodeBuilder#cb,int#inputSeqNum,Node#root)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n,SourceMap#sourceMap,boolean#firstOutput)", "void com.google.javascript.jscomp.Compiler#optimize()", "void com.google.javascript.jscomp.Compiler#setCssRenamingMap(CssRenamingMap#map)", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "void com.google.javascript.jscomp.Compiler#processDefines()", "boolean com.google.javascript.jscomp.Compiler#isInliningForbidden()", "ControlFlowGraph<Node> com.google.javascript.jscomp.Compiler#computeCFG()", "void com.google.javascript.jscomp.Compiler#normalize()", "void com.google.javascript.jscomp.Compiler#prepareAst(Node#root)", "void com.google.javascript.jscomp.Compiler#recordFunctionInformation()", "void com.google.javascript.jscomp.Compiler#addChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#removeChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#reportCodeChange()", "CodingConvention com.google.javascript.jscomp.Compiler#getCodingConvention()", "boolean com.google.javascript.jscomp.Compiler#isIdeMode()", "boolean com.google.javascript.jscomp.Compiler#acceptEcmaScript5()", "LanguageMode com.google.javascript.jscomp.Compiler#languageMode()", "boolean com.google.javascript.jscomp.Compiler#acceptConstKeyword()", "Config com.google.javascript.jscomp.Compiler#getParserConfig()", "boolean com.google.javascript.jscomp.Compiler#isTypeCheckingEnabled()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "void com.google.javascript.jscomp.Compiler#report(JSError#error)", "CheckLevel com.google.javascript.jscomp.Compiler#getErrorLevel(JSError#error)", "void com.google.javascript.jscomp.Compiler#throwInternalError(String#message,Exception#cause)", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "boolean com.google.javascript.jscomp.Compiler#hasHaltingErrors()", "boolean com.google.javascript.jscomp.Compiler#hasErrors()", "void com.google.javascript.jscomp.Compiler#addToDebugLog(String#str)", "SourceFile com.google.javascript.jscomp.Compiler#getSourceFileByName(String#sourceName)", "String com.google.javascript.jscomp.Compiler#getSourceLine(String#sourceName,int#lineNumber)", "Region com.google.javascript.jscomp.Compiler#getSourceRegion(String#sourceName,int#lineNumber)", "Node com.google.javascript.jscomp.Compiler#getNodeForCodeInsertion(JSModule#module)", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "void com.google.javascript.jscomp.Compiler#setLoggingLevel(Level#level)", "String com.google.javascript.jscomp.Compiler#getAstDotGraph()", "ErrorManager com.google.javascript.jscomp.Compiler#getErrorManager()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "IntermediateState com.google.javascript.jscomp.Compiler#getState()", "void com.google.javascript.jscomp.Compiler#setState(IntermediateState#state)", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "boolean com.google.javascript.jscomp.Compiler#hasRegExpGlobalReferences()", "void com.google.javascript.jscomp.Compiler#setHasRegExpGlobalReferences(boolean#references)", "void com.google.javascript.jscomp.Compiler#updateGlobalVarReferences(Map<Var, ReferenceCollection>#refMapPatch,Node#collectionRoot)", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "CompilerInput com.google.javascript.jscomp.Compiler#getSynthesizedExternsInput()", "double com.google.javascript.jscomp.Compiler#getProgress()", "void com.google.javascript.jscomp.Compiler#setProgress(double#newProgress)", "void com.google.javascript.jscomp.Compiler#replaceScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#addNewScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#processNewScript(JsAst#ast,Node#originalRoot)", "void com.google.javascript.jscomp.Compiler#runHotSwap(Node#originalRoot,Node#js,PassConfig#passConfig)", "void com.google.javascript.jscomp.Compiler#runHotSwapPass(Node#originalRoot,Node#js,PassFactory#passFactory)", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()", "void com.google.javascript.jscomp.Compiler#removeSyntheticVarsInput()", "Node com.google.javascript.jscomp.Compiler#ensureLibraryInjected(String#resourceName)", "Node com.google.javascript.jscomp.Compiler#loadLibraryCode(String#resourceName)"], "other_methods": ["public void setErrorManager(ErrorManager errorManager);", "public void initOptions(CompilerOptions options);", "public void init(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public void init(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public void init(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public void rebuildInputsFromModules();", "public Result compile(SourceFile extern,SourceFile input,CompilerOptions options);", "public Result compile(SourceFile extern,JSSourceFile[] input,CompilerOptions options);", "public Result compile(JSSourceFile extern,JSModule[] modules,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public Result compile(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public Result compileModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void disableThreads();", "public void parse();", "public void setPassConfig(PassConfig passes);", "public void check();", "public Result getResult();", "public JSError[] getMessages();", "public JSError[] getErrors();", "public JSError[] getWarnings();", "@Override\n  public Node getRoot();", "@Override\n  public CompilerInput getInput(InputId id);", "@Override\n  public CompilerInput newExternInput(String name);", "@Override\n  public JSTypeRegistry getTypeRegistry();", "@Override\n  public MemoizedScopeCreator getTypedScopeCreator();", "public SymbolTable buildKnownSymbolTable();", "@Override\n  public Scope getTopScope();", "@Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter();", "public Node parse(SourceFile file);", "public String toSource();", "public String[] toSourceArray();", "public String toSource(JSModule module);", "public String[] toSourceArray(JSModule module);", "public void toSource(CodeBuilder cb,int inputSeqNum,Node root);", "public void optimize();", "public void processDefines();", "public void normalize();", "@Override\n  public void reportCodeChange();", "@Override\n  public CodingConvention getCodingConvention();", "@Override\n  public boolean isIdeMode();", "@Override\n  public boolean acceptEcmaScript5();", "public LanguageMode languageMode();", "@Override\n  public boolean acceptConstKeyword();", "@Override\n  public boolean isTypeCheckingEnabled();", "@Override\n  public void report(JSError error);", "@Override\n  public CheckLevel getErrorLevel(JSError error);", "public int getErrorCount();", "public int getWarningCount();", "public boolean hasErrors();", "@Override\n  public String getSourceLine(String sourceName,int lineNumber);", "@Override\n  public Region getSourceRegion(String sourceName,int lineNumber);", "public SourceMap getSourceMap();", "public static void setLoggingLevel(Level level);", "public String getAstDotGraph();", "@Override\n  public ErrorManager getErrorManager();", "public Map<InputId, CompilerInput> getInputsById();", "public IntermediateState getState();", "public void setState(IntermediateState state);", "@Override\n  public double getProgress();", "public void replaceScript(JsAst ast);", "public void addNewScript(JsAst ast);"], "fields_dict": {"String#SINGLETON_MODULE_NAME": "static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "DiagnosticType#MODULE_DEPENDENCY_ERROR": "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "DiagnosticType#MISSING_ENTRY_ERROR": "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions#options": "CompilerOptions options = null", "PassConfig#passes": "private PassConfig passes = null", "List<CompilerInput>#externs": "private List<CompilerInput> externs", "List<JSModule>#modules": "private List<JSModule> modules", "JSModuleGraph#moduleGraph": "private JSModuleGraph moduleGraph", "List<CompilerInput>#inputs": "private List<CompilerInput> inputs", "ErrorManager#errorManager": "private ErrorManager errorManager", "WarningsGuard#warningsGuard": "private WarningsGuard warningsGuard", "Map<String, Node>#injectedLibraries": "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node#externsRoot": "Node externsRoot", "Node#jsRoot": "Node jsRoot", "Node#externAndJsRoot": "Node externAndJsRoot", "Map<InputId, CompilerInput>#inputsById": "private Map<InputId, CompilerInput> inputsById", "SourceMap#sourceMap": "private SourceMap sourceMap", "String#externExports": "private String externExports = null", "int#uniqueNameId": "private int uniqueNameId = 0", "boolean#useThreads": "private boolean useThreads = true", "boolean#hasRegExpGlobalReferences": "private boolean hasRegExpGlobalReferences = true", "FunctionInformationMap#functionInformationMap": "private FunctionInformationMap functionInformationMap", "StringBuilder#debugLog": "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention#defaultCodingConvention": "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "JSTypeRegistry#typeRegistry": "private JSTypeRegistry typeRegistry", "Config#parserConfig": "private Config parserConfig = null", "ReverseAbstractInterpreter#abstractInterpreter": "private ReverseAbstractInterpreter abstractInterpreter", "TypeValidator#typeValidator": "private TypeValidator typeValidator", "PerformanceTracker#tracker": "public PerformanceTracker tracker", "com.google.javascript.rhino.ErrorReporter#oldErrorReporter": "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "ErrorReporter#defaultErrorReporter": "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "DiagnosticType#OPTIMIZE_LOOP_ERROR": "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "DiagnosticType#MOTION_ITERATIONS_ERROR": "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "long#COMPILER_STACK_SIZE": "private static final long COMPILER_STACK_SIZE = 1048576L", "Logger#logger": "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "PrintStream#outStream": "private final PrintStream outStream", "GlobalVarReferenceMap#globalRefMap": "private GlobalVarReferenceMap globalRefMap = null", "double#progress": "private volatile double progress = 0.0", "DiagnosticType#EMPTY_MODULE_LIST_ERROR": "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "DiagnosticType#EMPTY_ROOT_MODULE_ERROR": "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "DiagnosticType#DUPLICATE_INPUT": "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "DiagnosticType#DUPLICATE_EXTERN_INPUT": "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "PassFactory#sanityCheck": "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "Tracer#currentTracer": "private Tracer currentTracer = null", "String#currentPassName": "private String currentPassName = null", "int#syntheticCodeId": "private int syntheticCodeId = 0", "CodeChangeHandler.RecentChange#recentChange": "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "List<CodeChangeHandler>#codeChangeHandlers": "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "String#SYNTHETIC_EXTERNS": "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "CompilerInput#synthesizedExternsInput": "private CompilerInput synthesizedExternsInput = null"}, "text": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Charsets;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.io.CharStreams;\nimport com.google.javascript.jscomp.CompilerOptions.DevMode;\nimport com.google.javascript.jscomp.CompilerOptions.LanguageMode;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\nimport com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\nimport com.google.javascript.jscomp.parsing.Config;\nimport com.google.javascript.jscomp.parsing.ParserRunner;\nimport com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.head.ErrorReporter;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\n\n/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  static final String SINGLETON_MODULE_NAME = \"[singleton]\";\n\n  static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\");\n\n  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\");\n\n  CompilerOptions options = null;\n\n  private PassConfig passes = null;\n\n  // The externs inputs\n  private List<CompilerInput> externs;\n\n  // The JS source modules\n  private List<JSModule> modules;\n\n  // The graph of the JS source modules. Must be null if there are less than\n  // 2 modules, because we use this as a signal for which passes to run.\n  private JSModuleGraph moduleGraph;\n\n  // The JS source inputs\n  private List<CompilerInput> inputs;\n\n  // error manager to which error management is delegated\n  private ErrorManager errorManager;\n\n  // Warnings guard for filtering warnings.\n  private WarningsGuard warningsGuard;\n\n  // Compile-time injected libraries. The node points to the last node of\n  // the library, so code can be inserted after.\n  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n\n  // Parse tree root nodes\n  Node externsRoot;\n  Node jsRoot;\n  Node externAndJsRoot;\n\n  private Map<InputId, CompilerInput> inputsById;\n\n  /** The source code map */\n  private SourceMap sourceMap;\n\n  /** The externs created from the exports.  */\n  private String externExports = null;\n\n  /**\n   * Ids for function inlining so that each declared name remains\n   * unique.\n   */\n  private int uniqueNameId = 0;\n\n  /** Whether to use threads. */\n  private boolean useThreads = true;\n\n  /**\n   * Whether to assume there are references to the RegExp Global object\n   * properties.\n   */\n  private boolean hasRegExpGlobalReferences = true;\n\n  /** The function information map */\n  private FunctionInformationMap functionInformationMap;\n\n  /** Debugging information */\n  private final StringBuilder debugLog = new StringBuilder();\n\n  /** Detects Google-specific coding conventions. */\n  CodingConvention defaultCodingConvention = new ClosureCodingConvention();\n\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n\n  public PerformanceTracker tracker;\n\n  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.\n  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =\n      RhinoErrorReporter.forOldRhino(this);\n\n  // This error reporter gets the messages from the current Rhino parser.\n  private final ErrorReporter defaultErrorReporter =\n      RhinoErrorReporter.forNewRhino(this);\n\n  /** Error strings used for reporting JSErrors */\n  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\");\n  public static final DiagnosticType MOTION_ITERATIONS_ERROR =\n      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\");\n\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n\n\n  /**\n   * Logger for the whole com.google.javascript.jscomp domain -\n   * setting configuration for this logger affects all loggers\n   *  in other classes within the compiler.\n   */\n  private static final Logger logger =\n      Logger.getLogger(\"com.google.javascript.jscomp\");\n\n  private final PrintStream outStream;\n\n  private GlobalVarReferenceMap globalRefMap = null;\n\n  private volatile double progress = 0.0;\n\n  /**\n   * Creates a Compiler that reports errors and warnings to its logger.\n   */\n  public Compiler() {\n    this((PrintStream) null);\n  }\n\n  /**\n   * Creates n Compiler that reports errors and warnings to an output\n   * stream.\n   */\n  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }\n\n  /**\n   * Creates a Compiler that uses a custom error manager.\n   */\n  public Compiler(ErrorManager errorManager) {\n    this();\n    setErrorManager(errorManager);\n  }\n\n  /**\n   * Sets the error manager.\n   *\n   * @param errorManager the error manager, it cannot be {@code null}\n   */\n  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }\n\n  /**\n   * Creates a message formatter instance corresponding to the value of\n   * {@link CompilerOptions}.\n   */\n  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }\n\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    init(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n    for (SourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options) {\n    initModules(Lists.<SourceFile>newArrayList(externs),\n         Lists.<JSModule>newArrayList(modules), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }\n\n  /**\n   * Do any initialization that is dependent on the compiler options.\n   */\n  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }\n\n  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n      List<T> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (T file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }\n\n  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\");\n\n  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\");\n\n  /**\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   */\n  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }\n\n  /**\n   * Empty modules get an empty \"fill\" file, so that we can move code into\n   * an empty module.\n   */\n  static String createFillFileName(String moduleName) {\n    return \"[\" + moduleName + \"]\";\n  }\n\n  /**\n   * Fill any empty modules with a place holder file. It makes any cross module\n   * motion easier.\n   */\n  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(SourceFile.fromCode(\n            createFillFileName(module.getName()), \"\"));\n      }\n    }\n  }\n\n  /**\n   * Rebuilds the internal list of inputs by iterating over all modules.\n   * This is necessary if inputs have been added to or removed from a module\n   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n   */\n  public void rebuildInputsFromModules() {\n    inputs = getAllInputsFromModules(modules);\n    initInputsByIdMap();\n  }\n\n  /**\n   * Builds a single list of all module inputs. Verifies that it contains no\n   * duplicates.\n   */\n  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }\n\n  static final DiagnosticType DUPLICATE_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");\n  static final DiagnosticType DUPLICATE_EXTERN_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\");\n\n  /**\n   * Creates a map to make looking up an input by name fast. Also checks for\n   * duplicate inputs.\n   */\n  void initInputsByIdMap() {\n    inputsById = new HashMap<InputId, CompilerInput>();\n    for (CompilerInput input : externs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n      }\n    }\n  }\n\n  public Result compile(\n      SourceFile extern, SourceFile input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      SourceFile extern, JSSourceFile[] input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {\n     return compileModules(\n         Lists.newArrayList(extern), Lists.newArrayList(modules), options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options) {\n    return compile(Lists.<SourceFile>newArrayList(externs),\n        Lists.<SourceFile>newArrayList(inputs),\n        options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n      List<T1> externs, List<T2> inputs, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, inputs, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options) {\n    return compileModules(Lists.<SourceFile>newArrayList(externs),\n        Lists.<JSModule>newArrayList(modules),\n        options);\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public <T extends SourceFile> Result compileModules(List<T> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      @Override\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }\n\n  /**\n   * Disable threads. This is for clients that run on AppEngine and\n   * don't have threads.\n   */\n  public void disableThreads() {\n    useThreads = false;\n  }\n\n  private <T> T runInCompilerThread(final Callable<T> callable) {\n    return runCallable(callable, useThreads, options.tracer.isOn());\n  }\n\n  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n    return runCallable(callable, true, false);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n\n    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n    // large or complex js code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = trace;\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useLargeStackThread) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }\n\n  private void compileInternal() {\n    setProgress(0.0);\n    parse();\n    // 15 percent of the work is assumed to be for parsing (based on some\n    // minimal analysis on big JS projects, of course this depends on options)\n    setProgress(0.15);\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n    setProgress(1.0);\n  }\n\n  public void parse() {\n    parseInputs();\n  }\n\n  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }\n\n  /**\n   * Create the passes object. Clients should use setPassConfig instead of\n   * overriding this.\n   */\n  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }\n\n  /**\n   * @param passes The PassConfig to use with this Compiler.\n   * @throws NullPointerException if passes is null\n   * @throws IllegalStateException if this.passes has already been assigned\n   */\n  public void setPassConfig(PassConfig passes) {\n    // Important to check for null because if setPassConfig(null) is\n    // called before this.passes is set, getPassConfig() will create a\n    // new PassConfig object and use that, which is probably not what\n    // the client wanted since he or she probably meant to use their\n    // own PassConfig object.\n    Preconditions.checkNotNull(passes);\n\n    if (this.passes != null) {\n      throw new IllegalStateException(\"this.passes has already been assigned\");\n    }\n    this.passes = passes;\n  }\n\n  /**\n   * Carry out any special checks or procedures that need to be done before\n   * proceeding with rest of the compilation process.\n   *\n   * @return true, to continue with compilation\n   */\n  boolean precheck() {\n    return true;\n  }\n\n  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    // We are currently only interested in check-passes for progress reporting\n    // as it is used for IDEs, that's why the maximum progress is set to 1.0.\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,\n        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }\n\n  private void externExports() {\n    logger.fine(\"Creating extern file for exports\");\n    startPass(\"externExports\");\n\n    ExternExportsPass pass = new ExternExportsPass(this);\n    process(pass);\n\n    externExports = pass.getGeneratedExterns();\n\n    endPass();\n  }\n\n  @Override\n  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }\n\n  private final PassFactory sanityCheck =\n      new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  };\n\n  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }\n\n  private void runSanityCheck() {\n    sanityCheck.create(this).process(externsRoot, jsRoot);\n  }\n\n  /**\n   * Removes try/catch/finally statements for easier debugging.\n   */\n  void removeTryCatchFinally() {\n    logger.fine(\"Remove try/catch/finally\");\n    startPass(\"removeTryCatchFinally\");\n    RemoveTryCatch r = new RemoveTryCatch(this);\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Strips code for smaller compiled code. This is useful for removing debug\n   * statements to prevent leaking them publicly.\n   */\n  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n    logger.fine(\"Strip code\");\n    startPass(\"stripCode\");\n    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n        stripTypePrefixes, stripNamePrefixes);\n    if (options.getTweakProcessing().shouldStrip()) {\n      r.enableTweakStripping();\n    }\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Runs custom passes that are designated to run at a particular time.\n   */\n  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }\n\n  private Tracer currentTracer = null;\n  private String currentPassName = null;\n\n  /**\n   * Marks the beginning of a pass.\n   */\n  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }\n\n  /**\n   * Marks the end of a pass.\n   */\n  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }\n\n  /**\n   * Returns a new tracer for the given pass name.\n   */\n  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }\n\n  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }\n\n  /**\n   * Returns the result of the compilation.\n   */\n  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }\n\n  /**\n   * Returns an array constructed from errors + temporary warnings.\n   */\n  public JSError[] getMessages() {\n    return getErrors();\n  }\n\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }\n\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }\n\n  @Override\n  public Node getRoot() {\n    return externAndJsRoot;\n  }\n\n  /**\n   * Creates a new id for making unique names.\n   */\n  private int nextUniqueNameId() {\n    return uniqueNameId++;\n  }\n\n  /**\n   * Resets the unique name id counter\n   */\n  @VisibleForTesting\n  void resetUniqueNameId() {\n    uniqueNameId = 0;\n  }\n\n  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      @Override\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }\n\n  @Override\n  boolean areNodesEqualForInlining(Node n1, Node n2) {\n    if (options.ambiguateProperties ||\n        options.disambiguateProperties) {\n      // The type based optimizations require that type information is preserved\n      // during other optimizations.\n      return n1.isEquivalentToTyped(n2);\n    } else {\n      return n1.isEquivalentTo(n2);\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Inputs\n  //------------------------------------------------------------------------\n\n  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler\n  // interface, and which ones should always be injected.\n\n  @Override\n  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }\n\n  /**\n   * Removes an input file from AST.\n   * @param id The id of the input to be removed.\n   */\n  protected void removeExternInput(InputId id) {\n    CompilerInput input = getInput(id);\n    if (input == null) {\n      return;\n    }\n    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());\n    inputsById.remove(id);\n    externs.remove(input);\n    Node root = input.getAstRoot(this);\n    if (root != null) {\n      root.detachFromParent();\n    }\n  }\n\n  @Override\n  public CompilerInput newExternInput(String name) {\n    SourceAst ast = new SyntheticAst(name);\n    if (inputsById.containsKey(ast.getInputId())) {\n      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n    }\n    CompilerInput input = new CompilerInput(ast, true);\n    putCompilerInput(input.getInputId(), input);\n    externsRoot.addChildToFront(ast.getAstRoot(this));\n    externs.add(0, input);\n    return input;\n  }\n\n  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }\n\n  /** Add a source input dynamically. Intended for incremental compilation. */\n  void addIncrementalSourceAst(JsAst ast) {\n    InputId id = ast.getInputId();\n    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());\n    putCompilerInput(id, new CompilerInput(ast));\n  }\n\n  /**\n   * Replace a source input dynamically. Intended for incremental\n   * re-compilation.\n   *\n   * If the new source input doesn't parse, then keep the old input\n   * in the AST and return false.\n   *\n   * @return Whether the new AST was attached successfully.\n   */\n  boolean replaceIncrementalSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    Node oldRoot = oldInput.getAstRoot(this);\n    if (oldRoot != null) {\n      oldRoot.getParent().replaceChild(oldRoot, newRoot);\n    } else {\n      getRoot().getLastChild().addChildToBack(newRoot);\n    }\n\n    CompilerInput newInput = new CompilerInput(ast);\n    putCompilerInput(ast.getInputId(), newInput);\n\n    JSModule module = oldInput.getModule();\n    if (module != null) {\n      module.addAfter(newInput, oldInput);\n      module.remove(oldInput);\n    }\n\n    // Verify the input id is set properly.\n    Preconditions.checkState(\n        newInput.getInputId().equals(oldInput.getInputId()));\n    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();\n    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));\n\n    inputs.remove(oldInput);\n    return true;\n  }\n\n  /**\n   * Add a new source input dynamically. Intended for incremental compilation.\n   * <p>\n   * If the new source input doesn't parse, it will not be added, and a false\n   * will be returned.\n   *\n   * @param ast the JS Source to add.\n   * @return true if the source was added successfully, false otherwise.\n   * @throws IllegalStateException if an input for this ast already exists.\n   */\n  boolean addNewSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    if (oldInput != null) {\n      throw new IllegalStateException(\n          \"Input already exists: \" + ast.getInputId().getIdName());\n    }\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    getRoot().getLastChild().addChildToBack(newRoot);\n\n    CompilerInput newInput = new CompilerInput(ast);\n\n    // TODO(tylerg): handle this for multiple modules at some point.\n    if (moduleGraph == null && !modules.isEmpty()) {\n      // singleton module\n      modules.get(0).add(newInput);\n    }\n\n    putCompilerInput(ast.getInputId(), newInput);\n\n    return true;\n  }\n\n  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }\n\n  /**\n   * Gets a module graph. This will always return a module graph, even\n   * in the degenerate case when there's only one module.\n   */\n  JSModuleGraph getDegenerateModuleGraph() {\n    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;\n  }\n\n  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }\n\n  @Override\n  public MemoizedScopeCreator getTypedScopeCreator() {\n    return getPassConfig().getTypedScopeCreator();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  DefaultPassConfig ensureDefaultPassConfig() {\n    PassConfig passes = getPassConfig().getBasePassConfig();\n    Preconditions.checkState(passes instanceof DefaultPassConfig,\n        \"PassConfigs must eventually delegate to the DefaultPassConfig\");\n    return (DefaultPassConfig) passes;\n  }\n\n  public SymbolTable buildKnownSymbolTable() {\n    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());\n\n    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();\n    if (typedScopeCreator != null) {\n      symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());\n      symbolTable.addSymbolsFrom(typedScopeCreator);\n    } else {\n      symbolTable.findScopes(this, externsRoot, jsRoot);\n    }\n\n    GlobalNamespace globalNamespace =\n        ensureDefaultPassConfig().getGlobalNamespace();\n    if (globalNamespace != null) {\n      symbolTable.addSymbolsFrom(globalNamespace);\n    }\n\n    ReferenceCollectingCallback refCollector =\n        new ReferenceCollectingCallback(\n            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n    NodeTraversal.traverse(this, getRoot(), refCollector);\n    symbolTable.addSymbolsFrom(refCollector);\n\n    PreprocessorSymbolTable preprocessorSymbolTable =\n        ensureDefaultPassConfig().getPreprocessorSymbolTable();\n    if (preprocessorSymbolTable != null) {\n      symbolTable.addSymbolsFrom(preprocessorSymbolTable);\n    }\n\n    symbolTable.fillNamespaceReferences();\n    symbolTable.fillPropertyScopes();\n    symbolTable.fillThisReferences(this, externsRoot, jsRoot);\n    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);\n\n    return symbolTable;\n  }\n\n  @Override\n  public Scope getTopScope() {\n    return getPassConfig().getTopScope();\n  }\n\n  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }\n\n  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }\n\n  //------------------------------------------------------------------------\n  // Parsing\n  //------------------------------------------------------------------------\n\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n\n  /**\n   * Transforms AMD and CJS modules to something closure compiler can\n   * process and creates JSModules and the corresponding dependency tree\n   * on the way.\n   */\n  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n      if (!modules.isEmpty()) {\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }\n\n  public Node parse(SourceFile file) {\n    initCompilerOptionsIfTesting();\n    addToDebugLog(\"Parsing: \" + file.getName());\n    return new JsAst(file).getAstRoot(this);\n  }\n\n  private int syntheticCodeId = 0;\n\n  @Override\n  Node parseSyntheticCode(String js) {\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  /**\n   * Allow subclasses to override the default CompileOptions object.\n   */\n  protected CompilerOptions newCompilerOptions() {\n    return new CompilerOptions();\n  }\n\n  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(newCompilerOptions());\n    }\n  }\n\n  @Override\n  Node parseSyntheticCode(String fileName, String js) {\n    initCompilerOptionsIfTesting();\n    return parse(SourceFile.fromCode(fileName, js));\n  }\n\n  @Override\n  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\"[testcode]\", js));\n    if (inputsById == null) {\n      inputsById = Maps.newHashMap();\n    }\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }\n\n  //------------------------------------------------------------------------\n  // Convert back to source code\n  //------------------------------------------------------------------------\n\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource() {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for each input back to js code.\n   */\n  public String[] toSourceArray() {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        Tracer tracer = newTracer(\"toSourceArray\");\n        try {\n          int numInputs = inputs.size();\n          String[] sources = new String[numInputs];\n          CodeBuilder cb = new CodeBuilder();\n          for (int i = 0; i < numInputs; i++) {\n            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n            cb.reset();\n            toSource(cb, i, scriptNode);\n            sources[i] = cb.toString();\n          }\n          return sources;\n        } finally {\n          stopTracer(tracer, \"toSourceArray\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module) {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return \"\";\n        }\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module: \" + module.getName());\n          }\n          toSource(cb, i, scriptNode);\n        }\n        return cb.toString();\n      }\n    });\n  }\n\n\n  /**\n   * Converts the parse tree for each input in a module back to js code.\n   */\n  public String[] toSourceArray(final JSModule module) {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return new String[0];\n        }\n\n        String[] sources = new String[numInputs];\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module input: \" + inputs.get(i).getName());\n          }\n\n          cb.reset();\n          toSource(cb, i, scriptNode);\n          sources[i] = cb.toString();\n        }\n        return sources;\n      }\n    });\n  }\n\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n      @Override\n      public Void call() throws Exception {\n        if (options.printInputDelimiter) {\n          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            cb.append(\"\\n\");  // Make sure that the label starts on a new line\n          }\n          Preconditions.checkState(root.isScript());\n\n          String delimiter = options.inputDelimiter;\n\n          String inputName = root.getInputId().getIdName();\n          String sourceName = root.getSourceFileName();\n          Preconditions.checkState(sourceName != null);\n          Preconditions.checkState(!sourceName.isEmpty());\n\n          delimiter = delimiter\n              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))\n              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n          cb.append(delimiter)\n            .append(\"\\n\");\n        }\n        if (root.getJSDocInfo() != null &&\n            root.getJSDocInfo().getLicense() != null) {\n          cb.append(\"/*\\n\")\n            .append(root.getJSDocInfo().getLicense())\n            .append(\"*/\\n\");\n        }\n\n        // If there is a valid source map, then indicate to it that the current\n        // root node's mappings are offset by the given string builder buffer.\n        if (options.sourceMapOutputPath != null) {\n          sourceMap.setStartingPosition(\n              cb.getLineIndex(), cb.getColumnIndex());\n        }\n\n        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n        // for the first input file\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n        if (!code.isEmpty()) {\n          cb.append(code);\n\n          // In order to avoid parse ambiguity when files are concatenated\n          // together, all files should end in a semi-colon. Do a quick\n          // heuristic check if there's an obvious semi-colon already there.\n          int length = code.length();\n          char lastChar = code.charAt(length - 1);\n          char secondLastChar = length >= 2 ?\n              code.charAt(length - 2) : '\\0';\n          boolean hasSemiColon = lastChar == ';' ||\n              (lastChar == '\\n' && secondLastChar == ';');\n          if (!hasSemiColon) {\n            cb.append(\";\");\n          }\n        }\n        return null;\n      }\n    });\n  }\n\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n  }\n\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }\n\n  /**\n   * Stores a buffer of text to which more can be appended.  This is just like a\n   * StringBuilder except that we also track the number of lines.\n   */\n  public static class CodeBuilder {\n    private final StringBuilder sb = new StringBuilder();\n    private int lineCount = 0;\n    private int colCount = 0;\n\n    /** Removes all text, but leaves the line count unchanged. */\n    void reset() {\n      sb.setLength(0);\n    }\n\n    /** Appends the given string to the text buffer. */\n    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }\n\n    /** Returns all text in the text buffer. */\n    @Override\n    public String toString() {\n      return sb.toString();\n    }\n\n    /** Returns the length of the text buffer. */\n    public int getLength() {\n      return sb.length();\n    }\n\n    /** Returns the (zero-based) index of the last line in the text buffer. */\n    int getLineIndex() {\n      return lineCount;\n    }\n\n    /** Returns the (zero-based) index of the last column in the text buffer. */\n    int getColumnIndex() {\n      return colCount;\n    }\n\n    /** Determines whether the text ends with the given suffix. */\n    boolean endsWith(String suffix) {\n      return (sb.length() > suffix.length())\n          && suffix.equals(sb.substring(sb.length() - suffix.length()));\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Optimizations\n  //------------------------------------------------------------------------\n\n  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }\n\n  @Override\n  void setCssRenamingMap(CssRenamingMap map) {\n    options.cssRenamingMap = map;\n  }\n\n  @Override\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }\n\n  /**\n   * Reprocesses the current defines over the AST.  This is used by GwtCompiler\n   * to generate N outputs for different targets from the same (checked) AST.\n   * For each target, we apply the target-specific defines by calling\n   * {@code processDefines} and then {@code optimize} to optimize the AST\n   * specifically for that target.\n   */\n  public void processDefines() {\n    (new DefaultPassConfig(options)).processDefines.create(this)\n        .process(externsRoot, jsRoot);\n  }\n\n  boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }\n\n  /** Control Flow Analysis. */\n  ControlFlowGraph<Node> computeCFG() {\n    logger.fine(\"Computing Control Flow Graph\");\n    Tracer tracer = newTracer(\"computeCFG\");\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n    process(cfa);\n    stopTracer(tracer, \"computeCFG\");\n    return cfa.getCfg();\n  }\n\n  public void normalize() {\n    logger.fine(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }\n\n  @Override\n  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }\n\n  void recordFunctionInformation() {\n    logger.fine(\"Recording function information\");\n    startPass(\"recordFunctionInformation\");\n    RecordFunctionInformation recordFunctionInfoPass =\n        new RecordFunctionInformation(\n            this, getPassConfig().getIntermediateState().functionNames);\n    process(recordFunctionInfoPass);\n    functionInformationMap = recordFunctionInfoPass.getMap();\n    endPass();\n  }\n\n  protected final CodeChangeHandler.RecentChange recentChange =\n      new CodeChangeHandler.RecentChange();\n  private final List<CodeChangeHandler> codeChangeHandlers =\n      Lists.<CodeChangeHandler>newArrayList();\n\n  /** Name of the synthetic input that holds synthesized externs. */\n  static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\";\n\n  private CompilerInput synthesizedExternsInput = null;\n\n  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }\n\n  @Override\n  void removeChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.remove(handler);\n  }\n\n  /**\n   * All passes should call reportCodeChange() when they alter\n   * the JS tree structure. This is verified by CompilerTestCase.\n   * This allows us to optimize to a fixed point.\n   */\n  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }\n\n  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }\n\n  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }\n\n  @Override\n  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n    }\n    return false;\n  }\n\n  public LanguageMode languageMode() {\n    return options.getLanguageIn();\n  }\n\n  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }\n\n  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }\n\n  @Override\n  public boolean isTypeCheckingEnabled() {\n    return options.checkTypes;\n  }\n\n\n  //------------------------------------------------------------------------\n  // Error reporting\n  //------------------------------------------------------------------------\n\n  /**\n   * The warning classes that are available from the command-line, and\n   * are suppressable by the {@code @suppress} annotation.\n   */\n  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }\n\n  @Override\n  public void report(JSError error) {\n    CheckLevel level = error.getDefaultLevel();\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      if (getOptions().errorHandler != null) {\n        getOptions().errorHandler.report(level, error);\n      }\n      errorManager.report(level, error);\n    }\n  }\n\n  @Override\n  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }\n\n  /**\n   * Report an internal error.\n   */\n  @Override\n  void throwInternalError(String message, Exception cause) {\n    String finalMessage =\n      \"INTERNAL COMPILER ERROR.\\n\" +\n      \"Please report this problem.\\n\" + message;\n\n    RuntimeException e = new RuntimeException(finalMessage, cause);\n    if (cause != null) {\n      e.setStackTrace(cause.getStackTrace());\n    }\n    throw e;\n  }\n\n\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }\n\n  /**\n   * Gets the number of warnings.\n   */\n  public int getWarningCount() {\n    return errorManager.getWarningCount();\n  }\n\n  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }\n\n  /**\n   * Consults the {@link ErrorManager} to see if we've encountered errors\n   * that should halt compilation. <p>\n   *\n   * If {@link CompilerOptions#ideMode} is {@code true}, this function\n   * always returns {@code false} without consulting the error manager. The\n   * error manager will continue to be told about new errors and warnings, but\n   * the compiler will complete compilation of all inputs.<p>\n   */\n  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }\n\n  /** Called from the compiler passes, adds debug info */\n  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }\n\n  private SourceFile getSourceFileByName(String sourceName) {\n    // Here we assume that the source name is the input name, this\n    // is try of javascript parsed from source.\n    if (sourceName != null) {\n      CompilerInput input = inputsById.get(new InputId(sourceName));\n      if (input != null) {\n        return input.getSourceFile();\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }\n\n  @Override\n  public Region getSourceRegion(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getRegion(lineNumber);\n    }\n    return null;\n  }\n\n  //------------------------------------------------------------------------\n  // Package-private helpers\n  //------------------------------------------------------------------------\n\n  @Override\n  Node getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n      if (inputs.isEmpty()) {\n        throw new IllegalStateException(\"No inputs\");\n      }\n\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    List<CompilerInput> moduleInputs = module.getInputs();\n    if (moduleInputs.size() > 0) {\n      return moduleInputs.get(0).getAstRoot(this);\n    }\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }\n\n  public SourceMap getSourceMap() {\n    return sourceMap;\n  }\n\n  VariableMap getVariableMap() {\n    return getPassConfig().getIntermediateState().variableMap;\n  }\n\n  VariableMap getPropertyMap() {\n    return getPassConfig().getIntermediateState().propertyMap;\n  }\n\n  CompilerOptions getOptions() {\n    return options;\n  }\n\n  FunctionInformationMap getFunctionalInformationMap() {\n    return functionInformationMap;\n  }\n\n  /**\n   * Sets the logging level for the com.google.javascript.jscomp package.\n   */\n  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }\n\n  /** Gets the DOT graph of the AST generated at the end of compilation. */\n  public String getAstDotGraph() throws IOException {\n    if (jsRoot != null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n      cfa.process(null, jsRoot);\n      return DotFormatter.toDot(jsRoot, cfa.getCfg());\n    } else {\n      return \"\";\n    }\n  }\n\n  @Override\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(newCompilerOptions());\n    }\n    return errorManager;\n  }\n\n  @Override\n  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }\n\n  /**\n   * Returns an unmodifiable view of the compiler inputs indexed by id.\n   */\n  public Map<InputId, CompilerInput> getInputsById() {\n    return Collections.unmodifiableMap(inputsById);\n  }\n\n  /**\n   * Gets the externs in the order in which they are being processed.\n   */\n  List<CompilerInput> getExternsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(externs);\n  }\n\n  /**\n   * Stores the internal compiler state just before optimization is performed.\n   * This can be saved and restored in order to efficiently optimize multiple\n   * different output targets without having to perform checking multiple times.\n   *\n   * NOTE: This does not include all parts of the compiler's internal state. In\n   * particular, SourceFiles and CompilerOptions are not recorded. In\n   * order to recreate a Compiler instance from scratch, you would need to\n   * call {@code init} with the same arguments as in the initial creation before\n   * restoring intermediate state.\n   */\n  public static class IntermediateState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    Node externsRoot;\n    private Node jsRoot;\n    private List<CompilerInput> externs;\n    private List<CompilerInput> inputs;\n    private List<JSModule> modules;\n    private PassConfig.State passConfigState;\n    private JSTypeRegistry typeRegistry;\n    private AbstractCompiler.LifeCycleStage lifeCycleStage;\n    private Map<String, Node> injectedLibraries;\n\n    private IntermediateState() {}\n  }\n\n  /**\n   * Returns the current internal state, excluding the input files and modules.\n   */\n  public IntermediateState getState() {\n    IntermediateState state = new IntermediateState();\n    state.externsRoot = externsRoot;\n    state.jsRoot = jsRoot;\n    state.externs = externs;\n    state.inputs = inputs;\n    state.modules = modules;\n    state.passConfigState = getPassConfig().getIntermediateState();\n    state.typeRegistry = typeRegistry;\n    state.lifeCycleStage = getLifeCycleStage();\n    state.injectedLibraries = Maps.newLinkedHashMap(injectedLibraries);\n\n    return state;\n  }\n\n  /**\n   * Sets the internal state to the capture given.  Note that this assumes that\n   * the input files are already set up.\n   */\n  public void setState(IntermediateState state) {\n    externsRoot = state.externsRoot;\n    jsRoot = state.jsRoot;\n    externs = state.externs;\n    inputs = state.inputs;\n    modules = state.modules;\n    passes = createPassConfigInternal();\n    getPassConfig().setIntermediateState(state.passConfigState);\n    typeRegistry = state.typeRegistry;\n    setLifeCycleStage(state.lifeCycleStage);\n\n    injectedLibraries.clear();\n    injectedLibraries.putAll(state.injectedLibraries);\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getInputsForTesting() {\n    return inputs;\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getExternsForTesting() {\n    return externs;\n  }\n\n  @Override\n  boolean hasRegExpGlobalReferences() {\n    return hasRegExpGlobalReferences;\n  }\n\n  @Override\n  void setHasRegExpGlobalReferences(boolean references) {\n    hasRegExpGlobalReferences = references;\n  }\n\n  @Override\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.isScript()\n        || collectionRoot.isBlock());\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n          getExternsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }\n\n  @Override\n  GlobalVarReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }\n\n  @Override\n  CompilerInput getSynthesizedExternsInput() {\n    if (synthesizedExternsInput == null) {\n      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);\n    }\n    return synthesizedExternsInput;\n  }\n\n  @Override\n  public double getProgress() {\n    return progress;\n  }\n\n  @Override\n  void setProgress(double newProgress) {\n    if (newProgress > 1.0) {\n      progress = 1.0;\n    } else if (newProgress < 0.0) {\n      progress = 0.0;\n    } else {\n      progress = newProgress;\n    }\n  }\n\n  /**\n   * Replaces one file in a hot-swap mode. The given JsAst should be made\n   * from a new version of a file that already was present in the last compile\n   * call. If the file is new, this will silently ignored.\n   *\n   * @param ast the ast of the file that is being replaced\n   */\n  public void replaceScript(JsAst ast) {\n    CompilerInput input = this.getInput(ast.getInputId());\n    if (!replaceIncrementalSourceAst(ast)) {\n      return;\n    }\n    Node originalRoot = input.getAstRoot(this);\n\n    processNewScript(ast, originalRoot);\n  }\n\n  /**\n   * Adds a new Script AST to the compile state. If a script for the same file\n   * already exists the script will not be added, instead a call to\n   * #replaceScript should be used.\n   *\n   * @param ast the ast of the new file\n   */\n  public void addNewScript(JsAst ast) {\n    if (!addNewSourceAst(ast)) {\n      return;\n    }\n    Node emptyScript = new Node(Token.SCRIPT);\n    InputId inputId = ast.getInputId();\n    emptyScript.setInputId(inputId);\n    emptyScript.setStaticSourceFile(\n        SourceFile.fromCode(inputId.getIdName(), \"\"));\n\n    processNewScript(ast, emptyScript);\n  }\n\n  private void processNewScript(JsAst ast, Node originalRoot) {\n    Node js = ast.getAstRoot(this);\n    Preconditions.checkNotNull(js);\n\n    runHotSwap(originalRoot, js, this.getCleanupPassConfig());\n    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need\n    // to revisit this approach to clearing GlobalNamespaces\n    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);\n\n    this.getTypeRegistry().clearNamedTypes();\n    this.removeSyntheticVarsInput();\n\n    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());\n  }\n\n  /**\n   * Execute the passes from a PassConfig instance over a single replaced file.\n   */\n  private void runHotSwap(\n      Node originalRoot, Node js, PassConfig passConfig) {\n    for (PassFactory passFactory : passConfig.getChecks()) {\n      runHotSwapPass(originalRoot, js, passFactory);\n    }\n  }\n\n  private void runHotSwapPass(\n      Node originalRoot, Node js, PassFactory passFactory) {\n    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);\n    if (pass != null) {\n      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());\n      pass.hotSwapScript(js, originalRoot);\n    }\n  }\n\n  private PassConfig getCleanupPassConfig() {\n    return new CleanupPasses(getOptions());\n  }\n\n  private void removeSyntheticVarsInput() {\n    String sourceName = Compiler.SYNTHETIC_EXTERNS;\n    removeExternInput(new InputId(sourceName));\n  }\n\n  @Override\n  Node ensureLibraryInjected(String resourceName) {\n    if (injectedLibraries.containsKey(resourceName)) {\n      return null;\n    }\n\n    // All libraries depend on js/base.js\n    boolean isBase = \"base\".equals(resourceName);\n    if (!isBase) {\n      ensureLibraryInjected(\"base\");\n    }\n\n    Node firstChild = loadLibraryCode(resourceName).removeChildren();\n    Node lastChild = firstChild.getLastSibling();\n\n    Node parent = getNodeForCodeInsertion(null);\n    if (isBase) {\n      parent.addChildrenToFront(firstChild);\n    } else {\n      parent.addChildrenAfter(\n          firstChild, injectedLibraries.get(\"base\"));\n    }\n    reportCodeChange();\n\n    injectedLibraries.put(resourceName, lastChild);\n    return lastChild;\n  }\n\n  /** Load a library as a resource */\n  @VisibleForTesting\n  Node loadLibraryCode(String resourceName) {\n    String originalCode;\n    try {\n      originalCode = CharStreams.toString(new InputStreamReader(\n          Compiler.class.getResourceAsStream(\n              String.format(\"js/%s.js\", resourceName)),\n          Charsets.UTF_8));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    return Normalize.parseAndNormalizeSyntheticCode(\n        this, originalCode,\n        String.format(\"jscomp_%s_\", resourceName));\n  }\n}\n"}, "generated_test_class": "Sure! Below is a set of unit tests for the `initModules` method in the `Compiler` class. These tests aim to cover various branches and lines within the method.\n\n```java\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.*;\nimport com.google.javascript.jscomp.CompilerOptions.LanguageMode;\nimport com.google.javascript.jscomp.NodeUtil.SourceKind;\nimport com.google.javascript.rhino.JSDocInfo.Visibility;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.StaticSourceFile;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\nimport java.util.List;\n\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\n@RunWith(JUnit4.class)\npublic class CompilerInitModulesTest {\n\n    private Compiler compiler;\n    private CompilerOptions options;\n    private JSModule module1;\n    private JSModule module2;\n    private JSModule module3;\n    private List<JSSourceFile> externs;\n    private List<JSSourceFile> inputs;\n\n    @Before\n    public void setUp() {\n        compiler = new Compiler();\n        options = new CompilerOptions();\n        options.setLanguageIn(LanguageMode.ECMASCRIPT5);\n\n        module1 = new JSModule(\"module1\");\n        module2 = new JSModule(\"module2\");\n        module3 = new JSModule(\"module3\");\n\n        JSSourceFile externFile = JSSourceFile.fromCode(\"externs.js\", \"\");\n        JSSourceFile inputFile1 = JSSourceFile.fromCode(\"input1.js\", \"var a = 1;\");\n        JSSourceFile inputFile2 = JSSourceFile.fromCode(\"input2.js\", \"var b = 2;\");\n        JSSourceFile inputFile3 = JSSourceFile.fromCode(\"input3.js\", \"var c = 3;\");\n\n        externs = ImmutableList.of(externFile);\n        inputs = ImmutableList.of(inputFile1, inputFile2, inputFile3);\n    }\n\n    @Test\n    public void testInitModules_SingleModule_NoErrors() {\n        module1.add(inputFile1);\n\n        compiler.initModules(externs, ImmutableList.of(module1), options);\n\n        assertNotNull(compiler.moduleGraph);\n        assertEquals(1, compiler.moduleGraph.getAllModules().size());\n        assertNull(compiler.getErrorManager().getErrors()[0]);\n    }\n\n    @Test\n    public void testInitModules_MultipleModules_NoErrors() {\n        module1.add(inputFile1);\n        module1.add(inputFile2);\n        module2.addDependency(module1);\n        module2.add(inputFile3);\n\n        compiler.initModules(externs, ImmutableList.of(module1, module2), options);\n\n        assertNotNull(compiler.moduleGraph);\n        assertEquals(2, compiler.moduleGraph.getAllModules().size());\n        assertNull(compiler.getErrorManager().getErrors()[0]);\n    }\n\n    @Test\n    public void testInitModules_DependentModuleBeforeDependent_NoErrors() {\n        module2.add(inputFile1);\n        module1.addDependency(module2);\n        module1.add(inputFile2);\n\n        compiler.initModules(externs, ImmutableList.of(module2, module1), options);\n\n        assertNotNull(compiler.moduleGraph);\n        assertEquals(2, compiler.moduleGraph.getAllModules().size());\n        assertNull(compiler.getErrorManager().getErrors()[0]);\n    }\n\n    @Test\n    public void testInitModules_EmptyModuleList_Error() {\n        compiler.initModules(externs, ImmutableList.of(), options);\n\n        assertNull(compiler.moduleGraph);\n        JSError[] errors = compiler.getErrorManager().getErrors();\n        assertEquals(1, errors.length);\n        assertEquals(DiagnosticType.ERROR, errors[0].getType().level);\n        assertEquals(\"JSC_EMPTY_MODULE_LIST_ERROR\", errors[0].getType().key);\n    }\n\n    @Test\n    public void testInitModules_FirstModuleEmpty_Error() {\n        compiler.initModules(externs, ImmutableList.of(new JSModule(\"emptyModule\")), options);\n\n        assertNull(compiler.moduleGraph);\n        JSError[] errors = compiler.getErrorManager().getErrors();\n        assertEquals(1, errors.length);\n        assertEquals(DiagnosticType.ERROR, errors[0].getType().level);\n        assertEquals(\"JSC_EMPTY_ROOT_MODULE_ERROR\", errors[0].getType().key);\n    }\n\n    @Test\n    public void testInitModules_ModuleDependencyError() {\n        module1.add(inputFile1);\n        module2.add(inputFile2);\n        module3.add(inputFile3);\n        module1.addDependency(module2);\n        module2.addDependency(module3);\n        module3.addDependency(module1); // Circular dependency\n\n        compiler.initModules(externs, ImmutableList.of(module1, module2, module3), options);\n\n        assertNull(compiler.moduleGraph);\n        JSError[] errors = compiler.getErrorManager().getErrors();\n        assertEquals(1, errors.length);\n        assertEquals(DiagnosticType.ERROR, errors[0].getType().level);\n        assertEquals(\"JSC_MODULE_DEPENDENCY_ERROR\", errors[0].getType().key);\n    }\n}\n```\n\n### Explanation:\n\n1. **Single Module Test (`testInitModules_SingleModule_NoErrors`)**:\n   - Sets up a single module with one input file.\n   - Verifies that `moduleGraph` is created correctly and no errors are reported.\n\n2. **Multiple Modules Test (`testInitModules_MultipleModules_NoErrors`)**:\n   - Sets up two modules with dependencies between them.\n   - Verifies that `moduleGraph` is created correctly and no errors are reported.\n\n3. **Dependent Module Before Dependent Test (`testInitModules_DependentModuleBeforeDependent_NoErrors`)**:\n   - Sets up two modules where the dependent module is listed before the module it depends on.\n   - Verifies that `moduleGraph` is created correctly and no errors are reported.\n\n4. **Empty Module List Test (`testInitModules_EmptyModuleList_Error`)**:\n   - Attempts to initialize with an empty list of modules.\n   - Verifies that an error is reported.\n\n5. **First Module Empty Test (`testInitModules_FirstModuleEmpty_Error`)**:\n   - Attempts to initialize with a single empty module.\n   - Verifies that an error is reported.\n\n6. **Module Dependency Error Test (`testInitModules_ModuleDependencyError`)**:\n   - Sets up three modules with a circular dependency.\n   - Verifies that an error is reported.\n\nThese tests should provide good coverage for the `initModules` method, ensuring that all branches and lines are exercised."}
{"bug_id": "Closure_31", "version": "fixed", "focal_method_signature": "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "focal_method": "public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options) {\n    return compile(Lists.<SourceFile>newArrayList(externs),\n        Lists.<SourceFile>newArrayList(inputs),\n        options);\n  }", "return_type": "Result", "assertion_subject_candidates": ["JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "double com.google.javascript.jscomp.Compiler#getProgress()", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()"], "focal_class": {"name": "Compiler", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "superclass": "extends AbstractCompiler", "interface": "", "imports": ["import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.Charsets;", "import com.google.common.base.Preconditions;", "import com.google.common.base.Supplier;", "import com.google.common.base.Throwables;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.common.io.CharStreams;", "import com.google.javascript.jscomp.CompilerOptions.DevMode;", "import com.google.javascript.jscomp.CompilerOptions.LanguageMode;", "import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;", "import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;", "import com.google.javascript.jscomp.parsing.Config;", "import com.google.javascript.jscomp.parsing.ParserRunner;", "import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;", "import com.google.javascript.rhino.IR;", "import com.google.javascript.rhino.InputId;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import com.google.javascript.rhino.head.ErrorReporter;", "import com.google.javascript.rhino.jstype.JSTypeRegistry;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.PrintStream;", "import java.io.Serializable;", "import java.nio.charset.Charset;", "import java.util.Collections;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;", "import java.util.concurrent.Callable;", "import java.util.logging.Level;", "import java.util.logging.Logger;", "import java.util.regex.Matcher;"], "fields": ["static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions options = null", "private PassConfig passes = null", "private List<CompilerInput> externs", "private List<JSModule> modules", "private JSModuleGraph moduleGraph", "private List<CompilerInput> inputs", "private ErrorManager errorManager", "private WarningsGuard warningsGuard", "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node externsRoot", "Node jsRoot", "Node externAndJsRoot", "private Map<InputId, CompilerInput> inputsById", "private SourceMap sourceMap", "private String externExports = null", "private int uniqueNameId = 0", "private boolean useThreads = true", "private boolean hasRegExpGlobalReferences = true", "private FunctionInformationMap functionInformationMap", "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "private JSTypeRegistry typeRegistry", "private Config parserConfig = null", "private ReverseAbstractInterpreter abstractInterpreter", "private TypeValidator typeValidator", "public PerformanceTracker tracker", "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "private static final long COMPILER_STACK_SIZE = 1048576L", "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "private final PrintStream outStream", "private GlobalVarReferenceMap globalRefMap = null", "private volatile double progress = 0.0", "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "private Tracer currentTracer = null", "private String currentPassName = null", "private int syntheticCodeId = 0", "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "private CompilerInput synthesizedExternsInput = null"], "methods": ["void com.google.javascript.jscomp.Compiler#setErrorManager(ErrorManager#errorManager)", "MessageFormatter com.google.javascript.jscomp.Compiler#createMessageFormatter()", "void com.google.javascript.jscomp.Compiler#initOptions(CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initBasedOnOptions()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#makeCompilerInput(List<T>#files,boolean#isExtern)", "void com.google.javascript.jscomp.Compiler#checkFirstModule(List<JSModule>#modules)", "String com.google.javascript.jscomp.Compiler#createFillFileName(String#moduleName)", "void com.google.javascript.jscomp.Compiler#fillEmptyModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#rebuildInputsFromModules()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getAllInputsFromModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#initInputsByIdMap()", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,SourceFile#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,JSSourceFile[]#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile#extern,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compileModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile()", "void com.google.javascript.jscomp.Compiler#disableThreads()", "T com.google.javascript.jscomp.Compiler#runInCompilerThread(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallableWithLargeStack(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallable(Callable<T>#callable,boolean#useLargeStackThread,boolean#trace)", "void com.google.javascript.jscomp.Compiler#compileInternal()", "void com.google.javascript.jscomp.Compiler#parse()", "PassConfig com.google.javascript.jscomp.Compiler#getPassConfig()", "PassConfig com.google.javascript.jscomp.Compiler#createPassConfigInternal()", "void com.google.javascript.jscomp.Compiler#setPassConfig(PassConfig#passes)", "boolean com.google.javascript.jscomp.Compiler#precheck()", "void com.google.javascript.jscomp.Compiler#check()", "void com.google.javascript.jscomp.Compiler#externExports()", "void com.google.javascript.jscomp.Compiler#process(CompilerPass#p)", "void com.google.javascript.jscomp.Compiler#maybeSanityCheck()", "void com.google.javascript.jscomp.Compiler#runSanityCheck()", "void com.google.javascript.jscomp.Compiler#removeTryCatchFinally()", "void com.google.javascript.jscomp.Compiler#stripCode(Set<String>#stripTypes,Set<String>#stripNameSuffixes,Set<String>#stripTypePrefixes,Set<String>#stripNamePrefixes)", "void com.google.javascript.jscomp.Compiler#runCustomPasses(CustomPassExecutionTime#executionTime)", "void com.google.javascript.jscomp.Compiler#startPass(String#passName)", "void com.google.javascript.jscomp.Compiler#endPass()", "Tracer com.google.javascript.jscomp.Compiler#newTracer(String#passName)", "void com.google.javascript.jscomp.Compiler#stopTracer(Tracer#t,String#passName)", "Result com.google.javascript.jscomp.Compiler#getResult()", "JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "int com.google.javascript.jscomp.Compiler#nextUniqueNameId()", "void com.google.javascript.jscomp.Compiler#resetUniqueNameId()", "Supplier<String> com.google.javascript.jscomp.Compiler#getUniqueNameIdSupplier()", "boolean com.google.javascript.jscomp.Compiler#areNodesEqualForInlining(Node#n1,Node#n2)", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "void com.google.javascript.jscomp.Compiler#removeExternInput(InputId#id)", "CompilerInput com.google.javascript.jscomp.Compiler#newExternInput(String#name)", "CompilerInput com.google.javascript.jscomp.Compiler#putCompilerInput(InputId#id,CompilerInput#input)", "void com.google.javascript.jscomp.Compiler#addIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#replaceIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#addNewSourceAst(JsAst#ast)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "JSTypeRegistry com.google.javascript.jscomp.Compiler#getTypeRegistry()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "DefaultPassConfig com.google.javascript.jscomp.Compiler#ensureDefaultPassConfig()", "SymbolTable com.google.javascript.jscomp.Compiler#buildKnownSymbolTable()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ReverseAbstractInterpreter com.google.javascript.jscomp.Compiler#getReverseAbstractInterpreter()", "TypeValidator com.google.javascript.jscomp.Compiler#getTypeValidator()", "Node com.google.javascript.jscomp.Compiler#parseInputs()", "void com.google.javascript.jscomp.Compiler#processAMDAndCommonJSModules()", "Node com.google.javascript.jscomp.Compiler#parse(SourceFile#file)", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#js)", "CompilerOptions com.google.javascript.jscomp.Compiler#newCompilerOptions()", "void com.google.javascript.jscomp.Compiler#initCompilerOptionsIfTesting()", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#fileName,String#js)", "Node com.google.javascript.jscomp.Compiler#parseTestCode(String#js)", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "String com.google.javascript.jscomp.Compiler#toSource()", "String[] com.google.javascript.jscomp.Compiler#toSourceArray()", "String com.google.javascript.jscomp.Compiler#toSource(JSModule#module)", "String[] com.google.javascript.jscomp.Compiler#toSourceArray(JSModule#module)", "void com.google.javascript.jscomp.Compiler#toSource(CodeBuilder#cb,int#inputSeqNum,Node#root)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n,SourceMap#sourceMap,boolean#firstOutput)", "void com.google.javascript.jscomp.Compiler#optimize()", "void com.google.javascript.jscomp.Compiler#setCssRenamingMap(CssRenamingMap#map)", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "void com.google.javascript.jscomp.Compiler#processDefines()", "boolean com.google.javascript.jscomp.Compiler#isInliningForbidden()", "ControlFlowGraph<Node> com.google.javascript.jscomp.Compiler#computeCFG()", "void com.google.javascript.jscomp.Compiler#normalize()", "void com.google.javascript.jscomp.Compiler#prepareAst(Node#root)", "void com.google.javascript.jscomp.Compiler#recordFunctionInformation()", "void com.google.javascript.jscomp.Compiler#addChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#removeChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#reportCodeChange()", "CodingConvention com.google.javascript.jscomp.Compiler#getCodingConvention()", "boolean com.google.javascript.jscomp.Compiler#isIdeMode()", "boolean com.google.javascript.jscomp.Compiler#acceptEcmaScript5()", "LanguageMode com.google.javascript.jscomp.Compiler#languageMode()", "boolean com.google.javascript.jscomp.Compiler#acceptConstKeyword()", "Config com.google.javascript.jscomp.Compiler#getParserConfig()", "boolean com.google.javascript.jscomp.Compiler#isTypeCheckingEnabled()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "void com.google.javascript.jscomp.Compiler#report(JSError#error)", "CheckLevel com.google.javascript.jscomp.Compiler#getErrorLevel(JSError#error)", "void com.google.javascript.jscomp.Compiler#throwInternalError(String#message,Exception#cause)", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "boolean com.google.javascript.jscomp.Compiler#hasHaltingErrors()", "boolean com.google.javascript.jscomp.Compiler#hasErrors()", "void com.google.javascript.jscomp.Compiler#addToDebugLog(String#str)", "SourceFile com.google.javascript.jscomp.Compiler#getSourceFileByName(String#sourceName)", "String com.google.javascript.jscomp.Compiler#getSourceLine(String#sourceName,int#lineNumber)", "Region com.google.javascript.jscomp.Compiler#getSourceRegion(String#sourceName,int#lineNumber)", "Node com.google.javascript.jscomp.Compiler#getNodeForCodeInsertion(JSModule#module)", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "void com.google.javascript.jscomp.Compiler#setLoggingLevel(Level#level)", "String com.google.javascript.jscomp.Compiler#getAstDotGraph()", "ErrorManager com.google.javascript.jscomp.Compiler#getErrorManager()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "IntermediateState com.google.javascript.jscomp.Compiler#getState()", "void com.google.javascript.jscomp.Compiler#setState(IntermediateState#state)", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "boolean com.google.javascript.jscomp.Compiler#hasRegExpGlobalReferences()", "void com.google.javascript.jscomp.Compiler#setHasRegExpGlobalReferences(boolean#references)", "void com.google.javascript.jscomp.Compiler#updateGlobalVarReferences(Map<Var, ReferenceCollection>#refMapPatch,Node#collectionRoot)", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "CompilerInput com.google.javascript.jscomp.Compiler#getSynthesizedExternsInput()", "double com.google.javascript.jscomp.Compiler#getProgress()", "void com.google.javascript.jscomp.Compiler#setProgress(double#newProgress)", "void com.google.javascript.jscomp.Compiler#replaceScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#addNewScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#processNewScript(JsAst#ast,Node#originalRoot)", "void com.google.javascript.jscomp.Compiler#runHotSwap(Node#originalRoot,Node#js,PassConfig#passConfig)", "void com.google.javascript.jscomp.Compiler#runHotSwapPass(Node#originalRoot,Node#js,PassFactory#passFactory)", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()", "void com.google.javascript.jscomp.Compiler#removeSyntheticVarsInput()", "Node com.google.javascript.jscomp.Compiler#ensureLibraryInjected(String#resourceName)", "Node com.google.javascript.jscomp.Compiler#loadLibraryCode(String#resourceName)"], "other_methods": ["public void setErrorManager(ErrorManager errorManager);", "public void initOptions(CompilerOptions options);", "public void init(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public void init(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public void init(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public void initModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void rebuildInputsFromModules();", "public Result compile(SourceFile extern,SourceFile input,CompilerOptions options);", "public Result compile(SourceFile extern,JSSourceFile[] input,CompilerOptions options);", "public Result compile(JSSourceFile extern,JSModule[] modules,CompilerOptions options);", "public Result compile(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public Result compileModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void disableThreads();", "public void parse();", "public void setPassConfig(PassConfig passes);", "public void check();", "public Result getResult();", "public JSError[] getMessages();", "public JSError[] getErrors();", "public JSError[] getWarnings();", "@Override\n  public Node getRoot();", "@Override\n  public CompilerInput getInput(InputId id);", "@Override\n  public CompilerInput newExternInput(String name);", "@Override\n  public JSTypeRegistry getTypeRegistry();", "@Override\n  public MemoizedScopeCreator getTypedScopeCreator();", "public SymbolTable buildKnownSymbolTable();", "@Override\n  public Scope getTopScope();", "@Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter();", "public Node parse(SourceFile file);", "public String toSource();", "public String[] toSourceArray();", "public String toSource(JSModule module);", "public String[] toSourceArray(JSModule module);", "public void toSource(CodeBuilder cb,int inputSeqNum,Node root);", "public void optimize();", "public void processDefines();", "public void normalize();", "@Override\n  public void reportCodeChange();", "@Override\n  public CodingConvention getCodingConvention();", "@Override\n  public boolean isIdeMode();", "@Override\n  public boolean acceptEcmaScript5();", "public LanguageMode languageMode();", "@Override\n  public boolean acceptConstKeyword();", "@Override\n  public boolean isTypeCheckingEnabled();", "@Override\n  public void report(JSError error);", "@Override\n  public CheckLevel getErrorLevel(JSError error);", "public int getErrorCount();", "public int getWarningCount();", "public boolean hasErrors();", "@Override\n  public String getSourceLine(String sourceName,int lineNumber);", "@Override\n  public Region getSourceRegion(String sourceName,int lineNumber);", "public SourceMap getSourceMap();", "public static void setLoggingLevel(Level level);", "public String getAstDotGraph();", "@Override\n  public ErrorManager getErrorManager();", "public Map<InputId, CompilerInput> getInputsById();", "public IntermediateState getState();", "public void setState(IntermediateState state);", "@Override\n  public double getProgress();", "public void replaceScript(JsAst ast);", "public void addNewScript(JsAst ast);"], "fields_dict": {"String#SINGLETON_MODULE_NAME": "static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "DiagnosticType#MODULE_DEPENDENCY_ERROR": "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "DiagnosticType#MISSING_ENTRY_ERROR": "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions#options": "CompilerOptions options = null", "PassConfig#passes": "private PassConfig passes = null", "List<CompilerInput>#externs": "private List<CompilerInput> externs", "List<JSModule>#modules": "private List<JSModule> modules", "JSModuleGraph#moduleGraph": "private JSModuleGraph moduleGraph", "List<CompilerInput>#inputs": "private List<CompilerInput> inputs", "ErrorManager#errorManager": "private ErrorManager errorManager", "WarningsGuard#warningsGuard": "private WarningsGuard warningsGuard", "Map<String, Node>#injectedLibraries": "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node#externsRoot": "Node externsRoot", "Node#jsRoot": "Node jsRoot", "Node#externAndJsRoot": "Node externAndJsRoot", "Map<InputId, CompilerInput>#inputsById": "private Map<InputId, CompilerInput> inputsById", "SourceMap#sourceMap": "private SourceMap sourceMap", "String#externExports": "private String externExports = null", "int#uniqueNameId": "private int uniqueNameId = 0", "boolean#useThreads": "private boolean useThreads = true", "boolean#hasRegExpGlobalReferences": "private boolean hasRegExpGlobalReferences = true", "FunctionInformationMap#functionInformationMap": "private FunctionInformationMap functionInformationMap", "StringBuilder#debugLog": "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention#defaultCodingConvention": "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "JSTypeRegistry#typeRegistry": "private JSTypeRegistry typeRegistry", "Config#parserConfig": "private Config parserConfig = null", "ReverseAbstractInterpreter#abstractInterpreter": "private ReverseAbstractInterpreter abstractInterpreter", "TypeValidator#typeValidator": "private TypeValidator typeValidator", "PerformanceTracker#tracker": "public PerformanceTracker tracker", "com.google.javascript.rhino.ErrorReporter#oldErrorReporter": "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "ErrorReporter#defaultErrorReporter": "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "DiagnosticType#OPTIMIZE_LOOP_ERROR": "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "DiagnosticType#MOTION_ITERATIONS_ERROR": "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "long#COMPILER_STACK_SIZE": "private static final long COMPILER_STACK_SIZE = 1048576L", "Logger#logger": "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "PrintStream#outStream": "private final PrintStream outStream", "GlobalVarReferenceMap#globalRefMap": "private GlobalVarReferenceMap globalRefMap = null", "double#progress": "private volatile double progress = 0.0", "DiagnosticType#EMPTY_MODULE_LIST_ERROR": "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "DiagnosticType#EMPTY_ROOT_MODULE_ERROR": "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "DiagnosticType#DUPLICATE_INPUT": "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "DiagnosticType#DUPLICATE_EXTERN_INPUT": "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "PassFactory#sanityCheck": "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "Tracer#currentTracer": "private Tracer currentTracer = null", "String#currentPassName": "private String currentPassName = null", "int#syntheticCodeId": "private int syntheticCodeId = 0", "CodeChangeHandler.RecentChange#recentChange": "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "List<CodeChangeHandler>#codeChangeHandlers": "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "String#SYNTHETIC_EXTERNS": "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "CompilerInput#synthesizedExternsInput": "private CompilerInput synthesizedExternsInput = null"}, "text": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Charsets;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.io.CharStreams;\nimport com.google.javascript.jscomp.CompilerOptions.DevMode;\nimport com.google.javascript.jscomp.CompilerOptions.LanguageMode;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\nimport com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\nimport com.google.javascript.jscomp.parsing.Config;\nimport com.google.javascript.jscomp.parsing.ParserRunner;\nimport com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.head.ErrorReporter;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\n\n/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  static final String SINGLETON_MODULE_NAME = \"[singleton]\";\n\n  static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\");\n\n  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\");\n\n  CompilerOptions options = null;\n\n  private PassConfig passes = null;\n\n  // The externs inputs\n  private List<CompilerInput> externs;\n\n  // The JS source modules\n  private List<JSModule> modules;\n\n  // The graph of the JS source modules. Must be null if there are less than\n  // 2 modules, because we use this as a signal for which passes to run.\n  private JSModuleGraph moduleGraph;\n\n  // The JS source inputs\n  private List<CompilerInput> inputs;\n\n  // error manager to which error management is delegated\n  private ErrorManager errorManager;\n\n  // Warnings guard for filtering warnings.\n  private WarningsGuard warningsGuard;\n\n  // Compile-time injected libraries. The node points to the last node of\n  // the library, so code can be inserted after.\n  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n\n  // Parse tree root nodes\n  Node externsRoot;\n  Node jsRoot;\n  Node externAndJsRoot;\n\n  private Map<InputId, CompilerInput> inputsById;\n\n  /** The source code map */\n  private SourceMap sourceMap;\n\n  /** The externs created from the exports.  */\n  private String externExports = null;\n\n  /**\n   * Ids for function inlining so that each declared name remains\n   * unique.\n   */\n  private int uniqueNameId = 0;\n\n  /** Whether to use threads. */\n  private boolean useThreads = true;\n\n  /**\n   * Whether to assume there are references to the RegExp Global object\n   * properties.\n   */\n  private boolean hasRegExpGlobalReferences = true;\n\n  /** The function information map */\n  private FunctionInformationMap functionInformationMap;\n\n  /** Debugging information */\n  private final StringBuilder debugLog = new StringBuilder();\n\n  /** Detects Google-specific coding conventions. */\n  CodingConvention defaultCodingConvention = new ClosureCodingConvention();\n\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n\n  public PerformanceTracker tracker;\n\n  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.\n  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =\n      RhinoErrorReporter.forOldRhino(this);\n\n  // This error reporter gets the messages from the current Rhino parser.\n  private final ErrorReporter defaultErrorReporter =\n      RhinoErrorReporter.forNewRhino(this);\n\n  /** Error strings used for reporting JSErrors */\n  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\");\n  public static final DiagnosticType MOTION_ITERATIONS_ERROR =\n      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\");\n\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n\n\n  /**\n   * Logger for the whole com.google.javascript.jscomp domain -\n   * setting configuration for this logger affects all loggers\n   *  in other classes within the compiler.\n   */\n  private static final Logger logger =\n      Logger.getLogger(\"com.google.javascript.jscomp\");\n\n  private final PrintStream outStream;\n\n  private GlobalVarReferenceMap globalRefMap = null;\n\n  private volatile double progress = 0.0;\n\n  /**\n   * Creates a Compiler that reports errors and warnings to its logger.\n   */\n  public Compiler() {\n    this((PrintStream) null);\n  }\n\n  /**\n   * Creates n Compiler that reports errors and warnings to an output\n   * stream.\n   */\n  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }\n\n  /**\n   * Creates a Compiler that uses a custom error manager.\n   */\n  public Compiler(ErrorManager errorManager) {\n    this();\n    setErrorManager(errorManager);\n  }\n\n  /**\n   * Sets the error manager.\n   *\n   * @param errorManager the error manager, it cannot be {@code null}\n   */\n  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }\n\n  /**\n   * Creates a message formatter instance corresponding to the value of\n   * {@link CompilerOptions}.\n   */\n  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }\n\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    init(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n    for (SourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options) {\n    initModules(Lists.<SourceFile>newArrayList(externs),\n         Lists.<JSModule>newArrayList(modules), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }\n\n  /**\n   * Do any initialization that is dependent on the compiler options.\n   */\n  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }\n\n  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n      List<T> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (T file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }\n\n  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\");\n\n  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\");\n\n  /**\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   */\n  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }\n\n  /**\n   * Empty modules get an empty \"fill\" file, so that we can move code into\n   * an empty module.\n   */\n  static String createFillFileName(String moduleName) {\n    return \"[\" + moduleName + \"]\";\n  }\n\n  /**\n   * Fill any empty modules with a place holder file. It makes any cross module\n   * motion easier.\n   */\n  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(SourceFile.fromCode(\n            createFillFileName(module.getName()), \"\"));\n      }\n    }\n  }\n\n  /**\n   * Rebuilds the internal list of inputs by iterating over all modules.\n   * This is necessary if inputs have been added to or removed from a module\n   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n   */\n  public void rebuildInputsFromModules() {\n    inputs = getAllInputsFromModules(modules);\n    initInputsByIdMap();\n  }\n\n  /**\n   * Builds a single list of all module inputs. Verifies that it contains no\n   * duplicates.\n   */\n  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }\n\n  static final DiagnosticType DUPLICATE_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");\n  static final DiagnosticType DUPLICATE_EXTERN_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\");\n\n  /**\n   * Creates a map to make looking up an input by name fast. Also checks for\n   * duplicate inputs.\n   */\n  void initInputsByIdMap() {\n    inputsById = new HashMap<InputId, CompilerInput>();\n    for (CompilerInput input : externs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n      }\n    }\n  }\n\n  public Result compile(\n      SourceFile extern, SourceFile input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      SourceFile extern, JSSourceFile[] input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {\n     return compileModules(\n         Lists.newArrayList(extern), Lists.newArrayList(modules), options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options) {\n    return compile(Lists.<SourceFile>newArrayList(externs),\n        Lists.<SourceFile>newArrayList(inputs),\n        options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n      List<T1> externs, List<T2> inputs, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, inputs, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options) {\n    return compileModules(Lists.<SourceFile>newArrayList(externs),\n        Lists.<JSModule>newArrayList(modules),\n        options);\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public <T extends SourceFile> Result compileModules(List<T> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      @Override\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }\n\n  /**\n   * Disable threads. This is for clients that run on AppEngine and\n   * don't have threads.\n   */\n  public void disableThreads() {\n    useThreads = false;\n  }\n\n  private <T> T runInCompilerThread(final Callable<T> callable) {\n    return runCallable(callable, useThreads, options.tracer.isOn());\n  }\n\n  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n    return runCallable(callable, true, false);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n\n    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n    // large or complex js code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = trace;\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useLargeStackThread) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }\n\n  private void compileInternal() {\n    setProgress(0.0);\n    parse();\n    // 15 percent of the work is assumed to be for parsing (based on some\n    // minimal analysis on big JS projects, of course this depends on options)\n    setProgress(0.15);\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n    setProgress(1.0);\n  }\n\n  public void parse() {\n    parseInputs();\n  }\n\n  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }\n\n  /**\n   * Create the passes object. Clients should use setPassConfig instead of\n   * overriding this.\n   */\n  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }\n\n  /**\n   * @param passes The PassConfig to use with this Compiler.\n   * @throws NullPointerException if passes is null\n   * @throws IllegalStateException if this.passes has already been assigned\n   */\n  public void setPassConfig(PassConfig passes) {\n    // Important to check for null because if setPassConfig(null) is\n    // called before this.passes is set, getPassConfig() will create a\n    // new PassConfig object and use that, which is probably not what\n    // the client wanted since he or she probably meant to use their\n    // own PassConfig object.\n    Preconditions.checkNotNull(passes);\n\n    if (this.passes != null) {\n      throw new IllegalStateException(\"this.passes has already been assigned\");\n    }\n    this.passes = passes;\n  }\n\n  /**\n   * Carry out any special checks or procedures that need to be done before\n   * proceeding with rest of the compilation process.\n   *\n   * @return true, to continue with compilation\n   */\n  boolean precheck() {\n    return true;\n  }\n\n  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    // We are currently only interested in check-passes for progress reporting\n    // as it is used for IDEs, that's why the maximum progress is set to 1.0.\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,\n        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }\n\n  private void externExports() {\n    logger.fine(\"Creating extern file for exports\");\n    startPass(\"externExports\");\n\n    ExternExportsPass pass = new ExternExportsPass(this);\n    process(pass);\n\n    externExports = pass.getGeneratedExterns();\n\n    endPass();\n  }\n\n  @Override\n  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }\n\n  private final PassFactory sanityCheck =\n      new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  };\n\n  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }\n\n  private void runSanityCheck() {\n    sanityCheck.create(this).process(externsRoot, jsRoot);\n  }\n\n  /**\n   * Removes try/catch/finally statements for easier debugging.\n   */\n  void removeTryCatchFinally() {\n    logger.fine(\"Remove try/catch/finally\");\n    startPass(\"removeTryCatchFinally\");\n    RemoveTryCatch r = new RemoveTryCatch(this);\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Strips code for smaller compiled code. This is useful for removing debug\n   * statements to prevent leaking them publicly.\n   */\n  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n    logger.fine(\"Strip code\");\n    startPass(\"stripCode\");\n    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n        stripTypePrefixes, stripNamePrefixes);\n    if (options.getTweakProcessing().shouldStrip()) {\n      r.enableTweakStripping();\n    }\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Runs custom passes that are designated to run at a particular time.\n   */\n  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }\n\n  private Tracer currentTracer = null;\n  private String currentPassName = null;\n\n  /**\n   * Marks the beginning of a pass.\n   */\n  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }\n\n  /**\n   * Marks the end of a pass.\n   */\n  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }\n\n  /**\n   * Returns a new tracer for the given pass name.\n   */\n  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }\n\n  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }\n\n  /**\n   * Returns the result of the compilation.\n   */\n  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }\n\n  /**\n   * Returns an array constructed from errors + temporary warnings.\n   */\n  public JSError[] getMessages() {\n    return getErrors();\n  }\n\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }\n\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }\n\n  @Override\n  public Node getRoot() {\n    return externAndJsRoot;\n  }\n\n  /**\n   * Creates a new id for making unique names.\n   */\n  private int nextUniqueNameId() {\n    return uniqueNameId++;\n  }\n\n  /**\n   * Resets the unique name id counter\n   */\n  @VisibleForTesting\n  void resetUniqueNameId() {\n    uniqueNameId = 0;\n  }\n\n  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      @Override\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }\n\n  @Override\n  boolean areNodesEqualForInlining(Node n1, Node n2) {\n    if (options.ambiguateProperties ||\n        options.disambiguateProperties) {\n      // The type based optimizations require that type information is preserved\n      // during other optimizations.\n      return n1.isEquivalentToTyped(n2);\n    } else {\n      return n1.isEquivalentTo(n2);\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Inputs\n  //------------------------------------------------------------------------\n\n  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler\n  // interface, and which ones should always be injected.\n\n  @Override\n  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }\n\n  /**\n   * Removes an input file from AST.\n   * @param id The id of the input to be removed.\n   */\n  protected void removeExternInput(InputId id) {\n    CompilerInput input = getInput(id);\n    if (input == null) {\n      return;\n    }\n    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());\n    inputsById.remove(id);\n    externs.remove(input);\n    Node root = input.getAstRoot(this);\n    if (root != null) {\n      root.detachFromParent();\n    }\n  }\n\n  @Override\n  public CompilerInput newExternInput(String name) {\n    SourceAst ast = new SyntheticAst(name);\n    if (inputsById.containsKey(ast.getInputId())) {\n      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n    }\n    CompilerInput input = new CompilerInput(ast, true);\n    putCompilerInput(input.getInputId(), input);\n    externsRoot.addChildToFront(ast.getAstRoot(this));\n    externs.add(0, input);\n    return input;\n  }\n\n  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }\n\n  /** Add a source input dynamically. Intended for incremental compilation. */\n  void addIncrementalSourceAst(JsAst ast) {\n    InputId id = ast.getInputId();\n    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());\n    putCompilerInput(id, new CompilerInput(ast));\n  }\n\n  /**\n   * Replace a source input dynamically. Intended for incremental\n   * re-compilation.\n   *\n   * If the new source input doesn't parse, then keep the old input\n   * in the AST and return false.\n   *\n   * @return Whether the new AST was attached successfully.\n   */\n  boolean replaceIncrementalSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    Node oldRoot = oldInput.getAstRoot(this);\n    if (oldRoot != null) {\n      oldRoot.getParent().replaceChild(oldRoot, newRoot);\n    } else {\n      getRoot().getLastChild().addChildToBack(newRoot);\n    }\n\n    CompilerInput newInput = new CompilerInput(ast);\n    putCompilerInput(ast.getInputId(), newInput);\n\n    JSModule module = oldInput.getModule();\n    if (module != null) {\n      module.addAfter(newInput, oldInput);\n      module.remove(oldInput);\n    }\n\n    // Verify the input id is set properly.\n    Preconditions.checkState(\n        newInput.getInputId().equals(oldInput.getInputId()));\n    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();\n    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));\n\n    inputs.remove(oldInput);\n    return true;\n  }\n\n  /**\n   * Add a new source input dynamically. Intended for incremental compilation.\n   * <p>\n   * If the new source input doesn't parse, it will not be added, and a false\n   * will be returned.\n   *\n   * @param ast the JS Source to add.\n   * @return true if the source was added successfully, false otherwise.\n   * @throws IllegalStateException if an input for this ast already exists.\n   */\n  boolean addNewSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    if (oldInput != null) {\n      throw new IllegalStateException(\n          \"Input already exists: \" + ast.getInputId().getIdName());\n    }\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    getRoot().getLastChild().addChildToBack(newRoot);\n\n    CompilerInput newInput = new CompilerInput(ast);\n\n    // TODO(tylerg): handle this for multiple modules at some point.\n    if (moduleGraph == null && !modules.isEmpty()) {\n      // singleton module\n      modules.get(0).add(newInput);\n    }\n\n    putCompilerInput(ast.getInputId(), newInput);\n\n    return true;\n  }\n\n  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }\n\n  /**\n   * Gets a module graph. This will always return a module graph, even\n   * in the degenerate case when there's only one module.\n   */\n  JSModuleGraph getDegenerateModuleGraph() {\n    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;\n  }\n\n  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }\n\n  @Override\n  public MemoizedScopeCreator getTypedScopeCreator() {\n    return getPassConfig().getTypedScopeCreator();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  DefaultPassConfig ensureDefaultPassConfig() {\n    PassConfig passes = getPassConfig().getBasePassConfig();\n    Preconditions.checkState(passes instanceof DefaultPassConfig,\n        \"PassConfigs must eventually delegate to the DefaultPassConfig\");\n    return (DefaultPassConfig) passes;\n  }\n\n  public SymbolTable buildKnownSymbolTable() {\n    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());\n\n    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();\n    if (typedScopeCreator != null) {\n      symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());\n      symbolTable.addSymbolsFrom(typedScopeCreator);\n    } else {\n      symbolTable.findScopes(this, externsRoot, jsRoot);\n    }\n\n    GlobalNamespace globalNamespace =\n        ensureDefaultPassConfig().getGlobalNamespace();\n    if (globalNamespace != null) {\n      symbolTable.addSymbolsFrom(globalNamespace);\n    }\n\n    ReferenceCollectingCallback refCollector =\n        new ReferenceCollectingCallback(\n            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n    NodeTraversal.traverse(this, getRoot(), refCollector);\n    symbolTable.addSymbolsFrom(refCollector);\n\n    PreprocessorSymbolTable preprocessorSymbolTable =\n        ensureDefaultPassConfig().getPreprocessorSymbolTable();\n    if (preprocessorSymbolTable != null) {\n      symbolTable.addSymbolsFrom(preprocessorSymbolTable);\n    }\n\n    symbolTable.fillNamespaceReferences();\n    symbolTable.fillPropertyScopes();\n    symbolTable.fillThisReferences(this, externsRoot, jsRoot);\n    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);\n\n    return symbolTable;\n  }\n\n  @Override\n  public Scope getTopScope() {\n    return getPassConfig().getTopScope();\n  }\n\n  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }\n\n  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }\n\n  //------------------------------------------------------------------------\n  // Parsing\n  //------------------------------------------------------------------------\n\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n\n  /**\n   * Transforms AMD and CJS modules to something closure compiler can\n   * process and creates JSModules and the corresponding dependency tree\n   * on the way.\n   */\n  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n      if (!modules.isEmpty()) {\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }\n\n  public Node parse(SourceFile file) {\n    initCompilerOptionsIfTesting();\n    addToDebugLog(\"Parsing: \" + file.getName());\n    return new JsAst(file).getAstRoot(this);\n  }\n\n  private int syntheticCodeId = 0;\n\n  @Override\n  Node parseSyntheticCode(String js) {\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  /**\n   * Allow subclasses to override the default CompileOptions object.\n   */\n  protected CompilerOptions newCompilerOptions() {\n    return new CompilerOptions();\n  }\n\n  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(newCompilerOptions());\n    }\n  }\n\n  @Override\n  Node parseSyntheticCode(String fileName, String js) {\n    initCompilerOptionsIfTesting();\n    return parse(SourceFile.fromCode(fileName, js));\n  }\n\n  @Override\n  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\"[testcode]\", js));\n    if (inputsById == null) {\n      inputsById = Maps.newHashMap();\n    }\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }\n\n  //------------------------------------------------------------------------\n  // Convert back to source code\n  //------------------------------------------------------------------------\n\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource() {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for each input back to js code.\n   */\n  public String[] toSourceArray() {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        Tracer tracer = newTracer(\"toSourceArray\");\n        try {\n          int numInputs = inputs.size();\n          String[] sources = new String[numInputs];\n          CodeBuilder cb = new CodeBuilder();\n          for (int i = 0; i < numInputs; i++) {\n            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n            cb.reset();\n            toSource(cb, i, scriptNode);\n            sources[i] = cb.toString();\n          }\n          return sources;\n        } finally {\n          stopTracer(tracer, \"toSourceArray\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module) {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return \"\";\n        }\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module: \" + module.getName());\n          }\n          toSource(cb, i, scriptNode);\n        }\n        return cb.toString();\n      }\n    });\n  }\n\n\n  /**\n   * Converts the parse tree for each input in a module back to js code.\n   */\n  public String[] toSourceArray(final JSModule module) {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return new String[0];\n        }\n\n        String[] sources = new String[numInputs];\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module input: \" + inputs.get(i).getName());\n          }\n\n          cb.reset();\n          toSource(cb, i, scriptNode);\n          sources[i] = cb.toString();\n        }\n        return sources;\n      }\n    });\n  }\n\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n      @Override\n      public Void call() throws Exception {\n        if (options.printInputDelimiter) {\n          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            cb.append(\"\\n\");  // Make sure that the label starts on a new line\n          }\n          Preconditions.checkState(root.isScript());\n\n          String delimiter = options.inputDelimiter;\n\n          String inputName = root.getInputId().getIdName();\n          String sourceName = root.getSourceFileName();\n          Preconditions.checkState(sourceName != null);\n          Preconditions.checkState(!sourceName.isEmpty());\n\n          delimiter = delimiter\n              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))\n              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n          cb.append(delimiter)\n            .append(\"\\n\");\n        }\n        if (root.getJSDocInfo() != null &&\n            root.getJSDocInfo().getLicense() != null) {\n          cb.append(\"/*\\n\")\n            .append(root.getJSDocInfo().getLicense())\n            .append(\"*/\\n\");\n        }\n\n        // If there is a valid source map, then indicate to it that the current\n        // root node's mappings are offset by the given string builder buffer.\n        if (options.sourceMapOutputPath != null) {\n          sourceMap.setStartingPosition(\n              cb.getLineIndex(), cb.getColumnIndex());\n        }\n\n        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n        // for the first input file\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n        if (!code.isEmpty()) {\n          cb.append(code);\n\n          // In order to avoid parse ambiguity when files are concatenated\n          // together, all files should end in a semi-colon. Do a quick\n          // heuristic check if there's an obvious semi-colon already there.\n          int length = code.length();\n          char lastChar = code.charAt(length - 1);\n          char secondLastChar = length >= 2 ?\n              code.charAt(length - 2) : '\\0';\n          boolean hasSemiColon = lastChar == ';' ||\n              (lastChar == '\\n' && secondLastChar == ';');\n          if (!hasSemiColon) {\n            cb.append(\";\");\n          }\n        }\n        return null;\n      }\n    });\n  }\n\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n  }\n\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }\n\n  /**\n   * Stores a buffer of text to which more can be appended.  This is just like a\n   * StringBuilder except that we also track the number of lines.\n   */\n  public static class CodeBuilder {\n    private final StringBuilder sb = new StringBuilder();\n    private int lineCount = 0;\n    private int colCount = 0;\n\n    /** Removes all text, but leaves the line count unchanged. */\n    void reset() {\n      sb.setLength(0);\n    }\n\n    /** Appends the given string to the text buffer. */\n    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }\n\n    /** Returns all text in the text buffer. */\n    @Override\n    public String toString() {\n      return sb.toString();\n    }\n\n    /** Returns the length of the text buffer. */\n    public int getLength() {\n      return sb.length();\n    }\n\n    /** Returns the (zero-based) index of the last line in the text buffer. */\n    int getLineIndex() {\n      return lineCount;\n    }\n\n    /** Returns the (zero-based) index of the last column in the text buffer. */\n    int getColumnIndex() {\n      return colCount;\n    }\n\n    /** Determines whether the text ends with the given suffix. */\n    boolean endsWith(String suffix) {\n      return (sb.length() > suffix.length())\n          && suffix.equals(sb.substring(sb.length() - suffix.length()));\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Optimizations\n  //------------------------------------------------------------------------\n\n  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }\n\n  @Override\n  void setCssRenamingMap(CssRenamingMap map) {\n    options.cssRenamingMap = map;\n  }\n\n  @Override\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }\n\n  /**\n   * Reprocesses the current defines over the AST.  This is used by GwtCompiler\n   * to generate N outputs for different targets from the same (checked) AST.\n   * For each target, we apply the target-specific defines by calling\n   * {@code processDefines} and then {@code optimize} to optimize the AST\n   * specifically for that target.\n   */\n  public void processDefines() {\n    (new DefaultPassConfig(options)).processDefines.create(this)\n        .process(externsRoot, jsRoot);\n  }\n\n  boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }\n\n  /** Control Flow Analysis. */\n  ControlFlowGraph<Node> computeCFG() {\n    logger.fine(\"Computing Control Flow Graph\");\n    Tracer tracer = newTracer(\"computeCFG\");\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n    process(cfa);\n    stopTracer(tracer, \"computeCFG\");\n    return cfa.getCfg();\n  }\n\n  public void normalize() {\n    logger.fine(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }\n\n  @Override\n  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }\n\n  void recordFunctionInformation() {\n    logger.fine(\"Recording function information\");\n    startPass(\"recordFunctionInformation\");\n    RecordFunctionInformation recordFunctionInfoPass =\n        new RecordFunctionInformation(\n            this, getPassConfig().getIntermediateState().functionNames);\n    process(recordFunctionInfoPass);\n    functionInformationMap = recordFunctionInfoPass.getMap();\n    endPass();\n  }\n\n  protected final CodeChangeHandler.RecentChange recentChange =\n      new CodeChangeHandler.RecentChange();\n  private final List<CodeChangeHandler> codeChangeHandlers =\n      Lists.<CodeChangeHandler>newArrayList();\n\n  /** Name of the synthetic input that holds synthesized externs. */\n  static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\";\n\n  private CompilerInput synthesizedExternsInput = null;\n\n  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }\n\n  @Override\n  void removeChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.remove(handler);\n  }\n\n  /**\n   * All passes should call reportCodeChange() when they alter\n   * the JS tree structure. This is verified by CompilerTestCase.\n   * This allows us to optimize to a fixed point.\n   */\n  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }\n\n  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }\n\n  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }\n\n  @Override\n  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n    }\n    return false;\n  }\n\n  public LanguageMode languageMode() {\n    return options.getLanguageIn();\n  }\n\n  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }\n\n  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }\n\n  @Override\n  public boolean isTypeCheckingEnabled() {\n    return options.checkTypes;\n  }\n\n\n  //------------------------------------------------------------------------\n  // Error reporting\n  //------------------------------------------------------------------------\n\n  /**\n   * The warning classes that are available from the command-line, and\n   * are suppressable by the {@code @suppress} annotation.\n   */\n  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }\n\n  @Override\n  public void report(JSError error) {\n    CheckLevel level = error.getDefaultLevel();\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      if (getOptions().errorHandler != null) {\n        getOptions().errorHandler.report(level, error);\n      }\n      errorManager.report(level, error);\n    }\n  }\n\n  @Override\n  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }\n\n  /**\n   * Report an internal error.\n   */\n  @Override\n  void throwInternalError(String message, Exception cause) {\n    String finalMessage =\n      \"INTERNAL COMPILER ERROR.\\n\" +\n      \"Please report this problem.\\n\" + message;\n\n    RuntimeException e = new RuntimeException(finalMessage, cause);\n    if (cause != null) {\n      e.setStackTrace(cause.getStackTrace());\n    }\n    throw e;\n  }\n\n\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }\n\n  /**\n   * Gets the number of warnings.\n   */\n  public int getWarningCount() {\n    return errorManager.getWarningCount();\n  }\n\n  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }\n\n  /**\n   * Consults the {@link ErrorManager} to see if we've encountered errors\n   * that should halt compilation. <p>\n   *\n   * If {@link CompilerOptions#ideMode} is {@code true}, this function\n   * always returns {@code false} without consulting the error manager. The\n   * error manager will continue to be told about new errors and warnings, but\n   * the compiler will complete compilation of all inputs.<p>\n   */\n  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }\n\n  /** Called from the compiler passes, adds debug info */\n  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }\n\n  private SourceFile getSourceFileByName(String sourceName) {\n    // Here we assume that the source name is the input name, this\n    // is try of javascript parsed from source.\n    if (sourceName != null) {\n      CompilerInput input = inputsById.get(new InputId(sourceName));\n      if (input != null) {\n        return input.getSourceFile();\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }\n\n  @Override\n  public Region getSourceRegion(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getRegion(lineNumber);\n    }\n    return null;\n  }\n\n  //------------------------------------------------------------------------\n  // Package-private helpers\n  //------------------------------------------------------------------------\n\n  @Override\n  Node getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n      if (inputs.isEmpty()) {\n        throw new IllegalStateException(\"No inputs\");\n      }\n\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    List<CompilerInput> moduleInputs = module.getInputs();\n    if (moduleInputs.size() > 0) {\n      return moduleInputs.get(0).getAstRoot(this);\n    }\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }\n\n  public SourceMap getSourceMap() {\n    return sourceMap;\n  }\n\n  VariableMap getVariableMap() {\n    return getPassConfig().getIntermediateState().variableMap;\n  }\n\n  VariableMap getPropertyMap() {\n    return getPassConfig().getIntermediateState().propertyMap;\n  }\n\n  CompilerOptions getOptions() {\n    return options;\n  }\n\n  FunctionInformationMap getFunctionalInformationMap() {\n    return functionInformationMap;\n  }\n\n  /**\n   * Sets the logging level for the com.google.javascript.jscomp package.\n   */\n  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }\n\n  /** Gets the DOT graph of the AST generated at the end of compilation. */\n  public String getAstDotGraph() throws IOException {\n    if (jsRoot != null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n      cfa.process(null, jsRoot);\n      return DotFormatter.toDot(jsRoot, cfa.getCfg());\n    } else {\n      return \"\";\n    }\n  }\n\n  @Override\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(newCompilerOptions());\n    }\n    return errorManager;\n  }\n\n  @Override\n  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }\n\n  /**\n   * Returns an unmodifiable view of the compiler inputs indexed by id.\n   */\n  public Map<InputId, CompilerInput> getInputsById() {\n    return Collections.unmodifiableMap(inputsById);\n  }\n\n  /**\n   * Gets the externs in the order in which they are being processed.\n   */\n  List<CompilerInput> getExternsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(externs);\n  }\n\n  /**\n   * Stores the internal compiler state just before optimization is performed.\n   * This can be saved and restored in order to efficiently optimize multiple\n   * different output targets without having to perform checking multiple times.\n   *\n   * NOTE: This does not include all parts of the compiler's internal state. In\n   * particular, SourceFiles and CompilerOptions are not recorded. In\n   * order to recreate a Compiler instance from scratch, you would need to\n   * call {@code init} with the same arguments as in the initial creation before\n   * restoring intermediate state.\n   */\n  public static class IntermediateState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    Node externsRoot;\n    private Node jsRoot;\n    private List<CompilerInput> externs;\n    private List<CompilerInput> inputs;\n    private List<JSModule> modules;\n    private PassConfig.State passConfigState;\n    private JSTypeRegistry typeRegistry;\n    private AbstractCompiler.LifeCycleStage lifeCycleStage;\n    private Map<String, Node> injectedLibraries;\n\n    private IntermediateState() {}\n  }\n\n  /**\n   * Returns the current internal state, excluding the input files and modules.\n   */\n  public IntermediateState getState() {\n    IntermediateState state = new IntermediateState();\n    state.externsRoot = externsRoot;\n    state.jsRoot = jsRoot;\n    state.externs = externs;\n    state.inputs = inputs;\n    state.modules = modules;\n    state.passConfigState = getPassConfig().getIntermediateState();\n    state.typeRegistry = typeRegistry;\n    state.lifeCycleStage = getLifeCycleStage();\n    state.injectedLibraries = Maps.newLinkedHashMap(injectedLibraries);\n\n    return state;\n  }\n\n  /**\n   * Sets the internal state to the capture given.  Note that this assumes that\n   * the input files are already set up.\n   */\n  public void setState(IntermediateState state) {\n    externsRoot = state.externsRoot;\n    jsRoot = state.jsRoot;\n    externs = state.externs;\n    inputs = state.inputs;\n    modules = state.modules;\n    passes = createPassConfigInternal();\n    getPassConfig().setIntermediateState(state.passConfigState);\n    typeRegistry = state.typeRegistry;\n    setLifeCycleStage(state.lifeCycleStage);\n\n    injectedLibraries.clear();\n    injectedLibraries.putAll(state.injectedLibraries);\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getInputsForTesting() {\n    return inputs;\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getExternsForTesting() {\n    return externs;\n  }\n\n  @Override\n  boolean hasRegExpGlobalReferences() {\n    return hasRegExpGlobalReferences;\n  }\n\n  @Override\n  void setHasRegExpGlobalReferences(boolean references) {\n    hasRegExpGlobalReferences = references;\n  }\n\n  @Override\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.isScript()\n        || collectionRoot.isBlock());\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n          getExternsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }\n\n  @Override\n  GlobalVarReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }\n\n  @Override\n  CompilerInput getSynthesizedExternsInput() {\n    if (synthesizedExternsInput == null) {\n      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);\n    }\n    return synthesizedExternsInput;\n  }\n\n  @Override\n  public double getProgress() {\n    return progress;\n  }\n\n  @Override\n  void setProgress(double newProgress) {\n    if (newProgress > 1.0) {\n      progress = 1.0;\n    } else if (newProgress < 0.0) {\n      progress = 0.0;\n    } else {\n      progress = newProgress;\n    }\n  }\n\n  /**\n   * Replaces one file in a hot-swap mode. The given JsAst should be made\n   * from a new version of a file that already was present in the last compile\n   * call. If the file is new, this will silently ignored.\n   *\n   * @param ast the ast of the file that is being replaced\n   */\n  public void replaceScript(JsAst ast) {\n    CompilerInput input = this.getInput(ast.getInputId());\n    if (!replaceIncrementalSourceAst(ast)) {\n      return;\n    }\n    Node originalRoot = input.getAstRoot(this);\n\n    processNewScript(ast, originalRoot);\n  }\n\n  /**\n   * Adds a new Script AST to the compile state. If a script for the same file\n   * already exists the script will not be added, instead a call to\n   * #replaceScript should be used.\n   *\n   * @param ast the ast of the new file\n   */\n  public void addNewScript(JsAst ast) {\n    if (!addNewSourceAst(ast)) {\n      return;\n    }\n    Node emptyScript = new Node(Token.SCRIPT);\n    InputId inputId = ast.getInputId();\n    emptyScript.setInputId(inputId);\n    emptyScript.setStaticSourceFile(\n        SourceFile.fromCode(inputId.getIdName(), \"\"));\n\n    processNewScript(ast, emptyScript);\n  }\n\n  private void processNewScript(JsAst ast, Node originalRoot) {\n    Node js = ast.getAstRoot(this);\n    Preconditions.checkNotNull(js);\n\n    runHotSwap(originalRoot, js, this.getCleanupPassConfig());\n    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need\n    // to revisit this approach to clearing GlobalNamespaces\n    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);\n\n    this.getTypeRegistry().clearNamedTypes();\n    this.removeSyntheticVarsInput();\n\n    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());\n  }\n\n  /**\n   * Execute the passes from a PassConfig instance over a single replaced file.\n   */\n  private void runHotSwap(\n      Node originalRoot, Node js, PassConfig passConfig) {\n    for (PassFactory passFactory : passConfig.getChecks()) {\n      runHotSwapPass(originalRoot, js, passFactory);\n    }\n  }\n\n  private void runHotSwapPass(\n      Node originalRoot, Node js, PassFactory passFactory) {\n    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);\n    if (pass != null) {\n      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());\n      pass.hotSwapScript(js, originalRoot);\n    }\n  }\n\n  private PassConfig getCleanupPassConfig() {\n    return new CleanupPasses(getOptions());\n  }\n\n  private void removeSyntheticVarsInput() {\n    String sourceName = Compiler.SYNTHETIC_EXTERNS;\n    removeExternInput(new InputId(sourceName));\n  }\n\n  @Override\n  Node ensureLibraryInjected(String resourceName) {\n    if (injectedLibraries.containsKey(resourceName)) {\n      return null;\n    }\n\n    // All libraries depend on js/base.js\n    boolean isBase = \"base\".equals(resourceName);\n    if (!isBase) {\n      ensureLibraryInjected(\"base\");\n    }\n\n    Node firstChild = loadLibraryCode(resourceName).removeChildren();\n    Node lastChild = firstChild.getLastSibling();\n\n    Node parent = getNodeForCodeInsertion(null);\n    if (isBase) {\n      parent.addChildrenToFront(firstChild);\n    } else {\n      parent.addChildrenAfter(\n          firstChild, injectedLibraries.get(\"base\"));\n    }\n    reportCodeChange();\n\n    injectedLibraries.put(resourceName, lastChild);\n    return lastChild;\n  }\n\n  /** Load a library as a resource */\n  @VisibleForTesting\n  Node loadLibraryCode(String resourceName) {\n    String originalCode;\n    try {\n      originalCode = CharStreams.toString(new InputStreamReader(\n          Compiler.class.getResourceAsStream(\n              String.format(\"js/%s.js\", resourceName)),\n          Charsets.UTF_8));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    return Normalize.parseAndNormalizeSyntheticCode(\n        this, originalCode,\n        String.format(\"jscomp_%s_\", resourceName));\n  }\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `compile` method in the `Compiler` class. The tests aim to maximize both branch and line coverage by considering different scenarios such as null inputs, empty inputs, and valid inputs.\n\n```java\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.Compiler;\nimport com.google.javascript.jscomp.CompilerOptions;\nimport com.google.javascript.jscomp.JSSourceFile;\nimport com.google.javascript.jscomp.Result;\nimport com.google.javascript.jscomp.DiagnosticGroup;\nimport com.google.javascript.jscomp.DiagnosticGroups;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class CompilerTest {\n\n    private Compiler compiler;\n\n    @Before\n    public void setUp() {\n        compiler = new Compiler();\n        CompilerOptions options = new CompilerOptions();\n        options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.WARNING);\n        compiler.initOptions(options);\n    }\n\n    @Test\n    public void testCompileWithNullExterns() {\n        JSSourceFile[] inputs = {\n            JSSourceFile.fromCode(\"input1\", \"var x = 10;\")\n        };\n        CompilerOptions options = new CompilerOptions();\n        Result result = compiler.compile(null, inputs, options);\n        assertFalse(result.success);\n        assertEquals(1, compiler.getErrorCount());\n    }\n\n    @Test\n    public void testCompileWithNullInputs() {\n        JSSourceFile[] externs = {\n            JSSourceFile.fromCode(\"extern1\", \"var y = 10;\")\n        };\n        CompilerOptions options = new CompilerOptions();\n        Result result = compiler.compile(externs, null, options);\n        assertFalse(result.success);\n        assertEquals(1, compiler.getErrorCount());\n    }\n\n    @Test\n    public void testCompileWithEmptyExternsAndInputs() {\n        JSSourceFile[] externs = new JSSourceFile[0];\n        JSSourceFile[] inputs = new JSSourceFile[0];\n        CompilerOptions options = new CompilerOptions();\n        Result result = compiler.compile(externs, inputs, options);\n        assertFalse(result.success);\n        assertEquals(1, compiler.getErrorCount());\n    }\n\n    @Test\n    public void testCompileWithValidExternsAndInputs() {\n        JSSourceFile[] externs = {\n            JSSourceFile.fromCode(\"extern1\", \"var y = 10;\")\n        };\n        JSSourceFile[] inputs = {\n            JSSourceFile.fromCode(\"input1\", \"var x = 10;\")\n        };\n        CompilerOptions options = new CompilerOptions();\n        Result result = compiler.compile(externs, inputs, options);\n        assertTrue(result.success);\n        assertEquals(0, compiler.getErrorCount());\n    }\n\n    @Test\n    public void testCompileWithSyntaxErrorInInput() {\n        JSSourceFile[] externs = {\n            JSSourceFile.fromCode(\"extern1\", \"var y = 10;\")\n        };\n        JSSourceFile[] inputs = {\n            JSSourceFile.fromCode(\"input1\", \"var x = 10; var z = 20++\")\n        };\n        CompilerOptions options = new CompilerOptions();\n        Result result = compiler.compile(externs, inputs, options);\n        assertFalse(result.success);\n        assertEquals(1, compiler.getErrorCount());\n    }\n\n    @Test\n    public void testCompileWithDuplicateInputs() {\n        JSSourceFile[] externs = {\n            JSSourceFile.fromCode(\"extern1\", \"var y = 10;\")\n        };\n        JSSourceFile[] inputs = {\n            JSSourceFile.fromCode(\"input1\", \"var x = 10;\"),\n            JSSourceFile.fromCode(\"input1\", \"var z = 20;\")\n        };\n        CompilerOptions options = new CompilerOptions();\n        Result result = compiler.compile(externs, inputs, options);\n        assertFalse(result.success);\n        assertEquals(1, compiler.getErrorCount());\n    }\n\n    @Test\n    public void testCompileWithDuplicateExterns() {\n        JSSourceFile[] externs = {\n            JSSourceFile.fromCode(\"extern1\", \"var y = 10;\"),\n            JSSourceFile.fromCode(\"extern1\", \"var z = 20;\")\n        };\n        JSSourceFile[] inputs = {\n            JSSourceFile.fromCode(\"input1\", \"var x = 10;\")\n        };\n        CompilerOptions options = new CompilerOptions();\n        Result result = compiler.compile(externs, inputs, options);\n        assertFalse(result.success);\n        assertEquals(1, compiler.getErrorCount());\n    }\n\n    @Test\n    public void testCompileWithValidExternsAndInputsMultipleFiles() {\n        JSSourceFile[] externs = {\n            JSSourceFile.fromCode(\"extern1\", \"var y = 10;\"),\n            JSSourceFile.fromCode(\"extern2\", \"var z = 20;\")\n        };\n        JSSourceFile[] inputs = {\n            JSSourceFile.fromCode(\"input1\", \"var x = 10;\"),\n            JSSourceFile.fromCode(\"input2\", \"var w = 30;\")\n        };\n        CompilerOptions options = new CompilerOptions();\n        Result result = compiler.compile(externs, inputs, options);\n        assertTrue(result.success);\n        assertEquals(0, compiler.getErrorCount());\n    }\n\n    @Test\n    public void testCompileWithExternsHavingSyntaxError() {\n        JSSourceFile[] externs = {\n            JSSourceFile.fromCode(\"extern1\", \"var y = 10; var z = 20++\")\n        };\n        JSSourceFile[] inputs = {\n            JSSourceFile.fromCode(\"input1\", \"var x = 10;\")\n        };\n        CompilerOptions options = new CompilerOptions();\n        Result result = compiler.compile(externs, inputs, options);\n        assertFalse(result.success);\n        assertEquals(1, compiler.getErrorCount());\n    }\n}\n```\n\n### Explanation of Test Cases:\n1. **`testCompileWithNullExterns`**: Tests the scenario where the externs array is null.\n2. **`testCompileWithNullInputs`**: Tests the scenario where the inputs array is null.\n3. **`testCompileWithEmptyExternsAndInputs`**: Tests the scenario where both externs and inputs arrays are empty.\n4. **`testCompileWithValidExternsAndInputs`**: Tests a valid scenario with one extern and one input.\n5. **`testCompileWithSyntaxErrorInInput`**: Tests a scenario where an input file has a syntax error.\n6. **`testCompileWithDuplicateInputs`**: Tests a scenario where the input files have duplicate names.\n7. **`testCompileWithDuplicateExterns`**: Tests a scenario where the extern files have duplicate names.\n8. **`testCompileWithValidExternsAndInputsMultipleFiles`**: Tests a valid scenario with multiple extern and input files.\n9. **`testCompileWithExternsHavingSyntaxError`**: Tests a scenario where an extern file has a syntax error.\n\nThese tests should help cover a variety of scenarios and maximize both branch and line coverage for the `compile` method."}
{"bug_id": "Closure_31", "version": "fixed", "focal_method_signature": "Result com.google.javascript.jscomp.Compiler#compile(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "focal_method": "public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n      List<T1> externs, List<T2> inputs, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, inputs, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }", "return_type": "Result", "assertion_subject_candidates": ["JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "double com.google.javascript.jscomp.Compiler#getProgress()", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()"], "focal_class": {"name": "Compiler", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "superclass": "extends AbstractCompiler", "interface": "", "imports": ["import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.Charsets;", "import com.google.common.base.Preconditions;", "import com.google.common.base.Supplier;", "import com.google.common.base.Throwables;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.common.io.CharStreams;", "import com.google.javascript.jscomp.CompilerOptions.DevMode;", "import com.google.javascript.jscomp.CompilerOptions.LanguageMode;", "import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;", "import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;", "import com.google.javascript.jscomp.parsing.Config;", "import com.google.javascript.jscomp.parsing.ParserRunner;", "import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;", "import com.google.javascript.rhino.IR;", "import com.google.javascript.rhino.InputId;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import com.google.javascript.rhino.head.ErrorReporter;", "import com.google.javascript.rhino.jstype.JSTypeRegistry;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.PrintStream;", "import java.io.Serializable;", "import java.nio.charset.Charset;", "import java.util.Collections;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;", "import java.util.concurrent.Callable;", "import java.util.logging.Level;", "import java.util.logging.Logger;", "import java.util.regex.Matcher;"], "fields": ["static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions options = null", "private PassConfig passes = null", "private List<CompilerInput> externs", "private List<JSModule> modules", "private JSModuleGraph moduleGraph", "private List<CompilerInput> inputs", "private ErrorManager errorManager", "private WarningsGuard warningsGuard", "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node externsRoot", "Node jsRoot", "Node externAndJsRoot", "private Map<InputId, CompilerInput> inputsById", "private SourceMap sourceMap", "private String externExports = null", "private int uniqueNameId = 0", "private boolean useThreads = true", "private boolean hasRegExpGlobalReferences = true", "private FunctionInformationMap functionInformationMap", "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "private JSTypeRegistry typeRegistry", "private Config parserConfig = null", "private ReverseAbstractInterpreter abstractInterpreter", "private TypeValidator typeValidator", "public PerformanceTracker tracker", "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "private static final long COMPILER_STACK_SIZE = 1048576L", "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "private final PrintStream outStream", "private GlobalVarReferenceMap globalRefMap = null", "private volatile double progress = 0.0", "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "private Tracer currentTracer = null", "private String currentPassName = null", "private int syntheticCodeId = 0", "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "private CompilerInput synthesizedExternsInput = null"], "methods": ["void com.google.javascript.jscomp.Compiler#setErrorManager(ErrorManager#errorManager)", "MessageFormatter com.google.javascript.jscomp.Compiler#createMessageFormatter()", "void com.google.javascript.jscomp.Compiler#initOptions(CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initBasedOnOptions()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#makeCompilerInput(List<T>#files,boolean#isExtern)", "void com.google.javascript.jscomp.Compiler#checkFirstModule(List<JSModule>#modules)", "String com.google.javascript.jscomp.Compiler#createFillFileName(String#moduleName)", "void com.google.javascript.jscomp.Compiler#fillEmptyModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#rebuildInputsFromModules()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getAllInputsFromModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#initInputsByIdMap()", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,SourceFile#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,JSSourceFile[]#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile#extern,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compileModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile()", "void com.google.javascript.jscomp.Compiler#disableThreads()", "T com.google.javascript.jscomp.Compiler#runInCompilerThread(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallableWithLargeStack(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallable(Callable<T>#callable,boolean#useLargeStackThread,boolean#trace)", "void com.google.javascript.jscomp.Compiler#compileInternal()", "void com.google.javascript.jscomp.Compiler#parse()", "PassConfig com.google.javascript.jscomp.Compiler#getPassConfig()", "PassConfig com.google.javascript.jscomp.Compiler#createPassConfigInternal()", "void com.google.javascript.jscomp.Compiler#setPassConfig(PassConfig#passes)", "boolean com.google.javascript.jscomp.Compiler#precheck()", "void com.google.javascript.jscomp.Compiler#check()", "void com.google.javascript.jscomp.Compiler#externExports()", "void com.google.javascript.jscomp.Compiler#process(CompilerPass#p)", "void com.google.javascript.jscomp.Compiler#maybeSanityCheck()", "void com.google.javascript.jscomp.Compiler#runSanityCheck()", "void com.google.javascript.jscomp.Compiler#removeTryCatchFinally()", "void com.google.javascript.jscomp.Compiler#stripCode(Set<String>#stripTypes,Set<String>#stripNameSuffixes,Set<String>#stripTypePrefixes,Set<String>#stripNamePrefixes)", "void com.google.javascript.jscomp.Compiler#runCustomPasses(CustomPassExecutionTime#executionTime)", "void com.google.javascript.jscomp.Compiler#startPass(String#passName)", "void com.google.javascript.jscomp.Compiler#endPass()", "Tracer com.google.javascript.jscomp.Compiler#newTracer(String#passName)", "void com.google.javascript.jscomp.Compiler#stopTracer(Tracer#t,String#passName)", "Result com.google.javascript.jscomp.Compiler#getResult()", "JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "int com.google.javascript.jscomp.Compiler#nextUniqueNameId()", "void com.google.javascript.jscomp.Compiler#resetUniqueNameId()", "Supplier<String> com.google.javascript.jscomp.Compiler#getUniqueNameIdSupplier()", "boolean com.google.javascript.jscomp.Compiler#areNodesEqualForInlining(Node#n1,Node#n2)", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "void com.google.javascript.jscomp.Compiler#removeExternInput(InputId#id)", "CompilerInput com.google.javascript.jscomp.Compiler#newExternInput(String#name)", "CompilerInput com.google.javascript.jscomp.Compiler#putCompilerInput(InputId#id,CompilerInput#input)", "void com.google.javascript.jscomp.Compiler#addIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#replaceIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#addNewSourceAst(JsAst#ast)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "JSTypeRegistry com.google.javascript.jscomp.Compiler#getTypeRegistry()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "DefaultPassConfig com.google.javascript.jscomp.Compiler#ensureDefaultPassConfig()", "SymbolTable com.google.javascript.jscomp.Compiler#buildKnownSymbolTable()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ReverseAbstractInterpreter com.google.javascript.jscomp.Compiler#getReverseAbstractInterpreter()", "TypeValidator com.google.javascript.jscomp.Compiler#getTypeValidator()", "Node com.google.javascript.jscomp.Compiler#parseInputs()", "void com.google.javascript.jscomp.Compiler#processAMDAndCommonJSModules()", "Node com.google.javascript.jscomp.Compiler#parse(SourceFile#file)", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#js)", "CompilerOptions com.google.javascript.jscomp.Compiler#newCompilerOptions()", "void com.google.javascript.jscomp.Compiler#initCompilerOptionsIfTesting()", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#fileName,String#js)", "Node com.google.javascript.jscomp.Compiler#parseTestCode(String#js)", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "String com.google.javascript.jscomp.Compiler#toSource()", "String[] com.google.javascript.jscomp.Compiler#toSourceArray()", "String com.google.javascript.jscomp.Compiler#toSource(JSModule#module)", "String[] com.google.javascript.jscomp.Compiler#toSourceArray(JSModule#module)", "void com.google.javascript.jscomp.Compiler#toSource(CodeBuilder#cb,int#inputSeqNum,Node#root)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n,SourceMap#sourceMap,boolean#firstOutput)", "void com.google.javascript.jscomp.Compiler#optimize()", "void com.google.javascript.jscomp.Compiler#setCssRenamingMap(CssRenamingMap#map)", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "void com.google.javascript.jscomp.Compiler#processDefines()", "boolean com.google.javascript.jscomp.Compiler#isInliningForbidden()", "ControlFlowGraph<Node> com.google.javascript.jscomp.Compiler#computeCFG()", "void com.google.javascript.jscomp.Compiler#normalize()", "void com.google.javascript.jscomp.Compiler#prepareAst(Node#root)", "void com.google.javascript.jscomp.Compiler#recordFunctionInformation()", "void com.google.javascript.jscomp.Compiler#addChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#removeChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#reportCodeChange()", "CodingConvention com.google.javascript.jscomp.Compiler#getCodingConvention()", "boolean com.google.javascript.jscomp.Compiler#isIdeMode()", "boolean com.google.javascript.jscomp.Compiler#acceptEcmaScript5()", "LanguageMode com.google.javascript.jscomp.Compiler#languageMode()", "boolean com.google.javascript.jscomp.Compiler#acceptConstKeyword()", "Config com.google.javascript.jscomp.Compiler#getParserConfig()", "boolean com.google.javascript.jscomp.Compiler#isTypeCheckingEnabled()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "void com.google.javascript.jscomp.Compiler#report(JSError#error)", "CheckLevel com.google.javascript.jscomp.Compiler#getErrorLevel(JSError#error)", "void com.google.javascript.jscomp.Compiler#throwInternalError(String#message,Exception#cause)", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "boolean com.google.javascript.jscomp.Compiler#hasHaltingErrors()", "boolean com.google.javascript.jscomp.Compiler#hasErrors()", "void com.google.javascript.jscomp.Compiler#addToDebugLog(String#str)", "SourceFile com.google.javascript.jscomp.Compiler#getSourceFileByName(String#sourceName)", "String com.google.javascript.jscomp.Compiler#getSourceLine(String#sourceName,int#lineNumber)", "Region com.google.javascript.jscomp.Compiler#getSourceRegion(String#sourceName,int#lineNumber)", "Node com.google.javascript.jscomp.Compiler#getNodeForCodeInsertion(JSModule#module)", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "void com.google.javascript.jscomp.Compiler#setLoggingLevel(Level#level)", "String com.google.javascript.jscomp.Compiler#getAstDotGraph()", "ErrorManager com.google.javascript.jscomp.Compiler#getErrorManager()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "IntermediateState com.google.javascript.jscomp.Compiler#getState()", "void com.google.javascript.jscomp.Compiler#setState(IntermediateState#state)", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "boolean com.google.javascript.jscomp.Compiler#hasRegExpGlobalReferences()", "void com.google.javascript.jscomp.Compiler#setHasRegExpGlobalReferences(boolean#references)", "void com.google.javascript.jscomp.Compiler#updateGlobalVarReferences(Map<Var, ReferenceCollection>#refMapPatch,Node#collectionRoot)", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "CompilerInput com.google.javascript.jscomp.Compiler#getSynthesizedExternsInput()", "double com.google.javascript.jscomp.Compiler#getProgress()", "void com.google.javascript.jscomp.Compiler#setProgress(double#newProgress)", "void com.google.javascript.jscomp.Compiler#replaceScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#addNewScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#processNewScript(JsAst#ast,Node#originalRoot)", "void com.google.javascript.jscomp.Compiler#runHotSwap(Node#originalRoot,Node#js,PassConfig#passConfig)", "void com.google.javascript.jscomp.Compiler#runHotSwapPass(Node#originalRoot,Node#js,PassFactory#passFactory)", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()", "void com.google.javascript.jscomp.Compiler#removeSyntheticVarsInput()", "Node com.google.javascript.jscomp.Compiler#ensureLibraryInjected(String#resourceName)", "Node com.google.javascript.jscomp.Compiler#loadLibraryCode(String#resourceName)"], "other_methods": ["public void setErrorManager(ErrorManager errorManager);", "public void initOptions(CompilerOptions options);", "public void init(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public void init(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public void init(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public void initModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void rebuildInputsFromModules();", "public Result compile(SourceFile extern,SourceFile input,CompilerOptions options);", "public Result compile(SourceFile extern,JSSourceFile[] input,CompilerOptions options);", "public Result compile(JSSourceFile extern,JSModule[] modules,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public Result compileModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void disableThreads();", "public void parse();", "public void setPassConfig(PassConfig passes);", "public void check();", "public Result getResult();", "public JSError[] getMessages();", "public JSError[] getErrors();", "public JSError[] getWarnings();", "@Override\n  public Node getRoot();", "@Override\n  public CompilerInput getInput(InputId id);", "@Override\n  public CompilerInput newExternInput(String name);", "@Override\n  public JSTypeRegistry getTypeRegistry();", "@Override\n  public MemoizedScopeCreator getTypedScopeCreator();", "public SymbolTable buildKnownSymbolTable();", "@Override\n  public Scope getTopScope();", "@Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter();", "public Node parse(SourceFile file);", "public String toSource();", "public String[] toSourceArray();", "public String toSource(JSModule module);", "public String[] toSourceArray(JSModule module);", "public void toSource(CodeBuilder cb,int inputSeqNum,Node root);", "public void optimize();", "public void processDefines();", "public void normalize();", "@Override\n  public void reportCodeChange();", "@Override\n  public CodingConvention getCodingConvention();", "@Override\n  public boolean isIdeMode();", "@Override\n  public boolean acceptEcmaScript5();", "public LanguageMode languageMode();", "@Override\n  public boolean acceptConstKeyword();", "@Override\n  public boolean isTypeCheckingEnabled();", "@Override\n  public void report(JSError error);", "@Override\n  public CheckLevel getErrorLevel(JSError error);", "public int getErrorCount();", "public int getWarningCount();", "public boolean hasErrors();", "@Override\n  public String getSourceLine(String sourceName,int lineNumber);", "@Override\n  public Region getSourceRegion(String sourceName,int lineNumber);", "public SourceMap getSourceMap();", "public static void setLoggingLevel(Level level);", "public String getAstDotGraph();", "@Override\n  public ErrorManager getErrorManager();", "public Map<InputId, CompilerInput> getInputsById();", "public IntermediateState getState();", "public void setState(IntermediateState state);", "@Override\n  public double getProgress();", "public void replaceScript(JsAst ast);", "public void addNewScript(JsAst ast);"], "fields_dict": {"String#SINGLETON_MODULE_NAME": "static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "DiagnosticType#MODULE_DEPENDENCY_ERROR": "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "DiagnosticType#MISSING_ENTRY_ERROR": "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions#options": "CompilerOptions options = null", "PassConfig#passes": "private PassConfig passes = null", "List<CompilerInput>#externs": "private List<CompilerInput> externs", "List<JSModule>#modules": "private List<JSModule> modules", "JSModuleGraph#moduleGraph": "private JSModuleGraph moduleGraph", "List<CompilerInput>#inputs": "private List<CompilerInput> inputs", "ErrorManager#errorManager": "private ErrorManager errorManager", "WarningsGuard#warningsGuard": "private WarningsGuard warningsGuard", "Map<String, Node>#injectedLibraries": "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node#externsRoot": "Node externsRoot", "Node#jsRoot": "Node jsRoot", "Node#externAndJsRoot": "Node externAndJsRoot", "Map<InputId, CompilerInput>#inputsById": "private Map<InputId, CompilerInput> inputsById", "SourceMap#sourceMap": "private SourceMap sourceMap", "String#externExports": "private String externExports = null", "int#uniqueNameId": "private int uniqueNameId = 0", "boolean#useThreads": "private boolean useThreads = true", "boolean#hasRegExpGlobalReferences": "private boolean hasRegExpGlobalReferences = true", "FunctionInformationMap#functionInformationMap": "private FunctionInformationMap functionInformationMap", "StringBuilder#debugLog": "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention#defaultCodingConvention": "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "JSTypeRegistry#typeRegistry": "private JSTypeRegistry typeRegistry", "Config#parserConfig": "private Config parserConfig = null", "ReverseAbstractInterpreter#abstractInterpreter": "private ReverseAbstractInterpreter abstractInterpreter", "TypeValidator#typeValidator": "private TypeValidator typeValidator", "PerformanceTracker#tracker": "public PerformanceTracker tracker", "com.google.javascript.rhino.ErrorReporter#oldErrorReporter": "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "ErrorReporter#defaultErrorReporter": "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "DiagnosticType#OPTIMIZE_LOOP_ERROR": "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "DiagnosticType#MOTION_ITERATIONS_ERROR": "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "long#COMPILER_STACK_SIZE": "private static final long COMPILER_STACK_SIZE = 1048576L", "Logger#logger": "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "PrintStream#outStream": "private final PrintStream outStream", "GlobalVarReferenceMap#globalRefMap": "private GlobalVarReferenceMap globalRefMap = null", "double#progress": "private volatile double progress = 0.0", "DiagnosticType#EMPTY_MODULE_LIST_ERROR": "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "DiagnosticType#EMPTY_ROOT_MODULE_ERROR": "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "DiagnosticType#DUPLICATE_INPUT": "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "DiagnosticType#DUPLICATE_EXTERN_INPUT": "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "PassFactory#sanityCheck": "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "Tracer#currentTracer": "private Tracer currentTracer = null", "String#currentPassName": "private String currentPassName = null", "int#syntheticCodeId": "private int syntheticCodeId = 0", "CodeChangeHandler.RecentChange#recentChange": "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "List<CodeChangeHandler>#codeChangeHandlers": "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "String#SYNTHETIC_EXTERNS": "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "CompilerInput#synthesizedExternsInput": "private CompilerInput synthesizedExternsInput = null"}, "text": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Charsets;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.io.CharStreams;\nimport com.google.javascript.jscomp.CompilerOptions.DevMode;\nimport com.google.javascript.jscomp.CompilerOptions.LanguageMode;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\nimport com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\nimport com.google.javascript.jscomp.parsing.Config;\nimport com.google.javascript.jscomp.parsing.ParserRunner;\nimport com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.head.ErrorReporter;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\n\n/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  static final String SINGLETON_MODULE_NAME = \"[singleton]\";\n\n  static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\");\n\n  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\");\n\n  CompilerOptions options = null;\n\n  private PassConfig passes = null;\n\n  // The externs inputs\n  private List<CompilerInput> externs;\n\n  // The JS source modules\n  private List<JSModule> modules;\n\n  // The graph of the JS source modules. Must be null if there are less than\n  // 2 modules, because we use this as a signal for which passes to run.\n  private JSModuleGraph moduleGraph;\n\n  // The JS source inputs\n  private List<CompilerInput> inputs;\n\n  // error manager to which error management is delegated\n  private ErrorManager errorManager;\n\n  // Warnings guard for filtering warnings.\n  private WarningsGuard warningsGuard;\n\n  // Compile-time injected libraries. The node points to the last node of\n  // the library, so code can be inserted after.\n  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n\n  // Parse tree root nodes\n  Node externsRoot;\n  Node jsRoot;\n  Node externAndJsRoot;\n\n  private Map<InputId, CompilerInput> inputsById;\n\n  /** The source code map */\n  private SourceMap sourceMap;\n\n  /** The externs created from the exports.  */\n  private String externExports = null;\n\n  /**\n   * Ids for function inlining so that each declared name remains\n   * unique.\n   */\n  private int uniqueNameId = 0;\n\n  /** Whether to use threads. */\n  private boolean useThreads = true;\n\n  /**\n   * Whether to assume there are references to the RegExp Global object\n   * properties.\n   */\n  private boolean hasRegExpGlobalReferences = true;\n\n  /** The function information map */\n  private FunctionInformationMap functionInformationMap;\n\n  /** Debugging information */\n  private final StringBuilder debugLog = new StringBuilder();\n\n  /** Detects Google-specific coding conventions. */\n  CodingConvention defaultCodingConvention = new ClosureCodingConvention();\n\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n\n  public PerformanceTracker tracker;\n\n  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.\n  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =\n      RhinoErrorReporter.forOldRhino(this);\n\n  // This error reporter gets the messages from the current Rhino parser.\n  private final ErrorReporter defaultErrorReporter =\n      RhinoErrorReporter.forNewRhino(this);\n\n  /** Error strings used for reporting JSErrors */\n  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\");\n  public static final DiagnosticType MOTION_ITERATIONS_ERROR =\n      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\");\n\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n\n\n  /**\n   * Logger for the whole com.google.javascript.jscomp domain -\n   * setting configuration for this logger affects all loggers\n   *  in other classes within the compiler.\n   */\n  private static final Logger logger =\n      Logger.getLogger(\"com.google.javascript.jscomp\");\n\n  private final PrintStream outStream;\n\n  private GlobalVarReferenceMap globalRefMap = null;\n\n  private volatile double progress = 0.0;\n\n  /**\n   * Creates a Compiler that reports errors and warnings to its logger.\n   */\n  public Compiler() {\n    this((PrintStream) null);\n  }\n\n  /**\n   * Creates n Compiler that reports errors and warnings to an output\n   * stream.\n   */\n  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }\n\n  /**\n   * Creates a Compiler that uses a custom error manager.\n   */\n  public Compiler(ErrorManager errorManager) {\n    this();\n    setErrorManager(errorManager);\n  }\n\n  /**\n   * Sets the error manager.\n   *\n   * @param errorManager the error manager, it cannot be {@code null}\n   */\n  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }\n\n  /**\n   * Creates a message formatter instance corresponding to the value of\n   * {@link CompilerOptions}.\n   */\n  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }\n\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    init(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n    for (SourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options) {\n    initModules(Lists.<SourceFile>newArrayList(externs),\n         Lists.<JSModule>newArrayList(modules), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }\n\n  /**\n   * Do any initialization that is dependent on the compiler options.\n   */\n  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }\n\n  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n      List<T> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (T file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }\n\n  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\");\n\n  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\");\n\n  /**\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   */\n  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }\n\n  /**\n   * Empty modules get an empty \"fill\" file, so that we can move code into\n   * an empty module.\n   */\n  static String createFillFileName(String moduleName) {\n    return \"[\" + moduleName + \"]\";\n  }\n\n  /**\n   * Fill any empty modules with a place holder file. It makes any cross module\n   * motion easier.\n   */\n  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(SourceFile.fromCode(\n            createFillFileName(module.getName()), \"\"));\n      }\n    }\n  }\n\n  /**\n   * Rebuilds the internal list of inputs by iterating over all modules.\n   * This is necessary if inputs have been added to or removed from a module\n   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n   */\n  public void rebuildInputsFromModules() {\n    inputs = getAllInputsFromModules(modules);\n    initInputsByIdMap();\n  }\n\n  /**\n   * Builds a single list of all module inputs. Verifies that it contains no\n   * duplicates.\n   */\n  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }\n\n  static final DiagnosticType DUPLICATE_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");\n  static final DiagnosticType DUPLICATE_EXTERN_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\");\n\n  /**\n   * Creates a map to make looking up an input by name fast. Also checks for\n   * duplicate inputs.\n   */\n  void initInputsByIdMap() {\n    inputsById = new HashMap<InputId, CompilerInput>();\n    for (CompilerInput input : externs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n      }\n    }\n  }\n\n  public Result compile(\n      SourceFile extern, SourceFile input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      SourceFile extern, JSSourceFile[] input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {\n     return compileModules(\n         Lists.newArrayList(extern), Lists.newArrayList(modules), options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options) {\n    return compile(Lists.<SourceFile>newArrayList(externs),\n        Lists.<SourceFile>newArrayList(inputs),\n        options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n      List<T1> externs, List<T2> inputs, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, inputs, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options) {\n    return compileModules(Lists.<SourceFile>newArrayList(externs),\n        Lists.<JSModule>newArrayList(modules),\n        options);\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public <T extends SourceFile> Result compileModules(List<T> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      @Override\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }\n\n  /**\n   * Disable threads. This is for clients that run on AppEngine and\n   * don't have threads.\n   */\n  public void disableThreads() {\n    useThreads = false;\n  }\n\n  private <T> T runInCompilerThread(final Callable<T> callable) {\n    return runCallable(callable, useThreads, options.tracer.isOn());\n  }\n\n  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n    return runCallable(callable, true, false);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n\n    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n    // large or complex js code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = trace;\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useLargeStackThread) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }\n\n  private void compileInternal() {\n    setProgress(0.0);\n    parse();\n    // 15 percent of the work is assumed to be for parsing (based on some\n    // minimal analysis on big JS projects, of course this depends on options)\n    setProgress(0.15);\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n    setProgress(1.0);\n  }\n\n  public void parse() {\n    parseInputs();\n  }\n\n  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }\n\n  /**\n   * Create the passes object. Clients should use setPassConfig instead of\n   * overriding this.\n   */\n  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }\n\n  /**\n   * @param passes The PassConfig to use with this Compiler.\n   * @throws NullPointerException if passes is null\n   * @throws IllegalStateException if this.passes has already been assigned\n   */\n  public void setPassConfig(PassConfig passes) {\n    // Important to check for null because if setPassConfig(null) is\n    // called before this.passes is set, getPassConfig() will create a\n    // new PassConfig object and use that, which is probably not what\n    // the client wanted since he or she probably meant to use their\n    // own PassConfig object.\n    Preconditions.checkNotNull(passes);\n\n    if (this.passes != null) {\n      throw new IllegalStateException(\"this.passes has already been assigned\");\n    }\n    this.passes = passes;\n  }\n\n  /**\n   * Carry out any special checks or procedures that need to be done before\n   * proceeding with rest of the compilation process.\n   *\n   * @return true, to continue with compilation\n   */\n  boolean precheck() {\n    return true;\n  }\n\n  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    // We are currently only interested in check-passes for progress reporting\n    // as it is used for IDEs, that's why the maximum progress is set to 1.0.\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,\n        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }\n\n  private void externExports() {\n    logger.fine(\"Creating extern file for exports\");\n    startPass(\"externExports\");\n\n    ExternExportsPass pass = new ExternExportsPass(this);\n    process(pass);\n\n    externExports = pass.getGeneratedExterns();\n\n    endPass();\n  }\n\n  @Override\n  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }\n\n  private final PassFactory sanityCheck =\n      new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  };\n\n  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }\n\n  private void runSanityCheck() {\n    sanityCheck.create(this).process(externsRoot, jsRoot);\n  }\n\n  /**\n   * Removes try/catch/finally statements for easier debugging.\n   */\n  void removeTryCatchFinally() {\n    logger.fine(\"Remove try/catch/finally\");\n    startPass(\"removeTryCatchFinally\");\n    RemoveTryCatch r = new RemoveTryCatch(this);\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Strips code for smaller compiled code. This is useful for removing debug\n   * statements to prevent leaking them publicly.\n   */\n  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n    logger.fine(\"Strip code\");\n    startPass(\"stripCode\");\n    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n        stripTypePrefixes, stripNamePrefixes);\n    if (options.getTweakProcessing().shouldStrip()) {\n      r.enableTweakStripping();\n    }\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Runs custom passes that are designated to run at a particular time.\n   */\n  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }\n\n  private Tracer currentTracer = null;\n  private String currentPassName = null;\n\n  /**\n   * Marks the beginning of a pass.\n   */\n  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }\n\n  /**\n   * Marks the end of a pass.\n   */\n  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }\n\n  /**\n   * Returns a new tracer for the given pass name.\n   */\n  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }\n\n  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }\n\n  /**\n   * Returns the result of the compilation.\n   */\n  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }\n\n  /**\n   * Returns an array constructed from errors + temporary warnings.\n   */\n  public JSError[] getMessages() {\n    return getErrors();\n  }\n\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }\n\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }\n\n  @Override\n  public Node getRoot() {\n    return externAndJsRoot;\n  }\n\n  /**\n   * Creates a new id for making unique names.\n   */\n  private int nextUniqueNameId() {\n    return uniqueNameId++;\n  }\n\n  /**\n   * Resets the unique name id counter\n   */\n  @VisibleForTesting\n  void resetUniqueNameId() {\n    uniqueNameId = 0;\n  }\n\n  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      @Override\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }\n\n  @Override\n  boolean areNodesEqualForInlining(Node n1, Node n2) {\n    if (options.ambiguateProperties ||\n        options.disambiguateProperties) {\n      // The type based optimizations require that type information is preserved\n      // during other optimizations.\n      return n1.isEquivalentToTyped(n2);\n    } else {\n      return n1.isEquivalentTo(n2);\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Inputs\n  //------------------------------------------------------------------------\n\n  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler\n  // interface, and which ones should always be injected.\n\n  @Override\n  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }\n\n  /**\n   * Removes an input file from AST.\n   * @param id The id of the input to be removed.\n   */\n  protected void removeExternInput(InputId id) {\n    CompilerInput input = getInput(id);\n    if (input == null) {\n      return;\n    }\n    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());\n    inputsById.remove(id);\n    externs.remove(input);\n    Node root = input.getAstRoot(this);\n    if (root != null) {\n      root.detachFromParent();\n    }\n  }\n\n  @Override\n  public CompilerInput newExternInput(String name) {\n    SourceAst ast = new SyntheticAst(name);\n    if (inputsById.containsKey(ast.getInputId())) {\n      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n    }\n    CompilerInput input = new CompilerInput(ast, true);\n    putCompilerInput(input.getInputId(), input);\n    externsRoot.addChildToFront(ast.getAstRoot(this));\n    externs.add(0, input);\n    return input;\n  }\n\n  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }\n\n  /** Add a source input dynamically. Intended for incremental compilation. */\n  void addIncrementalSourceAst(JsAst ast) {\n    InputId id = ast.getInputId();\n    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());\n    putCompilerInput(id, new CompilerInput(ast));\n  }\n\n  /**\n   * Replace a source input dynamically. Intended for incremental\n   * re-compilation.\n   *\n   * If the new source input doesn't parse, then keep the old input\n   * in the AST and return false.\n   *\n   * @return Whether the new AST was attached successfully.\n   */\n  boolean replaceIncrementalSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    Node oldRoot = oldInput.getAstRoot(this);\n    if (oldRoot != null) {\n      oldRoot.getParent().replaceChild(oldRoot, newRoot);\n    } else {\n      getRoot().getLastChild().addChildToBack(newRoot);\n    }\n\n    CompilerInput newInput = new CompilerInput(ast);\n    putCompilerInput(ast.getInputId(), newInput);\n\n    JSModule module = oldInput.getModule();\n    if (module != null) {\n      module.addAfter(newInput, oldInput);\n      module.remove(oldInput);\n    }\n\n    // Verify the input id is set properly.\n    Preconditions.checkState(\n        newInput.getInputId().equals(oldInput.getInputId()));\n    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();\n    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));\n\n    inputs.remove(oldInput);\n    return true;\n  }\n\n  /**\n   * Add a new source input dynamically. Intended for incremental compilation.\n   * <p>\n   * If the new source input doesn't parse, it will not be added, and a false\n   * will be returned.\n   *\n   * @param ast the JS Source to add.\n   * @return true if the source was added successfully, false otherwise.\n   * @throws IllegalStateException if an input for this ast already exists.\n   */\n  boolean addNewSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    if (oldInput != null) {\n      throw new IllegalStateException(\n          \"Input already exists: \" + ast.getInputId().getIdName());\n    }\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    getRoot().getLastChild().addChildToBack(newRoot);\n\n    CompilerInput newInput = new CompilerInput(ast);\n\n    // TODO(tylerg): handle this for multiple modules at some point.\n    if (moduleGraph == null && !modules.isEmpty()) {\n      // singleton module\n      modules.get(0).add(newInput);\n    }\n\n    putCompilerInput(ast.getInputId(), newInput);\n\n    return true;\n  }\n\n  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }\n\n  /**\n   * Gets a module graph. This will always return a module graph, even\n   * in the degenerate case when there's only one module.\n   */\n  JSModuleGraph getDegenerateModuleGraph() {\n    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;\n  }\n\n  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }\n\n  @Override\n  public MemoizedScopeCreator getTypedScopeCreator() {\n    return getPassConfig().getTypedScopeCreator();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  DefaultPassConfig ensureDefaultPassConfig() {\n    PassConfig passes = getPassConfig().getBasePassConfig();\n    Preconditions.checkState(passes instanceof DefaultPassConfig,\n        \"PassConfigs must eventually delegate to the DefaultPassConfig\");\n    return (DefaultPassConfig) passes;\n  }\n\n  public SymbolTable buildKnownSymbolTable() {\n    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());\n\n    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();\n    if (typedScopeCreator != null) {\n      symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());\n      symbolTable.addSymbolsFrom(typedScopeCreator);\n    } else {\n      symbolTable.findScopes(this, externsRoot, jsRoot);\n    }\n\n    GlobalNamespace globalNamespace =\n        ensureDefaultPassConfig().getGlobalNamespace();\n    if (globalNamespace != null) {\n      symbolTable.addSymbolsFrom(globalNamespace);\n    }\n\n    ReferenceCollectingCallback refCollector =\n        new ReferenceCollectingCallback(\n            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n    NodeTraversal.traverse(this, getRoot(), refCollector);\n    symbolTable.addSymbolsFrom(refCollector);\n\n    PreprocessorSymbolTable preprocessorSymbolTable =\n        ensureDefaultPassConfig().getPreprocessorSymbolTable();\n    if (preprocessorSymbolTable != null) {\n      symbolTable.addSymbolsFrom(preprocessorSymbolTable);\n    }\n\n    symbolTable.fillNamespaceReferences();\n    symbolTable.fillPropertyScopes();\n    symbolTable.fillThisReferences(this, externsRoot, jsRoot);\n    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);\n\n    return symbolTable;\n  }\n\n  @Override\n  public Scope getTopScope() {\n    return getPassConfig().getTopScope();\n  }\n\n  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }\n\n  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }\n\n  //------------------------------------------------------------------------\n  // Parsing\n  //------------------------------------------------------------------------\n\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n\n  /**\n   * Transforms AMD and CJS modules to something closure compiler can\n   * process and creates JSModules and the corresponding dependency tree\n   * on the way.\n   */\n  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n      if (!modules.isEmpty()) {\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }\n\n  public Node parse(SourceFile file) {\n    initCompilerOptionsIfTesting();\n    addToDebugLog(\"Parsing: \" + file.getName());\n    return new JsAst(file).getAstRoot(this);\n  }\n\n  private int syntheticCodeId = 0;\n\n  @Override\n  Node parseSyntheticCode(String js) {\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  /**\n   * Allow subclasses to override the default CompileOptions object.\n   */\n  protected CompilerOptions newCompilerOptions() {\n    return new CompilerOptions();\n  }\n\n  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(newCompilerOptions());\n    }\n  }\n\n  @Override\n  Node parseSyntheticCode(String fileName, String js) {\n    initCompilerOptionsIfTesting();\n    return parse(SourceFile.fromCode(fileName, js));\n  }\n\n  @Override\n  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\"[testcode]\", js));\n    if (inputsById == null) {\n      inputsById = Maps.newHashMap();\n    }\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }\n\n  //------------------------------------------------------------------------\n  // Convert back to source code\n  //------------------------------------------------------------------------\n\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource() {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for each input back to js code.\n   */\n  public String[] toSourceArray() {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        Tracer tracer = newTracer(\"toSourceArray\");\n        try {\n          int numInputs = inputs.size();\n          String[] sources = new String[numInputs];\n          CodeBuilder cb = new CodeBuilder();\n          for (int i = 0; i < numInputs; i++) {\n            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n            cb.reset();\n            toSource(cb, i, scriptNode);\n            sources[i] = cb.toString();\n          }\n          return sources;\n        } finally {\n          stopTracer(tracer, \"toSourceArray\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module) {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return \"\";\n        }\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module: \" + module.getName());\n          }\n          toSource(cb, i, scriptNode);\n        }\n        return cb.toString();\n      }\n    });\n  }\n\n\n  /**\n   * Converts the parse tree for each input in a module back to js code.\n   */\n  public String[] toSourceArray(final JSModule module) {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return new String[0];\n        }\n\n        String[] sources = new String[numInputs];\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module input: \" + inputs.get(i).getName());\n          }\n\n          cb.reset();\n          toSource(cb, i, scriptNode);\n          sources[i] = cb.toString();\n        }\n        return sources;\n      }\n    });\n  }\n\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n      @Override\n      public Void call() throws Exception {\n        if (options.printInputDelimiter) {\n          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            cb.append(\"\\n\");  // Make sure that the label starts on a new line\n          }\n          Preconditions.checkState(root.isScript());\n\n          String delimiter = options.inputDelimiter;\n\n          String inputName = root.getInputId().getIdName();\n          String sourceName = root.getSourceFileName();\n          Preconditions.checkState(sourceName != null);\n          Preconditions.checkState(!sourceName.isEmpty());\n\n          delimiter = delimiter\n              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))\n              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n          cb.append(delimiter)\n            .append(\"\\n\");\n        }\n        if (root.getJSDocInfo() != null &&\n            root.getJSDocInfo().getLicense() != null) {\n          cb.append(\"/*\\n\")\n            .append(root.getJSDocInfo().getLicense())\n            .append(\"*/\\n\");\n        }\n\n        // If there is a valid source map, then indicate to it that the current\n        // root node's mappings are offset by the given string builder buffer.\n        if (options.sourceMapOutputPath != null) {\n          sourceMap.setStartingPosition(\n              cb.getLineIndex(), cb.getColumnIndex());\n        }\n\n        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n        // for the first input file\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n        if (!code.isEmpty()) {\n          cb.append(code);\n\n          // In order to avoid parse ambiguity when files are concatenated\n          // together, all files should end in a semi-colon. Do a quick\n          // heuristic check if there's an obvious semi-colon already there.\n          int length = code.length();\n          char lastChar = code.charAt(length - 1);\n          char secondLastChar = length >= 2 ?\n              code.charAt(length - 2) : '\\0';\n          boolean hasSemiColon = lastChar == ';' ||\n              (lastChar == '\\n' && secondLastChar == ';');\n          if (!hasSemiColon) {\n            cb.append(\";\");\n          }\n        }\n        return null;\n      }\n    });\n  }\n\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n  }\n\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }\n\n  /**\n   * Stores a buffer of text to which more can be appended.  This is just like a\n   * StringBuilder except that we also track the number of lines.\n   */\n  public static class CodeBuilder {\n    private final StringBuilder sb = new StringBuilder();\n    private int lineCount = 0;\n    private int colCount = 0;\n\n    /** Removes all text, but leaves the line count unchanged. */\n    void reset() {\n      sb.setLength(0);\n    }\n\n    /** Appends the given string to the text buffer. */\n    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }\n\n    /** Returns all text in the text buffer. */\n    @Override\n    public String toString() {\n      return sb.toString();\n    }\n\n    /** Returns the length of the text buffer. */\n    public int getLength() {\n      return sb.length();\n    }\n\n    /** Returns the (zero-based) index of the last line in the text buffer. */\n    int getLineIndex() {\n      return lineCount;\n    }\n\n    /** Returns the (zero-based) index of the last column in the text buffer. */\n    int getColumnIndex() {\n      return colCount;\n    }\n\n    /** Determines whether the text ends with the given suffix. */\n    boolean endsWith(String suffix) {\n      return (sb.length() > suffix.length())\n          && suffix.equals(sb.substring(sb.length() - suffix.length()));\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Optimizations\n  //------------------------------------------------------------------------\n\n  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }\n\n  @Override\n  void setCssRenamingMap(CssRenamingMap map) {\n    options.cssRenamingMap = map;\n  }\n\n  @Override\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }\n\n  /**\n   * Reprocesses the current defines over the AST.  This is used by GwtCompiler\n   * to generate N outputs for different targets from the same (checked) AST.\n   * For each target, we apply the target-specific defines by calling\n   * {@code processDefines} and then {@code optimize} to optimize the AST\n   * specifically for that target.\n   */\n  public void processDefines() {\n    (new DefaultPassConfig(options)).processDefines.create(this)\n        .process(externsRoot, jsRoot);\n  }\n\n  boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }\n\n  /** Control Flow Analysis. */\n  ControlFlowGraph<Node> computeCFG() {\n    logger.fine(\"Computing Control Flow Graph\");\n    Tracer tracer = newTracer(\"computeCFG\");\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n    process(cfa);\n    stopTracer(tracer, \"computeCFG\");\n    return cfa.getCfg();\n  }\n\n  public void normalize() {\n    logger.fine(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }\n\n  @Override\n  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }\n\n  void recordFunctionInformation() {\n    logger.fine(\"Recording function information\");\n    startPass(\"recordFunctionInformation\");\n    RecordFunctionInformation recordFunctionInfoPass =\n        new RecordFunctionInformation(\n            this, getPassConfig().getIntermediateState().functionNames);\n    process(recordFunctionInfoPass);\n    functionInformationMap = recordFunctionInfoPass.getMap();\n    endPass();\n  }\n\n  protected final CodeChangeHandler.RecentChange recentChange =\n      new CodeChangeHandler.RecentChange();\n  private final List<CodeChangeHandler> codeChangeHandlers =\n      Lists.<CodeChangeHandler>newArrayList();\n\n  /** Name of the synthetic input that holds synthesized externs. */\n  static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\";\n\n  private CompilerInput synthesizedExternsInput = null;\n\n  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }\n\n  @Override\n  void removeChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.remove(handler);\n  }\n\n  /**\n   * All passes should call reportCodeChange() when they alter\n   * the JS tree structure. This is verified by CompilerTestCase.\n   * This allows us to optimize to a fixed point.\n   */\n  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }\n\n  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }\n\n  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }\n\n  @Override\n  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n    }\n    return false;\n  }\n\n  public LanguageMode languageMode() {\n    return options.getLanguageIn();\n  }\n\n  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }\n\n  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }\n\n  @Override\n  public boolean isTypeCheckingEnabled() {\n    return options.checkTypes;\n  }\n\n\n  //------------------------------------------------------------------------\n  // Error reporting\n  //------------------------------------------------------------------------\n\n  /**\n   * The warning classes that are available from the command-line, and\n   * are suppressable by the {@code @suppress} annotation.\n   */\n  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }\n\n  @Override\n  public void report(JSError error) {\n    CheckLevel level = error.getDefaultLevel();\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      if (getOptions().errorHandler != null) {\n        getOptions().errorHandler.report(level, error);\n      }\n      errorManager.report(level, error);\n    }\n  }\n\n  @Override\n  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }\n\n  /**\n   * Report an internal error.\n   */\n  @Override\n  void throwInternalError(String message, Exception cause) {\n    String finalMessage =\n      \"INTERNAL COMPILER ERROR.\\n\" +\n      \"Please report this problem.\\n\" + message;\n\n    RuntimeException e = new RuntimeException(finalMessage, cause);\n    if (cause != null) {\n      e.setStackTrace(cause.getStackTrace());\n    }\n    throw e;\n  }\n\n\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }\n\n  /**\n   * Gets the number of warnings.\n   */\n  public int getWarningCount() {\n    return errorManager.getWarningCount();\n  }\n\n  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }\n\n  /**\n   * Consults the {@link ErrorManager} to see if we've encountered errors\n   * that should halt compilation. <p>\n   *\n   * If {@link CompilerOptions#ideMode} is {@code true}, this function\n   * always returns {@code false} without consulting the error manager. The\n   * error manager will continue to be told about new errors and warnings, but\n   * the compiler will complete compilation of all inputs.<p>\n   */\n  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }\n\n  /** Called from the compiler passes, adds debug info */\n  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }\n\n  private SourceFile getSourceFileByName(String sourceName) {\n    // Here we assume that the source name is the input name, this\n    // is try of javascript parsed from source.\n    if (sourceName != null) {\n      CompilerInput input = inputsById.get(new InputId(sourceName));\n      if (input != null) {\n        return input.getSourceFile();\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }\n\n  @Override\n  public Region getSourceRegion(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getRegion(lineNumber);\n    }\n    return null;\n  }\n\n  //------------------------------------------------------------------------\n  // Package-private helpers\n  //------------------------------------------------------------------------\n\n  @Override\n  Node getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n      if (inputs.isEmpty()) {\n        throw new IllegalStateException(\"No inputs\");\n      }\n\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    List<CompilerInput> moduleInputs = module.getInputs();\n    if (moduleInputs.size() > 0) {\n      return moduleInputs.get(0).getAstRoot(this);\n    }\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }\n\n  public SourceMap getSourceMap() {\n    return sourceMap;\n  }\n\n  VariableMap getVariableMap() {\n    return getPassConfig().getIntermediateState().variableMap;\n  }\n\n  VariableMap getPropertyMap() {\n    return getPassConfig().getIntermediateState().propertyMap;\n  }\n\n  CompilerOptions getOptions() {\n    return options;\n  }\n\n  FunctionInformationMap getFunctionalInformationMap() {\n    return functionInformationMap;\n  }\n\n  /**\n   * Sets the logging level for the com.google.javascript.jscomp package.\n   */\n  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }\n\n  /** Gets the DOT graph of the AST generated at the end of compilation. */\n  public String getAstDotGraph() throws IOException {\n    if (jsRoot != null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n      cfa.process(null, jsRoot);\n      return DotFormatter.toDot(jsRoot, cfa.getCfg());\n    } else {\n      return \"\";\n    }\n  }\n\n  @Override\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(newCompilerOptions());\n    }\n    return errorManager;\n  }\n\n  @Override\n  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }\n\n  /**\n   * Returns an unmodifiable view of the compiler inputs indexed by id.\n   */\n  public Map<InputId, CompilerInput> getInputsById() {\n    return Collections.unmodifiableMap(inputsById);\n  }\n\n  /**\n   * Gets the externs in the order in which they are being processed.\n   */\n  List<CompilerInput> getExternsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(externs);\n  }\n\n  /**\n   * Stores the internal compiler state just before optimization is performed.\n   * This can be saved and restored in order to efficiently optimize multiple\n   * different output targets without having to perform checking multiple times.\n   *\n   * NOTE: This does not include all parts of the compiler's internal state. In\n   * particular, SourceFiles and CompilerOptions are not recorded. In\n   * order to recreate a Compiler instance from scratch, you would need to\n   * call {@code init} with the same arguments as in the initial creation before\n   * restoring intermediate state.\n   */\n  public static class IntermediateState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    Node externsRoot;\n    private Node jsRoot;\n    private List<CompilerInput> externs;\n    private List<CompilerInput> inputs;\n    private List<JSModule> modules;\n    private PassConfig.State passConfigState;\n    private JSTypeRegistry typeRegistry;\n    private AbstractCompiler.LifeCycleStage lifeCycleStage;\n    private Map<String, Node> injectedLibraries;\n\n    private IntermediateState() {}\n  }\n\n  /**\n   * Returns the current internal state, excluding the input files and modules.\n   */\n  public IntermediateState getState() {\n    IntermediateState state = new IntermediateState();\n    state.externsRoot = externsRoot;\n    state.jsRoot = jsRoot;\n    state.externs = externs;\n    state.inputs = inputs;\n    state.modules = modules;\n    state.passConfigState = getPassConfig().getIntermediateState();\n    state.typeRegistry = typeRegistry;\n    state.lifeCycleStage = getLifeCycleStage();\n    state.injectedLibraries = Maps.newLinkedHashMap(injectedLibraries);\n\n    return state;\n  }\n\n  /**\n   * Sets the internal state to the capture given.  Note that this assumes that\n   * the input files are already set up.\n   */\n  public void setState(IntermediateState state) {\n    externsRoot = state.externsRoot;\n    jsRoot = state.jsRoot;\n    externs = state.externs;\n    inputs = state.inputs;\n    modules = state.modules;\n    passes = createPassConfigInternal();\n    getPassConfig().setIntermediateState(state.passConfigState);\n    typeRegistry = state.typeRegistry;\n    setLifeCycleStage(state.lifeCycleStage);\n\n    injectedLibraries.clear();\n    injectedLibraries.putAll(state.injectedLibraries);\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getInputsForTesting() {\n    return inputs;\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getExternsForTesting() {\n    return externs;\n  }\n\n  @Override\n  boolean hasRegExpGlobalReferences() {\n    return hasRegExpGlobalReferences;\n  }\n\n  @Override\n  void setHasRegExpGlobalReferences(boolean references) {\n    hasRegExpGlobalReferences = references;\n  }\n\n  @Override\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.isScript()\n        || collectionRoot.isBlock());\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n          getExternsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }\n\n  @Override\n  GlobalVarReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }\n\n  @Override\n  CompilerInput getSynthesizedExternsInput() {\n    if (synthesizedExternsInput == null) {\n      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);\n    }\n    return synthesizedExternsInput;\n  }\n\n  @Override\n  public double getProgress() {\n    return progress;\n  }\n\n  @Override\n  void setProgress(double newProgress) {\n    if (newProgress > 1.0) {\n      progress = 1.0;\n    } else if (newProgress < 0.0) {\n      progress = 0.0;\n    } else {\n      progress = newProgress;\n    }\n  }\n\n  /**\n   * Replaces one file in a hot-swap mode. The given JsAst should be made\n   * from a new version of a file that already was present in the last compile\n   * call. If the file is new, this will silently ignored.\n   *\n   * @param ast the ast of the file that is being replaced\n   */\n  public void replaceScript(JsAst ast) {\n    CompilerInput input = this.getInput(ast.getInputId());\n    if (!replaceIncrementalSourceAst(ast)) {\n      return;\n    }\n    Node originalRoot = input.getAstRoot(this);\n\n    processNewScript(ast, originalRoot);\n  }\n\n  /**\n   * Adds a new Script AST to the compile state. If a script for the same file\n   * already exists the script will not be added, instead a call to\n   * #replaceScript should be used.\n   *\n   * @param ast the ast of the new file\n   */\n  public void addNewScript(JsAst ast) {\n    if (!addNewSourceAst(ast)) {\n      return;\n    }\n    Node emptyScript = new Node(Token.SCRIPT);\n    InputId inputId = ast.getInputId();\n    emptyScript.setInputId(inputId);\n    emptyScript.setStaticSourceFile(\n        SourceFile.fromCode(inputId.getIdName(), \"\"));\n\n    processNewScript(ast, emptyScript);\n  }\n\n  private void processNewScript(JsAst ast, Node originalRoot) {\n    Node js = ast.getAstRoot(this);\n    Preconditions.checkNotNull(js);\n\n    runHotSwap(originalRoot, js, this.getCleanupPassConfig());\n    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need\n    // to revisit this approach to clearing GlobalNamespaces\n    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);\n\n    this.getTypeRegistry().clearNamedTypes();\n    this.removeSyntheticVarsInput();\n\n    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());\n  }\n\n  /**\n   * Execute the passes from a PassConfig instance over a single replaced file.\n   */\n  private void runHotSwap(\n      Node originalRoot, Node js, PassConfig passConfig) {\n    for (PassFactory passFactory : passConfig.getChecks()) {\n      runHotSwapPass(originalRoot, js, passFactory);\n    }\n  }\n\n  private void runHotSwapPass(\n      Node originalRoot, Node js, PassFactory passFactory) {\n    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);\n    if (pass != null) {\n      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());\n      pass.hotSwapScript(js, originalRoot);\n    }\n  }\n\n  private PassConfig getCleanupPassConfig() {\n    return new CleanupPasses(getOptions());\n  }\n\n  private void removeSyntheticVarsInput() {\n    String sourceName = Compiler.SYNTHETIC_EXTERNS;\n    removeExternInput(new InputId(sourceName));\n  }\n\n  @Override\n  Node ensureLibraryInjected(String resourceName) {\n    if (injectedLibraries.containsKey(resourceName)) {\n      return null;\n    }\n\n    // All libraries depend on js/base.js\n    boolean isBase = \"base\".equals(resourceName);\n    if (!isBase) {\n      ensureLibraryInjected(\"base\");\n    }\n\n    Node firstChild = loadLibraryCode(resourceName).removeChildren();\n    Node lastChild = firstChild.getLastSibling();\n\n    Node parent = getNodeForCodeInsertion(null);\n    if (isBase) {\n      parent.addChildrenToFront(firstChild);\n    } else {\n      parent.addChildrenAfter(\n          firstChild, injectedLibraries.get(\"base\"));\n    }\n    reportCodeChange();\n\n    injectedLibraries.put(resourceName, lastChild);\n    return lastChild;\n  }\n\n  /** Load a library as a resource */\n  @VisibleForTesting\n  Node loadLibraryCode(String resourceName) {\n    String originalCode;\n    try {\n      originalCode = CharStreams.toString(new InputStreamReader(\n          Compiler.class.getResourceAsStream(\n              String.format(\"js/%s.js\", resourceName)),\n          Charsets.UTF_8));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    return Normalize.parseAndNormalizeSyntheticCode(\n        this, originalCode,\n        String.format(\"jscomp_%s_\", resourceName));\n  }\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `compile` method in the `Compiler` class. These tests aim to maximize branch and line coverage, ensuring that various conditions and scenarios are tested.\n\n### Prerequisites:\n1. **Dependencies**: Ensure you have JUnit 4 in your classpath.\n2. **Mocking Framework**: Since some dependencies like `ErrorManager`, `CompilerOptions`, and `SourceFile` are involved, we will use Mockito for mocking.\n\n### Unit Tests:\n\n```java\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.*;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.SourceFile;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.junit.MockitoJUnitRunner;\n\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class CompilerTest {\n\n    @Mock\n    private ErrorManager errorManager;\n\n    @Mock\n    private CompilerOptions compilerOptions;\n\n    @Mock\n    private SourceFile externFile;\n\n    @Mock\n    private SourceFile inputFile;\n\n    @Mock\n    private Tracer tracer;\n\n    private Compiler compiler;\n\n    @Before\n    public void setUp() {\n        compiler = new Compiler();\n        compiler.setErrorManager(errorManager);\n    }\n\n    @Test\n    public void testCompileSuccess() throws Exception {\n        // Arrange\n        List<SourceFile> externs = Lists.newArrayList(externFile);\n        List<SourceFile> inputs = Lists.newArrayList(inputFile);\n        when(compiler.hasErrors()).thenReturn(false);\n        when(compiler.compile()).thenReturn(new Result(Node.newString(\"compiled\")));\n\n        // Act\n        Result result = compiler.compile(externs, inputs, compilerOptions);\n\n        // Assert\n        assertEquals(\"compiled\", result.toSource());\n        verify(compiler, times(1)).init(externs, inputs, compilerOptions);\n        verify(compiler, times(1)).compile();\n        verify(tracer, times(1)).startTracer(\"generateReport\");\n        verify(tracer, times(1)).stopTracer(\"generateReport\");\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testCompileCalledTwice() throws Exception {\n        // Arrange\n        compiler.jsRoot = new Node(Token.SCRIPT); // Simulate jsRoot being set\n        List<SourceFile> externs = Lists.newArrayList(externFile);\n        List<SourceFile> inputs = Lists.newArrayList(inputFile);\n\n        // Act & Assert\n        compiler.compile(externs, inputs, compilerOptions);\n    }\n\n    @Test\n    public void testCompileWithError() throws Exception {\n        // Arrange\n        List<SourceFile> externs = Lists.newArrayList(externFile);\n        List<SourceFile> inputs = Lists.newArrayList(inputFile);\n        when(compiler.hasErrors()).thenReturn(true);\n\n        // Act\n        Result result = compiler.compile(externs, inputs, compilerOptions);\n\n        // Assert\n        assertEquals(\"\", result.toSource());\n        verify(compiler, times(1)).init(externs, inputs, compilerOptions);\n        verify(compiler, times(0)).compile();\n        verify(tracer, times(1)).startTracer(\"generateReport\");\n        verify(tracer, times(1)).stopTracer(\"generateReport\");\n    }\n\n    @Test\n    public void testCompileReportCodeChange() throws Exception {\n        // Arrange\n        List<SourceFile> externs = Lists.newArrayList(externFile);\n        List<SourceFile> inputs = Lists.newArrayList(inputFile);\n        when(compiler.hasErrors()).thenReturn(false);\n        when(compiler.compile()).thenReturn(new Result(Node.newString(\"compiled\")));\n        doAnswer(invocation -> {\n            compiler.reportCodeChange();\n            return null;\n        }).when(compiler).init(anyList(), anyList(), any());\n\n        // Act\n        Result result = compiler.compile(externs, inputs, compilerOptions);\n\n        // Assert\n        assertEquals(\"compiled\", result.toSource());\n        InOrder inOrder = inOrder(compiler, tracer);\n        inOrder.verify(compiler).init(externs, inputs, compilerOptions);\n        inOrder.verify(compiler).compile();\n        inOrder.verify(compiler).reportCodeChange();\n        inOrder.verify(tracer).startTracer(\"generateReport\");\n        inOrder.verify(tracer).stopTracer(\"generateReport\");\n    }\n}\n```\n\n### Explanation of Tests:\n1. **testCompileSuccess**: Tests the successful compilation path, ensuring that the `init` method is called once, `compile` is called once, and the result is correctly returned. It also verifies that the `generateReport` tracer is started and stopped.\n\n2. **testCompileCalledTwice**: Tests that an `IllegalStateException` is thrown when the `compile` method is called more than once. This is achieved by manually setting `jsRoot` to a non-null value.\n\n3. **testCompileWithError**: Tests the path where there are compilation errors, ensuring that `init` is called once, `compile` is not called, and an empty result is returned. It also verifies the tracer actions.\n\n4. **testCompileReportCodeChange**: Tests the path where a code change is reported during initialization. It ensures that the code change is reported and verifies the order of method calls.\n\nThese tests should cover the main branches and lines in the `compile` method, providing good coverage."}
{"bug_id": "Closure_31", "version": "fixed", "focal_method_signature": "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "focal_method": "public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options) {\n    return compileModules(Lists.<SourceFile>newArrayList(externs),\n        Lists.<JSModule>newArrayList(modules),\n        options);\n  }", "return_type": "Result", "assertion_subject_candidates": ["JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "double com.google.javascript.jscomp.Compiler#getProgress()", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()"], "focal_class": {"name": "Compiler", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "superclass": "extends AbstractCompiler", "interface": "", "imports": ["import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.Charsets;", "import com.google.common.base.Preconditions;", "import com.google.common.base.Supplier;", "import com.google.common.base.Throwables;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.common.io.CharStreams;", "import com.google.javascript.jscomp.CompilerOptions.DevMode;", "import com.google.javascript.jscomp.CompilerOptions.LanguageMode;", "import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;", "import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;", "import com.google.javascript.jscomp.parsing.Config;", "import com.google.javascript.jscomp.parsing.ParserRunner;", "import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;", "import com.google.javascript.rhino.IR;", "import com.google.javascript.rhino.InputId;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import com.google.javascript.rhino.head.ErrorReporter;", "import com.google.javascript.rhino.jstype.JSTypeRegistry;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.PrintStream;", "import java.io.Serializable;", "import java.nio.charset.Charset;", "import java.util.Collections;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;", "import java.util.concurrent.Callable;", "import java.util.logging.Level;", "import java.util.logging.Logger;", "import java.util.regex.Matcher;"], "fields": ["static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions options = null", "private PassConfig passes = null", "private List<CompilerInput> externs", "private List<JSModule> modules", "private JSModuleGraph moduleGraph", "private List<CompilerInput> inputs", "private ErrorManager errorManager", "private WarningsGuard warningsGuard", "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node externsRoot", "Node jsRoot", "Node externAndJsRoot", "private Map<InputId, CompilerInput> inputsById", "private SourceMap sourceMap", "private String externExports = null", "private int uniqueNameId = 0", "private boolean useThreads = true", "private boolean hasRegExpGlobalReferences = true", "private FunctionInformationMap functionInformationMap", "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "private JSTypeRegistry typeRegistry", "private Config parserConfig = null", "private ReverseAbstractInterpreter abstractInterpreter", "private TypeValidator typeValidator", "public PerformanceTracker tracker", "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "private static final long COMPILER_STACK_SIZE = 1048576L", "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "private final PrintStream outStream", "private GlobalVarReferenceMap globalRefMap = null", "private volatile double progress = 0.0", "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "private Tracer currentTracer = null", "private String currentPassName = null", "private int syntheticCodeId = 0", "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "private CompilerInput synthesizedExternsInput = null"], "methods": ["void com.google.javascript.jscomp.Compiler#setErrorManager(ErrorManager#errorManager)", "MessageFormatter com.google.javascript.jscomp.Compiler#createMessageFormatter()", "void com.google.javascript.jscomp.Compiler#initOptions(CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initBasedOnOptions()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#makeCompilerInput(List<T>#files,boolean#isExtern)", "void com.google.javascript.jscomp.Compiler#checkFirstModule(List<JSModule>#modules)", "String com.google.javascript.jscomp.Compiler#createFillFileName(String#moduleName)", "void com.google.javascript.jscomp.Compiler#fillEmptyModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#rebuildInputsFromModules()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getAllInputsFromModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#initInputsByIdMap()", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,SourceFile#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,JSSourceFile[]#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile#extern,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compileModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile()", "void com.google.javascript.jscomp.Compiler#disableThreads()", "T com.google.javascript.jscomp.Compiler#runInCompilerThread(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallableWithLargeStack(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallable(Callable<T>#callable,boolean#useLargeStackThread,boolean#trace)", "void com.google.javascript.jscomp.Compiler#compileInternal()", "void com.google.javascript.jscomp.Compiler#parse()", "PassConfig com.google.javascript.jscomp.Compiler#getPassConfig()", "PassConfig com.google.javascript.jscomp.Compiler#createPassConfigInternal()", "void com.google.javascript.jscomp.Compiler#setPassConfig(PassConfig#passes)", "boolean com.google.javascript.jscomp.Compiler#precheck()", "void com.google.javascript.jscomp.Compiler#check()", "void com.google.javascript.jscomp.Compiler#externExports()", "void com.google.javascript.jscomp.Compiler#process(CompilerPass#p)", "void com.google.javascript.jscomp.Compiler#maybeSanityCheck()", "void com.google.javascript.jscomp.Compiler#runSanityCheck()", "void com.google.javascript.jscomp.Compiler#removeTryCatchFinally()", "void com.google.javascript.jscomp.Compiler#stripCode(Set<String>#stripTypes,Set<String>#stripNameSuffixes,Set<String>#stripTypePrefixes,Set<String>#stripNamePrefixes)", "void com.google.javascript.jscomp.Compiler#runCustomPasses(CustomPassExecutionTime#executionTime)", "void com.google.javascript.jscomp.Compiler#startPass(String#passName)", "void com.google.javascript.jscomp.Compiler#endPass()", "Tracer com.google.javascript.jscomp.Compiler#newTracer(String#passName)", "void com.google.javascript.jscomp.Compiler#stopTracer(Tracer#t,String#passName)", "Result com.google.javascript.jscomp.Compiler#getResult()", "JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "int com.google.javascript.jscomp.Compiler#nextUniqueNameId()", "void com.google.javascript.jscomp.Compiler#resetUniqueNameId()", "Supplier<String> com.google.javascript.jscomp.Compiler#getUniqueNameIdSupplier()", "boolean com.google.javascript.jscomp.Compiler#areNodesEqualForInlining(Node#n1,Node#n2)", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "void com.google.javascript.jscomp.Compiler#removeExternInput(InputId#id)", "CompilerInput com.google.javascript.jscomp.Compiler#newExternInput(String#name)", "CompilerInput com.google.javascript.jscomp.Compiler#putCompilerInput(InputId#id,CompilerInput#input)", "void com.google.javascript.jscomp.Compiler#addIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#replaceIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#addNewSourceAst(JsAst#ast)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "JSTypeRegistry com.google.javascript.jscomp.Compiler#getTypeRegistry()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "DefaultPassConfig com.google.javascript.jscomp.Compiler#ensureDefaultPassConfig()", "SymbolTable com.google.javascript.jscomp.Compiler#buildKnownSymbolTable()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ReverseAbstractInterpreter com.google.javascript.jscomp.Compiler#getReverseAbstractInterpreter()", "TypeValidator com.google.javascript.jscomp.Compiler#getTypeValidator()", "Node com.google.javascript.jscomp.Compiler#parseInputs()", "void com.google.javascript.jscomp.Compiler#processAMDAndCommonJSModules()", "Node com.google.javascript.jscomp.Compiler#parse(SourceFile#file)", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#js)", "CompilerOptions com.google.javascript.jscomp.Compiler#newCompilerOptions()", "void com.google.javascript.jscomp.Compiler#initCompilerOptionsIfTesting()", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#fileName,String#js)", "Node com.google.javascript.jscomp.Compiler#parseTestCode(String#js)", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "String com.google.javascript.jscomp.Compiler#toSource()", "String[] com.google.javascript.jscomp.Compiler#toSourceArray()", "String com.google.javascript.jscomp.Compiler#toSource(JSModule#module)", "String[] com.google.javascript.jscomp.Compiler#toSourceArray(JSModule#module)", "void com.google.javascript.jscomp.Compiler#toSource(CodeBuilder#cb,int#inputSeqNum,Node#root)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n,SourceMap#sourceMap,boolean#firstOutput)", "void com.google.javascript.jscomp.Compiler#optimize()", "void com.google.javascript.jscomp.Compiler#setCssRenamingMap(CssRenamingMap#map)", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "void com.google.javascript.jscomp.Compiler#processDefines()", "boolean com.google.javascript.jscomp.Compiler#isInliningForbidden()", "ControlFlowGraph<Node> com.google.javascript.jscomp.Compiler#computeCFG()", "void com.google.javascript.jscomp.Compiler#normalize()", "void com.google.javascript.jscomp.Compiler#prepareAst(Node#root)", "void com.google.javascript.jscomp.Compiler#recordFunctionInformation()", "void com.google.javascript.jscomp.Compiler#addChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#removeChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#reportCodeChange()", "CodingConvention com.google.javascript.jscomp.Compiler#getCodingConvention()", "boolean com.google.javascript.jscomp.Compiler#isIdeMode()", "boolean com.google.javascript.jscomp.Compiler#acceptEcmaScript5()", "LanguageMode com.google.javascript.jscomp.Compiler#languageMode()", "boolean com.google.javascript.jscomp.Compiler#acceptConstKeyword()", "Config com.google.javascript.jscomp.Compiler#getParserConfig()", "boolean com.google.javascript.jscomp.Compiler#isTypeCheckingEnabled()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "void com.google.javascript.jscomp.Compiler#report(JSError#error)", "CheckLevel com.google.javascript.jscomp.Compiler#getErrorLevel(JSError#error)", "void com.google.javascript.jscomp.Compiler#throwInternalError(String#message,Exception#cause)", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "boolean com.google.javascript.jscomp.Compiler#hasHaltingErrors()", "boolean com.google.javascript.jscomp.Compiler#hasErrors()", "void com.google.javascript.jscomp.Compiler#addToDebugLog(String#str)", "SourceFile com.google.javascript.jscomp.Compiler#getSourceFileByName(String#sourceName)", "String com.google.javascript.jscomp.Compiler#getSourceLine(String#sourceName,int#lineNumber)", "Region com.google.javascript.jscomp.Compiler#getSourceRegion(String#sourceName,int#lineNumber)", "Node com.google.javascript.jscomp.Compiler#getNodeForCodeInsertion(JSModule#module)", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "void com.google.javascript.jscomp.Compiler#setLoggingLevel(Level#level)", "String com.google.javascript.jscomp.Compiler#getAstDotGraph()", "ErrorManager com.google.javascript.jscomp.Compiler#getErrorManager()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "IntermediateState com.google.javascript.jscomp.Compiler#getState()", "void com.google.javascript.jscomp.Compiler#setState(IntermediateState#state)", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "boolean com.google.javascript.jscomp.Compiler#hasRegExpGlobalReferences()", "void com.google.javascript.jscomp.Compiler#setHasRegExpGlobalReferences(boolean#references)", "void com.google.javascript.jscomp.Compiler#updateGlobalVarReferences(Map<Var, ReferenceCollection>#refMapPatch,Node#collectionRoot)", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "CompilerInput com.google.javascript.jscomp.Compiler#getSynthesizedExternsInput()", "double com.google.javascript.jscomp.Compiler#getProgress()", "void com.google.javascript.jscomp.Compiler#setProgress(double#newProgress)", "void com.google.javascript.jscomp.Compiler#replaceScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#addNewScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#processNewScript(JsAst#ast,Node#originalRoot)", "void com.google.javascript.jscomp.Compiler#runHotSwap(Node#originalRoot,Node#js,PassConfig#passConfig)", "void com.google.javascript.jscomp.Compiler#runHotSwapPass(Node#originalRoot,Node#js,PassFactory#passFactory)", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()", "void com.google.javascript.jscomp.Compiler#removeSyntheticVarsInput()", "Node com.google.javascript.jscomp.Compiler#ensureLibraryInjected(String#resourceName)", "Node com.google.javascript.jscomp.Compiler#loadLibraryCode(String#resourceName)"], "other_methods": ["public void setErrorManager(ErrorManager errorManager);", "public void initOptions(CompilerOptions options);", "public void init(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public void init(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public void init(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public void initModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void rebuildInputsFromModules();", "public Result compile(SourceFile extern,SourceFile input,CompilerOptions options);", "public Result compile(SourceFile extern,JSSourceFile[] input,CompilerOptions options);", "public Result compile(JSSourceFile extern,JSModule[] modules,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public Result compile(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public Result compileModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void disableThreads();", "public void parse();", "public void setPassConfig(PassConfig passes);", "public void check();", "public Result getResult();", "public JSError[] getMessages();", "public JSError[] getErrors();", "public JSError[] getWarnings();", "@Override\n  public Node getRoot();", "@Override\n  public CompilerInput getInput(InputId id);", "@Override\n  public CompilerInput newExternInput(String name);", "@Override\n  public JSTypeRegistry getTypeRegistry();", "@Override\n  public MemoizedScopeCreator getTypedScopeCreator();", "public SymbolTable buildKnownSymbolTable();", "@Override\n  public Scope getTopScope();", "@Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter();", "public Node parse(SourceFile file);", "public String toSource();", "public String[] toSourceArray();", "public String toSource(JSModule module);", "public String[] toSourceArray(JSModule module);", "public void toSource(CodeBuilder cb,int inputSeqNum,Node root);", "public void optimize();", "public void processDefines();", "public void normalize();", "@Override\n  public void reportCodeChange();", "@Override\n  public CodingConvention getCodingConvention();", "@Override\n  public boolean isIdeMode();", "@Override\n  public boolean acceptEcmaScript5();", "public LanguageMode languageMode();", "@Override\n  public boolean acceptConstKeyword();", "@Override\n  public boolean isTypeCheckingEnabled();", "@Override\n  public void report(JSError error);", "@Override\n  public CheckLevel getErrorLevel(JSError error);", "public int getErrorCount();", "public int getWarningCount();", "public boolean hasErrors();", "@Override\n  public String getSourceLine(String sourceName,int lineNumber);", "@Override\n  public Region getSourceRegion(String sourceName,int lineNumber);", "public SourceMap getSourceMap();", "public static void setLoggingLevel(Level level);", "public String getAstDotGraph();", "@Override\n  public ErrorManager getErrorManager();", "public Map<InputId, CompilerInput> getInputsById();", "public IntermediateState getState();", "public void setState(IntermediateState state);", "@Override\n  public double getProgress();", "public void replaceScript(JsAst ast);", "public void addNewScript(JsAst ast);"], "fields_dict": {"String#SINGLETON_MODULE_NAME": "static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "DiagnosticType#MODULE_DEPENDENCY_ERROR": "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "DiagnosticType#MISSING_ENTRY_ERROR": "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions#options": "CompilerOptions options = null", "PassConfig#passes": "private PassConfig passes = null", "List<CompilerInput>#externs": "private List<CompilerInput> externs", "List<JSModule>#modules": "private List<JSModule> modules", "JSModuleGraph#moduleGraph": "private JSModuleGraph moduleGraph", "List<CompilerInput>#inputs": "private List<CompilerInput> inputs", "ErrorManager#errorManager": "private ErrorManager errorManager", "WarningsGuard#warningsGuard": "private WarningsGuard warningsGuard", "Map<String, Node>#injectedLibraries": "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node#externsRoot": "Node externsRoot", "Node#jsRoot": "Node jsRoot", "Node#externAndJsRoot": "Node externAndJsRoot", "Map<InputId, CompilerInput>#inputsById": "private Map<InputId, CompilerInput> inputsById", "SourceMap#sourceMap": "private SourceMap sourceMap", "String#externExports": "private String externExports = null", "int#uniqueNameId": "private int uniqueNameId = 0", "boolean#useThreads": "private boolean useThreads = true", "boolean#hasRegExpGlobalReferences": "private boolean hasRegExpGlobalReferences = true", "FunctionInformationMap#functionInformationMap": "private FunctionInformationMap functionInformationMap", "StringBuilder#debugLog": "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention#defaultCodingConvention": "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "JSTypeRegistry#typeRegistry": "private JSTypeRegistry typeRegistry", "Config#parserConfig": "private Config parserConfig = null", "ReverseAbstractInterpreter#abstractInterpreter": "private ReverseAbstractInterpreter abstractInterpreter", "TypeValidator#typeValidator": "private TypeValidator typeValidator", "PerformanceTracker#tracker": "public PerformanceTracker tracker", "com.google.javascript.rhino.ErrorReporter#oldErrorReporter": "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "ErrorReporter#defaultErrorReporter": "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "DiagnosticType#OPTIMIZE_LOOP_ERROR": "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "DiagnosticType#MOTION_ITERATIONS_ERROR": "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "long#COMPILER_STACK_SIZE": "private static final long COMPILER_STACK_SIZE = 1048576L", "Logger#logger": "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "PrintStream#outStream": "private final PrintStream outStream", "GlobalVarReferenceMap#globalRefMap": "private GlobalVarReferenceMap globalRefMap = null", "double#progress": "private volatile double progress = 0.0", "DiagnosticType#EMPTY_MODULE_LIST_ERROR": "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "DiagnosticType#EMPTY_ROOT_MODULE_ERROR": "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "DiagnosticType#DUPLICATE_INPUT": "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "DiagnosticType#DUPLICATE_EXTERN_INPUT": "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "PassFactory#sanityCheck": "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "Tracer#currentTracer": "private Tracer currentTracer = null", "String#currentPassName": "private String currentPassName = null", "int#syntheticCodeId": "private int syntheticCodeId = 0", "CodeChangeHandler.RecentChange#recentChange": "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "List<CodeChangeHandler>#codeChangeHandlers": "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "String#SYNTHETIC_EXTERNS": "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "CompilerInput#synthesizedExternsInput": "private CompilerInput synthesizedExternsInput = null"}, "text": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Charsets;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.io.CharStreams;\nimport com.google.javascript.jscomp.CompilerOptions.DevMode;\nimport com.google.javascript.jscomp.CompilerOptions.LanguageMode;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\nimport com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\nimport com.google.javascript.jscomp.parsing.Config;\nimport com.google.javascript.jscomp.parsing.ParserRunner;\nimport com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.head.ErrorReporter;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\n\n/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  static final String SINGLETON_MODULE_NAME = \"[singleton]\";\n\n  static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\");\n\n  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\");\n\n  CompilerOptions options = null;\n\n  private PassConfig passes = null;\n\n  // The externs inputs\n  private List<CompilerInput> externs;\n\n  // The JS source modules\n  private List<JSModule> modules;\n\n  // The graph of the JS source modules. Must be null if there are less than\n  // 2 modules, because we use this as a signal for which passes to run.\n  private JSModuleGraph moduleGraph;\n\n  // The JS source inputs\n  private List<CompilerInput> inputs;\n\n  // error manager to which error management is delegated\n  private ErrorManager errorManager;\n\n  // Warnings guard for filtering warnings.\n  private WarningsGuard warningsGuard;\n\n  // Compile-time injected libraries. The node points to the last node of\n  // the library, so code can be inserted after.\n  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n\n  // Parse tree root nodes\n  Node externsRoot;\n  Node jsRoot;\n  Node externAndJsRoot;\n\n  private Map<InputId, CompilerInput> inputsById;\n\n  /** The source code map */\n  private SourceMap sourceMap;\n\n  /** The externs created from the exports.  */\n  private String externExports = null;\n\n  /**\n   * Ids for function inlining so that each declared name remains\n   * unique.\n   */\n  private int uniqueNameId = 0;\n\n  /** Whether to use threads. */\n  private boolean useThreads = true;\n\n  /**\n   * Whether to assume there are references to the RegExp Global object\n   * properties.\n   */\n  private boolean hasRegExpGlobalReferences = true;\n\n  /** The function information map */\n  private FunctionInformationMap functionInformationMap;\n\n  /** Debugging information */\n  private final StringBuilder debugLog = new StringBuilder();\n\n  /** Detects Google-specific coding conventions. */\n  CodingConvention defaultCodingConvention = new ClosureCodingConvention();\n\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n\n  public PerformanceTracker tracker;\n\n  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.\n  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =\n      RhinoErrorReporter.forOldRhino(this);\n\n  // This error reporter gets the messages from the current Rhino parser.\n  private final ErrorReporter defaultErrorReporter =\n      RhinoErrorReporter.forNewRhino(this);\n\n  /** Error strings used for reporting JSErrors */\n  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\");\n  public static final DiagnosticType MOTION_ITERATIONS_ERROR =\n      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\");\n\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n\n\n  /**\n   * Logger for the whole com.google.javascript.jscomp domain -\n   * setting configuration for this logger affects all loggers\n   *  in other classes within the compiler.\n   */\n  private static final Logger logger =\n      Logger.getLogger(\"com.google.javascript.jscomp\");\n\n  private final PrintStream outStream;\n\n  private GlobalVarReferenceMap globalRefMap = null;\n\n  private volatile double progress = 0.0;\n\n  /**\n   * Creates a Compiler that reports errors and warnings to its logger.\n   */\n  public Compiler() {\n    this((PrintStream) null);\n  }\n\n  /**\n   * Creates n Compiler that reports errors and warnings to an output\n   * stream.\n   */\n  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }\n\n  /**\n   * Creates a Compiler that uses a custom error manager.\n   */\n  public Compiler(ErrorManager errorManager) {\n    this();\n    setErrorManager(errorManager);\n  }\n\n  /**\n   * Sets the error manager.\n   *\n   * @param errorManager the error manager, it cannot be {@code null}\n   */\n  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }\n\n  /**\n   * Creates a message formatter instance corresponding to the value of\n   * {@link CompilerOptions}.\n   */\n  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }\n\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    init(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n    for (SourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options) {\n    initModules(Lists.<SourceFile>newArrayList(externs),\n         Lists.<JSModule>newArrayList(modules), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }\n\n  /**\n   * Do any initialization that is dependent on the compiler options.\n   */\n  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }\n\n  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n      List<T> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (T file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }\n\n  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\");\n\n  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\");\n\n  /**\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   */\n  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }\n\n  /**\n   * Empty modules get an empty \"fill\" file, so that we can move code into\n   * an empty module.\n   */\n  static String createFillFileName(String moduleName) {\n    return \"[\" + moduleName + \"]\";\n  }\n\n  /**\n   * Fill any empty modules with a place holder file. It makes any cross module\n   * motion easier.\n   */\n  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(SourceFile.fromCode(\n            createFillFileName(module.getName()), \"\"));\n      }\n    }\n  }\n\n  /**\n   * Rebuilds the internal list of inputs by iterating over all modules.\n   * This is necessary if inputs have been added to or removed from a module\n   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n   */\n  public void rebuildInputsFromModules() {\n    inputs = getAllInputsFromModules(modules);\n    initInputsByIdMap();\n  }\n\n  /**\n   * Builds a single list of all module inputs. Verifies that it contains no\n   * duplicates.\n   */\n  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }\n\n  static final DiagnosticType DUPLICATE_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");\n  static final DiagnosticType DUPLICATE_EXTERN_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\");\n\n  /**\n   * Creates a map to make looking up an input by name fast. Also checks for\n   * duplicate inputs.\n   */\n  void initInputsByIdMap() {\n    inputsById = new HashMap<InputId, CompilerInput>();\n    for (CompilerInput input : externs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n      }\n    }\n  }\n\n  public Result compile(\n      SourceFile extern, SourceFile input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      SourceFile extern, JSSourceFile[] input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {\n     return compileModules(\n         Lists.newArrayList(extern), Lists.newArrayList(modules), options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options) {\n    return compile(Lists.<SourceFile>newArrayList(externs),\n        Lists.<SourceFile>newArrayList(inputs),\n        options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n      List<T1> externs, List<T2> inputs, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, inputs, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options) {\n    return compileModules(Lists.<SourceFile>newArrayList(externs),\n        Lists.<JSModule>newArrayList(modules),\n        options);\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public <T extends SourceFile> Result compileModules(List<T> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      @Override\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }\n\n  /**\n   * Disable threads. This is for clients that run on AppEngine and\n   * don't have threads.\n   */\n  public void disableThreads() {\n    useThreads = false;\n  }\n\n  private <T> T runInCompilerThread(final Callable<T> callable) {\n    return runCallable(callable, useThreads, options.tracer.isOn());\n  }\n\n  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n    return runCallable(callable, true, false);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n\n    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n    // large or complex js code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = trace;\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useLargeStackThread) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }\n\n  private void compileInternal() {\n    setProgress(0.0);\n    parse();\n    // 15 percent of the work is assumed to be for parsing (based on some\n    // minimal analysis on big JS projects, of course this depends on options)\n    setProgress(0.15);\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n    setProgress(1.0);\n  }\n\n  public void parse() {\n    parseInputs();\n  }\n\n  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }\n\n  /**\n   * Create the passes object. Clients should use setPassConfig instead of\n   * overriding this.\n   */\n  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }\n\n  /**\n   * @param passes The PassConfig to use with this Compiler.\n   * @throws NullPointerException if passes is null\n   * @throws IllegalStateException if this.passes has already been assigned\n   */\n  public void setPassConfig(PassConfig passes) {\n    // Important to check for null because if setPassConfig(null) is\n    // called before this.passes is set, getPassConfig() will create a\n    // new PassConfig object and use that, which is probably not what\n    // the client wanted since he or she probably meant to use their\n    // own PassConfig object.\n    Preconditions.checkNotNull(passes);\n\n    if (this.passes != null) {\n      throw new IllegalStateException(\"this.passes has already been assigned\");\n    }\n    this.passes = passes;\n  }\n\n  /**\n   * Carry out any special checks or procedures that need to be done before\n   * proceeding with rest of the compilation process.\n   *\n   * @return true, to continue with compilation\n   */\n  boolean precheck() {\n    return true;\n  }\n\n  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    // We are currently only interested in check-passes for progress reporting\n    // as it is used for IDEs, that's why the maximum progress is set to 1.0.\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,\n        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }\n\n  private void externExports() {\n    logger.fine(\"Creating extern file for exports\");\n    startPass(\"externExports\");\n\n    ExternExportsPass pass = new ExternExportsPass(this);\n    process(pass);\n\n    externExports = pass.getGeneratedExterns();\n\n    endPass();\n  }\n\n  @Override\n  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }\n\n  private final PassFactory sanityCheck =\n      new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  };\n\n  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }\n\n  private void runSanityCheck() {\n    sanityCheck.create(this).process(externsRoot, jsRoot);\n  }\n\n  /**\n   * Removes try/catch/finally statements for easier debugging.\n   */\n  void removeTryCatchFinally() {\n    logger.fine(\"Remove try/catch/finally\");\n    startPass(\"removeTryCatchFinally\");\n    RemoveTryCatch r = new RemoveTryCatch(this);\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Strips code for smaller compiled code. This is useful for removing debug\n   * statements to prevent leaking them publicly.\n   */\n  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n    logger.fine(\"Strip code\");\n    startPass(\"stripCode\");\n    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n        stripTypePrefixes, stripNamePrefixes);\n    if (options.getTweakProcessing().shouldStrip()) {\n      r.enableTweakStripping();\n    }\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Runs custom passes that are designated to run at a particular time.\n   */\n  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }\n\n  private Tracer currentTracer = null;\n  private String currentPassName = null;\n\n  /**\n   * Marks the beginning of a pass.\n   */\n  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }\n\n  /**\n   * Marks the end of a pass.\n   */\n  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }\n\n  /**\n   * Returns a new tracer for the given pass name.\n   */\n  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }\n\n  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }\n\n  /**\n   * Returns the result of the compilation.\n   */\n  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }\n\n  /**\n   * Returns an array constructed from errors + temporary warnings.\n   */\n  public JSError[] getMessages() {\n    return getErrors();\n  }\n\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }\n\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }\n\n  @Override\n  public Node getRoot() {\n    return externAndJsRoot;\n  }\n\n  /**\n   * Creates a new id for making unique names.\n   */\n  private int nextUniqueNameId() {\n    return uniqueNameId++;\n  }\n\n  /**\n   * Resets the unique name id counter\n   */\n  @VisibleForTesting\n  void resetUniqueNameId() {\n    uniqueNameId = 0;\n  }\n\n  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      @Override\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }\n\n  @Override\n  boolean areNodesEqualForInlining(Node n1, Node n2) {\n    if (options.ambiguateProperties ||\n        options.disambiguateProperties) {\n      // The type based optimizations require that type information is preserved\n      // during other optimizations.\n      return n1.isEquivalentToTyped(n2);\n    } else {\n      return n1.isEquivalentTo(n2);\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Inputs\n  //------------------------------------------------------------------------\n\n  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler\n  // interface, and which ones should always be injected.\n\n  @Override\n  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }\n\n  /**\n   * Removes an input file from AST.\n   * @param id The id of the input to be removed.\n   */\n  protected void removeExternInput(InputId id) {\n    CompilerInput input = getInput(id);\n    if (input == null) {\n      return;\n    }\n    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());\n    inputsById.remove(id);\n    externs.remove(input);\n    Node root = input.getAstRoot(this);\n    if (root != null) {\n      root.detachFromParent();\n    }\n  }\n\n  @Override\n  public CompilerInput newExternInput(String name) {\n    SourceAst ast = new SyntheticAst(name);\n    if (inputsById.containsKey(ast.getInputId())) {\n      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n    }\n    CompilerInput input = new CompilerInput(ast, true);\n    putCompilerInput(input.getInputId(), input);\n    externsRoot.addChildToFront(ast.getAstRoot(this));\n    externs.add(0, input);\n    return input;\n  }\n\n  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }\n\n  /** Add a source input dynamically. Intended for incremental compilation. */\n  void addIncrementalSourceAst(JsAst ast) {\n    InputId id = ast.getInputId();\n    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());\n    putCompilerInput(id, new CompilerInput(ast));\n  }\n\n  /**\n   * Replace a source input dynamically. Intended for incremental\n   * re-compilation.\n   *\n   * If the new source input doesn't parse, then keep the old input\n   * in the AST and return false.\n   *\n   * @return Whether the new AST was attached successfully.\n   */\n  boolean replaceIncrementalSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    Node oldRoot = oldInput.getAstRoot(this);\n    if (oldRoot != null) {\n      oldRoot.getParent().replaceChild(oldRoot, newRoot);\n    } else {\n      getRoot().getLastChild().addChildToBack(newRoot);\n    }\n\n    CompilerInput newInput = new CompilerInput(ast);\n    putCompilerInput(ast.getInputId(), newInput);\n\n    JSModule module = oldInput.getModule();\n    if (module != null) {\n      module.addAfter(newInput, oldInput);\n      module.remove(oldInput);\n    }\n\n    // Verify the input id is set properly.\n    Preconditions.checkState(\n        newInput.getInputId().equals(oldInput.getInputId()));\n    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();\n    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));\n\n    inputs.remove(oldInput);\n    return true;\n  }\n\n  /**\n   * Add a new source input dynamically. Intended for incremental compilation.\n   * <p>\n   * If the new source input doesn't parse, it will not be added, and a false\n   * will be returned.\n   *\n   * @param ast the JS Source to add.\n   * @return true if the source was added successfully, false otherwise.\n   * @throws IllegalStateException if an input for this ast already exists.\n   */\n  boolean addNewSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    if (oldInput != null) {\n      throw new IllegalStateException(\n          \"Input already exists: \" + ast.getInputId().getIdName());\n    }\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    getRoot().getLastChild().addChildToBack(newRoot);\n\n    CompilerInput newInput = new CompilerInput(ast);\n\n    // TODO(tylerg): handle this for multiple modules at some point.\n    if (moduleGraph == null && !modules.isEmpty()) {\n      // singleton module\n      modules.get(0).add(newInput);\n    }\n\n    putCompilerInput(ast.getInputId(), newInput);\n\n    return true;\n  }\n\n  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }\n\n  /**\n   * Gets a module graph. This will always return a module graph, even\n   * in the degenerate case when there's only one module.\n   */\n  JSModuleGraph getDegenerateModuleGraph() {\n    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;\n  }\n\n  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }\n\n  @Override\n  public MemoizedScopeCreator getTypedScopeCreator() {\n    return getPassConfig().getTypedScopeCreator();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  DefaultPassConfig ensureDefaultPassConfig() {\n    PassConfig passes = getPassConfig().getBasePassConfig();\n    Preconditions.checkState(passes instanceof DefaultPassConfig,\n        \"PassConfigs must eventually delegate to the DefaultPassConfig\");\n    return (DefaultPassConfig) passes;\n  }\n\n  public SymbolTable buildKnownSymbolTable() {\n    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());\n\n    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();\n    if (typedScopeCreator != null) {\n      symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());\n      symbolTable.addSymbolsFrom(typedScopeCreator);\n    } else {\n      symbolTable.findScopes(this, externsRoot, jsRoot);\n    }\n\n    GlobalNamespace globalNamespace =\n        ensureDefaultPassConfig().getGlobalNamespace();\n    if (globalNamespace != null) {\n      symbolTable.addSymbolsFrom(globalNamespace);\n    }\n\n    ReferenceCollectingCallback refCollector =\n        new ReferenceCollectingCallback(\n            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n    NodeTraversal.traverse(this, getRoot(), refCollector);\n    symbolTable.addSymbolsFrom(refCollector);\n\n    PreprocessorSymbolTable preprocessorSymbolTable =\n        ensureDefaultPassConfig().getPreprocessorSymbolTable();\n    if (preprocessorSymbolTable != null) {\n      symbolTable.addSymbolsFrom(preprocessorSymbolTable);\n    }\n\n    symbolTable.fillNamespaceReferences();\n    symbolTable.fillPropertyScopes();\n    symbolTable.fillThisReferences(this, externsRoot, jsRoot);\n    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);\n\n    return symbolTable;\n  }\n\n  @Override\n  public Scope getTopScope() {\n    return getPassConfig().getTopScope();\n  }\n\n  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }\n\n  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }\n\n  //------------------------------------------------------------------------\n  // Parsing\n  //------------------------------------------------------------------------\n\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n\n  /**\n   * Transforms AMD and CJS modules to something closure compiler can\n   * process and creates JSModules and the corresponding dependency tree\n   * on the way.\n   */\n  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n      if (!modules.isEmpty()) {\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }\n\n  public Node parse(SourceFile file) {\n    initCompilerOptionsIfTesting();\n    addToDebugLog(\"Parsing: \" + file.getName());\n    return new JsAst(file).getAstRoot(this);\n  }\n\n  private int syntheticCodeId = 0;\n\n  @Override\n  Node parseSyntheticCode(String js) {\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  /**\n   * Allow subclasses to override the default CompileOptions object.\n   */\n  protected CompilerOptions newCompilerOptions() {\n    return new CompilerOptions();\n  }\n\n  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(newCompilerOptions());\n    }\n  }\n\n  @Override\n  Node parseSyntheticCode(String fileName, String js) {\n    initCompilerOptionsIfTesting();\n    return parse(SourceFile.fromCode(fileName, js));\n  }\n\n  @Override\n  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\"[testcode]\", js));\n    if (inputsById == null) {\n      inputsById = Maps.newHashMap();\n    }\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }\n\n  //------------------------------------------------------------------------\n  // Convert back to source code\n  //------------------------------------------------------------------------\n\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource() {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for each input back to js code.\n   */\n  public String[] toSourceArray() {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        Tracer tracer = newTracer(\"toSourceArray\");\n        try {\n          int numInputs = inputs.size();\n          String[] sources = new String[numInputs];\n          CodeBuilder cb = new CodeBuilder();\n          for (int i = 0; i < numInputs; i++) {\n            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n            cb.reset();\n            toSource(cb, i, scriptNode);\n            sources[i] = cb.toString();\n          }\n          return sources;\n        } finally {\n          stopTracer(tracer, \"toSourceArray\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module) {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return \"\";\n        }\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module: \" + module.getName());\n          }\n          toSource(cb, i, scriptNode);\n        }\n        return cb.toString();\n      }\n    });\n  }\n\n\n  /**\n   * Converts the parse tree for each input in a module back to js code.\n   */\n  public String[] toSourceArray(final JSModule module) {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return new String[0];\n        }\n\n        String[] sources = new String[numInputs];\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module input: \" + inputs.get(i).getName());\n          }\n\n          cb.reset();\n          toSource(cb, i, scriptNode);\n          sources[i] = cb.toString();\n        }\n        return sources;\n      }\n    });\n  }\n\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n      @Override\n      public Void call() throws Exception {\n        if (options.printInputDelimiter) {\n          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            cb.append(\"\\n\");  // Make sure that the label starts on a new line\n          }\n          Preconditions.checkState(root.isScript());\n\n          String delimiter = options.inputDelimiter;\n\n          String inputName = root.getInputId().getIdName();\n          String sourceName = root.getSourceFileName();\n          Preconditions.checkState(sourceName != null);\n          Preconditions.checkState(!sourceName.isEmpty());\n\n          delimiter = delimiter\n              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))\n              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n          cb.append(delimiter)\n            .append(\"\\n\");\n        }\n        if (root.getJSDocInfo() != null &&\n            root.getJSDocInfo().getLicense() != null) {\n          cb.append(\"/*\\n\")\n            .append(root.getJSDocInfo().getLicense())\n            .append(\"*/\\n\");\n        }\n\n        // If there is a valid source map, then indicate to it that the current\n        // root node's mappings are offset by the given string builder buffer.\n        if (options.sourceMapOutputPath != null) {\n          sourceMap.setStartingPosition(\n              cb.getLineIndex(), cb.getColumnIndex());\n        }\n\n        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n        // for the first input file\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n        if (!code.isEmpty()) {\n          cb.append(code);\n\n          // In order to avoid parse ambiguity when files are concatenated\n          // together, all files should end in a semi-colon. Do a quick\n          // heuristic check if there's an obvious semi-colon already there.\n          int length = code.length();\n          char lastChar = code.charAt(length - 1);\n          char secondLastChar = length >= 2 ?\n              code.charAt(length - 2) : '\\0';\n          boolean hasSemiColon = lastChar == ';' ||\n              (lastChar == '\\n' && secondLastChar == ';');\n          if (!hasSemiColon) {\n            cb.append(\";\");\n          }\n        }\n        return null;\n      }\n    });\n  }\n\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n  }\n\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }\n\n  /**\n   * Stores a buffer of text to which more can be appended.  This is just like a\n   * StringBuilder except that we also track the number of lines.\n   */\n  public static class CodeBuilder {\n    private final StringBuilder sb = new StringBuilder();\n    private int lineCount = 0;\n    private int colCount = 0;\n\n    /** Removes all text, but leaves the line count unchanged. */\n    void reset() {\n      sb.setLength(0);\n    }\n\n    /** Appends the given string to the text buffer. */\n    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }\n\n    /** Returns all text in the text buffer. */\n    @Override\n    public String toString() {\n      return sb.toString();\n    }\n\n    /** Returns the length of the text buffer. */\n    public int getLength() {\n      return sb.length();\n    }\n\n    /** Returns the (zero-based) index of the last line in the text buffer. */\n    int getLineIndex() {\n      return lineCount;\n    }\n\n    /** Returns the (zero-based) index of the last column in the text buffer. */\n    int getColumnIndex() {\n      return colCount;\n    }\n\n    /** Determines whether the text ends with the given suffix. */\n    boolean endsWith(String suffix) {\n      return (sb.length() > suffix.length())\n          && suffix.equals(sb.substring(sb.length() - suffix.length()));\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Optimizations\n  //------------------------------------------------------------------------\n\n  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }\n\n  @Override\n  void setCssRenamingMap(CssRenamingMap map) {\n    options.cssRenamingMap = map;\n  }\n\n  @Override\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }\n\n  /**\n   * Reprocesses the current defines over the AST.  This is used by GwtCompiler\n   * to generate N outputs for different targets from the same (checked) AST.\n   * For each target, we apply the target-specific defines by calling\n   * {@code processDefines} and then {@code optimize} to optimize the AST\n   * specifically for that target.\n   */\n  public void processDefines() {\n    (new DefaultPassConfig(options)).processDefines.create(this)\n        .process(externsRoot, jsRoot);\n  }\n\n  boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }\n\n  /** Control Flow Analysis. */\n  ControlFlowGraph<Node> computeCFG() {\n    logger.fine(\"Computing Control Flow Graph\");\n    Tracer tracer = newTracer(\"computeCFG\");\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n    process(cfa);\n    stopTracer(tracer, \"computeCFG\");\n    return cfa.getCfg();\n  }\n\n  public void normalize() {\n    logger.fine(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }\n\n  @Override\n  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }\n\n  void recordFunctionInformation() {\n    logger.fine(\"Recording function information\");\n    startPass(\"recordFunctionInformation\");\n    RecordFunctionInformation recordFunctionInfoPass =\n        new RecordFunctionInformation(\n            this, getPassConfig().getIntermediateState().functionNames);\n    process(recordFunctionInfoPass);\n    functionInformationMap = recordFunctionInfoPass.getMap();\n    endPass();\n  }\n\n  protected final CodeChangeHandler.RecentChange recentChange =\n      new CodeChangeHandler.RecentChange();\n  private final List<CodeChangeHandler> codeChangeHandlers =\n      Lists.<CodeChangeHandler>newArrayList();\n\n  /** Name of the synthetic input that holds synthesized externs. */\n  static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\";\n\n  private CompilerInput synthesizedExternsInput = null;\n\n  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }\n\n  @Override\n  void removeChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.remove(handler);\n  }\n\n  /**\n   * All passes should call reportCodeChange() when they alter\n   * the JS tree structure. This is verified by CompilerTestCase.\n   * This allows us to optimize to a fixed point.\n   */\n  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }\n\n  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }\n\n  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }\n\n  @Override\n  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n    }\n    return false;\n  }\n\n  public LanguageMode languageMode() {\n    return options.getLanguageIn();\n  }\n\n  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }\n\n  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }\n\n  @Override\n  public boolean isTypeCheckingEnabled() {\n    return options.checkTypes;\n  }\n\n\n  //------------------------------------------------------------------------\n  // Error reporting\n  //------------------------------------------------------------------------\n\n  /**\n   * The warning classes that are available from the command-line, and\n   * are suppressable by the {@code @suppress} annotation.\n   */\n  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }\n\n  @Override\n  public void report(JSError error) {\n    CheckLevel level = error.getDefaultLevel();\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      if (getOptions().errorHandler != null) {\n        getOptions().errorHandler.report(level, error);\n      }\n      errorManager.report(level, error);\n    }\n  }\n\n  @Override\n  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }\n\n  /**\n   * Report an internal error.\n   */\n  @Override\n  void throwInternalError(String message, Exception cause) {\n    String finalMessage =\n      \"INTERNAL COMPILER ERROR.\\n\" +\n      \"Please report this problem.\\n\" + message;\n\n    RuntimeException e = new RuntimeException(finalMessage, cause);\n    if (cause != null) {\n      e.setStackTrace(cause.getStackTrace());\n    }\n    throw e;\n  }\n\n\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }\n\n  /**\n   * Gets the number of warnings.\n   */\n  public int getWarningCount() {\n    return errorManager.getWarningCount();\n  }\n\n  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }\n\n  /**\n   * Consults the {@link ErrorManager} to see if we've encountered errors\n   * that should halt compilation. <p>\n   *\n   * If {@link CompilerOptions#ideMode} is {@code true}, this function\n   * always returns {@code false} without consulting the error manager. The\n   * error manager will continue to be told about new errors and warnings, but\n   * the compiler will complete compilation of all inputs.<p>\n   */\n  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }\n\n  /** Called from the compiler passes, adds debug info */\n  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }\n\n  private SourceFile getSourceFileByName(String sourceName) {\n    // Here we assume that the source name is the input name, this\n    // is try of javascript parsed from source.\n    if (sourceName != null) {\n      CompilerInput input = inputsById.get(new InputId(sourceName));\n      if (input != null) {\n        return input.getSourceFile();\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }\n\n  @Override\n  public Region getSourceRegion(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getRegion(lineNumber);\n    }\n    return null;\n  }\n\n  //------------------------------------------------------------------------\n  // Package-private helpers\n  //------------------------------------------------------------------------\n\n  @Override\n  Node getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n      if (inputs.isEmpty()) {\n        throw new IllegalStateException(\"No inputs\");\n      }\n\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    List<CompilerInput> moduleInputs = module.getInputs();\n    if (moduleInputs.size() > 0) {\n      return moduleInputs.get(0).getAstRoot(this);\n    }\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }\n\n  public SourceMap getSourceMap() {\n    return sourceMap;\n  }\n\n  VariableMap getVariableMap() {\n    return getPassConfig().getIntermediateState().variableMap;\n  }\n\n  VariableMap getPropertyMap() {\n    return getPassConfig().getIntermediateState().propertyMap;\n  }\n\n  CompilerOptions getOptions() {\n    return options;\n  }\n\n  FunctionInformationMap getFunctionalInformationMap() {\n    return functionInformationMap;\n  }\n\n  /**\n   * Sets the logging level for the com.google.javascript.jscomp package.\n   */\n  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }\n\n  /** Gets the DOT graph of the AST generated at the end of compilation. */\n  public String getAstDotGraph() throws IOException {\n    if (jsRoot != null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n      cfa.process(null, jsRoot);\n      return DotFormatter.toDot(jsRoot, cfa.getCfg());\n    } else {\n      return \"\";\n    }\n  }\n\n  @Override\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(newCompilerOptions());\n    }\n    return errorManager;\n  }\n\n  @Override\n  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }\n\n  /**\n   * Returns an unmodifiable view of the compiler inputs indexed by id.\n   */\n  public Map<InputId, CompilerInput> getInputsById() {\n    return Collections.unmodifiableMap(inputsById);\n  }\n\n  /**\n   * Gets the externs in the order in which they are being processed.\n   */\n  List<CompilerInput> getExternsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(externs);\n  }\n\n  /**\n   * Stores the internal compiler state just before optimization is performed.\n   * This can be saved and restored in order to efficiently optimize multiple\n   * different output targets without having to perform checking multiple times.\n   *\n   * NOTE: This does not include all parts of the compiler's internal state. In\n   * particular, SourceFiles and CompilerOptions are not recorded. In\n   * order to recreate a Compiler instance from scratch, you would need to\n   * call {@code init} with the same arguments as in the initial creation before\n   * restoring intermediate state.\n   */\n  public static class IntermediateState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    Node externsRoot;\n    private Node jsRoot;\n    private List<CompilerInput> externs;\n    private List<CompilerInput> inputs;\n    private List<JSModule> modules;\n    private PassConfig.State passConfigState;\n    private JSTypeRegistry typeRegistry;\n    private AbstractCompiler.LifeCycleStage lifeCycleStage;\n    private Map<String, Node> injectedLibraries;\n\n    private IntermediateState() {}\n  }\n\n  /**\n   * Returns the current internal state, excluding the input files and modules.\n   */\n  public IntermediateState getState() {\n    IntermediateState state = new IntermediateState();\n    state.externsRoot = externsRoot;\n    state.jsRoot = jsRoot;\n    state.externs = externs;\n    state.inputs = inputs;\n    state.modules = modules;\n    state.passConfigState = getPassConfig().getIntermediateState();\n    state.typeRegistry = typeRegistry;\n    state.lifeCycleStage = getLifeCycleStage();\n    state.injectedLibraries = Maps.newLinkedHashMap(injectedLibraries);\n\n    return state;\n  }\n\n  /**\n   * Sets the internal state to the capture given.  Note that this assumes that\n   * the input files are already set up.\n   */\n  public void setState(IntermediateState state) {\n    externsRoot = state.externsRoot;\n    jsRoot = state.jsRoot;\n    externs = state.externs;\n    inputs = state.inputs;\n    modules = state.modules;\n    passes = createPassConfigInternal();\n    getPassConfig().setIntermediateState(state.passConfigState);\n    typeRegistry = state.typeRegistry;\n    setLifeCycleStage(state.lifeCycleStage);\n\n    injectedLibraries.clear();\n    injectedLibraries.putAll(state.injectedLibraries);\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getInputsForTesting() {\n    return inputs;\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getExternsForTesting() {\n    return externs;\n  }\n\n  @Override\n  boolean hasRegExpGlobalReferences() {\n    return hasRegExpGlobalReferences;\n  }\n\n  @Override\n  void setHasRegExpGlobalReferences(boolean references) {\n    hasRegExpGlobalReferences = references;\n  }\n\n  @Override\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.isScript()\n        || collectionRoot.isBlock());\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n          getExternsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }\n\n  @Override\n  GlobalVarReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }\n\n  @Override\n  CompilerInput getSynthesizedExternsInput() {\n    if (synthesizedExternsInput == null) {\n      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);\n    }\n    return synthesizedExternsInput;\n  }\n\n  @Override\n  public double getProgress() {\n    return progress;\n  }\n\n  @Override\n  void setProgress(double newProgress) {\n    if (newProgress > 1.0) {\n      progress = 1.0;\n    } else if (newProgress < 0.0) {\n      progress = 0.0;\n    } else {\n      progress = newProgress;\n    }\n  }\n\n  /**\n   * Replaces one file in a hot-swap mode. The given JsAst should be made\n   * from a new version of a file that already was present in the last compile\n   * call. If the file is new, this will silently ignored.\n   *\n   * @param ast the ast of the file that is being replaced\n   */\n  public void replaceScript(JsAst ast) {\n    CompilerInput input = this.getInput(ast.getInputId());\n    if (!replaceIncrementalSourceAst(ast)) {\n      return;\n    }\n    Node originalRoot = input.getAstRoot(this);\n\n    processNewScript(ast, originalRoot);\n  }\n\n  /**\n   * Adds a new Script AST to the compile state. If a script for the same file\n   * already exists the script will not be added, instead a call to\n   * #replaceScript should be used.\n   *\n   * @param ast the ast of the new file\n   */\n  public void addNewScript(JsAst ast) {\n    if (!addNewSourceAst(ast)) {\n      return;\n    }\n    Node emptyScript = new Node(Token.SCRIPT);\n    InputId inputId = ast.getInputId();\n    emptyScript.setInputId(inputId);\n    emptyScript.setStaticSourceFile(\n        SourceFile.fromCode(inputId.getIdName(), \"\"));\n\n    processNewScript(ast, emptyScript);\n  }\n\n  private void processNewScript(JsAst ast, Node originalRoot) {\n    Node js = ast.getAstRoot(this);\n    Preconditions.checkNotNull(js);\n\n    runHotSwap(originalRoot, js, this.getCleanupPassConfig());\n    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need\n    // to revisit this approach to clearing GlobalNamespaces\n    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);\n\n    this.getTypeRegistry().clearNamedTypes();\n    this.removeSyntheticVarsInput();\n\n    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());\n  }\n\n  /**\n   * Execute the passes from a PassConfig instance over a single replaced file.\n   */\n  private void runHotSwap(\n      Node originalRoot, Node js, PassConfig passConfig) {\n    for (PassFactory passFactory : passConfig.getChecks()) {\n      runHotSwapPass(originalRoot, js, passFactory);\n    }\n  }\n\n  private void runHotSwapPass(\n      Node originalRoot, Node js, PassFactory passFactory) {\n    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);\n    if (pass != null) {\n      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());\n      pass.hotSwapScript(js, originalRoot);\n    }\n  }\n\n  private PassConfig getCleanupPassConfig() {\n    return new CleanupPasses(getOptions());\n  }\n\n  private void removeSyntheticVarsInput() {\n    String sourceName = Compiler.SYNTHETIC_EXTERNS;\n    removeExternInput(new InputId(sourceName));\n  }\n\n  @Override\n  Node ensureLibraryInjected(String resourceName) {\n    if (injectedLibraries.containsKey(resourceName)) {\n      return null;\n    }\n\n    // All libraries depend on js/base.js\n    boolean isBase = \"base\".equals(resourceName);\n    if (!isBase) {\n      ensureLibraryInjected(\"base\");\n    }\n\n    Node firstChild = loadLibraryCode(resourceName).removeChildren();\n    Node lastChild = firstChild.getLastSibling();\n\n    Node parent = getNodeForCodeInsertion(null);\n    if (isBase) {\n      parent.addChildrenToFront(firstChild);\n    } else {\n      parent.addChildrenAfter(\n          firstChild, injectedLibraries.get(\"base\"));\n    }\n    reportCodeChange();\n\n    injectedLibraries.put(resourceName, lastChild);\n    return lastChild;\n  }\n\n  /** Load a library as a resource */\n  @VisibleForTesting\n  Node loadLibraryCode(String resourceName) {\n    String originalCode;\n    try {\n      originalCode = CharStreams.toString(new InputStreamReader(\n          Compiler.class.getResourceAsStream(\n              String.format(\"js/%s.js\", resourceName)),\n          Charsets.UTF_8));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    return Normalize.parseAndNormalizeSyntheticCode(\n        this, originalCode,\n        String.format(\"jscomp_%s_\", resourceName));\n  }\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `compile` method in the `Compiler` class. These tests aim to maximize both branch and line coverage, ensuring that the method behaves as expected under various scenarios.\n\n```java\nimport com.google.common.collect.Lists;\nimport com.google.javascript.jscomp.Compiler;\nimport com.google.javascript.jscomp.CompilerOptions;\nimport com.google.javascript.jscomp.JSSourceFile;\nimport com.google.javascript.jscomp.Result;\nimport com.google.javascript.jscomp.SourceFile;\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class CompilerTest {\n\n    private Compiler compiler;\n    private CompilerOptions options;\n    private JSSourceFile externsFile;\n    private JSModule module;\n\n    @Before\n    public void setUp() {\n        compiler = new Compiler();\n        options = new CompilerOptions();\n        externsFile = JSSourceFile.fromCode(\"externs.js\", \"\");\n        module = new JSModule(\"moduleA\");\n        module.add(JSSourceFile.fromCode(\"moduleA.js\", \"var foo = 42;\"));\n    }\n\n    @Test\n    public void testCompileWithExternsAndModules() {\n        Result result = compiler.compile(new JSSourceFile[]{externsFile}, new JSModule[]{module}, options);\n        assertFalse(result.success);\n        assertEquals(2, result.errors.length); // One for the module and one for the entry point\n    }\n\n    @Test\n    public void testCompileWithNoExterns() {\n        Result result = compiler.compile(new JSSourceFile[0], new JSModule[]{module}, options);\n        assertFalse(result.success);\n        assertEquals(2, result.errors.length); // One for the module and one for the entry point\n    }\n\n    @Test\n    public void testCompileWithNoModules() {\n        Result result = compiler.compile(new JSSourceFile[]{externsFile}, new JSModule[0], options);\n        assertFalse(result.success);\n        assertEquals(1, result.errors.length); // One for the module list being empty\n        assertEquals(Compiler.EMPTY_MODULE_LIST_ERROR, result.errors[0].getType());\n    }\n\n    @Test\n    public void testCompileWithEmptyModule() {\n        JSModule emptyModule = new JSModule(\"emptyModule\");\n        Result result = compiler.compile(new JSSourceFile[]{externsFile}, new JSModule[]{emptyModule}, options);\n        assertFalse(result.success);\n        assertEquals(1, result.errors.length); // One for the root module being empty\n        assertEquals(Compiler.EMPTY_ROOT_MODULE_ERROR, result.errors[0].getType());\n    }\n\n    @Test\n    public void testCompileWithMultipleModules() {\n        JSModule moduleB = new JSModule(\"moduleB\");\n        moduleB.add(JSSourceFile.fromCode(\"moduleB.js\", \"var bar = 42;\"));\n        Result result = compiler.compile(new JSSourceFile[]{externsFile}, new JSModule[]{module, moduleB}, options);\n        assertFalse(result.success);\n        assertEquals(2, result.errors.length); // One for each module and one for the entry point\n    }\n\n    @Test\n    public void testCompileWithDuplicateInputInModules() {\n        module.add(JSSourceFile.fromCode(\"moduleA.js\", \"var foo = 42;\")); // Adding duplicate input\n        Result result = compiler.compile(new JSSourceFile[]{externsFile}, new JSModule[]{module}, options);\n        assertFalse(result.success);\n        assertEquals(2, result.errors.length); // One for the duplicate input and one for the entry point\n        assertEquals(Compiler.DUPLICATE_INPUT, result.errors[0].getType());\n    }\n\n    @Test\n    public void testCompileWithDuplicateExternInput() {\n        JSSourceFile duplicateExternsFile = JSSourceFile.fromCode(\"externs.js\", \"\");\n        Result result = compiler.compile(new JSSourceFile[]{externsFile, duplicateExternsFile}, new JSModule[]{module}, options);\n        assertFalse(result.success);\n        assertEquals(2, result.errors.length); // One for the duplicate extern and one for the entry point\n        assertEquals(Compiler.DUPLICATE_EXTERN_INPUT, result.errors[0].getType());\n    }\n\n    @Test\n    public void testCompileWithValidSetup() {\n        // Add entry points to satisfy the missing entry point error\n        module.getEntryPoints().add(\"moduleA.js\");\n        Result result = compiler.compile(new JSSourceFile[]{externsFile}, new JSModule[]{module}, options);\n        assertFalse(result.success); // Still not successful due to other errors, but at least no missing entry point\n        assertEquals(1, result.errors.length);\n    }\n}\n```\n\n### Explanation:\n1. **testCompileWithExternsAndModules**: Tests a typical setup with externs and modules, expecting errors due to the missing entry points.\n2. **testCompileWithNoExterns**: Tests the scenario with no extern files, expecting similar errors.\n3. **testCompileWithNoModules**: Tests the scenario with no modules, expecting an error about the empty module list.\n4. **testCompileWithEmptyModule**: Tests a scenario with an empty module, expecting an error about the root module being empty.\n5. **testCompileWithMultipleModules**: Tests multiple modules, expecting errors due to missing entry points.\n6. **testCompileWithDuplicateInputInModules**: Tests a scenario with duplicate inputs in modules, expecting a duplicate input error.\n7. **testCompileWithDuplicateExternInput**: Tests duplicate extern files, expecting a duplicate extern input error.\n8. **testCompileWithValidSetup**: Tests a setup with a valid entry point to satisfy the missing entry point error, but still expects other errors.\n\nThese tests should help in achieving good coverage for the `compile` method in the `Compiler` class."}
{"bug_id": "Closure_31", "version": "fixed", "focal_method_signature": "Result com.google.javascript.jscomp.Compiler#compileModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "focal_method": "public <T extends SourceFile> Result compileModules(List<T> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }", "return_type": "Result", "assertion_subject_candidates": ["JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "double com.google.javascript.jscomp.Compiler#getProgress()", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()"], "focal_class": {"name": "Compiler", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Closure_31/fixed/src/com/google/javascript/jscomp/Compiler.java", "superclass": "extends AbstractCompiler", "interface": "", "imports": ["import com.google.common.annotations.VisibleForTesting;", "import com.google.common.base.Charsets;", "import com.google.common.base.Preconditions;", "import com.google.common.base.Supplier;", "import com.google.common.base.Throwables;", "import com.google.common.collect.Lists;", "import com.google.common.collect.Maps;", "import com.google.common.io.CharStreams;", "import com.google.javascript.jscomp.CompilerOptions.DevMode;", "import com.google.javascript.jscomp.CompilerOptions.LanguageMode;", "import com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;", "import com.google.javascript.jscomp.Scope.Var;", "import com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;", "import com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;", "import com.google.javascript.jscomp.parsing.Config;", "import com.google.javascript.jscomp.parsing.ParserRunner;", "import com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.ReverseAbstractInterpreter;", "import com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;", "import com.google.javascript.rhino.IR;", "import com.google.javascript.rhino.InputId;", "import com.google.javascript.rhino.JSDocInfo;", "import com.google.javascript.rhino.Node;", "import com.google.javascript.rhino.Token;", "import com.google.javascript.rhino.head.ErrorReporter;", "import com.google.javascript.rhino.jstype.JSTypeRegistry;", "import java.io.IOException;", "import java.io.InputStreamReader;", "import java.io.PrintStream;", "import java.io.Serializable;", "import java.nio.charset.Charset;", "import java.util.Collections;", "import java.util.HashMap;", "import java.util.List;", "import java.util.Map;", "import java.util.Set;", "import java.util.concurrent.Callable;", "import java.util.logging.Level;", "import java.util.logging.Logger;", "import java.util.regex.Matcher;"], "fields": ["static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions options = null", "private PassConfig passes = null", "private List<CompilerInput> externs", "private List<JSModule> modules", "private JSModuleGraph moduleGraph", "private List<CompilerInput> inputs", "private ErrorManager errorManager", "private WarningsGuard warningsGuard", "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node externsRoot", "Node jsRoot", "Node externAndJsRoot", "private Map<InputId, CompilerInput> inputsById", "private SourceMap sourceMap", "private String externExports = null", "private int uniqueNameId = 0", "private boolean useThreads = true", "private boolean hasRegExpGlobalReferences = true", "private FunctionInformationMap functionInformationMap", "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "private JSTypeRegistry typeRegistry", "private Config parserConfig = null", "private ReverseAbstractInterpreter abstractInterpreter", "private TypeValidator typeValidator", "public PerformanceTracker tracker", "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "private static final long COMPILER_STACK_SIZE = 1048576L", "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "private final PrintStream outStream", "private GlobalVarReferenceMap globalRefMap = null", "private volatile double progress = 0.0", "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "private Tracer currentTracer = null", "private String currentPassName = null", "private int syntheticCodeId = 0", "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "private CompilerInput synthesizedExternsInput = null"], "methods": ["void com.google.javascript.jscomp.Compiler#setErrorManager(ErrorManager#errorManager)", "MessageFormatter com.google.javascript.jscomp.Compiler#createMessageFormatter()", "void com.google.javascript.jscomp.Compiler#initOptions(CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#init(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initModules(List<T>#externs,List<JSModule>#modules,CompilerOptions#options)", "void com.google.javascript.jscomp.Compiler#initBasedOnOptions()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#makeCompilerInput(List<T>#files,boolean#isExtern)", "void com.google.javascript.jscomp.Compiler#checkFirstModule(List<JSModule>#modules)", "String com.google.javascript.jscomp.Compiler#createFillFileName(String#moduleName)", "void com.google.javascript.jscomp.Compiler#fillEmptyModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#rebuildInputsFromModules()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getAllInputsFromModules(List<JSModule>#modules)", "void com.google.javascript.jscomp.Compiler#initInputsByIdMap()", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,SourceFile#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(SourceFile#extern,JSSourceFile[]#input,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile#extern,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSSourceFile[]#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(List<T1>#externs,List<T2>#inputs,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile(JSSourceFile[]#externs,JSModule[]#modules,CompilerOptions#options)", "Result com.google.javascript.jscomp.Compiler#compile()", "void com.google.javascript.jscomp.Compiler#disableThreads()", "T com.google.javascript.jscomp.Compiler#runInCompilerThread(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallableWithLargeStack(Callable<T>#callable)", "T com.google.javascript.jscomp.Compiler#runCallable(Callable<T>#callable,boolean#useLargeStackThread,boolean#trace)", "void com.google.javascript.jscomp.Compiler#compileInternal()", "void com.google.javascript.jscomp.Compiler#parse()", "PassConfig com.google.javascript.jscomp.Compiler#getPassConfig()", "PassConfig com.google.javascript.jscomp.Compiler#createPassConfigInternal()", "void com.google.javascript.jscomp.Compiler#setPassConfig(PassConfig#passes)", "boolean com.google.javascript.jscomp.Compiler#precheck()", "void com.google.javascript.jscomp.Compiler#check()", "void com.google.javascript.jscomp.Compiler#externExports()", "void com.google.javascript.jscomp.Compiler#process(CompilerPass#p)", "void com.google.javascript.jscomp.Compiler#maybeSanityCheck()", "void com.google.javascript.jscomp.Compiler#runSanityCheck()", "void com.google.javascript.jscomp.Compiler#removeTryCatchFinally()", "void com.google.javascript.jscomp.Compiler#stripCode(Set<String>#stripTypes,Set<String>#stripNameSuffixes,Set<String>#stripTypePrefixes,Set<String>#stripNamePrefixes)", "void com.google.javascript.jscomp.Compiler#runCustomPasses(CustomPassExecutionTime#executionTime)", "void com.google.javascript.jscomp.Compiler#startPass(String#passName)", "void com.google.javascript.jscomp.Compiler#endPass()", "Tracer com.google.javascript.jscomp.Compiler#newTracer(String#passName)", "void com.google.javascript.jscomp.Compiler#stopTracer(Tracer#t,String#passName)", "Result com.google.javascript.jscomp.Compiler#getResult()", "JSError[] com.google.javascript.jscomp.Compiler#getMessages()", "JSError[] com.google.javascript.jscomp.Compiler#getErrors()", "JSError[] com.google.javascript.jscomp.Compiler#getWarnings()", "Node com.google.javascript.jscomp.Compiler#getRoot()", "int com.google.javascript.jscomp.Compiler#nextUniqueNameId()", "void com.google.javascript.jscomp.Compiler#resetUniqueNameId()", "Supplier<String> com.google.javascript.jscomp.Compiler#getUniqueNameIdSupplier()", "boolean com.google.javascript.jscomp.Compiler#areNodesEqualForInlining(Node#n1,Node#n2)", "CompilerInput com.google.javascript.jscomp.Compiler#getInput(InputId#id)", "void com.google.javascript.jscomp.Compiler#removeExternInput(InputId#id)", "CompilerInput com.google.javascript.jscomp.Compiler#newExternInput(String#name)", "CompilerInput com.google.javascript.jscomp.Compiler#putCompilerInput(InputId#id,CompilerInput#input)", "void com.google.javascript.jscomp.Compiler#addIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#replaceIncrementalSourceAst(JsAst#ast)", "boolean com.google.javascript.jscomp.Compiler#addNewSourceAst(JsAst#ast)", "JSModuleGraph com.google.javascript.jscomp.Compiler#getModuleGraph()", "JSModuleGraph com.google.javascript.jscomp.Compiler#getDegenerateModuleGraph()", "JSTypeRegistry com.google.javascript.jscomp.Compiler#getTypeRegistry()", "MemoizedScopeCreator com.google.javascript.jscomp.Compiler#getTypedScopeCreator()", "DefaultPassConfig com.google.javascript.jscomp.Compiler#ensureDefaultPassConfig()", "SymbolTable com.google.javascript.jscomp.Compiler#buildKnownSymbolTable()", "Scope com.google.javascript.jscomp.Compiler#getTopScope()", "ReverseAbstractInterpreter com.google.javascript.jscomp.Compiler#getReverseAbstractInterpreter()", "TypeValidator com.google.javascript.jscomp.Compiler#getTypeValidator()", "Node com.google.javascript.jscomp.Compiler#parseInputs()", "void com.google.javascript.jscomp.Compiler#processAMDAndCommonJSModules()", "Node com.google.javascript.jscomp.Compiler#parse(SourceFile#file)", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#js)", "CompilerOptions com.google.javascript.jscomp.Compiler#newCompilerOptions()", "void com.google.javascript.jscomp.Compiler#initCompilerOptionsIfTesting()", "Node com.google.javascript.jscomp.Compiler#parseSyntheticCode(String#fileName,String#js)", "Node com.google.javascript.jscomp.Compiler#parseTestCode(String#js)", "ErrorReporter com.google.javascript.jscomp.Compiler#getDefaultErrorReporter()", "String com.google.javascript.jscomp.Compiler#toSource()", "String[] com.google.javascript.jscomp.Compiler#toSourceArray()", "String com.google.javascript.jscomp.Compiler#toSource(JSModule#module)", "String[] com.google.javascript.jscomp.Compiler#toSourceArray(JSModule#module)", "void com.google.javascript.jscomp.Compiler#toSource(CodeBuilder#cb,int#inputSeqNum,Node#root)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n)", "String com.google.javascript.jscomp.Compiler#toSource(Node#n,SourceMap#sourceMap,boolean#firstOutput)", "void com.google.javascript.jscomp.Compiler#optimize()", "void com.google.javascript.jscomp.Compiler#setCssRenamingMap(CssRenamingMap#map)", "CssRenamingMap com.google.javascript.jscomp.Compiler#getCssRenamingMap()", "void com.google.javascript.jscomp.Compiler#processDefines()", "boolean com.google.javascript.jscomp.Compiler#isInliningForbidden()", "ControlFlowGraph<Node> com.google.javascript.jscomp.Compiler#computeCFG()", "void com.google.javascript.jscomp.Compiler#normalize()", "void com.google.javascript.jscomp.Compiler#prepareAst(Node#root)", "void com.google.javascript.jscomp.Compiler#recordFunctionInformation()", "void com.google.javascript.jscomp.Compiler#addChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#removeChangeHandler(CodeChangeHandler#handler)", "void com.google.javascript.jscomp.Compiler#reportCodeChange()", "CodingConvention com.google.javascript.jscomp.Compiler#getCodingConvention()", "boolean com.google.javascript.jscomp.Compiler#isIdeMode()", "boolean com.google.javascript.jscomp.Compiler#acceptEcmaScript5()", "LanguageMode com.google.javascript.jscomp.Compiler#languageMode()", "boolean com.google.javascript.jscomp.Compiler#acceptConstKeyword()", "Config com.google.javascript.jscomp.Compiler#getParserConfig()", "boolean com.google.javascript.jscomp.Compiler#isTypeCheckingEnabled()", "DiagnosticGroups com.google.javascript.jscomp.Compiler#getDiagnosticGroups()", "void com.google.javascript.jscomp.Compiler#report(JSError#error)", "CheckLevel com.google.javascript.jscomp.Compiler#getErrorLevel(JSError#error)", "void com.google.javascript.jscomp.Compiler#throwInternalError(String#message,Exception#cause)", "int com.google.javascript.jscomp.Compiler#getErrorCount()", "int com.google.javascript.jscomp.Compiler#getWarningCount()", "boolean com.google.javascript.jscomp.Compiler#hasHaltingErrors()", "boolean com.google.javascript.jscomp.Compiler#hasErrors()", "void com.google.javascript.jscomp.Compiler#addToDebugLog(String#str)", "SourceFile com.google.javascript.jscomp.Compiler#getSourceFileByName(String#sourceName)", "String com.google.javascript.jscomp.Compiler#getSourceLine(String#sourceName,int#lineNumber)", "Region com.google.javascript.jscomp.Compiler#getSourceRegion(String#sourceName,int#lineNumber)", "Node com.google.javascript.jscomp.Compiler#getNodeForCodeInsertion(JSModule#module)", "SourceMap com.google.javascript.jscomp.Compiler#getSourceMap()", "VariableMap com.google.javascript.jscomp.Compiler#getVariableMap()", "VariableMap com.google.javascript.jscomp.Compiler#getPropertyMap()", "CompilerOptions com.google.javascript.jscomp.Compiler#getOptions()", "FunctionInformationMap com.google.javascript.jscomp.Compiler#getFunctionalInformationMap()", "void com.google.javascript.jscomp.Compiler#setLoggingLevel(Level#level)", "String com.google.javascript.jscomp.Compiler#getAstDotGraph()", "ErrorManager com.google.javascript.jscomp.Compiler#getErrorManager()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsInOrder()", "Map<InputId, CompilerInput> com.google.javascript.jscomp.Compiler#getInputsById()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsInOrder()", "IntermediateState com.google.javascript.jscomp.Compiler#getState()", "void com.google.javascript.jscomp.Compiler#setState(IntermediateState#state)", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getInputsForTesting()", "List<CompilerInput> com.google.javascript.jscomp.Compiler#getExternsForTesting()", "boolean com.google.javascript.jscomp.Compiler#hasRegExpGlobalReferences()", "void com.google.javascript.jscomp.Compiler#setHasRegExpGlobalReferences(boolean#references)", "void com.google.javascript.jscomp.Compiler#updateGlobalVarReferences(Map<Var, ReferenceCollection>#refMapPatch,Node#collectionRoot)", "GlobalVarReferenceMap com.google.javascript.jscomp.Compiler#getGlobalVarReferences()", "CompilerInput com.google.javascript.jscomp.Compiler#getSynthesizedExternsInput()", "double com.google.javascript.jscomp.Compiler#getProgress()", "void com.google.javascript.jscomp.Compiler#setProgress(double#newProgress)", "void com.google.javascript.jscomp.Compiler#replaceScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#addNewScript(JsAst#ast)", "void com.google.javascript.jscomp.Compiler#processNewScript(JsAst#ast,Node#originalRoot)", "void com.google.javascript.jscomp.Compiler#runHotSwap(Node#originalRoot,Node#js,PassConfig#passConfig)", "void com.google.javascript.jscomp.Compiler#runHotSwapPass(Node#originalRoot,Node#js,PassFactory#passFactory)", "PassConfig com.google.javascript.jscomp.Compiler#getCleanupPassConfig()", "void com.google.javascript.jscomp.Compiler#removeSyntheticVarsInput()", "Node com.google.javascript.jscomp.Compiler#ensureLibraryInjected(String#resourceName)", "Node com.google.javascript.jscomp.Compiler#loadLibraryCode(String#resourceName)"], "other_methods": ["public void setErrorManager(ErrorManager errorManager);", "public void initOptions(CompilerOptions options);", "public void init(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public void init(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public void init(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public void initModules(List<T> externs,List<JSModule> modules,CompilerOptions options);", "public void rebuildInputsFromModules();", "public Result compile(SourceFile extern,SourceFile input,CompilerOptions options);", "public Result compile(SourceFile extern,JSSourceFile[] input,CompilerOptions options);", "public Result compile(JSSourceFile extern,JSModule[] modules,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSSourceFile[] inputs,CompilerOptions options);", "public Result compile(List<T1> externs,List<T2> inputs,CompilerOptions options);", "public Result compile(JSSourceFile[] externs,JSModule[] modules,CompilerOptions options);", "public void disableThreads();", "public void parse();", "public void setPassConfig(PassConfig passes);", "public void check();", "public Result getResult();", "public JSError[] getMessages();", "public JSError[] getErrors();", "public JSError[] getWarnings();", "@Override\n  public Node getRoot();", "@Override\n  public CompilerInput getInput(InputId id);", "@Override\n  public CompilerInput newExternInput(String name);", "@Override\n  public JSTypeRegistry getTypeRegistry();", "@Override\n  public MemoizedScopeCreator getTypedScopeCreator();", "public SymbolTable buildKnownSymbolTable();", "@Override\n  public Scope getTopScope();", "@Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter();", "public Node parse(SourceFile file);", "public String toSource();", "public String[] toSourceArray();", "public String toSource(JSModule module);", "public String[] toSourceArray(JSModule module);", "public void toSource(CodeBuilder cb,int inputSeqNum,Node root);", "public void optimize();", "public void processDefines();", "public void normalize();", "@Override\n  public void reportCodeChange();", "@Override\n  public CodingConvention getCodingConvention();", "@Override\n  public boolean isIdeMode();", "@Override\n  public boolean acceptEcmaScript5();", "public LanguageMode languageMode();", "@Override\n  public boolean acceptConstKeyword();", "@Override\n  public boolean isTypeCheckingEnabled();", "@Override\n  public void report(JSError error);", "@Override\n  public CheckLevel getErrorLevel(JSError error);", "public int getErrorCount();", "public int getWarningCount();", "public boolean hasErrors();", "@Override\n  public String getSourceLine(String sourceName,int lineNumber);", "@Override\n  public Region getSourceRegion(String sourceName,int lineNumber);", "public SourceMap getSourceMap();", "public static void setLoggingLevel(Level level);", "public String getAstDotGraph();", "@Override\n  public ErrorManager getErrorManager();", "public Map<InputId, CompilerInput> getInputsById();", "public IntermediateState getState();", "public void setState(IntermediateState state);", "@Override\n  public double getProgress();", "public void replaceScript(JsAst ast);", "public void addNewScript(JsAst ast);"], "fields_dict": {"String#SINGLETON_MODULE_NAME": "static final String SINGLETON_MODULE_NAME = \"[singleton]\"", "DiagnosticType#MODULE_DEPENDENCY_ERROR": "static final DiagnosticType MODULE_DEPENDENCY_ERROR = DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\")", "DiagnosticType#MISSING_ENTRY_ERROR": "static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\")", "CompilerOptions#options": "CompilerOptions options = null", "PassConfig#passes": "private PassConfig passes = null", "List<CompilerInput>#externs": "private List<CompilerInput> externs", "List<JSModule>#modules": "private List<JSModule> modules", "JSModuleGraph#moduleGraph": "private JSModuleGraph moduleGraph", "List<CompilerInput>#inputs": "private List<CompilerInput> inputs", "ErrorManager#errorManager": "private ErrorManager errorManager", "WarningsGuard#warningsGuard": "private WarningsGuard warningsGuard", "Map<String, Node>#injectedLibraries": "private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap()", "Node#externsRoot": "Node externsRoot", "Node#jsRoot": "Node jsRoot", "Node#externAndJsRoot": "Node externAndJsRoot", "Map<InputId, CompilerInput>#inputsById": "private Map<InputId, CompilerInput> inputsById", "SourceMap#sourceMap": "private SourceMap sourceMap", "String#externExports": "private String externExports = null", "int#uniqueNameId": "private int uniqueNameId = 0", "boolean#useThreads": "private boolean useThreads = true", "boolean#hasRegExpGlobalReferences": "private boolean hasRegExpGlobalReferences = true", "FunctionInformationMap#functionInformationMap": "private FunctionInformationMap functionInformationMap", "StringBuilder#debugLog": "private final StringBuilder debugLog = new StringBuilder()", "CodingConvention#defaultCodingConvention": "CodingConvention defaultCodingConvention = new ClosureCodingConvention()", "JSTypeRegistry#typeRegistry": "private JSTypeRegistry typeRegistry", "Config#parserConfig": "private Config parserConfig = null", "ReverseAbstractInterpreter#abstractInterpreter": "private ReverseAbstractInterpreter abstractInterpreter", "TypeValidator#typeValidator": "private TypeValidator typeValidator", "PerformanceTracker#tracker": "public PerformanceTracker tracker", "com.google.javascript.rhino.ErrorReporter#oldErrorReporter": "private final com.google.javascript.rhino.ErrorReporter oldErrorReporter = RhinoErrorReporter.forOldRhino(this)", "ErrorReporter#defaultErrorReporter": "private final ErrorReporter defaultErrorReporter = RhinoErrorReporter.forNewRhino(this)", "DiagnosticType#OPTIMIZE_LOOP_ERROR": "public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\")", "DiagnosticType#MOTION_ITERATIONS_ERROR": "public static final DiagnosticType MOTION_ITERATIONS_ERROR = DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\")", "long#COMPILER_STACK_SIZE": "private static final long COMPILER_STACK_SIZE = 1048576L", "Logger#logger": "private static final Logger logger = Logger.getLogger(\"com.google.javascript.jscomp\")", "PrintStream#outStream": "private final PrintStream outStream", "GlobalVarReferenceMap#globalRefMap": "private GlobalVarReferenceMap globalRefMap = null", "double#progress": "private volatile double progress = 0.0", "DiagnosticType#EMPTY_MODULE_LIST_ERROR": "private static final DiagnosticType EMPTY_MODULE_LIST_ERROR = DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\")", "DiagnosticType#EMPTY_ROOT_MODULE_ERROR": "private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR = DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\")", "DiagnosticType#DUPLICATE_INPUT": "static final DiagnosticType DUPLICATE_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\")", "DiagnosticType#DUPLICATE_EXTERN_INPUT": "static final DiagnosticType DUPLICATE_EXTERN_INPUT = DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\")", "PassFactory#sanityCheck": "private final PassFactory sanityCheck = new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  }", "Tracer#currentTracer": "private Tracer currentTracer = null", "String#currentPassName": "private String currentPassName = null", "int#syntheticCodeId": "private int syntheticCodeId = 0", "CodeChangeHandler.RecentChange#recentChange": "protected final CodeChangeHandler.RecentChange recentChange = new CodeChangeHandler.RecentChange()", "List<CodeChangeHandler>#codeChangeHandlers": "private final List<CodeChangeHandler> codeChangeHandlers = Lists.<CodeChangeHandler>newArrayList()", "String#SYNTHETIC_EXTERNS": "static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\"", "CompilerInput#synthesizedExternsInput": "private CompilerInput synthesizedExternsInput = null"}, "text": "/*\n * Copyright 2004 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Charsets;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.io.CharStreams;\nimport com.google.javascript.jscomp.CompilerOptions.DevMode;\nimport com.google.javascript.jscomp.CompilerOptions.LanguageMode;\nimport com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollection;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.deps.SortedDependencies.CircularDependencyException;\nimport com.google.javascript.jscomp.deps.SortedDependencies.MissingProvideException;\nimport com.google.javascript.jscomp.parsing.Config;\nimport com.google.javascript.jscomp.parsing.ParserRunner;\nimport com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.ReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.head.ErrorReporter;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.nio.charset.Charset;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\n\n/**\n * Compiler (and the other classes in this package) does the following:\n * <ul>\n * <li>parses JS code\n * <li>checks for undefined variables\n * <li>performs optimizations such as constant folding and constants inlining\n * <li>renames variables (to short names)\n * <li>outputs compact javascript code\n * </ul>\n *\n * External variables are declared in 'externs' files. For instance, the file\n * may include definitions for global javascript/browser objects such as\n * window, document.\n *\n */\npublic class Compiler extends AbstractCompiler {\n  static final String SINGLETON_MODULE_NAME = \"[singleton]\";\n\n  static final DiagnosticType MODULE_DEPENDENCY_ERROR =\n      DiagnosticType.error(\"JSC_MODULE_DEPENDENCY_ERROR\",\n          \"Bad dependency: {0} -> {1}. \"\n              + \"Modules must be listed in dependency order.\");\n\n  static final DiagnosticType MISSING_ENTRY_ERROR = DiagnosticType.error(\n      \"JSC_MISSING_ENTRY_ERROR\",\n      \"required entry point \\\"{0}\\\" never provided\");\n\n  CompilerOptions options = null;\n\n  private PassConfig passes = null;\n\n  // The externs inputs\n  private List<CompilerInput> externs;\n\n  // The JS source modules\n  private List<JSModule> modules;\n\n  // The graph of the JS source modules. Must be null if there are less than\n  // 2 modules, because we use this as a signal for which passes to run.\n  private JSModuleGraph moduleGraph;\n\n  // The JS source inputs\n  private List<CompilerInput> inputs;\n\n  // error manager to which error management is delegated\n  private ErrorManager errorManager;\n\n  // Warnings guard for filtering warnings.\n  private WarningsGuard warningsGuard;\n\n  // Compile-time injected libraries. The node points to the last node of\n  // the library, so code can be inserted after.\n  private final Map<String, Node> injectedLibraries = Maps.newLinkedHashMap();\n\n  // Parse tree root nodes\n  Node externsRoot;\n  Node jsRoot;\n  Node externAndJsRoot;\n\n  private Map<InputId, CompilerInput> inputsById;\n\n  /** The source code map */\n  private SourceMap sourceMap;\n\n  /** The externs created from the exports.  */\n  private String externExports = null;\n\n  /**\n   * Ids for function inlining so that each declared name remains\n   * unique.\n   */\n  private int uniqueNameId = 0;\n\n  /** Whether to use threads. */\n  private boolean useThreads = true;\n\n  /**\n   * Whether to assume there are references to the RegExp Global object\n   * properties.\n   */\n  private boolean hasRegExpGlobalReferences = true;\n\n  /** The function information map */\n  private FunctionInformationMap functionInformationMap;\n\n  /** Debugging information */\n  private final StringBuilder debugLog = new StringBuilder();\n\n  /** Detects Google-specific coding conventions. */\n  CodingConvention defaultCodingConvention = new ClosureCodingConvention();\n\n  private JSTypeRegistry typeRegistry;\n  private Config parserConfig = null;\n\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n\n  public PerformanceTracker tracker;\n\n  // The oldErrorReporter exists so we can get errors from the JSTypeRegistry.\n  private final com.google.javascript.rhino.ErrorReporter oldErrorReporter =\n      RhinoErrorReporter.forOldRhino(this);\n\n  // This error reporter gets the messages from the current Rhino parser.\n  private final ErrorReporter defaultErrorReporter =\n      RhinoErrorReporter.forNewRhino(this);\n\n  /** Error strings used for reporting JSErrors */\n  public static final DiagnosticType OPTIMIZE_LOOP_ERROR = DiagnosticType.error(\n      \"JSC_OPTIMIZE_LOOP_ERROR\",\n      \"Exceeded max number of optimization iterations: {0}\");\n  public static final DiagnosticType MOTION_ITERATIONS_ERROR =\n      DiagnosticType.error(\"JSC_OPTIMIZE_LOOP_ERROR\",\n          \"Exceeded max number of code motion iterations: {0}\");\n\n  private static final long COMPILER_STACK_SIZE = 1048576L;\n\n\n  /**\n   * Logger for the whole com.google.javascript.jscomp domain -\n   * setting configuration for this logger affects all loggers\n   *  in other classes within the compiler.\n   */\n  private static final Logger logger =\n      Logger.getLogger(\"com.google.javascript.jscomp\");\n\n  private final PrintStream outStream;\n\n  private GlobalVarReferenceMap globalRefMap = null;\n\n  private volatile double progress = 0.0;\n\n  /**\n   * Creates a Compiler that reports errors and warnings to its logger.\n   */\n  public Compiler() {\n    this((PrintStream) null);\n  }\n\n  /**\n   * Creates n Compiler that reports errors and warnings to an output\n   * stream.\n   */\n  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }\n\n  /**\n   * Creates a Compiler that uses a custom error manager.\n   */\n  public Compiler(ErrorManager errorManager) {\n    this();\n    setErrorManager(errorManager);\n  }\n\n  /**\n   * Sets the error manager.\n   *\n   * @param errorManager the error manager, it cannot be {@code null}\n   */\n  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }\n\n  /**\n   * Creates a message formatter instance corresponding to the value of\n   * {@link CompilerOptions}.\n   */\n  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }\n\n  /**\n   * Initialize the compiler options. Only necessary if you're not doing\n   * a normal compile() job.\n   */\n  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    init(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> void init(\n      List<T1> externs,\n      List<T2> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(SINGLETON_MODULE_NAME);\n    for (SourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options) {\n    initModules(Lists.<SourceFile>newArrayList(externs),\n         Lists.<JSModule>newArrayList(modules), options);\n  }\n\n  /**\n   * Initializes the instance state needed for a compile job if the sources\n   * are in modules.\n   */\n  public <T extends SourceFile> void initModules(\n      List<T> externs, List<JSModule> modules, CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByIdMap();\n  }\n\n  /**\n   * Do any initialization that is dependent on the compiler options.\n   */\n  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }\n\n  private <T extends SourceFile> List<CompilerInput> makeCompilerInput(\n      List<T> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (T file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }\n\n  private static final DiagnosticType EMPTY_MODULE_LIST_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_MODULE_LIST_ERROR\",\n          \"At least one module must be provided\");\n\n  private static final DiagnosticType EMPTY_ROOT_MODULE_ERROR =\n      DiagnosticType.error(\"JSC_EMPTY_ROOT_MODULE_ERROR\",\n          \"Root module '{0}' must contain at least one source code input\");\n\n  /**\n   * Verifies that at least one module has been provided and that the first one\n   * has at least one source code input.\n   */\n  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }\n\n  /**\n   * Empty modules get an empty \"fill\" file, so that we can move code into\n   * an empty module.\n   */\n  static String createFillFileName(String moduleName) {\n    return \"[\" + moduleName + \"]\";\n  }\n\n  /**\n   * Fill any empty modules with a place holder file. It makes any cross module\n   * motion easier.\n   */\n  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(SourceFile.fromCode(\n            createFillFileName(module.getName()), \"\"));\n      }\n    }\n  }\n\n  /**\n   * Rebuilds the internal list of inputs by iterating over all modules.\n   * This is necessary if inputs have been added to or removed from a module\n   * after the {@link #init(JSSourceFile[], JSModule[], CompilerOptions)} call.\n   */\n  public void rebuildInputsFromModules() {\n    inputs = getAllInputsFromModules(modules);\n    initInputsByIdMap();\n  }\n\n  /**\n   * Builds a single list of all module inputs. Verifies that it contains no\n   * duplicates.\n   */\n  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }\n\n  static final DiagnosticType DUPLICATE_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_INPUT\", \"Duplicate input: {0}\");\n  static final DiagnosticType DUPLICATE_EXTERN_INPUT =\n      DiagnosticType.error(\"JSC_DUPLICATE_EXTERN_INPUT\",\n          \"Duplicate extern input: {0}\");\n\n  /**\n   * Creates a map to make looking up an input by name fast. Also checks for\n   * duplicate inputs.\n   */\n  void initInputsByIdMap() {\n    inputsById = new HashMap<InputId, CompilerInput>();\n    for (CompilerInput input : externs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, input.getName()));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      InputId id = input.getInputId();\n      CompilerInput previous = putCompilerInput(id, input);\n      if (previous != null) {\n        report(JSError.make(DUPLICATE_INPUT, input.getName()));\n      }\n    }\n  }\n\n  public Result compile(\n      SourceFile extern, SourceFile input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      SourceFile extern, JSSourceFile[] input, CompilerOptions options) {\n     return compile(Lists.newArrayList(extern), Lists.newArrayList(input), options);\n  }\n\n  public Result compile(\n      JSSourceFile extern, JSModule[] modules, CompilerOptions options) {\n     return compileModules(\n         Lists.newArrayList(extern), Lists.newArrayList(modules), options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSSourceFile[] inputs,\n                        CompilerOptions options) {\n    return compile(Lists.<SourceFile>newArrayList(externs),\n        Lists.<SourceFile>newArrayList(inputs),\n        options);\n  }\n\n  /**\n   * Compiles a list of inputs.\n   */\n  public <T1 extends SourceFile, T2 extends SourceFile> Result compile(\n      List<T1> externs, List<T2> inputs, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, inputs, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options) {\n    return compileModules(Lists.<SourceFile>newArrayList(externs),\n        Lists.<JSModule>newArrayList(modules),\n        options);\n  }\n\n  /**\n   * Compiles a list of modules.\n   */\n  public <T extends SourceFile> Result compileModules(List<T> externs,\n      List<JSModule> modules, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      initModules(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }\n\n  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      @Override\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }\n\n  /**\n   * Disable threads. This is for clients that run on AppEngine and\n   * don't have threads.\n   */\n  public void disableThreads() {\n    useThreads = false;\n  }\n\n  private <T> T runInCompilerThread(final Callable<T> callable) {\n    return runCallable(callable, useThreads, options.tracer.isOn());\n  }\n\n  static <T> T runCallableWithLargeStack(final Callable<T> callable) {\n    return runCallable(callable, true, false);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n\n    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n    // large or complex js code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = trace;\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useLargeStackThread) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }\n\n  private void compileInternal() {\n    setProgress(0.0);\n    parse();\n    // 15 percent of the work is assumed to be for parsing (based on some\n    // minimal analysis on big JS projects, of course this depends on options)\n    setProgress(0.15);\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n    setProgress(1.0);\n  }\n\n  public void parse() {\n    parseInputs();\n  }\n\n  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }\n\n  /**\n   * Create the passes object. Clients should use setPassConfig instead of\n   * overriding this.\n   */\n  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }\n\n  /**\n   * @param passes The PassConfig to use with this Compiler.\n   * @throws NullPointerException if passes is null\n   * @throws IllegalStateException if this.passes has already been assigned\n   */\n  public void setPassConfig(PassConfig passes) {\n    // Important to check for null because if setPassConfig(null) is\n    // called before this.passes is set, getPassConfig() will create a\n    // new PassConfig object and use that, which is probably not what\n    // the client wanted since he or she probably meant to use their\n    // own PassConfig object.\n    Preconditions.checkNotNull(passes);\n\n    if (this.passes != null) {\n      throw new IllegalStateException(\"this.passes has already been assigned\");\n    }\n    this.passes = passes;\n  }\n\n  /**\n   * Carry out any special checks or procedures that need to be done before\n   * proceeding with rest of the compilation process.\n   *\n   * @return true, to continue with compilation\n   */\n  boolean precheck() {\n    return true;\n  }\n\n  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    // We are currently only interested in check-passes for progress reporting\n    // as it is used for IDEs, that's why the maximum progress is set to 1.0.\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker,\n        new PhaseOptimizer.ProgressRange(getProgress(), 1.0));\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }\n\n  private void externExports() {\n    logger.fine(\"Creating extern file for exports\");\n    startPass(\"externExports\");\n\n    ExternExportsPass pass = new ExternExportsPass(this);\n    process(pass);\n\n    externExports = pass.getGeneratedExterns();\n\n    endPass();\n  }\n\n  @Override\n  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }\n\n  private final PassFactory sanityCheck =\n      new PassFactory(\"sanityCheck\", false) {\n    @Override\n    protected CompilerPass createInternal(AbstractCompiler compiler) {\n      return new SanityCheck(compiler);\n    }\n  };\n\n  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }\n\n  private void runSanityCheck() {\n    sanityCheck.create(this).process(externsRoot, jsRoot);\n  }\n\n  /**\n   * Removes try/catch/finally statements for easier debugging.\n   */\n  void removeTryCatchFinally() {\n    logger.fine(\"Remove try/catch/finally\");\n    startPass(\"removeTryCatchFinally\");\n    RemoveTryCatch r = new RemoveTryCatch(this);\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Strips code for smaller compiled code. This is useful for removing debug\n   * statements to prevent leaking them publicly.\n   */\n  void stripCode(Set<String> stripTypes, Set<String> stripNameSuffixes,\n      Set<String> stripTypePrefixes, Set<String> stripNamePrefixes) {\n    logger.fine(\"Strip code\");\n    startPass(\"stripCode\");\n    StripCode r = new StripCode(this, stripTypes, stripNameSuffixes,\n        stripTypePrefixes, stripNamePrefixes);\n    if (options.getTweakProcessing().shouldStrip()) {\n      r.enableTweakStripping();\n    }\n    process(r);\n    endPass();\n  }\n\n  /**\n   * Runs custom passes that are designated to run at a particular time.\n   */\n  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }\n\n  private Tracer currentTracer = null;\n  private String currentPassName = null;\n\n  /**\n   * Marks the beginning of a pass.\n   */\n  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }\n\n  /**\n   * Marks the end of a pass.\n   */\n  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }\n\n  /**\n   * Returns a new tracer for the given pass name.\n   */\n  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }\n\n  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }\n\n  /**\n   * Returns the result of the compilation.\n   */\n  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }\n\n  /**\n   * Returns an array constructed from errors + temporary warnings.\n   */\n  public JSError[] getMessages() {\n    return getErrors();\n  }\n\n  /**\n   * Returns the array of errors (never null).\n   */\n  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }\n\n  /**\n   * Returns the array of warnings (never null).\n   */\n  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }\n\n  @Override\n  public Node getRoot() {\n    return externAndJsRoot;\n  }\n\n  /**\n   * Creates a new id for making unique names.\n   */\n  private int nextUniqueNameId() {\n    return uniqueNameId++;\n  }\n\n  /**\n   * Resets the unique name id counter\n   */\n  @VisibleForTesting\n  void resetUniqueNameId() {\n    uniqueNameId = 0;\n  }\n\n  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      @Override\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }\n\n  @Override\n  boolean areNodesEqualForInlining(Node n1, Node n2) {\n    if (options.ambiguateProperties ||\n        options.disambiguateProperties) {\n      // The type based optimizations require that type information is preserved\n      // during other optimizations.\n      return n1.isEquivalentToTyped(n2);\n    } else {\n      return n1.isEquivalentTo(n2);\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Inputs\n  //------------------------------------------------------------------------\n\n  // TODO(nicksantos): Decide which parts of these belong in an AbstractCompiler\n  // interface, and which ones should always be injected.\n\n  @Override\n  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }\n\n  /**\n   * Removes an input file from AST.\n   * @param id The id of the input to be removed.\n   */\n  protected void removeExternInput(InputId id) {\n    CompilerInput input = getInput(id);\n    if (input == null) {\n      return;\n    }\n    Preconditions.checkState(input.isExtern(), \"Not an extern input: %s\", input.getName());\n    inputsById.remove(id);\n    externs.remove(input);\n    Node root = input.getAstRoot(this);\n    if (root != null) {\n      root.detachFromParent();\n    }\n  }\n\n  @Override\n  public CompilerInput newExternInput(String name) {\n    SourceAst ast = new SyntheticAst(name);\n    if (inputsById.containsKey(ast.getInputId())) {\n      throw new IllegalArgumentException(\"Conflicting externs name: \" + name);\n    }\n    CompilerInput input = new CompilerInput(ast, true);\n    putCompilerInput(input.getInputId(), input);\n    externsRoot.addChildToFront(ast.getAstRoot(this));\n    externs.add(0, input);\n    return input;\n  }\n\n  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }\n\n  /** Add a source input dynamically. Intended for incremental compilation. */\n  void addIncrementalSourceAst(JsAst ast) {\n    InputId id = ast.getInputId();\n    Preconditions.checkState(getInput(id) == null, \"Duplicate input %s\", id.getIdName());\n    putCompilerInput(id, new CompilerInput(ast));\n  }\n\n  /**\n   * Replace a source input dynamically. Intended for incremental\n   * re-compilation.\n   *\n   * If the new source input doesn't parse, then keep the old input\n   * in the AST and return false.\n   *\n   * @return Whether the new AST was attached successfully.\n   */\n  boolean replaceIncrementalSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    Preconditions.checkNotNull(oldInput, \"No input to replace: %s\", ast.getInputId().getIdName());\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    Node oldRoot = oldInput.getAstRoot(this);\n    if (oldRoot != null) {\n      oldRoot.getParent().replaceChild(oldRoot, newRoot);\n    } else {\n      getRoot().getLastChild().addChildToBack(newRoot);\n    }\n\n    CompilerInput newInput = new CompilerInput(ast);\n    putCompilerInput(ast.getInputId(), newInput);\n\n    JSModule module = oldInput.getModule();\n    if (module != null) {\n      module.addAfter(newInput, oldInput);\n      module.remove(oldInput);\n    }\n\n    // Verify the input id is set properly.\n    Preconditions.checkState(\n        newInput.getInputId().equals(oldInput.getInputId()));\n    InputId inputIdOnAst = newInput.getAstRoot(this).getInputId();\n    Preconditions.checkState(newInput.getInputId().equals(inputIdOnAst));\n\n    inputs.remove(oldInput);\n    return true;\n  }\n\n  /**\n   * Add a new source input dynamically. Intended for incremental compilation.\n   * <p>\n   * If the new source input doesn't parse, it will not be added, and a false\n   * will be returned.\n   *\n   * @param ast the JS Source to add.\n   * @return true if the source was added successfully, false otherwise.\n   * @throws IllegalStateException if an input for this ast already exists.\n   */\n  boolean addNewSourceAst(JsAst ast) {\n    CompilerInput oldInput = getInput(ast.getInputId());\n    if (oldInput != null) {\n      throw new IllegalStateException(\n          \"Input already exists: \" + ast.getInputId().getIdName());\n    }\n    Node newRoot = ast.getAstRoot(this);\n    if (newRoot == null) {\n      return false;\n    }\n\n    getRoot().getLastChild().addChildToBack(newRoot);\n\n    CompilerInput newInput = new CompilerInput(ast);\n\n    // TODO(tylerg): handle this for multiple modules at some point.\n    if (moduleGraph == null && !modules.isEmpty()) {\n      // singleton module\n      modules.get(0).add(newInput);\n    }\n\n    putCompilerInput(ast.getInputId(), newInput);\n\n    return true;\n  }\n\n  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }\n\n  /**\n   * Gets a module graph. This will always return a module graph, even\n   * in the degenerate case when there's only one module.\n   */\n  JSModuleGraph getDegenerateModuleGraph() {\n    return moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph;\n  }\n\n  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }\n\n  @Override\n  public MemoizedScopeCreator getTypedScopeCreator() {\n    return getPassConfig().getTypedScopeCreator();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  DefaultPassConfig ensureDefaultPassConfig() {\n    PassConfig passes = getPassConfig().getBasePassConfig();\n    Preconditions.checkState(passes instanceof DefaultPassConfig,\n        \"PassConfigs must eventually delegate to the DefaultPassConfig\");\n    return (DefaultPassConfig) passes;\n  }\n\n  public SymbolTable buildKnownSymbolTable() {\n    SymbolTable symbolTable = new SymbolTable(getTypeRegistry());\n\n    MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator();\n    if (typedScopeCreator != null) {\n      symbolTable.addScopes(typedScopeCreator.getAllMemoizedScopes());\n      symbolTable.addSymbolsFrom(typedScopeCreator);\n    } else {\n      symbolTable.findScopes(this, externsRoot, jsRoot);\n    }\n\n    GlobalNamespace globalNamespace =\n        ensureDefaultPassConfig().getGlobalNamespace();\n    if (globalNamespace != null) {\n      symbolTable.addSymbolsFrom(globalNamespace);\n    }\n\n    ReferenceCollectingCallback refCollector =\n        new ReferenceCollectingCallback(\n            this, ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR);\n    NodeTraversal.traverse(this, getRoot(), refCollector);\n    symbolTable.addSymbolsFrom(refCollector);\n\n    PreprocessorSymbolTable preprocessorSymbolTable =\n        ensureDefaultPassConfig().getPreprocessorSymbolTable();\n    if (preprocessorSymbolTable != null) {\n      symbolTable.addSymbolsFrom(preprocessorSymbolTable);\n    }\n\n    symbolTable.fillNamespaceReferences();\n    symbolTable.fillPropertyScopes();\n    symbolTable.fillThisReferences(this, externsRoot, jsRoot);\n    symbolTable.fillPropertySymbols(this, externsRoot, jsRoot);\n    symbolTable.fillJSDocInfo(this, externsRoot, jsRoot);\n\n    return symbolTable;\n  }\n\n  @Override\n  public Scope getTopScope() {\n    return getPassConfig().getTopScope();\n  }\n\n  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }\n\n  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }\n\n  //------------------------------------------------------------------------\n  // Parsing\n  //------------------------------------------------------------------------\n\n  /**\n   * Parses the externs and main inputs.\n   *\n   * @return A synthetic root node whose two children are the externs root\n   *     and the main root\n   */\n  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = IR.block();\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = IR.block();\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Modules inferred in ProcessCommonJS pass.\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n        processAMDAndCommonJSModules();\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions.needsManagement() &&\n          options.closurePass) {\n        for (CompilerInput input : inputs) {\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(options.dependencyOptions, inputs);\n          staleInputs = true;\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }\n\n  /**\n   * Transforms AMD and CJS modules to something closure compiler can\n   * process and creates JSModules and the corresponding dependency tree\n   * on the way.\n   */\n  void processAMDAndCommonJSModules() {\n    Map<String, JSModule> modulesByName = Maps.newLinkedHashMap();\n    Map<CompilerInput, JSModule> modulesByInput = Maps.newLinkedHashMap();\n    // TODO(nicksantos): Refactor module dependency resolution to work nicely\n    // with multiple ways to express dependencies. Directly support JSModules\n    // that are equivalent to a signal file and which express their deps\n    // directly in the source.\n    for (CompilerInput input : inputs) {\n      input.setCompiler(this);\n      Node root = input.getAstRoot(this);\n      if (root == null) {\n        continue;\n      }\n      if (options.transformAMDToCJSModules) {\n        new TransformAMDToCJSModule(this).process(null, root);\n      }\n      if (options.processCommonJSModules) {\n        ProcessCommonJSModules cjs = new ProcessCommonJSModules(this,\n            options.commonJSModulePathPrefix);\n        cjs.process(null, root);\n        JSModule m = cjs.getModule();\n        if (m != null) {\n          modulesByName.put(m.getName(), m);\n          modulesByInput.put(input, m);\n        }\n      }\n    }\n    if (options.processCommonJSModules) {\n      List<JSModule> modules = Lists.newArrayList(modulesByName.values());\n      if (!modules.isEmpty()) {\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(this.modules);\n      }\n      for (JSModule module : modules) {\n        for (CompilerInput input : module.getInputs()) {\n          for (String require : input.getRequires()) {\n            JSModule dependency = modulesByName.get(require);\n            if (dependency == null) {\n              report(JSError.make(MISSING_ENTRY_ERROR, require));\n            } else {\n              module.addDependency(dependency);\n            }\n          }\n        }\n      }\n      try {\n        modules = Lists.newArrayList();\n        for (CompilerInput input : this.moduleGraph.manageDependencies(\n            options.dependencyOptions, inputs)) {\n          modules.add(modulesByInput.get(input));\n        }\n        this.modules = modules;\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (Exception e) {\n        Throwables.propagate(e);\n      }\n    }\n  }\n\n  public Node parse(SourceFile file) {\n    initCompilerOptionsIfTesting();\n    addToDebugLog(\"Parsing: \" + file.getName());\n    return new JsAst(file).getAstRoot(this);\n  }\n\n  private int syntheticCodeId = 0;\n\n  @Override\n  Node parseSyntheticCode(String js) {\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\" [synthetic:\" + (++syntheticCodeId) + \"] \", js));\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  /**\n   * Allow subclasses to override the default CompileOptions object.\n   */\n  protected CompilerOptions newCompilerOptions() {\n    return new CompilerOptions();\n  }\n\n  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(newCompilerOptions());\n    }\n  }\n\n  @Override\n  Node parseSyntheticCode(String fileName, String js) {\n    initCompilerOptionsIfTesting();\n    return parse(SourceFile.fromCode(fileName, js));\n  }\n\n  @Override\n  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\"[testcode]\", js));\n    if (inputsById == null) {\n      inputsById = Maps.newHashMap();\n    }\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }\n\n  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }\n\n  //------------------------------------------------------------------------\n  // Convert back to source code\n  //------------------------------------------------------------------------\n\n  /**\n   * Converts the main parse tree back to js code.\n   */\n  public String toSource() {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for each input back to js code.\n   */\n  public String[] toSourceArray() {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        Tracer tracer = newTracer(\"toSourceArray\");\n        try {\n          int numInputs = inputs.size();\n          String[] sources = new String[numInputs];\n          CodeBuilder cb = new CodeBuilder();\n          for (int i = 0; i < numInputs; i++) {\n            Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n            cb.reset();\n            toSource(cb, i, scriptNode);\n            sources[i] = cb.toString();\n          }\n          return sources;\n        } finally {\n          stopTracer(tracer, \"toSourceArray\");\n        }\n      }\n    });\n  }\n\n  /**\n   * Converts the parse tree for a module back to js code.\n   */\n  public String toSource(final JSModule module) {\n    return runInCompilerThread(new Callable<String>() {\n      @Override\n      public String call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return \"\";\n        }\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module: \" + module.getName());\n          }\n          toSource(cb, i, scriptNode);\n        }\n        return cb.toString();\n      }\n    });\n  }\n\n\n  /**\n   * Converts the parse tree for each input in a module back to js code.\n   */\n  public String[] toSourceArray(final JSModule module) {\n    return runInCompilerThread(new Callable<String[]>() {\n      @Override\n      public String[] call() throws Exception {\n        List<CompilerInput> inputs = module.getInputs();\n        int numInputs = inputs.size();\n        if (numInputs == 0) {\n          return new String[0];\n        }\n\n        String[] sources = new String[numInputs];\n        CodeBuilder cb = new CodeBuilder();\n        for (int i = 0; i < numInputs; i++) {\n          Node scriptNode = inputs.get(i).getAstRoot(Compiler.this);\n          if (scriptNode == null) {\n            throw new IllegalArgumentException(\n                \"Bad module input: \" + inputs.get(i).getName());\n          }\n\n          cb.reset();\n          toSource(cb, i, scriptNode);\n          sources[i] = cb.toString();\n        }\n        return sources;\n      }\n    });\n  }\n\n  /**\n   * Writes out js code from a root node. If printing input delimiters, this\n   * method will attach a comment to the start of the text indicating which\n   * input the output derived from. If there were any preserve annotations\n   * within the root's source, they will also be printed in a block comment\n   * at the beginning of the output.\n   */\n  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n      @Override\n      public Void call() throws Exception {\n        if (options.printInputDelimiter) {\n          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            cb.append(\"\\n\");  // Make sure that the label starts on a new line\n          }\n          Preconditions.checkState(root.isScript());\n\n          String delimiter = options.inputDelimiter;\n\n          String inputName = root.getInputId().getIdName();\n          String sourceName = root.getSourceFileName();\n          Preconditions.checkState(sourceName != null);\n          Preconditions.checkState(!sourceName.isEmpty());\n\n          delimiter = delimiter\n              .replaceAll(\"%name%\", Matcher.quoteReplacement(inputName))\n              .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n          cb.append(delimiter)\n            .append(\"\\n\");\n        }\n        if (root.getJSDocInfo() != null &&\n            root.getJSDocInfo().getLicense() != null) {\n          cb.append(\"/*\\n\")\n            .append(root.getJSDocInfo().getLicense())\n            .append(\"*/\\n\");\n        }\n\n        // If there is a valid source map, then indicate to it that the current\n        // root node's mappings are offset by the given string builder buffer.\n        if (options.sourceMapOutputPath != null) {\n          sourceMap.setStartingPosition(\n              cb.getLineIndex(), cb.getColumnIndex());\n        }\n\n        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n        // for the first input file\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n        if (!code.isEmpty()) {\n          cb.append(code);\n\n          // In order to avoid parse ambiguity when files are concatenated\n          // together, all files should end in a semi-colon. Do a quick\n          // heuristic check if there's an obvious semi-colon already there.\n          int length = code.length();\n          char lastChar = code.charAt(length - 1);\n          char secondLastChar = length >= 2 ?\n              code.charAt(length - 2) : '\\0';\n          boolean hasSemiColon = lastChar == ';' ||\n              (lastChar == '\\n' && secondLastChar == ';');\n          if (!hasSemiColon) {\n            cb.append(\";\");\n          }\n        }\n        return null;\n      }\n    });\n  }\n\n  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n  }\n\n  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setPreferLineBreakAtEndOfFile(options.preferLineBreakAtEndOfFile);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }\n\n  /**\n   * Stores a buffer of text to which more can be appended.  This is just like a\n   * StringBuilder except that we also track the number of lines.\n   */\n  public static class CodeBuilder {\n    private final StringBuilder sb = new StringBuilder();\n    private int lineCount = 0;\n    private int colCount = 0;\n\n    /** Removes all text, but leaves the line count unchanged. */\n    void reset() {\n      sb.setLength(0);\n    }\n\n    /** Appends the given string to the text buffer. */\n    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }\n\n    /** Returns all text in the text buffer. */\n    @Override\n    public String toString() {\n      return sb.toString();\n    }\n\n    /** Returns the length of the text buffer. */\n    public int getLength() {\n      return sb.length();\n    }\n\n    /** Returns the (zero-based) index of the last line in the text buffer. */\n    int getLineIndex() {\n      return lineCount;\n    }\n\n    /** Returns the (zero-based) index of the last column in the text buffer. */\n    int getColumnIndex() {\n      return colCount;\n    }\n\n    /** Determines whether the text ends with the given suffix. */\n    boolean endsWith(String suffix) {\n      return (sb.length() > suffix.length())\n          && suffix.equals(sb.substring(sb.length() - suffix.length()));\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Optimizations\n  //------------------------------------------------------------------------\n\n  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker, null);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }\n\n  @Override\n  void setCssRenamingMap(CssRenamingMap map) {\n    options.cssRenamingMap = map;\n  }\n\n  @Override\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }\n\n  /**\n   * Reprocesses the current defines over the AST.  This is used by GwtCompiler\n   * to generate N outputs for different targets from the same (checked) AST.\n   * For each target, we apply the target-specific defines by calling\n   * {@code processDefines} and then {@code optimize} to optimize the AST\n   * specifically for that target.\n   */\n  public void processDefines() {\n    (new DefaultPassConfig(options)).processDefines.create(this)\n        .process(externsRoot, jsRoot);\n  }\n\n  boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }\n\n  /** Control Flow Analysis. */\n  ControlFlowGraph<Node> computeCFG() {\n    logger.fine(\"Computing Control Flow Graph\");\n    Tracer tracer = newTracer(\"computeCFG\");\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n    process(cfa);\n    stopTracer(tracer, \"computeCFG\");\n    return cfa.getCfg();\n  }\n\n  public void normalize() {\n    logger.fine(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }\n\n  @Override\n  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }\n\n  void recordFunctionInformation() {\n    logger.fine(\"Recording function information\");\n    startPass(\"recordFunctionInformation\");\n    RecordFunctionInformation recordFunctionInfoPass =\n        new RecordFunctionInformation(\n            this, getPassConfig().getIntermediateState().functionNames);\n    process(recordFunctionInfoPass);\n    functionInformationMap = recordFunctionInfoPass.getMap();\n    endPass();\n  }\n\n  protected final CodeChangeHandler.RecentChange recentChange =\n      new CodeChangeHandler.RecentChange();\n  private final List<CodeChangeHandler> codeChangeHandlers =\n      Lists.<CodeChangeHandler>newArrayList();\n\n  /** Name of the synthetic input that holds synthesized externs. */\n  static final String SYNTHETIC_EXTERNS = \"{SyntheticVarsDeclar}\";\n\n  private CompilerInput synthesizedExternsInput = null;\n\n  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }\n\n  @Override\n  void removeChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.remove(handler);\n  }\n\n  /**\n   * All passes should call reportCodeChange() when they alter\n   * the JS tree structure. This is verified by CompilerTestCase.\n   * This allows us to optimize to a fixed point.\n   */\n  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }\n\n  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }\n\n  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }\n\n  @Override\n  public boolean acceptEcmaScript5() {\n    switch (options.getLanguageIn()) {\n      case ECMASCRIPT5:\n      case ECMASCRIPT5_STRICT:\n        return true;\n    }\n    return false;\n  }\n\n  public LanguageMode languageMode() {\n    return options.getLanguageIn();\n  }\n\n  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }\n\n  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }\n\n  @Override\n  public boolean isTypeCheckingEnabled() {\n    return options.checkTypes;\n  }\n\n\n  //------------------------------------------------------------------------\n  // Error reporting\n  //------------------------------------------------------------------------\n\n  /**\n   * The warning classes that are available from the command-line, and\n   * are suppressable by the {@code @suppress} annotation.\n   */\n  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }\n\n  @Override\n  public void report(JSError error) {\n    CheckLevel level = error.getDefaultLevel();\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      if (getOptions().errorHandler != null) {\n        getOptions().errorHandler.report(level, error);\n      }\n      errorManager.report(level, error);\n    }\n  }\n\n  @Override\n  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }\n\n  /**\n   * Report an internal error.\n   */\n  @Override\n  void throwInternalError(String message, Exception cause) {\n    String finalMessage =\n      \"INTERNAL COMPILER ERROR.\\n\" +\n      \"Please report this problem.\\n\" + message;\n\n    RuntimeException e = new RuntimeException(finalMessage, cause);\n    if (cause != null) {\n      e.setStackTrace(cause.getStackTrace());\n    }\n    throw e;\n  }\n\n\n  /**\n   * Gets the number of errors.\n   */\n  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }\n\n  /**\n   * Gets the number of warnings.\n   */\n  public int getWarningCount() {\n    return errorManager.getWarningCount();\n  }\n\n  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }\n\n  /**\n   * Consults the {@link ErrorManager} to see if we've encountered errors\n   * that should halt compilation. <p>\n   *\n   * If {@link CompilerOptions#ideMode} is {@code true}, this function\n   * always returns {@code false} without consulting the error manager. The\n   * error manager will continue to be told about new errors and warnings, but\n   * the compiler will complete compilation of all inputs.<p>\n   */\n  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }\n\n  /** Called from the compiler passes, adds debug info */\n  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }\n\n  private SourceFile getSourceFileByName(String sourceName) {\n    // Here we assume that the source name is the input name, this\n    // is try of javascript parsed from source.\n    if (sourceName != null) {\n      CompilerInput input = inputsById.get(new InputId(sourceName));\n      if (input != null) {\n        return input.getSourceFile();\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }\n\n  @Override\n  public Region getSourceRegion(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getRegion(lineNumber);\n    }\n    return null;\n  }\n\n  //------------------------------------------------------------------------\n  // Package-private helpers\n  //------------------------------------------------------------------------\n\n  @Override\n  Node getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n      if (inputs.isEmpty()) {\n        throw new IllegalStateException(\"No inputs\");\n      }\n\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    List<CompilerInput> moduleInputs = module.getInputs();\n    if (moduleInputs.size() > 0) {\n      return moduleInputs.get(0).getAstRoot(this);\n    }\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }\n\n  public SourceMap getSourceMap() {\n    return sourceMap;\n  }\n\n  VariableMap getVariableMap() {\n    return getPassConfig().getIntermediateState().variableMap;\n  }\n\n  VariableMap getPropertyMap() {\n    return getPassConfig().getIntermediateState().propertyMap;\n  }\n\n  CompilerOptions getOptions() {\n    return options;\n  }\n\n  FunctionInformationMap getFunctionalInformationMap() {\n    return functionInformationMap;\n  }\n\n  /**\n   * Sets the logging level for the com.google.javascript.jscomp package.\n   */\n  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }\n\n  /** Gets the DOT graph of the AST generated at the end of compilation. */\n  public String getAstDotGraph() throws IOException {\n    if (jsRoot != null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(this, true, false);\n      cfa.process(null, jsRoot);\n      return DotFormatter.toDot(jsRoot, cfa.getCfg());\n    } else {\n      return \"\";\n    }\n  }\n\n  @Override\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(newCompilerOptions());\n    }\n    return errorManager;\n  }\n\n  @Override\n  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }\n\n  /**\n   * Returns an unmodifiable view of the compiler inputs indexed by id.\n   */\n  public Map<InputId, CompilerInput> getInputsById() {\n    return Collections.unmodifiableMap(inputsById);\n  }\n\n  /**\n   * Gets the externs in the order in which they are being processed.\n   */\n  List<CompilerInput> getExternsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(externs);\n  }\n\n  /**\n   * Stores the internal compiler state just before optimization is performed.\n   * This can be saved and restored in order to efficiently optimize multiple\n   * different output targets without having to perform checking multiple times.\n   *\n   * NOTE: This does not include all parts of the compiler's internal state. In\n   * particular, SourceFiles and CompilerOptions are not recorded. In\n   * order to recreate a Compiler instance from scratch, you would need to\n   * call {@code init} with the same arguments as in the initial creation before\n   * restoring intermediate state.\n   */\n  public static class IntermediateState implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    Node externsRoot;\n    private Node jsRoot;\n    private List<CompilerInput> externs;\n    private List<CompilerInput> inputs;\n    private List<JSModule> modules;\n    private PassConfig.State passConfigState;\n    private JSTypeRegistry typeRegistry;\n    private AbstractCompiler.LifeCycleStage lifeCycleStage;\n    private Map<String, Node> injectedLibraries;\n\n    private IntermediateState() {}\n  }\n\n  /**\n   * Returns the current internal state, excluding the input files and modules.\n   */\n  public IntermediateState getState() {\n    IntermediateState state = new IntermediateState();\n    state.externsRoot = externsRoot;\n    state.jsRoot = jsRoot;\n    state.externs = externs;\n    state.inputs = inputs;\n    state.modules = modules;\n    state.passConfigState = getPassConfig().getIntermediateState();\n    state.typeRegistry = typeRegistry;\n    state.lifeCycleStage = getLifeCycleStage();\n    state.injectedLibraries = Maps.newLinkedHashMap(injectedLibraries);\n\n    return state;\n  }\n\n  /**\n   * Sets the internal state to the capture given.  Note that this assumes that\n   * the input files are already set up.\n   */\n  public void setState(IntermediateState state) {\n    externsRoot = state.externsRoot;\n    jsRoot = state.jsRoot;\n    externs = state.externs;\n    inputs = state.inputs;\n    modules = state.modules;\n    passes = createPassConfigInternal();\n    getPassConfig().setIntermediateState(state.passConfigState);\n    typeRegistry = state.typeRegistry;\n    setLifeCycleStage(state.lifeCycleStage);\n\n    injectedLibraries.clear();\n    injectedLibraries.putAll(state.injectedLibraries);\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getInputsForTesting() {\n    return inputs;\n  }\n\n  @VisibleForTesting\n  List<CompilerInput> getExternsForTesting() {\n    return externs;\n  }\n\n  @Override\n  boolean hasRegExpGlobalReferences() {\n    return hasRegExpGlobalReferences;\n  }\n\n  @Override\n  void setHasRegExpGlobalReferences(boolean references) {\n    hasRegExpGlobalReferences = references;\n  }\n\n  @Override\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.isScript()\n        || collectionRoot.isBlock());\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n          getExternsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }\n\n  @Override\n  GlobalVarReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }\n\n  @Override\n  CompilerInput getSynthesizedExternsInput() {\n    if (synthesizedExternsInput == null) {\n      synthesizedExternsInput = newExternInput(SYNTHETIC_EXTERNS);\n    }\n    return synthesizedExternsInput;\n  }\n\n  @Override\n  public double getProgress() {\n    return progress;\n  }\n\n  @Override\n  void setProgress(double newProgress) {\n    if (newProgress > 1.0) {\n      progress = 1.0;\n    } else if (newProgress < 0.0) {\n      progress = 0.0;\n    } else {\n      progress = newProgress;\n    }\n  }\n\n  /**\n   * Replaces one file in a hot-swap mode. The given JsAst should be made\n   * from a new version of a file that already was present in the last compile\n   * call. If the file is new, this will silently ignored.\n   *\n   * @param ast the ast of the file that is being replaced\n   */\n  public void replaceScript(JsAst ast) {\n    CompilerInput input = this.getInput(ast.getInputId());\n    if (!replaceIncrementalSourceAst(ast)) {\n      return;\n    }\n    Node originalRoot = input.getAstRoot(this);\n\n    processNewScript(ast, originalRoot);\n  }\n\n  /**\n   * Adds a new Script AST to the compile state. If a script for the same file\n   * already exists the script will not be added, instead a call to\n   * #replaceScript should be used.\n   *\n   * @param ast the ast of the new file\n   */\n  public void addNewScript(JsAst ast) {\n    if (!addNewSourceAst(ast)) {\n      return;\n    }\n    Node emptyScript = new Node(Token.SCRIPT);\n    InputId inputId = ast.getInputId();\n    emptyScript.setInputId(inputId);\n    emptyScript.setStaticSourceFile(\n        SourceFile.fromCode(inputId.getIdName(), \"\"));\n\n    processNewScript(ast, emptyScript);\n  }\n\n  private void processNewScript(JsAst ast, Node originalRoot) {\n    Node js = ast.getAstRoot(this);\n    Preconditions.checkNotNull(js);\n\n    runHotSwap(originalRoot, js, this.getCleanupPassConfig());\n    // NOTE: If hot swap passes that use GlobalNamespace are added, we will need\n    // to revisit this approach to clearing GlobalNamespaces\n    runHotSwapPass(null, null, ensureDefaultPassConfig().garbageCollectChecks);\n\n    this.getTypeRegistry().clearNamedTypes();\n    this.removeSyntheticVarsInput();\n\n    runHotSwap(originalRoot, js, this.ensureDefaultPassConfig());\n  }\n\n  /**\n   * Execute the passes from a PassConfig instance over a single replaced file.\n   */\n  private void runHotSwap(\n      Node originalRoot, Node js, PassConfig passConfig) {\n    for (PassFactory passFactory : passConfig.getChecks()) {\n      runHotSwapPass(originalRoot, js, passFactory);\n    }\n  }\n\n  private void runHotSwapPass(\n      Node originalRoot, Node js, PassFactory passFactory) {\n    HotSwapCompilerPass pass = passFactory.getHotSwapPass(this);\n    if (pass != null) {\n      logger.info(\"Performing HotSwap for pass \" + passFactory.getName());\n      pass.hotSwapScript(js, originalRoot);\n    }\n  }\n\n  private PassConfig getCleanupPassConfig() {\n    return new CleanupPasses(getOptions());\n  }\n\n  private void removeSyntheticVarsInput() {\n    String sourceName = Compiler.SYNTHETIC_EXTERNS;\n    removeExternInput(new InputId(sourceName));\n  }\n\n  @Override\n  Node ensureLibraryInjected(String resourceName) {\n    if (injectedLibraries.containsKey(resourceName)) {\n      return null;\n    }\n\n    // All libraries depend on js/base.js\n    boolean isBase = \"base\".equals(resourceName);\n    if (!isBase) {\n      ensureLibraryInjected(\"base\");\n    }\n\n    Node firstChild = loadLibraryCode(resourceName).removeChildren();\n    Node lastChild = firstChild.getLastSibling();\n\n    Node parent = getNodeForCodeInsertion(null);\n    if (isBase) {\n      parent.addChildrenToFront(firstChild);\n    } else {\n      parent.addChildrenAfter(\n          firstChild, injectedLibraries.get(\"base\"));\n    }\n    reportCodeChange();\n\n    injectedLibraries.put(resourceName, lastChild);\n    return lastChild;\n  }\n\n  /** Load a library as a resource */\n  @VisibleForTesting\n  Node loadLibraryCode(String resourceName) {\n    String originalCode;\n    try {\n      originalCode = CharStreams.toString(new InputStreamReader(\n          Compiler.class.getResourceAsStream(\n              String.format(\"js/%s.js\", resourceName)),\n          Charsets.UTF_8));\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    return Normalize.parseAndNormalizeSyntheticCode(\n        this, originalCode,\n        String.format(\"jscomp_%s_\", resourceName));\n  }\n}\n"}, "generated_test_class": "To write comprehensive unit tests for the `compileModules` method, we need to cover various scenarios including normal operation, error handling, and state checking. Heres how you can structure these tests using JUnit 4 in Java 1.7:\n\n### Required Setup\n\n1. **Mockito** - This is used for mocking dependencies, which helps in isolating the behavior of the `compileModules` method.\n2. **JMockit** - Alternatively, you can use JMockit for mocking if you prefer it over Mockito.\n\nSince Mockito is widely used, I'll use it in this example. Make sure to add Mockito to your project dependencies.\n\n### Unit Tests\n\n```java\nimport com.google.javascript.jscomp.*;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport static org.junit.Assert.*;\nimport static org.mockito.ArgumentMatchers.*;\nimport static org.mockito.Mockito.*;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class CompilerTest {\n\n    @Mock\n    private ErrorManager errorManager;\n\n    @Mock\n    private JSError error;\n\n    @Mock\n    private CompilerOptions options;\n\n    @Mock\n    private SourceFile extern;\n\n    @Mock\n    private JSModule module;\n\n    private Compiler compiler;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        compiler = new Compiler();\n        compiler.setErrorManager(errorManager);\n    }\n\n    @Test(expected = IllegalStateException.class)\n    public void testCompileModules_jsRootNotNull() {\n        // Arrange\n        compiler.jsRoot = new Node(Token.EMPTY);\n\n        // Act & Assert\n        compiler.compileModules(Collections.singletonList(extern), Collections.singletonList(module), options);\n    }\n\n    @Test\n    public void testCompileModules_noErrors() {\n        // Arrange\n        when(errorManager.getErrorCount()).thenReturn(0);\n        when(errorManager.getWarnings()).thenReturn(new JSError[0]);\n\n        // Act\n        Result result = compiler.compileModules(Collections.singletonList(extern), Collections.singletonList(module), options);\n\n        // Assert\n        verify(compiler).initModules(Collections.singletonList(extern), Collections.singletonList(module), options);\n        assertEquals(Result.SUCCESS, result);\n    }\n\n    @Test\n    public void testCompileModules_withErrors() {\n        // Arrange\n        when(errorManager.getErrorCount()).thenReturn(1);\n        when(errorManager.getErrors()).thenReturn(new JSError[]{error});\n\n        // Act\n        Result result = compiler.compileModules(Collections.singletonList(extern), Collections.singletonList(module), options);\n\n        // Assert\n        verify(compiler).initModules(Collections.singletonList(extern), Collections.singletonList(module), options);\n        assertEquals(Result.FAILURE, result);\n    }\n\n    @Test\n    public void testCompileModules_withWarnings() {\n        // Arrange\n        when(errorManager.getErrorCount()).thenReturn(0);\n        when(errorManager.getWarnings()).thenReturn(new JSError[]{error});\n\n        // Act\n        Result result = compiler.compileModules(Collections.singletonList(extern), Collections.singletonList(module), options);\n\n        // Assert\n        verify(compiler).initModules(Collections.singletonList(extern), Collections.singletonList(module), options);\n        assertEquals(Result.SUCCESS, result); // Warnings are not considered a failure\n    }\n\n    @Test\n    public void testCompileModules_withErrorsAndWarnings() {\n        // Arrange\n        when(errorManager.getErrorCount()).thenReturn(1);\n        when(errorManager.getErrors()).thenReturn(new JSError[]{error});\n        when(errorManager.getWarnings()).thenReturn(new JSError[]{error});\n\n        // Act\n        Result result = compiler.compileModules(Collections.singletonList(extern), Collections.singletonList(module), options);\n\n        // Assert\n        verify(compiler).initModules(Collections.singletonList(extern), Collections.singletonList(module), options);\n        assertEquals(Result.FAILURE, result);\n    }\n\n    @Test\n    public void testCompileModules_emptyExternsModules() {\n        // Arrange\n        when(errorManager.getErrorCount()).thenReturn(0);\n        when(errorManager.getWarnings()).thenReturn(new JSError[0]);\n\n        // Act\n        Result result = compiler.compileModules(Collections.<SourceFile>emptyList(), Collections.<JSModule>emptyList(), options);\n\n        // Assert\n        verify(compiler).initModules(Collections.<SourceFile>emptyList(), Collections.<JSModule>emptyList(), options);\n        assertEquals(Result.SUCCESS, result);\n    }\n\n    @Test\n    public void testCompileModules_generateReportCalled() {\n        // Arrange\n        when(errorManager.getErrorCount()).thenReturn(0);\n        when(errorManager.getWarnings()).thenReturn(new JSError[0]);\n\n        // Act\n        compiler.compileModules(Collections.singletonList(extern), Collections.singletonList(module), options);\n\n        // Assert\n        verify(errorManager).generateReport();\n    }\n}\n```\n\n### Explanation of Tests\n\n1. **testCompileModules_jsRootNotNull**: Tests if the method throws an `IllegalStateException` when `jsRoot` is not null.\n2. **testCompileModules_noErrors**: Ensures that the method returns `Result.SUCCESS` when there are no errors or warnings.\n3. **testCompileModules_withErrors**: Verifies that the method returns `Result.FAILURE` when there are errors.\n4. **testCompileModules_withWarnings**: Ensures that the method returns `Result.SUCCESS` when there are only warnings.\n5. **testCompileModules_withErrorsAndWarnings**: Verifies that the method returns `Result.FAILURE` when there are both errors and warnings.\n6. **testCompileModules_emptyExternsModules**: Ensures that the method can handle empty lists for externs and modules.\n7. **testCompileModules_generateReportCalled**: Confirms that the `generateReport` method of the `ErrorManager` is called regardless of the outcome.\n\n### Notes\n\n- **Mocking**: The use of Mockito to mock `ErrorManager`, `CompilerOptions`, `SourceFile`, and `JSModule` allows for controlled testing without the need for actual implementations.\n- **Preconditions**: The `Preconditions.checkState` call is a safeguard against multiple calls to `compileModules`. It ensures that the method behaves correctly when `jsRoot` is already set.\n\nThis test suite should help ensure that the `compileModules` method is well-tested for various scenarios and edge cases."}
