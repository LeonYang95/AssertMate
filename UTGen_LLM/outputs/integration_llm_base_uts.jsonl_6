{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }", "return_type": "Dfp", "assertion_subject_candidates": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "int org.apache.commons.math.dfp.Dfp#hashCode()", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "int org.apache.commons.math.dfp.Dfp#log10K()", "int org.apache.commons.math.dfp.Dfp#classify()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Certainly! Below are unit tests for the `newInstance(Dfp d)` method in the `Dfp` class. These tests aim to cover all branches and maximize line coverage.\n\nFirst, ensure you have JUnit 4 in your project dependencies. If you're using Maven, you can add the following to your `pom.xml`:\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\nNow, here are the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n\n    private DfpField field;\n    private Dfp dfpInstance;\n\n    @Before\n    public void setUp() {\n        field = new DfpField(20);  // Assuming 20 is a valid radix digits for this context\n        dfpInstance = field.newDfp(0);\n    }\n\n    @Test\n    public void testNewInstance_SamePrecision() {\n        Dfp anotherDfpInstance = field.newDfp(5);\n\n        Dfp result = dfpInstance.newInstance(anotherDfpInstance);\n\n        assertNotNull(result);\n        assertEquals(dfpInstance.getField(), result.getField());\n        assertEquals(anotherDfpInstance.sign, result.sign);\n        assertEquals(anotherDfpInstance.exp, result.exp);\n        assertArrayEquals(anotherDfpInstance.mant, result.mant);\n        assertEquals(anotherDfpInstance.nans, result.nans);\n    }\n\n    @Test\n    public void testNewInstance_DifferentPrecision() {\n        DfpField anotherField = new DfpField(30);  // Different radix digits\n        Dfp anotherDfpInstance = anotherField.newDfp(5);\n\n        Dfp result = dfpInstance.newInstance(anotherDfpInstance);\n\n        assertNotNull(result);\n        assertEquals(field, result.getField());\n        assertEquals(Dfp.QNAN, result.nans);\n        assertEquals(DfpField.FLAG_INVALID, field.getIEEEFlags());\n    }\n\n    @Test\n    public void testNewInstance_WithZero() {\n        Dfp zeroDfp = field.newDfp(0);\n        Dfp result = dfpInstance.newInstance(zeroDfp);\n\n        assertNotNull(result);\n        assertEquals(field, result.getField());\n        assertEquals(zeroDfp.sign, result.sign);\n        assertEquals(zeroDfp.exp, result.exp);\n        assertArrayEquals(zeroDfp.mant, result.mant);\n        assertEquals(zeroDfp.nans, result.nans);\n    }\n\n    @Test\n    public void testNewInstance_WithOne() {\n        Dfp oneDfp = field.newDfp(1);\n        Dfp result = dfpInstance.newInstance(oneDfp);\n\n        assertNotNull(result);\n        assertEquals(field, result.getField());\n        assertEquals(oneDfp.sign, result.sign);\n        assertEquals(oneDfp.exp, result.exp);\n        assertArrayEquals(oneDfp.mant, result.mant);\n        assertEquals(oneDfp.nans, result.nans);\n    }\n\n    @Test\n    public void testNewInstance_WithNegativeValue() {\n        Dfp negativeDfp = field.newDfp(-7);\n        Dfp result = dfpInstance.newInstance(negativeDfp);\n\n        assertNotNull(result);\n        assertEquals(field, result.getField());\n        assertEquals(negativeDfp.sign, result.sign);\n        assertEquals(negativeDfp.exp, result.exp);\n        assertArrayEquals(negativeDfp.mant, result.mant);\n        assertEquals(negativeDfp.nans, result.nans);\n    }\n\n    @Test\n    public void testNewInstance_WithNan() {\n        DfpField anotherField = new DfpField(20);\n        Dfp nanDfp = anotherField.newInstance(Dfp.QNAN, Dfp.QNAN);\n        Dfp result = dfpInstance.newInstance(nanDfp);\n\n        assertNotNull(result);\n        assertEquals(field, result.getField());\n        assertEquals(Dfp.QNAN, result.nans);\n        assertEquals(DfpField.FLAG_INVALID, field.getIEEEFlags());\n    }\n}\n```\n\n### Explanation:\n\n1. **testNewInstance_SamePrecision**: Tests creating a new `Dfp` instance from another `Dfp` instance with the same precision.\n2. **testNewInstance_DifferentPrecision**: Tests creating a new `Dfp` instance from another `Dfp` instance with different precision, which should result in an invalid flag being set and a NaN value.\n3. **testNewInstance_WithZero**: Tests creating a new `Dfp` instance from a zero value.\n4. **testNewInstance_WithOne**: Tests creating a new `Dfp` instance from a one value.\n5. **testNewInstance_WithNegativeValue**: Tests creating a new `Dfp` instance from a negative value.\n6. **testNewInstance_WithNan**: Tests creating a new `Dfp` instance from a NaN value with different precision, which should result in an invalid flag being set and a NaN value.\n\nThese tests should provide comprehensive coverage of the `newInstance(Dfp d)` method."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }", "return_type": "boolean", "assertion_subject_candidates": ["boolean", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Certainly! Below are unit tests for the `lessThan` method in the `Dfp` class. These tests aim to maximize both branch and line coverage.\n\nFirst, ensure you have JUnit 4 in your project dependencies. If you are using Maven, you can add the following dependency in your `pom.xml`:\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\nNow, let's write the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\npublic class DfpTest {\n\n    private DfpField mockField;\n    private Dfp dfp1;\n    private Dfp dfp2;\n\n    @Before\n    public void setUp() {\n        mockField = mock(DfpField.class);\n        when(mockField.getRadixDigits()).thenReturn(20); // Assuming some default precision for testing\n\n        dfp1 = new Dfp(mockField) {\n            @Override\n            public int compare(Dfp x, Dfp y) {\n                // Mock comparison logic for testing\n                return Integer.compare(this.exp, y.exp);\n            }\n\n            @Override\n            public Dfp newInstance(int x) {\n                return new Dfp(mockField);\n            }\n\n            @Override\n            public Dfp newInstance(Dfp d) {\n                return new Dfp(mockField);\n            }\n\n            @Override\n            public boolean isNaN() {\n                return this.nans == QNAN || this.nans == SNAN;\n            }\n\n            @Override\n            public String toString() {\n                return \"Dfp{\" +\n                        \"sign=\" + sign +\n                        \", exp=\" + exp +\n                        \", nans=\" + nans +\n                        '}';\n            }\n        };\n        dfp2 = new Dfp(mockField) {\n            @Override\n            public boolean isNaN() {\n                return this.nans == QNAN || this.nans == SNAN;\n            }\n\n            @Override\n            public Dfp newInstance(int x) {\n                return new Dfp(mockField);\n            }\n\n            @Override\n            public Dfp newInstance(Dfp d) {\n                return new Dfp(mockField);\n            }\n\n            @Override\n            public String toString() {\n                return \"Dfp{\" +\n                        \"sign=\" + sign +\n                        \", exp=\" + exp +\n                        \", nans=\" + nans +\n                        '}';\n            }\n        };\n    }\n\n    @Test\n    public void testLessThan_SamePrecision_Dfp1LessThanDfp2() {\n        dfp1.exp = 1;\n        dfp2.exp = 2;\n        assertTrue(dfp1.lessThan(dfp2));\n    }\n\n    @Test\n    public void testLessThan_SamePrecision_Dfp1GreaterThanDfp2() {\n        dfp1.exp = 3;\n        dfp2.exp = 2;\n        assertFalse(dfp1.lessThan(dfp2));\n    }\n\n    @Test\n    public void testLessThan_SamePrecision_Dfp1EqualDfp2() {\n        dfp1.exp = 2;\n        dfp2.exp = 2;\n        assertFalse(dfp1.lessThan(dfp2));\n    }\n\n    @Test\n    public void testLessThan_DifferentPrecision() {\n        DfpField mockField2 = mock(DfpField.class);\n        when(mockField2.getRadixDigits()).thenReturn(30); // Different precision\n\n        Dfp dfp3 = new Dfp(mockField2) {\n            @Override\n            public boolean isNaN() {\n                return this.nans == QNAN || this.nans == SNAN;\n            }\n\n            @Override\n            public Dfp newInstance(int x) {\n                return new Dfp(mockField2);\n            }\n\n            @Override\n            public Dfp newInstance(Dfp d) {\n                return new Dfp(mockField2);\n            }\n\n            @Override\n            public String toString() {\n                return \"Dfp{\" +\n                        \"sign=\" + sign +\n                        \", exp=\" + exp +\n                        \", nans=\" + nans +\n                        '}';\n            }\n        };\n\n        assertFalse(dfp1.lessThan(dfp3));\n        verify(mockField).setIEEEFlagsBits(DfpField.FLAG_INVALID);\n    }\n\n    @Test\n    public void testLessThan_Dfp1IsNaN() {\n        dfp1.nans = QNAN;\n        assertFalse(dfp1.lessThan(dfp2));\n        verify(mockField).setIEEEFlagsBits(DfpField.FLAG_INVALID);\n    }\n\n    @Test\n    public void testLessThan_Dfp2IsNaN() {\n        dfp2.nans = QNAN;\n        assertFalse(dfp1.lessThan(dfp2));\n        verify(mockField).setIEEEFlagsBits(DfpField.FLAG_INVALID);\n    }\n\n    @Test\n    public void testLessThan_BothAreNaN() {\n        dfp1.nans = QNAN;\n        dfp2.nans = QNAN;\n        assertFalse(dfp1.lessThan(dfp2));\n        verify(mockField, times(2)).setIEEEFlagsBits(DfpField.FLAG_INVALID);\n    }\n}\n```\n\n### Explanation of Tests\n\n1. **testLessThan_SamePrecision_Dfp1LessThanDfp2**: Tests the scenario where both `dfp1` and `dfp2` have the same precision, and `dfp1` has a smaller exponent than `dfp2`.\n\n2. **testLessThan_SamePrecision_Dfp1GreaterThanDfp2**: Tests the scenario where both `dfp1` and `dfp2` have the same precision, and `dfp1` has a larger exponent than `dfp2`.\n\n3. **testLessThan_SamePrecision_Dfp1EqualDfp2**: Tests the scenario where both `dfp1` and `dfp2` have the same precision and the same exponent.\n\n4. **testLessThan_DifferentPrecision**: Tests the scenario where `dfp1` and `dfp2` have different precision. It verifies that the method sets the IEEE flags correctly and returns `false`.\n\n5. **testLessThan_Dfp1IsNaN**: Tests the scenario where `dfp1` is NaN, which should set the IEEE flags and return `false`.\n\n6. **testLessThan_Dfp2IsNaN**: Tests the scenario where `dfp2` is NaN, which should set the IEEE flags and return `false`.\n\n7. **testLessThan_BothAreNaN**: Tests the scenario where both `dfp1` and `dfp2` are NaN, which should set the IEEE flags twice and return `false`.\n\nThese tests ensure that all branches and lines in the `lessThan` method are covered."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }", "return_type": "boolean", "assertion_subject_candidates": ["boolean", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Sure, I'll write some unit tests for the `greaterThan` method in the `Dfp` class using Java 1.7 and JUnit 4. The tests will cover different scenarios to maximize both branch and line coverage, including cases with different precision numbers, NaN values, and regular numeric comparisons.\n\nFirst, make sure you have the JUnit 4 library in your project dependencies. If you're using Maven, you can add the following dependency to your `pom.xml`:\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\nNow, let's write the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n\n    private DfpField field;\n    private Dfp dfp1;\n    private Dfp dfp2;\n    private Dfp nanDfp;\n    private Dfp infDfp;\n    private Dfp negInfDfp;\n\n    @Before\n    public void setUp() {\n        field = new DfpField(16);  // Assuming DfpField constructor takes the precision as argument\n        dfp1 = field.getOne();\n        dfp2 = field.getTwo();\n        nanDfp = field.newInstance(Dfp.NaN_STRING);\n        infDfp = field.newInstance(Dfp.POS_INFINITY_STRING);\n        negInfDfp = field.newInstance(Dfp.NEG_INFINITY_STRING);\n    }\n\n    @Test\n    public void testGreaterThan_DifferentPrecision() {\n        DfpField otherField = new DfpField(32);\n        Dfp otherDfp = otherField.getOne();\n        \n        assertFalse(dfp1.greaterThan(otherDfp));\n        assertEquals(Dfp.QNAN, field.newInstance(getZero()).nans);\n        assertEquals(DfpField.FLAG_INVALID, field.getIEEEFlags());\n    }\n\n    @Test\n    public void testGreaterThan_BothNaN() {\n        assertFalse(nanDfp.greaterThan(nanDfp));\n        assertEquals(Dfp.QNAN, field.newInstance(getZero()).nans);\n        assertEquals(DfpField.FLAG_INVALID, field.getIEEEFlags());\n    }\n\n    @Test\n    public void testGreaterThan_FirstNaN() {\n        assertFalse(nanDfp.greaterThan(dfp1));\n        assertEquals(Dfp.QNAN, field.newInstance(getZero()).nans);\n        assertEquals(DfpField.FLAG_INVALID, field.getIEEEFlags());\n    }\n\n    @Test\n    public void testGreaterThan_SecondNaN() {\n        assertFalse(dfp1.greaterThan(nanDfp));\n        assertEquals(Dfp.QNAN, field.newInstance(getZero()).nans);\n        assertEquals(DfpField.FLAG_INVALID, field.getIEEEFlags());\n    }\n\n    @Test\n    public void testGreaterThan_FirstPositiveInfinite() {\n        assertTrue(infDfp.greaterThan(dfp1));\n        assertFalse(infDfp.greaterThan(infDfp));\n        assertEquals(0, field.getIEEEFlags());\n    }\n\n    @Test\n    public void testGreaterThan_SecondPositiveInfinite() {\n        assertFalse(dfp1.greaterThan(infDfp));\n        assertEquals(0, field.getIEEEFlags());\n    }\n\n    @Test\n    public void testGreaterThan_FirstNegativeInfinite() {\n        assertFalse(negInfDfp.greaterThan(dfp1));\n        assertFalse(negInfDfp.greaterThan(negInfDfp));\n        assertEquals(0, field.getIEEEFlags());\n    }\n\n    @Test\n    public void testGreaterThan_SecondNegativeInfinite() {\n        assertTrue(dfp1.greaterThan(negInfDfp));\n        assertEquals(0, field.getIEEEFlags());\n    }\n\n    @Test\n    public void testGreaterThan_NegativeAndPositive() {\n        assertFalse(dfp1.greaterThan(dfp2));\n        assertTrue(dfp2.greaterThan(dfp1));\n        assertEquals(0, field.getIEEEFlags());\n    }\n\n    @Test\n    public void testGreaterThan_EqualValues() {\n        assertFalse(dfp1.greaterThan(dfp1));\n        assertEquals(0, field.getIEEEFlags());\n    }\n\n    private int[] getZero() {\n        return new int[field.getRadixDigits() + 1];\n    }\n}\n```\n\n### Explanation:\n1. **Different Precision Test**: Ensures the method correctly handles numbers with different precision by setting the IEEE flags and returning `false`.\n2. **NaN Tests**: Ensures the method handles NaN values correctly by setting the IEEE flags and returning `false`.\n3. **Infinite Tests**: Ensures the method handles positive and negative infinite values correctly.\n4. **Regular Comparison Tests**: Ensures the method correctly compares regular numeric values, including cases where the values are equal.\n\nThis set of tests should cover the different branches and provide good line coverage for the `greaterThan` method."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "@Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }", "return_type": "boolean", "assertion_subject_candidates": ["boolean", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "To achieve maximum branch and line coverage for the `equals` method in the `Dfp` class, we need to test various scenarios, including:\n\n1. Comparing two `Dfp` instances that are both finite and equal.\n2. Comparing two `Dfp` instances that are both finite but not equal.\n3. Comparing a `Dfp` instance with a non-`Dfp` object.\n4. Comparing a `Dfp` instance with another `Dfp` instance that has a different number of radix digits.\n5. Comparing two `Dfp` instances that are both `NaN`.\n6. Comparing a `Dfp` instance that is `NaN` with a finite `Dfp` instance.\n\nBelow are the unit tests in Java 1.7 with JUnit 4:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\nimport static org.mockito.Mockito.*;\n\npublic class DfpTest {\n\n    private DfpField mockField;\n\n    @Before\n    public void setUp() {\n        mockField = mock(DfpField.class);\n        when(mockField.getRadixDigits()).thenReturn(10); // Assuming 10 radix digits for simplicity\n    }\n\n    @Test\n    public void testEquals_FiniteEqual() {\n        Dfp dfp1 = new Dfp(mockField) {\n            @Override\n            public boolean isNaN() {\n                return false;\n            }\n\n            @Override\n            public int compare(Dfp x, Dfp y) {\n                return 0;\n            }\n        };\n\n        Dfp dfp2 = new Dfp(mockField) {\n            @Override\n            public boolean isNaN() {\n                return false;\n            }\n\n            @Override\n            public int compare(Dfp x, Dfp y) {\n                return 0;\n            }\n        };\n\n        assertTrue(dfp1.equals(dfp2));\n    }\n\n    @Test\n    public void testEquals_FiniteNotEqual() {\n        Dfp dfp1 = new Dfp(mockField) {\n            @Override\n            public boolean isNaN() {\n                return false;\n            }\n\n            @Override\n            public int compare(Dfp x, Dfp y) {\n                return -1;\n            }\n        };\n\n        Dfp dfp2 = new Dfp(mockField) {\n            @Override\n            public boolean isNaN() {\n                return false;\n            }\n\n            @Override\n            public int compare(Dfp x, Dfp y) {\n                return 1;\n            }\n        };\n\n        assertFalse(dfp1.equals(dfp2));\n    }\n\n    @Test\n    public void testEquals_NonDfpObject() {\n        Dfp dfp = new Dfp(mockField) {\n            @Override\n            public boolean isNaN() {\n                return false;\n            }\n        };\n\n        assertFalse(dfp.equals(new Object()));\n    }\n\n    @Test\n    public void testEquals_DifferentRadixDigits() {\n        DfpField mockField2 = mock(DfpField.class);\n        when(mockField2.getRadixDigits()).thenReturn(20); // Different radix digits\n\n        Dfp dfp1 = new Dfp(mockField) {\n            @Override\n            public boolean isNaN() {\n                return false;\n            }\n        };\n\n        Dfp dfp2 = new Dfp(mockField2) {\n            @Override\n            public boolean isNaN() {\n                return false;\n            }\n        };\n\n        assertFalse(dfp1.equals(dfp2));\n    }\n\n    @Test\n    public void testEquals_BothNaN() {\n        Dfp dfp1 = new Dfp(mockField) {\n            @Override\n            public boolean isNaN() {\n                return true;\n            }\n        };\n\n        Dfp dfp2 = new Dfp(mockField) {\n            @Override\n            public boolean isNaN() {\n                return true;\n            }\n        };\n\n        assertFalse(dfp1.equals(dfp2));\n    }\n\n    @Test\n    public void testEquals_OneNaN() {\n        Dfp dfp1 = new Dfp(mockField) {\n            @Override\n            public boolean isNaN() {\n                return true;\n            }\n        };\n\n        Dfp dfp2 = new Dfp(mockField) {\n            @Override\n            public boolean isNaN() {\n                return false;\n            }\n        };\n\n        assertFalse(dfp1.equals(dfp2));\n    }\n}\n```\n\n### Explanation:\n\n1. **testEquals_FiniteEqual**: Tests the scenario where both `Dfp` instances are finite and equal.\n2. **testEquals_FiniteNotEqual**: Tests the scenario where both `Dfp` instances are finite but not equal.\n3. **testEquals_NonDfpObject**: Tests the scenario where the object to compare with is not an instance of `Dfp`.\n4. **testEquals_DifferentRadixDigits**: Tests the scenario where both `Dfp` instances have different numbers of radix digits.\n5. **testEquals_BothNaN**: Tests the scenario where both `Dfp` instances are `NaN`.\n6. **testEquals_OneNaN**: Tests the scenario where one of the `Dfp` instances is `NaN` and the other is not.\n\nThese tests should cover the branches and lines in the `equals` method comprehensively."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }", "return_type": "boolean", "assertion_subject_candidates": ["boolean", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Sure, let's write some unit tests for the `unequal` method in the `Dfp` class. We will cover different branches including when either or both `Dfp` objects are NaN, when the radix digits differ, and when the values are actually unequal. Here's how you can structure your tests using JUnit 4:\n\nFirst, ensure you have JUnit 4 added to your project. If you are using Maven, you can add the following dependency in your `pom.xml`:\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\nNow, you can write the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n\n    private DfpField field;\n    private Dfp zero;\n    private Dfp one;\n    private Dfp two;\n    private Dfp inf;\n    private Dfp nInf;\n    private Dfp nan;\n\n    @Before\n    public void setUp() {\n        field = new DfpField(20);  // Assuming 20 as the number of radix digits for this test\n        zero = field.getZero();\n        one = field.getOne();\n        two = field.getTwo();\n        inf = field.newDfp(\"Infinity\");\n        nInf = field.newDfp(\"-Infinity\");\n        nan = field.newDfp(\"NaN\");\n    }\n\n    @Test\n    public void testUnequal_BothFiniteAndUnequal() {\n        assertTrue(one.unequal(two));\n        assertTrue(two.unequal(one));\n    }\n\n    @Test\n    public void testUnequal_BothFiniteAndEqual() {\n        assertFalse(one.unequal(one));\n        assertFalse(two.unequal(two));\n    }\n\n    @Test\n    public void testUnequal_OneIsNaN() {\n        assertFalse(nan.unequal(one));\n        assertFalse(one.unequal(nan));\n    }\n\n    @Test\n    public void testUnequal_BothAreNaN() {\n        assertFalse(nan.unequal(nan));\n    }\n\n    @Test\n    public void testUnequal_OneIsInfinite() {\n        assertFalse(inf.unequal(inf));\n        assertFalse(inf.unequal(one));\n        assertFalse(one.unequal(inf));\n    }\n\n    @Test\n    public void testUnequal_OneIsNegativeInfinite() {\n        assertFalse(nInf.unequal(nInf));\n        assertFalse(nInf.unequal(one));\n        assertFalse(one.unequal(nInf));\n    }\n\n    @Test\n    public void testUnequal_InfiniteAndFinite() {\n        assertTrue(inf.unequal(one));\n        assertTrue(one.unequal(inf));\n    }\n\n    @Test\n    public void testUnequal_InfiniteAndNegativeInfinite() {\n        assertTrue(inf.unequal(nInf));\n        assertTrue(nInf.unequal(inf));\n    }\n\n    @Test\n    public void testUnequal_DifferentRadixDigits() {\n        DfpField otherField = new DfpField(25);\n        Dfp otherZero = otherField.getZero();\n        assertFalse(zero.unequal(otherZero));\n    }\n\n    // Mocking of DfpField and Dfp is needed for some of the test scenarios above\n    // as JUnit does not support mocking out of the box. You might need to use\n    // a mocking framework like Mockito for advanced testing scenarios.\n}\n```\n\nFor the `DfpField` and `Dfp` classes, some mocking might be necessary to fully simulate different scenarios, especially when testing `field.getRadixDigits()` and other field-related methods. If you are using Mockito, you can mock the `DfpField` to return different radix digits for testing.\n\nHowever, for simplicity, I've assumed you can create instances of `Dfp` directly using the `DfpField` methods. If you need to simulate different field settings, consider using a mocking framework like Mockito to mock the `DfpField` class.\n\nHere is an example of how you might use Mockito to simulate different radix digits:\n\n```java\nimport static org.mockito.Mockito.*;\n\n@Test\npublic void testUnequal_DifferentRadixDigitsWithMocking() {\n    DfpField field1 = mock(DfpField.class);\n    DfpField field2 = mock(DfpField.class);\n    when(field1.getRadixDigits()).thenReturn(20);\n    when(field2.getRadixDigits()).thenReturn(25);\n\n    Dfp zero1 = new Dfp(field1, 0);\n    Dfp zero2 = new Dfp(field2, 0);\n\n    assertFalse(zero1.unequal(zero2));\n}\n```\n\nThis test uses Mockito to mock the `DfpField` class to simulate different radix digits for two `Dfp` instances. The `unequal` method should return `false` when the radix digits differ."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }", "return_type": "Dfp", "assertion_subject_candidates": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "int org.apache.commons.math.dfp.Dfp#hashCode()", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "int org.apache.commons.math.dfp.Dfp#log10K()", "int org.apache.commons.math.dfp.Dfp#classify()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `remainder` method in the `Dfp` class using Java 1.7 and JUnit 4. These tests aim to maximize branch and line coverage by considering various scenarios, including edge cases.\n\nFirst, ensure you have JUnit 4 included in your project dependencies. If you're using Maven, you can add it to your `pom.xml` like this:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.13.2</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\nNow, here are the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n\n    private DfpField field;\n\n    @Before\n    public void setUp() {\n        field = new DfpField(10000); // Assuming DfpField constructor is available\n    }\n\n    @Test\n    public void testRemainderPositiveDividendPositiveDivisor() {\n        Dfp dividend = field.newInstance(11);\n        Dfp divisor = field.newInstance(3);\n        Dfp expected = field.newInstance(2);\n        Dfp result = dividend.remainder(divisor);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemainderNegativeDividendPositiveDivisor() {\n        Dfp dividend = field.newInstance(-11);\n        Dfp divisor = field.newInstance(3);\n        Dfp expected = field.newInstance(-2);\n        Dfp result = dividend.remainder(divisor);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemainderPositiveDividendNegativeDivisor() {\n        Dfp dividend = field.newInstance(11);\n        Dfp divisor = field.newInstance(-3);\n        Dfp expected = field.newInstance(2);\n        Dfp result = dividend.remainder(divisor);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemainderNegativeDividendNegativeDivisor() {\n        Dfp dividend = field.newInstance(-11);\n        Dfp divisor = field.newInstance(-3);\n        Dfp expected = field.newInstance(-2);\n        Dfp result = dividend.remainder(divisor);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemainderDividendZero() {\n        Dfp dividend = field.getZero();\n        Dfp divisor = field.newInstance(3);\n        Dfp expected = field.getZero();\n        Dfp result = dividend.remainder(divisor);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemainderDivisorZero() {\n        Dfp dividend = field.newInstance(11);\n        Dfp divisor = field.getZero();\n        try {\n            dividend.remainder(divisor);\n            fail(\"Expected ArithmeticException for division by zero\");\n        } catch (ArithmeticException e) {\n            // Expected exception\n        }\n    }\n\n    @Test\n    public void testRemainderExactDivision() {\n        Dfp dividend = field.newInstance(12);\n        Dfp divisor = field.newInstance(3);\n        Dfp expected = field.getZero();\n        Dfp result = dividend.remainder(divisor);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testRemainderResultZeroSign() {\n        Dfp dividend = field.newInstance(12);\n        Dfp divisor = field.newInstance(3);\n        Dfp result = dividend.remainder(divisor);\n        assertEquals(field.getZero().sign, result.sign);\n    }\n\n    @Test\n    public void testRemainderResultNegativeSign() {\n        Dfp dividend = field.newInstance(-12);\n        Dfp divisor = field.newInstance(3);\n        Dfp result = dividend.remainder(divisor);\n        assertEquals(-1, result.sign);\n    }\n\n    @Test\n    public void testRemainderResultPositiveSign() {\n        Dfp dividend = field.newInstance(12);\n        Dfp divisor = field.newInstance(-3);\n        Dfp result = dividend.remainder(divisor);\n        assertEquals(1, result.sign);\n    }\n}\n```\n\n### Explanation:\n\n1. **Positive Dividend and Divisor**: Checks a simple positive remainder operation.\n2. **Negative Dividend and Positive Divisor**: Ensures the sign of the result is correctly negative.\n3. **Positive Dividend and Negative Divisor**: Ensures the sign of the result is correctly positive.\n4. **Negative Dividend and Negative Divisor**: Ensures the sign of the result is correctly negative.\n5. **Dividend Zero**: Tests the scenario where the dividend is zero.\n6. **Divisor Zero**: Tests for division by zero, expecting an `ArithmeticException`.\n7. **Exact Division**: Ensures that if the division is exact, the remainder is zero.\n8. **Result Zero Sign**: Ensures the sign of the zero result is correctly inherited from the dividend.\n9. **Result Negative Sign**: Ensures the sign of the result is negative when the dividend is negative.\n10. **Result Positive Sign**: Ensures the sign of the result is positive when the divisor is negative.\n\nThese tests should help achieve good coverage of both branches and lines in the `remainder` method."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "int org.apache.commons.math.dfp.Dfp#intValue()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }", "return_type": "int", "assertion_subject_candidates": ["int", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `intValue()` method of the `Dfp` class. These tests aim to maximize both branch and line coverage.\n\nFirst, ensure you have JUnit 4 in your project dependencies. If you're using Maven, you can add the following dependency to your `pom.xml`:\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\nHere are the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n\n    private DfpField field;\n\n    @Before\n    public void setUp() {\n        // Assuming DfpField has a default constructor or a way to get an instance\n        field = new DfpField();\n    }\n\n    @Test\n    public void testIntValuePositive() {\n        Dfp dfp = field.newInstance(12345);\n        assertEquals(12345, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueNegative() {\n        Dfp dfp = field.newInstance(-12345);\n        assertEquals(-12345, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueZero() {\n        Dfp dfp = field.newInstance(0);\n        assertEquals(0, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueMaxInt() {\n        Dfp dfp = field.newInstance(Integer.MAX_VALUE);\n        assertEquals(Integer.MAX_VALUE, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueMinInt() {\n        Dfp dfp = field.newInstance(Integer.MIN_VALUE);\n        assertEquals(Integer.MIN_VALUE, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueGreaterThanMaxInt() {\n        Dfp dfp = field.newInstance(2147483648L); // 2^31\n        assertEquals(Integer.MAX_VALUE, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueLessThanMinInt() {\n        Dfp dfp = field.newInstance(-2147483649L); // -(2^31 + 1)\n        assertEquals(Integer.MIN_VALUE, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueRoundedToMaxInt() {\n        Dfp dfp = field.newInstance(2147483647.99);\n        assertEquals(Integer.MAX_VALUE, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueRoundedToMinInt() {\n        Dfp dfp = field.newInstance(-2147483648.99);\n        assertEquals(Integer.MIN_VALUE, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueEdgeCasePositive() {\n        Dfp dfp = field.newInstance(1.0);\n        assertEquals(1, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueEdgeCaseNegative() {\n        Dfp dfp = field.newInstance(-1.0);\n        assertEquals(-1, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueNegativeWithDecimal() {\n        Dfp dfp = field.newInstance(-1.5);\n        assertEquals(-2, dfp.intValue()); // Rounding to nearest integer\n    }\n\n    @Test\n    public void testIntValuePositiveWithDecimal() {\n        Dfp dfp = field.newInstance(1.5);\n        assertEquals(2, dfp.intValue()); // Rounding to nearest integer\n    }\n\n    @Test\n    public void testIntValueRoundingTiesToEven() {\n        // Test rounding behavior when the decimal part is exactly 0.5\n        Dfp dfpEven = field.newInstance(2.5);\n        assertEquals(2, dfpEven.intValue()); // 2.5 rounds to 2 (even)\n\n        Dfp dfpOdd = field.newInstance(3.5);\n        assertEquals(4, dfpOdd.intValue()); // 3.5 rounds to 4 (even)\n    }\n\n    @Test\n    public void testIntValueLargePositive() {\n        Dfp dfp = field.newInstance(1000000000L);\n        assertEquals(1000000000, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueLargeNegative() {\n        Dfp dfp = field.newInstance(-1000000000L);\n        assertEquals(-1000000000, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValuePositiveFraction() {\n        Dfp dfp = field.newInstance(0.999999999);\n        assertEquals(0, dfp.intValue()); // Rounds towards zero\n    }\n\n    @Test\n    public void testIntValueNegativeFraction() {\n        Dfp dfp = field.newInstance(-0.999999999);\n        assertEquals(0, dfp.intValue()); // Rounds towards zero\n    }\n\n    @Test\n    public void testIntValuePositiveJustBelowMax() {\n        Dfp dfp = field.newInstance(2147483646.999999999);\n        assertEquals(2147483646, dfp.intValue());\n    }\n\n    @Test\n    public void testIntValueNegativeJustAboveMin() {\n        Dfp dfp = field.newInstance(-2147483647.999999999);\n        assertEquals(-2147483647, dfp.intValue());\n    }\n}\n```\n\n### Explanation:\n- **Positive, Negative, and Zero Values**: Tests for converting simple positive, negative, and zero values.\n- **Boundary Values**: Tests for the maximum and minimum integer values and edge cases around these boundaries.\n- **Rounding Behavior**: Tests for rounding decimal numbers to the nearest integer, including ties-to-even behavior.\n- **Large Values**: Tests for very large positive and negative values.\n- **Fractional Values**: Tests for fractional values that should round towards zero.\n\nThese tests should help ensure comprehensive coverage of the `intValue()` method's logic, including edge cases and rounding behavior."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "int org.apache.commons.math.dfp.Dfp#log10()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }", "return_type": "int", "assertion_subject_candidates": ["int", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Sure, I'll write some unit tests for the `log10` method in the `Dfp` class. The goal is to maximize both branch and line coverage. Here are the test cases:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class DfpTest {\n\n    private Dfp dfp;\n    private DfpField field;\n\n    @Before\n    public void setUp() {\n        field = new DfpField(10); // Assuming DfpField constructor exists with this signature for testing\n        dfp = new Dfp(field);\n    }\n\n    @Test\n    public void testLog10_MantGreaterThan1000() {\n        dfp.mant = new int[]{0, 5000}; // Example mantissa where mant[mant.length-1] > 1000\n        dfp.exp = 2;\n        assertEquals(7, dfp.log10()); // 2 * 4 - 1 = 7\n    }\n\n    @Test\n    public void testLog10_MantGreaterThan100() {\n        dfp.mant = new int[]{0, 500}; // Example mantissa where 100 < mant[mant.length-1] <= 1000\n        dfp.exp = 2;\n        assertEquals(6, dfp.log10()); // 2 * 4 - 2 = 6\n    }\n\n    @Test\n    public void testLog10_MantGreaterThan10() {\n        dfp.mant = new int[]{0, 50}; // Example mantissa where 10 < mant[mant.length-1] <= 100\n        dfp.exp = 2;\n        assertEquals(5, dfp.log10()); // 2 * 4 - 3 = 5\n    }\n\n    @Test\n    public void testLog10_MantLessThanOrEqualTo10() {\n        dfp.mant = new int[]{0, 5}; // Example mantissa where mant[mant.length-1] <= 10\n        dfp.exp = 2;\n        assertEquals(4, dfp.log10()); // 2 * 4 - 4 = 4\n    }\n\n    @Test\n    public void testLog10_ExpNegative() {\n        dfp.mant = new int[]{0, 5000}; // Example mantissa where mant[mant.length-1] > 1000\n        dfp.exp = -2;\n        assertEquals(-9, dfp.log10()); // -2 * 4 - 1 = -9\n    }\n\n    @Test\n    public void testLog10_ExpZero() {\n        dfp.mant = new int[]{0, 5000}; // Example mantissa where mant[mant.length-1] > 1000\n        dfp.exp = 0;\n        assertEquals(-1, dfp.log10()); // 0 * 4 - 1 = -1\n    }\n\n    @Test\n    public void testLog10_ExpPositiveWithSmallMantissa() {\n        dfp.mant = new int[]{0, 5}; // Example mantissa where mant[mant.length-1] <= 10\n        dfp.exp = 1;\n        assertEquals(0, dfp.log10()); // 1 * 4 - 4 = 0\n    }\n}\n```\n\n### Explanation:\n1. **testLog10_MantGreaterThan1000**: This test checks the scenario where the last element of the `mant` array is greater than 1000. The expected result is calculated as `exp * 4 - 1`.\n2. **testLog10_MantGreaterThan100**: This test checks the scenario where the last element of the `mant` array is between 100 and 1000. The expected result is calculated as `exp * 4 - 2`.\n3. **testLog10_MantGreaterThan10**: This test checks the scenario where the last element of the `mant` array is between 10 and 100. The expected result is calculated as `exp * 4 - 3`.\n4. **testLog10_MantLessThanOrEqualTo10**: This test checks the scenario where the last element of the `mant` array is less than or equal to 10. The expected result is calculated as `exp * 4 - 4`.\n5. **testLog10_ExpNegative**: This test checks the scenario where the exponent is negative. The expected result is calculated as `exp * 4 - 1`.\n6. **testLog10_ExpZero**: This test checks the scenario where the exponent is zero. The expected result is calculated as `exp * 4 - 1`.\n7. **testLog10_ExpPositiveWithSmallMantissa**: This test checks the scenario where the exponent is positive and the last element of the `mant` array is small. The expected result is calculated as `exp * 4 - 4`.\n\nThese tests cover all branches in the `log10` method, ensuring maximum branch and line coverage."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }", "return_type": "Dfp", "assertion_subject_candidates": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "int org.apache.commons.math.dfp.Dfp#hashCode()", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "int org.apache.commons.math.dfp.Dfp#log10K()", "int org.apache.commons.math.dfp.Dfp#classify()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `power10` method in the `Dfp` class. These tests aim to maximize both branch and line coverage.\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n\n    private Dfp dfp;\n\n    @Before\n    public void setUp() {\n        // Assuming DfpField has a default constructor or a way to obtain an instance\n        DfpField field = new DfpField(50); // Initialize with some precision\n        dfp = field.getZero(); // or field.getOne() depending on your setup\n    }\n\n    @Test\n    public void testPower10_Zero() {\n        Dfp result = dfp.power10(0);\n        assertEquals(1, result.intValue());\n        assertEquals(0, result.exp);\n    }\n\n    @Test\n    public void testPower10_Positive1() {\n        Dfp result = dfp.power10(1);\n        assertEquals(10, result.intValue());\n        assertEquals(0, result.exp);\n    }\n\n    @Test\n    public void testPower10_Positive2() {\n        Dfp result = dfp.power10(2);\n        assertEquals(100, result.intValue());\n        assertEquals(0, result.exp);\n    }\n\n    @Test\n    public void testPower10_Positive3() {\n        Dfp result = dfp.power10(3);\n        assertEquals(1000, result.intValue());\n        assertEquals(0, result.exp);\n    }\n\n    @Test\n    public void testPower10_Positive4() {\n        Dfp result = dfp.power10(4);\n        assertEquals(1, result.intValue());\n        assertEquals(1, result.exp);\n    }\n\n    @Test\n    public void testPower10_Positive5() {\n        Dfp result = dfp.power10(5);\n        assertEquals(10, result.intValue());\n        assertEquals(1, result.exp);\n    }\n\n    @Test\n    public void testPower10_Positive16() {\n        Dfp result = dfp.power10(16);\n        assertEquals(1, result.intValue());\n        assertEquals(4, result.exp);\n    }\n\n    @Test\n    public void testPower10_Positive17() {\n        Dfp result = dfp.power10(17);\n        assertEquals(10, result.intValue());\n        assertEquals(4, result.exp);\n    }\n\n    @Test\n    public void testPower10_Negative1() {\n        Dfp result = dfp.power10(-1);\n        assertEquals(1, result.intValue());\n        assertEquals(-1, result.exp);\n    }\n\n    @Test\n    public void testPower10_Negative2() {\n        Dfp result = dfp.power10(-2);\n        assertEquals(1, result.intValue());\n        assertEquals(-1, result.exp);\n    }\n\n    @Test\n    public void testPower10_Negative3() {\n        Dfp result = dfp.power10(-3);\n        assertEquals(1, result.intValue());\n        assertEquals(-1, result.exp);\n    }\n\n    @Test\n    public void testPower10_Negative4() {\n        Dfp result = dfp.power10(-4);\n        assertEquals(1, result.intValue());\n        assertEquals(-2, result.exp);\n    }\n\n    @Test\n    public void testPower10_Negative5() {\n        Dfp result = dfp.power10(-5);\n        assertEquals(1, result.intValue());\n        assertEquals(-2, result.exp);\n    }\n\n    @Test\n    public void testPower10_Negative16() {\n        Dfp result = dfp.power10(-16);\n        assertEquals(1, result.intValue());\n        assertEquals(-5, result.exp);\n    }\n\n    @Test\n    public void testPower10_Negative17() {\n        Dfp result = dfp.power10(-17);\n        assertEquals(1, result.intValue());\n        assertEquals(-5, result.exp);\n    }\n\n    @Test\n    public void testPower10_LargePositive() {\n        Dfp result = dfp.power10(12345);\n        assertEquals(1, result.intValue());\n        assertEquals(3086, result.exp);\n    }\n\n    @Test\n    public void testPower10_LargeNegative() {\n        Dfp result = dfp.power10(-12345);\n        assertEquals(1, result.intValue());\n        assertEquals(-3086, result.exp);\n    }\n}\n```\n\n### Explanation:\n- **Branch Coverage**: The tests cover all branches in the switch statement by testing `e % 4` values of 0, 1, 2, and 3.\n- **Line Coverage**: Each test case checks a different aspect of the method, ensuring that all lines are executed.\n\n### Assumptions:\n- `newInstance(getOne())` returns a `Dfp` instance representing the number 1.\n- The `intValue()` method correctly converts the `Dfp` instance to an integer value for comparison.\n\nMake sure to adjust the `DfpField` instantiation and other details according to your actual implementation."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }", "return_type": "Dfp", "assertion_subject_candidates": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "int org.apache.commons.math.dfp.Dfp#hashCode()", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "int org.apache.commons.math.dfp.Dfp#log10K()", "int org.apache.commons.math.dfp.Dfp#classify()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Certainly! To write comprehensive unit tests for the `add` method in the `Dfp` class, we need to cover various scenarios, including special cases such as NaN, infinity, zero, and normal numbers. Given the complexity of the method, we will also need to ensure that we cover different branches and lines.\n\nBelow are some unit tests written in Java 1.7 with JUnit 4 to maximize branch and line coverage:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n    private DfpField field;\n    private Dfp zero;\n    private Dfp one;\n    private Dfp two;\n    private Dfp inf;\n    private Dfp negInf;\n    private Dfp nan;\n    private Dfp qnan;\n\n    @Before\n    public void setUp() {\n        field = new DfpField(10); // Example precision\n        zero = field.getZero();\n        one = field.getOne();\n        two = field.getTwo();\n        inf = field.newDfp(Double.POSITIVE_INFINITY);\n        negInf = field.newDfp(Double.NEGATIVE_INFINITY);\n        nan = field.newDfp(Double.NaN);\n        qnan = field.newDfp(\"NaN\");\n    }\n\n    @Test\n    public void testAddZeroWithZero() {\n        Dfp result = zero.add(zero);\n        assertEquals(\"0 + 0\", 0, result.intValue());\n    }\n\n    @Test\n    public void testAddZeroWithOne() {\n        Dfp result = zero.add(one);\n        assertEquals(\"0 + 1\", 1, result.intValue());\n    }\n\n    @Test\n    public void testAddOneWithOne() {\n        Dfp result = one.add(one);\n        assertEquals(\"1 + 1\", 2, result.intValue());\n    }\n\n    @Test\n    public void testAddOneWithNegativeOne() {\n        Dfp negativeOne = one.negate();\n        Dfp result = one.add(negativeOne);\n        assertEquals(\"1 + (-1)\", 0, result.intValue());\n    }\n\n    @Test\n    public void testAddInfinityWithInfinity() {\n        Dfp result = inf.add(inf);\n        assertEquals(\"Infinity + Infinity\", inf, result);\n    }\n\n    @Test\n    public void testAddInfinityWithNegativeInfinity() {\n        Dfp result = inf.add(negInf);\n        assertEquals(\"Infinity + (-Infinity)\", Double.NaN, result.toDouble(), 0.0);\n    }\n\n    @Test\n    public void testAddNegativeInfinityWithNegativeInfinity() {\n        Dfp result = negInf.add(negInf);\n        assertEquals(\"-Infinity + (-Infinity)\", negInf, result);\n    }\n\n    @Test\n    public void testAddInfinityWithNumber() {\n        Dfp result = inf.add(one);\n        assertEquals(\"Infinity + 1\", inf, result);\n    }\n\n    @Test\n    public void testAddNegativeInfinityWithNumber() {\n        Dfp result = negInf.add(one);\n        assertEquals(\"-Infinity + 1\", negInf, result);\n    }\n\n    @Test\n    public void testAddNumberWithInfinity() {\n        Dfp result = one.add(inf);\n        assertEquals(\"1 + Infinity\", inf, result);\n    }\n\n    @Test\n    public void testAddNumberWithNegativeInfinity() {\n        Dfp result = one.add(negInf);\n        assertEquals(\"1 + (-Infinity)\", negInf, result);\n    }\n\n    @Test\n    public void testAddNaNWithNumber() {\n        Dfp result = nan.add(one);\n        assertTrue(\"NaN + 1\", result.isNaN());\n    }\n\n    @Test\n    public void testAddNumberWithNaN() {\n        Dfp result = one.add(nan);\n        assertTrue(\"1 + NaN\", result.isNaN());\n    }\n\n    @Test\n    public void testAddNaNWithNaN() {\n        Dfp result = nan.add(qnan);\n        assertTrue(\"NaN + NaN\", result.isNaN());\n    }\n\n    @Test\n    public void testAddVeryLargeNumbers() {\n        Dfp veryLarge = field.newDfp(Double.MAX_VALUE);\n        Dfp result = veryLarge.add(veryLarge);\n        assertEquals(\"Double.MAX_VALUE + Double.MAX_VALUE\", Double.MAX_VALUE, result.toDouble(), 0.0);\n    }\n\n    @Test\n    public void testAddVerySmallNumbers() {\n        Dfp verySmall = field.newDfp(Double.MIN_VALUE);\n        Dfp result = verySmall.add(verySmall);\n        assertEquals(\"Double.MIN_VALUE + Double.MIN_VALUE\", 2 * Double.MIN_VALUE, result.toDouble(), 0.0);\n    }\n\n    @Test\n    public void testAddWithDifferentPrecision() {\n        DfpField field2 = new DfpField(20); // Different precision\n        Dfp highPrecisionOne = field2.newDfp(1.0);\n        try {\n            one.add(highPrecisionOne);\n            fail(\"Should have thrown an exception for different precision\");\n        } catch (ArithmeticException e) {\n            // Expected exception\n        }\n    }\n\n    @Test\n    public void testAddWithCarry() {\n        Dfp large = field.newDfp(9999.9999);\n        Dfp result = large.add(large);\n        assertEquals(\"9999.9999 + 9999.9999\", 19999.9998, result.toDouble(), 0.01);\n    }\n\n    @Test\n    public void testAddWithNegativeCarry() {\n        Dfp large = field.newDfp(-9999.9999);\n        Dfp result = large.add(large);\n        assertEquals(\"-9999.9999 + (-9999.9999)\", -19999.9998, result.toDouble(), 0.01);\n    }\n\n    @Test\n    public void testAddNormalization() {\n        Dfp small = field.newDfp(0.0001);\n        Dfp result = small.add(small);\n        assertEquals(\"0.0001 + 0.0001\", 0.0002, result.toDouble(), 0.000001);\n    }\n}\n```\n\n### Explanation of Test Cases:\n1. **Test Addition with Zero**: Tests adding zero to zero, zero to one, and one to one.\n2. **Test Addition with Infinity**: Tests adding positive and negative infinity, and adding numbers to infinity and negative infinity.\n3. **Test Addition with NaN**: Tests adding NaN with a number, a number with NaN, and NaN with NaN.\n4. **Test Addition with Very Large and Small Numbers**: Tests adding very large and very small numbers to ensure they handle correctly.\n5. **Test Addition with Different Precision**: Tests adding numbers with different precision to ensure an exception is thrown.\n6. **Test Addition with Carry**: Tests addition that results in a carry.\n7. **Test Addition with Negative Carry**: Tests addition that results in a negative carry.\n8. **Test Addition Normalization**: Tests addition that requires normalization.\n\nThese tests should provide good coverage of the `add` method, including edge cases and typical use cases."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }", "return_type": "Dfp", "assertion_subject_candidates": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "int org.apache.commons.math.dfp.Dfp#hashCode()", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "int org.apache.commons.math.dfp.Dfp#log10K()", "int org.apache.commons.math.dfp.Dfp#classify()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `multiply` method in the `Dfp` class. These tests aim to maximize both branch and line coverage by covering different scenarios, including edge cases and special cases.\n\nFirst, ensure you have JUnit 4 included in your project dependencies. You can add it via Maven or download the JAR manually.\n\n### Maven Dependency for JUnit 4\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\n### Unit Tests for `multiply` Method\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n\n    private DfpField field;\n    private Dfp zero;\n    private Dfp one;\n    private Dfp two;\n    private Dfp inf;\n    private Dfp nInf;\n    private Dfp nan;\n\n    @Before\n    public void setUp() {\n        field = new DfpField(30); // Assuming a radix of 10000 and 30 digits\n        zero = field.getZero();\n        one = field.getOne();\n        two = field.getTwo();\n        inf = new Dfp(field, Dfp.INFINITE, 0);\n        nInf = new Dfp(field, Dfp.INFINITE, -1);\n        nan = new Dfp(field, Dfp.QNAN, 0);\n    }\n\n    @Test\n    public void testMultiplyZero() {\n        Dfp result = zero.multiply(zero);\n        assertEquals(0, result.mant[mant.length - 1]);\n        assertEquals(0, result.exp);\n        assertEquals(1, result.sign);\n        assertEquals(Dfp.FINITE, result.nans);\n\n        result = one.multiply(zero);\n        assertEquals(0, result.mant[mant.length - 1]);\n        assertEquals(0, result.exp);\n        assertEquals(1, result.sign);\n        assertEquals(Dfp.FINITE, result.nans);\n    }\n\n    @Test\n    public void testMultiplyOne() {\n        Dfp result = one.multiply(one);\n        assertEquals(1, result.mant[mant.length - 1]);\n        assertEquals(0, result.exp);\n        assertEquals(1, result.sign);\n        assertEquals(Dfp.FINITE, result.nans);\n\n        result = two.multiply(one);\n        assertEquals(2, result.mant[mant.length - 1]);\n        assertEquals(0, result.exp);\n        assertEquals(1, result.sign);\n        assertEquals(Dfp.FINITE, result.nans);\n    }\n\n    @Test\n    public void testMultiplyTwoPositive() {\n        Dfp result = two.multiply(two);\n        assertEquals(4, result.mant[mant.length - 1]);\n        assertEquals(0, result.exp);\n        assertEquals(1, result.sign);\n        assertEquals(Dfp.FINITE, result.nans);\n    }\n\n    @Test\n    public void testMultiplyTwoNegative() {\n        Dfp negTwo = new Dfp(field, -2, 0);\n        Dfp result = negTwo.multiply(negTwo);\n        assertEquals(4, result.mant[mant.length - 1]);\n        assertEquals(0, result.exp);\n        assertEquals(1, result.sign);\n        assertEquals(Dfp.FINITE, result.nans);\n\n        result = negTwo.multiply(two);\n        assertEquals(2, result.mant[mant.length - 1]);\n        assertEquals(0, result.exp);\n        assertEquals(-1, result.sign);\n        assertEquals(Dfp.FINITE, result.nans);\n    }\n\n    @Test\n    public void testMultiplyWithInfinity() {\n        Dfp result = inf.multiply(two);\n        assertEquals(Dfp.INFINITE, result.nans);\n        assertEquals(1, result.sign);\n\n        result = inf.multiply(nInf);\n        assertEquals(Dfp.INFINITE, result.nans);\n        assertEquals(-1, result.sign);\n\n        result = nInf.multiply(nInf);\n        assertEquals(Dfp.INFINITE, result.nans);\n        assertEquals(1, result.sign);\n    }\n\n    @Test\n    public void testMultiplyWithNaN() {\n        Dfp result = nan.multiply(two);\n        assertEquals(Dfp.QNAN, result.nans);\n\n        result = two.multiply(nan);\n        assertEquals(Dfp.QNAN, result.nans);\n\n        result = inf.multiply(nan);\n        assertEquals(Dfp.QNAN, result.nans);\n\n        result = nan.multiply(inf);\n        assertEquals(Dfp.QNAN, result.nans);\n    }\n\n    @Test\n    public void testMultiplyZeroWithInfinity() {\n        Dfp result = inf.multiply(zero);\n        assertEquals(Dfp.QNAN, result.nans);\n        assertEquals(1, field.getIEEEFlagsBits());\n\n        result = nInf.multiply(zero);\n        assertEquals(Dfp.QNAN, result.nans);\n        assertEquals(1, field.getIEEEFlagsBits());\n    }\n\n    @Test\n    public void testMultiplyDifferentPrecision() {\n        DfpField field2 = new DfpField(20);\n        Dfp diffPrecision = new Dfp(field2, 2, 1);\n\n        Dfp result = two.multiply(diffPrecision);\n        assertEquals(Dfp.QNAN, result.nans);\n        assertEquals(1, field.getIEEEFlagsBits());\n    }\n\n    @Test\n    public void testMultiplyLargeNumbers() {\n        Dfp large = new Dfp(field, 9999, 0);\n        Dfp result = large.multiply(large);\n\n        assertEquals(99980001, result.mant[mant.length - 1]);\n        assertEquals(0, result.exp);\n        assertEquals(1, result.sign);\n        assertEquals(Dfp.FINITE, result.nans);\n    }\n\n    @Test\n    public void testMultiplyWithRounding() {\n        Dfp large1 = new Dfp(field, 9999, 0);\n        Dfp large2 = new Dfp(field, 10001, 0);\n        Dfp result = large1.multiply(large2);\n\n        assertEquals(99999999, result.mant[mant.length - 1]);\n        assertEquals(1, result.exp);\n        assertEquals(1, result.sign);\n        assertEquals(Dfp.FINITE, result.nans);\n    }\n}\n```\n\n### Explanation of Tests\n\n1. **Test with Zero**: Ensures that multiplying any number by zero results in zero.\n2. **Test with One**: Ensures that multiplying any number by one results in the same number.\n3. **Test with Two Positive Numbers**: Ensures that the multiplication of two positive numbers results in the correct product.\n4. **Test with Two Negative Numbers**: Ensures that the multiplication of two negative numbers results in a positive product.\n5. **Test with Infinity**: Ensures that multiplying any finite number by infinity results in infinity.\n6. **Test with NaN**: Ensures that any operation involving NaN results in NaN.\n7. **Test with Zero and Infinity**: Ensures that multiplying zero by infinity results in NaN.\n8. **Test with Different Precision**: Ensures that attempting to multiply numbers with different precision results in NaN.\n9. **Test with Large Numbers**: Ensures that the multiplication of large numbers results in the correct product.\n10. **Test with Rounding**: Ensures that the multiplication of numbers results in the correct product with proper rounding.\n\nThese tests should help in achieving high branch and line coverage for the `multiply` method in the `Dfp` class."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }", "return_type": "Dfp", "assertion_subject_candidates": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "int org.apache.commons.math.dfp.Dfp#hashCode()", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "int org.apache.commons.math.dfp.Dfp#log10K()", "int org.apache.commons.math.dfp.Dfp#classify()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Certainly! Below are a series of unit tests for the `multiply` method of the `Dfp` class. These tests aim to cover all branches and lines of the method using Java 1.7 and JUnit 4.\n\nFirst, make sure to include the JUnit library in your project. If you're using Maven, you can add the following dependency to your `pom.xml`:\n\n```xml\n<dependency>\n    <groupId>junit</groupId>\n    <artifactId>junit</artifactId>\n    <version>4.13.2</version>\n    <scope>test</scope>\n</dependency>\n```\n\nNow, here are the unit tests:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n\n    private DfpField field;\n    private Dfp dfp;\n\n    @Before\n    public void setUp() {\n        field = new DfpField(5); // Example precision\n        dfp = new Dfp(field);\n    }\n\n    @Test\n    public void testMultiplyNaN() {\n        Dfp nanDfp = new Dfp(field);\n        nanDfp.nans = Dfp.SNAN;\n        Dfp result = nanDfp.multiply(5);\n        assertEquals(Dfp.SNAN, result.nans);\n    }\n\n    @Test\n    public void testMultiplyInfinityNonZero() {\n        Dfp infDfp = new Dfp(field);\n        infDfp.nans = Dfp.INFINITE;\n        Dfp result = infDfp.multiply(5);\n        assertEquals(Dfp.INFINITE, result.nans);\n    }\n\n    @Test\n    public void testMultiplyInfinityZero() {\n        Dfp infDfp = new Dfp(field);\n        infDfp.nans = Dfp.INFINITE;\n        Dfp result = infDfp.multiply(0);\n        assertEquals(Dfp.QNAN, result.nans);\n        assertTrue(field.getIEEEFlagsBits() == DfpField.FLAG_INVALID);\n    }\n\n    @Test\n    public void testMultiplyInvalidRangeNegative() {\n        Dfp result = dfp.multiply(-1);\n        assertEquals(Dfp.QNAN, result.nans);\n        assertTrue(field.getIEEEFlagsBits() == DfpField.FLAG_INVALID);\n    }\n\n    @Test\n    public void testMultiplyInvalidRangeTooLarge() {\n        Dfp result = dfp.multiply(Dfp.RADIX);\n        assertEquals(Dfp.QNAN, result.nans);\n        assertTrue(field.getIEEEFlagsBits() == DfpField.FLAG_INVALID);\n    }\n\n    @Test\n    public void testMultiplyZero() {\n        Dfp zeroDfp = field.getZero();\n        Dfp result = zeroDfp.multiply(5);\n        assertEquals(0, result.exp);\n        assertEquals(0, result.mant[0]);\n    }\n\n    @Test\n    public void testMultiplyOne() {\n        Dfp oneDfp = field.getOne();\n        Dfp result = oneDfp.multiply(5);\n        assertEquals(5, result.mant[0]);\n    }\n\n    @Test\n    public void testMultiplyWithShift() {\n        dfp.mant = new int[]{Dfp.RADIX - 1, 0};\n        Dfp result = dfp.multiply(Dfp.RADIX - 1);\n        assertEquals(Dfp.RADIX - 1, result.mant[0]);\n        assertEquals(1, result.mant[1]);\n        assertEquals(1, result.exp);\n    }\n\n    @Test\n    public void testMultiplyWithoutShift() {\n        dfp.mant = new int[]{1, 0};\n        Dfp result = dfp.multiply(5);\n        assertEquals(5, result.mant[0]);\n        assertEquals(0, result.exp);\n    }\n\n    @Test\n    public void testMultiplyLargestValue() {\n        dfp.mant = new int[]{Dfp.RADIX - 1, Dfp.RADIX - 1};\n        Dfp result = dfp.multiply(Dfp.RADIX - 1);\n        assertEquals(1, result.mant[0]);\n        assertEquals((Dfp.RADIX - 1) * (Dfp.RADIX - 1) - Dfp.RADIX, result.mant[1]);\n        assertEquals(1, result.exp);\n    }\n}\n```\n\n### Explanation of Tests\n\n1. **testMultiplyNaN**: Tests multiplication of a NaN value.\n2. **testMultiplyInfinityNonZero**: Tests multiplication of an infinite value by a non-zero number.\n3. **testMultiplyInfinityZero**: Tests multiplication of an infinite value by zero, which should result in NaN and set the invalid flag.\n4. **testMultiplyInvalidRangeNegative**: Tests multiplication by a negative number outside the valid range.\n5. **testMultiplyInvalidRangeTooLarge**: Tests multiplication by a number too large to be valid.\n6. **testMultiplyZero**: Tests multiplication of zero by any number.\n7. **testMultiplyOne**: Tests multiplication of one by any number.\n8. **testMultiplyWithShift**: Tests multiplication that requires a shift in the mantissa.\n9. **testMultiplyWithoutShift**: Tests multiplication that does not require a shift.\n10. **testMultiplyLargestValue**: Tests multiplication with the largest possible mantissa values.\n\nThese tests should cover all branches and lines of the `multiply` method, ensuring both branch and line coverage."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }", "return_type": "Dfp", "assertion_subject_candidates": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "int org.apache.commons.math.dfp.Dfp#hashCode()", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "int org.apache.commons.math.dfp.Dfp#log10K()", "int org.apache.commons.math.dfp.Dfp#classify()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "To write comprehensive unit tests for the `divide` method in the `Dfp` class, we need to cover various scenarios including normal cases, edge cases, and special cases such as division by zero, division by infinity, and division of NaN values. Below are the unit tests written in Java 1.7 with JUnit 4.\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n\n    private DfpField field;\n    private Dfp zero;\n    private Dfp one;\n    private Dfp two;\n    private Dfp infinity;\n    private Dfp negativeInfinity;\n    private Dfp nan;\n\n    @Before\n    public void setUp() {\n        field = new DfpField(20); // Assuming 20 is a valid precision\n        zero = field.getZero();\n        one = field.getOne();\n        two = field.getTwo();\n        infinity = field.newDfp(Dfp.POS_INFINITY_STRING);\n        negativeInfinity = field.newDfp(Dfp.NEG_INFINITY_STRING);\n        nan = field.newDfp(Dfp.NAN_STRING);\n    }\n\n    @Test\n    public void testDivideNormal() {\n        Dfp a = field.newDfp(\"10000\");\n        Dfp b = field.newDfp(\"10\");\n        Dfp result = a.divide(b);\n        assertEquals(\"1000.0\", result.toString());\n    }\n\n    @Test\n    public void testDivideByZero() {\n        Dfp a = field.newDfp(\"10000\");\n        Dfp b = field.newDfp(\"0\");\n        Dfp result = a.divide(b);\n        assertEquals(Dfp.INFINITE, result.nans);\n        assertEquals(1, result.sign);\n    }\n\n    @Test\n    public void testDivideByNegativeZero() {\n        Dfp a = field.newDfp(\"10000\");\n        Dfp b = field.newDfp(\"-0\");\n        Dfp result = a.divide(b);\n        assertEquals(Dfp.INFINITE, result.nans);\n        assertEquals(-1, result.sign);\n    }\n\n    @Test\n    public void testDivideNegativeByNegative() {\n        Dfp a = field.newDfp(\"-10000\");\n        Dfp b = field.newDfp(\"-10\");\n        Dfp result = a.divide(b);\n        assertEquals(\"1000.0\", result.toString());\n    }\n\n    @Test\n    public void testDivideNegativeByPositive() {\n        Dfp a = field.newDfp(\"-10000\");\n        Dfp b = field.newDfp(\"10\");\n        Dfp result = a.divide(b);\n        assertEquals(\"-1000.0\", result.toString());\n    }\n\n    @Test\n    public void testDividePositiveByNegative() {\n        Dfp a = field.newDfp(\"10000\");\n        Dfp b = field.newDfp(\"-10\");\n        Dfp result = a.divide(b);\n        assertEquals(\"-1000.0\", result.toString());\n    }\n\n    @Test\n    public void testDivideByInfinity() {\n        Dfp a = field.newDfp(\"10000\");\n        Dfp b = infinity;\n        Dfp result = a.divide(b);\n        assertEquals(\"0.0\", result.toString());\n    }\n\n    @Test\n    public void testDivideByNegativeInfinity() {\n        Dfp a = field.newDfp(\"10000\");\n        Dfp b = negativeInfinity;\n        Dfp result = a.divide(b);\n        assertEquals(\"-0.0\", result.toString());\n    }\n\n    @Test\n    public void testInfinityDivideByFinite() {\n        Dfp a = infinity;\n        Dfp b = field.newDfp(\"10\");\n        Dfp result = a.divide(b);\n        assertEquals(Dfp.INFINITE, result.nans);\n        assertEquals(1, result.sign);\n    }\n\n    @Test\n    public void testNegativeInfinityDivideByFinite() {\n        Dfp a = negativeInfinity;\n        Dfp b = field.newDfp(\"10\");\n        Dfp result = a.divide(b);\n        assertEquals(Dfp.INFINITE, result.nans);\n        assertEquals(-1, result.sign);\n    }\n\n    @Test\n    public void testInfinityDivideByInfinity() {\n        Dfp a = infinity;\n        Dfp b = infinity;\n        Dfp result = a.divide(b);\n        assertEquals(Dfp.QNAN, result.nans);\n    }\n\n    @Test\n    public void testNanDivideByFinite() {\n        Dfp a = nan;\n        Dfp b = field.newDfp(\"10\");\n        Dfp result = a.divide(b);\n        assertEquals(Dfp.QNAN, result.nans);\n    }\n\n    @Test\n    public void testFiniteDivideByNan() {\n        Dfp a = field.newDfp(\"10\");\n        Dfp b = nan;\n        Dfp result = a.divide(b);\n        assertEquals(Dfp.QNAN, result.nans);\n    }\n\n    @Test\n    public void testNanDivideByInfinity() {\n        Dfp a = nan;\n        Dfp b = infinity;\n        Dfp result = a.divide(b);\n        assertEquals(Dfp.QNAN, result.nans);\n    }\n\n    @Test\n    public void testInfinityDivideByNan() {\n        Dfp a = infinity;\n        Dfp b = nan;\n        Dfp result = a.divide(b);\n        assertEquals(Dfp.QNAN, result.nans);\n    }\n\n    @Test\n    public void testZeroDivideByFinite() {\n        Dfp a = zero;\n        Dfp b = field.newDfp(\"10\");\n        Dfp result = a.divide(b);\n        assertEquals(\"0.0\", result.toString());\n    }\n\n    @Test\n    public void testZeroDivideByZero() {\n        Dfp a = zero;\n        Dfp b = zero;\n        Dfp result = a.divide(b);\n        assertEquals(Dfp.QNAN, result.nans);\n    }\n\n    @Test\n    public void testZeroDivideByInfinity() {\n        Dfp a = zero;\n        Dfp b = infinity;\n        Dfp result = a.divide(b);\n        assertEquals(\"0.0\", result.toString());\n    }\n\n    @Test\n    public void testFiniteDivideByZero() {\n        Dfp a = field.newDfp(\"10\");\n        Dfp b = zero;\n        Dfp result = a.divide(b);\n        assertEquals(Dfp.INFINITE, result.nans);\n        assertEquals(1, result.sign);\n    }\n\n    @Test\n    public void testOneDivideByOne() {\n        Dfp a = field.getOne();\n        Dfp b = field.getOne();\n        Dfp result = a.divide(b);\n        assertEquals(\"1.0\", result.toString());\n    }\n\n    @Test\n    public void testTwoDivideByOne() {\n        Dfp a = field.getTwo();\n        Dfp b = field.getOne();\n        Dfp result = a.divide(b);\n        assertEquals(\"2.0\", result.toString());\n    }\n\n    @Test\n    public void testOneDivideByTwo() {\n        Dfp a = field.getOne();\n        Dfp b = field.getTwo();\n        Dfp result = a.divide(b);\n        assertEquals(\"0.5\", result.toString());\n    }\n}\n```\n\n### Explanation:\n- **Test Cases**: The tests cover a variety of scenarios, including division of finite numbers, division involving zero, division involving infinity, and division involving NaN (Not-a-Number).\n- **Branch Coverage**: Different branches of the `divide` method are tested, including special case handling, division by zero, and handling of infinite and NaN values.\n- **Line Coverage**: The tests aim to ensure that as many lines of the `divide` method as possible are executed to catch potential issues.\n\nThese tests should help in achieving high coverage of the `divide` method, ensuring that it behaves correctly across different inputs."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }", "return_type": "Dfp", "assertion_subject_candidates": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "int org.apache.commons.math.dfp.Dfp#hashCode()", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "int org.apache.commons.math.dfp.Dfp#log10K()", "int org.apache.commons.math.dfp.Dfp#classify()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp sqrt();", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Certainly! Below are some unit tests for the `divide(int divisor)` method in the `Dfp` class. These tests aim to maximize both branch and line coverage, including handling special cases like NaN, infinity, and edge cases such as zero and large divisors.\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n    private DfpField field;\n    private Dfp dfp;\n    private static final int RADIX = 10000;\n\n    @Before\n    public void setUp() {\n        field = new DfpField(3); // Example with 3 digits of mantissa\n        dfp = field.getZero().newInstance(12345);\n    }\n\n    @Test\n    public void testDivideByZero() {\n        Dfp result = dfp.divide(0);\n        assertTrue(result.isInfinite());\n        assertEquals(dfp.sign, result.sign);\n        assertEquals(Dfp.INFINITE, result.nans);\n        assertTrue(field.getIEEEFlagsBits() == DfpField.FLAG_DIV_ZERO);\n    }\n\n    @Test\n    public void testDivideByNegative() {\n        Dfp result = dfp.divide(-1);\n        assertTrue(result.isNaN());\n        assertEquals(Dfp.QNAN, result.nans);\n        assertTrue(field.getIEEEFlagsBits() == DfpField.FLAG_INVALID);\n    }\n\n    @Test\n    public void testDivideByLarge() {\n        Dfp result = dfp.divide(RADIX);\n        assertTrue(result.isNaN());\n        assertEquals(Dfp.QNAN, result.nans);\n        assertTrue(field.getIEEEFlagsBits() == DfpField.FLAG_INVALID);\n    }\n\n    @Test\n    public void testDivideByOne() {\n        Dfp result = dfp.divide(1);\n        assertFalse(result.isInfinite());\n        assertFalse(result.isNaN());\n        assertEquals(dfp.sign, result.sign);\n        assertEquals(dfp.exp, result.exp);\n        assertArrayEquals(dfp.mant, result.mant);\n    }\n\n    @Test\n    public void testDivideByPositive() {\n        Dfp dfpPositive = field.getZero().newInstance(10000);\n        Dfp result = dfpPositive.divide(2);\n        assertFalse(result.isInfinite());\n        assertFalse(result.isNaN());\n        assertEquals(dfpPositive.sign, result.sign);\n        assertEquals(5000, result.mant[0]);\n    }\n\n    @Test\n    public void testDivideNaN() {\n        Dfp dfpNaN = field.getZero().newInstance(Dfp.NaN_STRING);\n        Dfp result = dfpNaN.divide(1);\n        assertTrue(result.isNaN());\n        assertEquals(Dfp.NaN_STRING, result.toString());\n    }\n\n    @Test\n    public void testDivideInfinite() {\n        Dfp dfpInfinite = field.getZero().newInstance(Dfp.POS_INFINITY_STRING);\n        Dfp result = dfpInfinite.divide(1);\n        assertTrue(result.isInfinite());\n        assertEquals(Dfp.POS_INFINITY_STRING, result.toString());\n    }\n\n    @Test\n    public void testDivideNormalized() {\n        Dfp dfpNormalized = field.getZero().newInstance(1000000);\n        Dfp result = dfpNormalized.divide(10);\n        assertFalse(result.isInfinite());\n        assertFalse(result.isNaN());\n        assertEquals(100000, result.mant[0]);\n    }\n\n    @Test\n    public void testDivideWithRemainder() {\n        Dfp dfpWithRemainder = field.getZero().newInstance(10001);\n        Dfp result = dfpWithRemainder.divide(2);\n        assertFalse(result.isInfinite());\n        assertFalse(result.isNaN());\n        assertEquals(5000, result.mant[0]);\n    }\n\n    @Test\n    public void testDivideWithRounding() {\n        Dfp dfpRounding = field.getZero().newInstance(9999);\n        Dfp result = dfpRounding.divide(2);\n        assertFalse(result.isInfinite());\n        assertFalse(result.isNaN());\n        assertEquals(5000, result.mant[0]); // Rounding should give 5000\n    }\n}\n```\n\n### Explanation:\n1. **Test Cases**:\n   - **Divide by Zero**: Tests if the method correctly handles division by zero, returning infinity and setting the appropriate flag.\n   - **Divide by Negative/Large**: Tests if the method returns NaN for invalid divisor values and sets the appropriate flag.\n   - **Divide by One**: Tests if dividing by one returns the original number.\n   - **Divide by Positive**: Tests regular division by a positive number.\n   - **Divide NaN/Infinite**: Tests if the method correctly handles NaN and infinite values.\n   - **Divide Normalized/Remainder/Rounding**: Tests various scenarios involving normalization, remainders, and rounding.\n\n2. **Assertions**:\n   - Checks for infinity, NaN, sign, and mantissa values to ensure correctness.\n   - Verifies IEEE flag settings for invalid operations.\n\nThese tests should cover most branches and lines in the `divide(int divisor)` method, ensuring comprehensive testing."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }", "return_type": "Dfp", "assertion_subject_candidates": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "int org.apache.commons.math.dfp.Dfp#hashCode()", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "int org.apache.commons.math.dfp.Dfp#log10K()", "int org.apache.commons.math.dfp.Dfp#classify()", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "String org.apache.commons.math.dfp.Dfp#toString()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "@Override\n    public String toString();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "Certainly! Below are the unit tests for the `sqrt` method in the `Dfp` class. These tests aim to cover various scenarios, including edge cases, to maximize branch and line coverage.\n\n### DfpTest.java\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class DfpTest {\n\n    private DfpField field;\n    private Dfp dfpZero;\n    private Dfp dfpOne;\n    private Dfp dfpTwo;\n    private Dfp dfpFour;\n    private Dfp dfpNegativeOne;\n    private Dfp dfpNaN;\n    private Dfp dfpPositiveInfinity;\n    private Dfp dfpNegativeInfinity;\n    private Dfp dfpSNAN;\n\n    @Before\n    public void setUp() {\n        field = new DfpField(10); // Assume 10 digits of precision for the field\n        dfpZero = field.getZero();\n        dfpOne = field.getOne();\n        dfpTwo = field.getTwo();\n        dfpFour = dfpTwo.multiply(dfpTwo);\n        dfpNegativeOne = dfpOne.negate();\n        dfpNaN = field.newDfp(Double.NaN);\n        dfpPositiveInfinity = field.newDfp(Double.POSITIVE_INFINITY);\n        dfpNegativeInfinity = field.newDfp(Double.NEGATIVE_INFINITY);\n        dfpSNAN = field.newInstance((byte) Dfp.SNAN, (byte) 0);\n    }\n\n    @Test\n    public void testSqrtZero() {\n        Dfp result = dfpZero.sqrt();\n        assertTrue(result.equals(dfpZero));\n    }\n\n    @Test\n    public void testSqrtOne() {\n        Dfp result = dfpOne.sqrt();\n        assertTrue(result.equals(dfpOne));\n    }\n\n    @Test\n    public void testSqrtTwo() {\n        Dfp result = dfpTwo.sqrt();\n        assertTrue(result.greaterThan(dfpOne) && result.lessThan(dfpTwo));\n    }\n\n    @Test\n    public void testSqrtFour() {\n        Dfp result = dfpFour.sqrt();\n        assertTrue(result.equals(dfpTwo));\n    }\n\n    @Test\n    public void testSqrtNegativeOne() {\n        Dfp result = dfpNegativeOne.sqrt();\n        assertTrue(result.isNaN());\n    }\n\n    @Test\n    public void testSqrtPositiveInfinity() {\n        Dfp result = dfpPositiveInfinity.sqrt();\n        assertTrue(result.equals(dfpPositiveInfinity));\n    }\n\n    @Test\n    public void testSqrtNegativeInfinity() {\n        Dfp result = dfpNegativeInfinity.sqrt();\n        assertTrue(result.isNaN());\n    }\n\n    @Test\n    public void testSqrtNaN() {\n        Dfp result = dfpNaN.sqrt();\n        assertTrue(result.isNaN());\n    }\n\n    @Test\n    public void testSqrtSNAN() {\n        Dfp result = dfpSNAN.sqrt();\n        assertTrue(result.isNaN());\n        assertEquals(Dfp.QNAN, result.nans);\n    }\n\n    @Test\n    public void testSqrtAlternatingValues() {\n        // Create a Dfp number that will alternate between two values in the iteration\n        Dfp dfpAlternating = field.newDfp(1.41421356237);\n        Dfp result = dfpAlternating.sqrt();\n        assertTrue(result.unequal(dfpAlternating));\n    }\n\n    @Test\n    public void testSqrtLargeNumber() {\n        Dfp dfpLarge = field.newDfp(1e10);\n        Dfp result = dfpLarge.sqrt();\n        assertTrue(result.equals(field.newDfp(1e5)));\n    }\n\n    @Test\n    public void testSqrtSmallNumber() {\n        Dfp dfpSmall = field.newDfp(1e-10);\n        Dfp result = dfpSmall.sqrt();\n        assertTrue(result.equals(field.newDfp(1e-5)));\n    }\n}\n```\n\n### Explanation of the Tests\n\n1. **testSqrtZero**: Tests the square root of zero.\n2. **testSqrtOne**: Tests the square root of one.\n3. **testSqrtTwo**: Tests the square root of two to ensure it is between one and two.\n4. **testSqrtFour**: Tests the square root of four to ensure it equals two.\n5. **testSqrtNegativeOne**: Tests the square root of a negative number to ensure it results in NaN.\n6. **testSqrtPositiveInfinity**: Tests the square root of positive infinity to ensure it results in positive infinity.\n7. **testSqrtNegativeInfinity**: Tests the square root of negative infinity to ensure it results in NaN.\n8. **testSqrtNaN**: Tests the square root of NaN to ensure it results in NaN.\n9. **testSqrtSNAN**: Tests the square root of a signaling NaN (SNAN) to ensure it results in a quiet NaN (QNAN).\n10. **testSqrtAlternatingValues**: Tests the square root of a number that will alternate between two values in the iteration.\n11. **testSqrtLargeNumber**: Tests the square root of a large number.\n12. **testSqrtSmallNumber**: Tests the square root of a small number.\n\nThese tests should cover a wide range of scenarios and help ensure the `sqrt` method works as expected."}
{"bug_id": "Math_54", "version": "fixed", "focal_method_signature": "String org.apache.commons.math.dfp.Dfp#toString()", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "focal_method": "@Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }", "return_type": "String", "assertion_subject_candidates": ["String", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()"], "focal_class": {"name": "Dfp", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Math_54/fixed/src/main/java/org/apache/commons/math/dfp/Dfp.java", "superclass": "", "interface": "implements FieldElement<Dfp>", "imports": ["import java.util.Arrays;", "import org.apache.commons.math.FieldElement;"], "fields": ["public static final int RADIX = 10000", "public static final int MIN_EXP = -32767", "public static final int MAX_EXP = 32768", "public static final int ERR_SCALE = 32760", "public static final byte FINITE = 0", "public static final byte INFINITE = 1", "public static final byte SNAN = 2", "public static final byte QNAN = 3", "private static final String NAN_STRING = \"NaN\"", "private static final String POS_INFINITY_STRING = \"Infinity\"", "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "private static final String ADD_TRAP = \"add\"", "private static final String MULTIPLY_TRAP = \"multiply\"", "private static final String DIVIDE_TRAP = \"divide\"", "private static final String SQRT_TRAP = \"sqrt\"", "private static final String ALIGN_TRAP = \"align\"", "private static final String TRUNC_TRAP = \"trunc\"", "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "private static final String LESS_THAN_TRAP = \"lessThan\"", "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "protected int[] mant", "protected byte sign", "protected int exp", "protected byte nans", "private final DfpField field"], "methods": ["Dfp org.apache.commons.math.dfp.Dfp#newInstance()", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(long#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(double#x)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(String#s)", "Dfp org.apache.commons.math.dfp.Dfp#newInstance(byte#sig,byte#code)", "DfpField org.apache.commons.math.dfp.Dfp#getField()", "int org.apache.commons.math.dfp.Dfp#getRadixDigits()", "Dfp org.apache.commons.math.dfp.Dfp#getZero()", "Dfp org.apache.commons.math.dfp.Dfp#getOne()", "Dfp org.apache.commons.math.dfp.Dfp#getTwo()", "void org.apache.commons.math.dfp.Dfp#shiftLeft()", "void org.apache.commons.math.dfp.Dfp#shiftRight()", "int org.apache.commons.math.dfp.Dfp#align(int#e)", "boolean org.apache.commons.math.dfp.Dfp#lessThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#greaterThan(Dfp#x)", "boolean org.apache.commons.math.dfp.Dfp#isInfinite()", "boolean org.apache.commons.math.dfp.Dfp#isNaN()", "boolean org.apache.commons.math.dfp.Dfp#equals(Object#other)", "int org.apache.commons.math.dfp.Dfp#hashCode()", "boolean org.apache.commons.math.dfp.Dfp#unequal(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#compare(Dfp#a,Dfp#b)", "Dfp org.apache.commons.math.dfp.Dfp#rint()", "Dfp org.apache.commons.math.dfp.Dfp#floor()", "Dfp org.apache.commons.math.dfp.Dfp#ceil()", "Dfp org.apache.commons.math.dfp.Dfp#remainder(Dfp#d)", "Dfp org.apache.commons.math.dfp.Dfp#trunc(DfpField.RoundingMode#rmode)", "int org.apache.commons.math.dfp.Dfp#intValue()", "int org.apache.commons.math.dfp.Dfp#log10K()", "Dfp org.apache.commons.math.dfp.Dfp#power10K(int#e)", "int org.apache.commons.math.dfp.Dfp#log10()", "Dfp org.apache.commons.math.dfp.Dfp#power10(int#e)", "int org.apache.commons.math.dfp.Dfp#complement(int#extra)", "Dfp org.apache.commons.math.dfp.Dfp#add(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#negate()", "Dfp org.apache.commons.math.dfp.Dfp#subtract(Dfp#x)", "int org.apache.commons.math.dfp.Dfp#round(int#n)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(Dfp#x)", "Dfp org.apache.commons.math.dfp.Dfp#multiply(int#x)", "Dfp org.apache.commons.math.dfp.Dfp#divide(Dfp#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#divide(int#divisor)", "Dfp org.apache.commons.math.dfp.Dfp#sqrt()", "String org.apache.commons.math.dfp.Dfp#dfp2sci()", "String org.apache.commons.math.dfp.Dfp#dfp2string()", "Dfp org.apache.commons.math.dfp.Dfp#dotrap(int#type,String#what,Dfp#oper,Dfp#result)", "Dfp org.apache.commons.math.dfp.Dfp#trap(int#type,String#what,Dfp#oper,Dfp#def,Dfp#result)", "int org.apache.commons.math.dfp.Dfp#classify()", "Dfp org.apache.commons.math.dfp.Dfp#copysign(Dfp#x,Dfp#y)", "Dfp org.apache.commons.math.dfp.Dfp#nextAfter(Dfp#x)", "double org.apache.commons.math.dfp.Dfp#toDouble()", "double[] org.apache.commons.math.dfp.Dfp#toSplitDouble()"], "other_methods": ["public Dfp newInstance();", "public Dfp newInstance(byte x);", "public Dfp newInstance(int x);", "public Dfp newInstance(long x);", "public Dfp newInstance(double x);", "public Dfp newInstance(Dfp d);", "public Dfp newInstance(String s);", "public Dfp newInstance(byte sig,byte code);", "public DfpField getField();", "public int getRadixDigits();", "public Dfp getZero();", "public Dfp getOne();", "public Dfp getTwo();", "public boolean lessThan(Dfp x);", "public boolean greaterThan(Dfp x);", "public boolean isInfinite();", "public boolean isNaN();", "@Override\n    public boolean equals(Object other);", "@Override\n    public int hashCode();", "public boolean unequal(Dfp x);", "public Dfp rint();", "public Dfp floor();", "public Dfp ceil();", "public Dfp remainder(Dfp d);", "public int intValue();", "public int log10K();", "public Dfp power10K(int e);", "public int log10();", "public Dfp power10(int e);", "public Dfp add(Dfp x);", "public Dfp negate();", "public Dfp subtract(Dfp x);", "public Dfp multiply(Dfp x);", "public Dfp multiply(int x);", "public Dfp divide(Dfp divisor);", "public Dfp divide(int divisor);", "public Dfp sqrt();", "public Dfp dotrap(int type,String what,Dfp oper,Dfp result);", "public int classify();", "public static Dfp copysign(Dfp x,Dfp y);", "public Dfp nextAfter(Dfp x);", "public double toDouble();", "public double[] toSplitDouble();"], "fields_dict": {"int#RADIX": "public static final int RADIX = 10000", "int#MIN_EXP": "public static final int MIN_EXP = -32767", "int#MAX_EXP": "public static final int MAX_EXP = 32768", "int#ERR_SCALE": "public static final int ERR_SCALE = 32760", "byte#FINITE": "public static final byte FINITE = 0", "byte#INFINITE": "public static final byte INFINITE = 1", "byte#SNAN": "public static final byte SNAN = 2", "byte#QNAN": "public static final byte QNAN = 3", "String#NAN_STRING": "private static final String NAN_STRING = \"NaN\"", "String#POS_INFINITY_STRING": "private static final String POS_INFINITY_STRING = \"Infinity\"", "String#NEG_INFINITY_STRING": "private static final String NEG_INFINITY_STRING = \"-Infinity\"", "String#ADD_TRAP": "private static final String ADD_TRAP = \"add\"", "String#MULTIPLY_TRAP": "private static final String MULTIPLY_TRAP = \"multiply\"", "String#DIVIDE_TRAP": "private static final String DIVIDE_TRAP = \"divide\"", "String#SQRT_TRAP": "private static final String SQRT_TRAP = \"sqrt\"", "String#ALIGN_TRAP": "private static final String ALIGN_TRAP = \"align\"", "String#TRUNC_TRAP": "private static final String TRUNC_TRAP = \"trunc\"", "String#NEXT_AFTER_TRAP": "private static final String NEXT_AFTER_TRAP = \"nextAfter\"", "String#LESS_THAN_TRAP": "private static final String LESS_THAN_TRAP = \"lessThan\"", "String#GREATER_THAN_TRAP": "private static final String GREATER_THAN_TRAP = \"greaterThan\"", "String#NEW_INSTANCE_TRAP": "private static final String NEW_INSTANCE_TRAP = \"newInstance\"", "int[]#mant": "protected int[] mant", "byte#sign": "protected byte sign", "int#exp": "protected int exp", "byte#nans": "protected byte nans", "DfpField#field": "private final DfpField field"}, "text": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.math.dfp;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.math.FieldElement;\n\n/**\n *  Decimal floating point library for Java\n *\n *  <p>Another floating point class.  This one is built using radix 10000\n *  which is 10<sup>4</sup>, so its almost decimal.</p>\n *\n *  <p>The design goals here are:\n *  <ol>\n *    <li>Decimal math, or close to it</li>\n *    <li>Settable precision (but no mix between numbers using different settings)</li>\n *    <li>Portability.  Code should be keep as portable as possible.</li>\n *    <li>Performance</li>\n *    <li>Accuracy  - Results should always be +/- 1 ULP for basic\n *         algebraic operation</li>\n *    <li>Comply with IEEE 854-1987 as much as possible.\n *         (See IEEE 854-1987 notes below)</li>\n *  </ol></p>\n *\n *  <p>Trade offs:\n *  <ol>\n *    <li>Memory foot print.  I'm using more memory than necessary to\n *         represent numbers to get better performance.</li>\n *    <li>Digits are bigger, so rounding is a greater loss.  So, if you\n *         really need 12 decimal digits, better use 4 base 10000 digits\n *         there can be one partially filled.</li>\n *  </ol></p>\n *\n *  <p>Numbers are represented  in the following form:\n *  <pre>\n *  n  =  sign &times; mant &times; (radix)<sup>exp</sup>;</p>\n *  </pre>\n *  where sign is &plusmn;1, mantissa represents a fractional number between\n *  zero and one.  mant[0] is the least significant digit.\n *  exp is in the range of -32767 to 32768</p>\n *\n *  <p>IEEE 854-1987  Notes and differences</p>\n *\n *  <p>IEEE 854 requires the radix to be either 2 or 10.  The radix here is\n *  10000, so that requirement is not met, but  it is possible that a\n *  subclassed can be made to make it behave as a radix 10\n *  number.  It is my opinion that if it looks and behaves as a radix\n *  10 number then it is one and that requirement would be met.</p>\n *\n *  <p>The radix of 10000 was chosen because it should be faster to operate\n *  on 4 decimal digits at once instead of one at a time.  Radix 10 behavior\n *  can be realized by add an additional rounding step to ensure that\n *  the number of decimal digits represented is constant.</p>\n *\n *  <p>The IEEE standard specifically leaves out internal data encoding,\n *  so it is reasonable to conclude that such a subclass of this radix\n *  10000 system is merely an encoding of a radix 10 system.</p>\n *\n *  <p>IEEE 854 also specifies the existence of \"sub-normal\" numbers.  This\n *  class does not contain any such entities.  The most significant radix\n *  10000 digit is always non-zero.  Instead, we support \"gradual underflow\"\n *  by raising the underflow flag for numbers less with exponent less than\n *  expMin, but don't flush to zero until the exponent reaches MIN_EXP-digits.\n *  Thus the smallest number we can represent would be:\n *  1E(-(MIN_EXP-digits-1)*4),  eg, for digits=5, MIN_EXP=-32767, that would\n *  be 1e-131092.</p>\n *\n *  <p>IEEE 854 defines that the implied radix point lies just to the right\n *  of the most significant digit and to the left of the remaining digits.\n *  This implementation puts the implied radix point to the left of all\n *  digits including the most significant one.  The most significant digit\n *  here is the one just to the right of the radix point.  This is a fine\n *  detail and is really only a matter of definition.  Any side effects of\n *  this can be rendered invisible by a subclass.</p>\n * @see DfpField\n * @version $Revision$ $Date$\n * @since 2.2\n */\npublic class Dfp implements FieldElement<Dfp> {\n\n    /** The radix, or base of this system.  Set to 10000 */\n    public static final int RADIX = 10000;\n\n    /** The minimum exponent before underflow is signaled.  Flush to zero\n     *  occurs at minExp-DIGITS */\n    public static final int MIN_EXP = -32767;\n\n    /** The maximum exponent before overflow is signaled and results flushed\n     *  to infinity */\n    public static final int MAX_EXP =  32768;\n\n    /** The amount under/overflows are scaled by before going to trap handler */\n    public static final int ERR_SCALE = 32760;\n\n    /** Indicator value for normal finite numbers. */\n    public static final byte FINITE = 0;\n\n    /** Indicator value for Infinity. */\n    public static final byte INFINITE = 1;\n\n    /** Indicator value for signaling NaN. */\n    public static final byte SNAN = 2;\n\n    /** Indicator value for quiet NaN. */\n    public static final byte QNAN = 3;\n\n    /** String for NaN representation. */\n    private static final String NAN_STRING = \"NaN\";\n\n    /** String for positive infinity representation. */\n    private static final String POS_INFINITY_STRING = \"Infinity\";\n\n    /** String for negative infinity representation. */\n    private static final String NEG_INFINITY_STRING = \"-Infinity\";\n\n    /** Name for traps triggered by addition. */\n    private static final String ADD_TRAP = \"add\";\n\n    /** Name for traps triggered by multiplication. */\n    private static final String MULTIPLY_TRAP = \"multiply\";\n\n    /** Name for traps triggered by division. */\n    private static final String DIVIDE_TRAP = \"divide\";\n\n    /** Name for traps triggered by square root. */\n    private static final String SQRT_TRAP = \"sqrt\";\n\n    /** Name for traps triggered by alignment. */\n    private static final String ALIGN_TRAP = \"align\";\n\n    /** Name for traps triggered by truncation. */\n    private static final String TRUNC_TRAP = \"trunc\";\n\n    /** Name for traps triggered by nextAfter. */\n    private static final String NEXT_AFTER_TRAP = \"nextAfter\";\n\n    /** Name for traps triggered by lessThan. */\n    private static final String LESS_THAN_TRAP = \"lessThan\";\n\n    /** Name for traps triggered by greaterThan. */\n    private static final String GREATER_THAN_TRAP = \"greaterThan\";\n\n    /** Name for traps triggered by newInstance. */\n    private static final String NEW_INSTANCE_TRAP = \"newInstance\";\n\n    /** Mantissa. */\n    protected int[] mant;\n\n    /** Sign bit: 1 for positive, -1 for negative. */\n    protected byte sign;\n\n    /** Exponent. */\n    protected int exp;\n\n    /** Indicator for non-finite / non-number values. */\n    protected byte nans;\n\n    /** Factory building similar Dfp's. */\n    private final DfpField field;\n\n    /** Makes an instance with a value of zero.\n     * @param field field to which this instance belongs\n     */\n    protected Dfp(final DfpField field) {\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n    }\n\n    /** Create an instance from a byte value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, byte x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from an int value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, int x) {\n        this(field, (long) x);\n    }\n\n    /** Create an instance from a long value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, long x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        nans = FINITE;\n        this.field = field;\n\n        boolean isLongMin = false;\n        if (x == Long.MIN_VALUE) {\n            // special case for Long.MIN_VALUE (-9223372036854775808)\n            // we must shift it before taking its absolute value\n            isLongMin = true;\n            ++x;\n        }\n\n        // set the sign\n        if (x < 0) {\n            sign = -1;\n            x = -x;\n        } else {\n            sign = 1;\n        }\n\n        exp = 0;\n        while (x != 0) {\n            System.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\n            mant[mant.length - 1] = (int) (x % RADIX);\n            x /= RADIX;\n            exp++;\n        }\n\n        if (isLongMin) {\n            // remove the shift added for Long.MIN_VALUE\n            // we know in this case that fixing the last digit is sufficient\n            for (int i = 0; i < mant.length - 1; i++) {\n                if (mant[i] != 0) {\n                    mant[i]++;\n                    break;\n                }\n            }\n        }\n    }\n\n    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                if ((bits & 0x8000000000000000L) != 0) {\n                    sign = -1;\n                }\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }\n\n    /** Copy constructor.\n     * @param d instance to copy\n     */\n    public Dfp(final Dfp d) {\n        mant  = d.mant.clone();\n        sign  = d.sign;\n        exp   = d.exp;\n        nans  = d.nans;\n        field = d.field;\n    }\n\n    /** Create an instance from a String representation.\n     * @param field field to which this instance belongs\n     * @param s string representation of the instance\n     */\n    protected Dfp(final DfpField field, final String s) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        boolean decimalFound = false;\n        final int rsize = 4;   // size of radix in decimal digits\n        final int offset = 4;  // Starting offset into Striped\n        final char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n        // Check some special cases\n        if (s.equals(POS_INFINITY_STRING)) {\n            sign = (byte) 1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NEG_INFINITY_STRING)) {\n            sign = (byte) -1;\n            nans = INFINITE;\n            return;\n        }\n\n        if (s.equals(NAN_STRING)) {\n            sign = (byte) 1;\n            nans = QNAN;\n            return;\n        }\n\n        // Check for scientific notation\n        int p = s.indexOf(\"e\");\n        if (p == -1) { // try upper case?\n            p = s.indexOf(\"E\");\n        }\n\n        final String fpdecimal;\n        int sciexp = 0;\n        if (p != -1) {\n            // scientific notation\n            fpdecimal = s.substring(0, p);\n            String fpexp = s.substring(p+1);\n            boolean negative = false;\n\n            for (int i=0; i<fpexp.length(); i++)\n            {\n                if (fpexp.charAt(i) == '-')\n                {\n                    negative = true;\n                    continue;\n                }\n                if (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9')\n                    sciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n            }\n\n            if (negative) {\n                sciexp = -sciexp;\n            }\n        } else {\n            // normal case\n            fpdecimal = s;\n        }\n\n        // If there is a minus sign in the number then it is negative\n        if (fpdecimal.indexOf(\"-\") !=  -1) {\n            sign = -1;\n        }\n\n        // First off, find all of the leading zeros, trailing zeros, and significant digits\n        p = 0;\n\n        // Move p to first significant digit\n        int decimalPos = 0;\n        for (;;) {\n            if (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\n                break;\n            }\n\n            if (decimalFound && fpdecimal.charAt(p) == '0') {\n                decimalPos--;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n            }\n\n            p++;\n\n            if (p == fpdecimal.length()) {\n                break;\n            }\n        }\n\n        // Copy the string onto Stripped\n        int q = offset;\n        striped[0] = '0';\n        striped[1] = '0';\n        striped[2] = '0';\n        striped[3] = '0';\n        int significantDigits=0;\n        for(;;) {\n            if (p == (fpdecimal.length())) {\n                break;\n            }\n\n            // Don't want to run pass the end of the array\n            if (q == mant.length*rsize+offset+1) {\n                break;\n            }\n\n            if (fpdecimal.charAt(p) == '.') {\n                decimalFound = true;\n                decimalPos = significantDigits;\n                p++;\n                continue;\n            }\n\n            if (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\n                p++;\n                continue;\n            }\n\n            striped[q] = fpdecimal.charAt(p);\n            q++;\n            p++;\n            significantDigits++;\n        }\n\n\n        // If the decimal point has been found then get rid of trailing zeros.\n        if (decimalFound && q != offset) {\n            for (;;) {\n                q--;\n                if (q == offset) {\n                    break;\n                }\n                if (striped[q] == '0') {\n                    significantDigits--;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        // special case of numbers like \"0.00000\"\n        if (decimalFound && significantDigits == 0) {\n            decimalPos = 0;\n        }\n\n        // Implicit decimal point at end of number if not present\n        if (!decimalFound) {\n            decimalPos = q-offset;\n        }\n\n        // Find the number of significant trailing zeros\n        q = offset;  // set q to point to first sig digit\n        p = significantDigits-1+offset;\n\n        int trailingZeros = 0;\n        while (p > q) {\n            if (striped[p] != '0') {\n                break;\n            }\n            trailingZeros++;\n            p--;\n        }\n\n        // Make sure the decimal is on a mod 10000 boundary\n        int i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\n        q -= i;\n        decimalPos += i;\n\n        // Make the mantissa length right by adding zeros at the end if necessary\n        while ((p - q) < (mant.length * rsize)) {\n            for (i = 0; i < rsize; i++) {\n                striped[++p] = '0';\n            }\n        }\n\n        // Ok, now we know how many trailing zeros there are,\n        // and where the least significant digit is\n        for (i = mant.length - 1; i >= 0; i--) {\n            mant[i] = (striped[q]   - '0') * 1000 +\n                      (striped[q+1] - '0') * 100  +\n                      (striped[q+2] - '0') * 10   +\n                      (striped[q+3] - '0');\n            q += 4;\n        }\n\n\n        exp = (decimalPos+sciexp) / rsize;\n\n        if (q < striped.length) {\n            // Is there possible another digit?\n            round((striped[q] - '0')*1000);\n        }\n\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param field field to which this instance belongs\n     * @param sign sign of the Dfp to create\n     * @param nans code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     */\n    protected Dfp(final DfpField field, final byte sign, final byte nans) {\n        this.field = field;\n        this.mant    = new int[field.getRadixDigits()];\n        this.sign    = sign;\n        this.exp     = 0;\n        this.nans    = nans;\n    }\n\n    /** Create an instance with a value of 0.\n     * Use this internally in preference to constructors to facilitate subclasses\n     * @return a new instance with a value of 0\n     */\n    public Dfp newInstance() {\n        return new Dfp(getField());\n    }\n\n    /** Create an instance from a byte value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final byte x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from an int value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final int x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a long value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final long x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance from a double value.\n     * @param x value to convert to an instance\n     * @return a new instance with value x\n     */\n    public Dfp newInstance(final double x) {\n        return new Dfp(getField(), x);\n    }\n\n    /** Create an instance by copying an existing one.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param d instance to copy\n     * @return a new instance with the same value as d\n     */\n    public Dfp newInstance(final Dfp d) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != d.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEW_INSTANCE_TRAP, d, result);\n        }\n\n        return new Dfp(d);\n\n    }\n\n    /** Create an instance from a String representation.\n     * Use this internally in preference to constructors to facilitate subclasses.\n     * @param s string representation of the instance\n     * @return a new instance parsed from specified string\n     */\n    public Dfp newInstance(final String s) {\n        return new Dfp(field, s);\n    }\n\n    /** Creates an instance with a non-finite value.\n     * @param sig sign of the Dfp to create\n     * @param code code of the value, must be one of {@link #INFINITE},\n     * {@link #SNAN},  {@link #QNAN}\n     * @return a new instance with a non-finite value\n     */\n    public Dfp newInstance(final byte sig, final byte code) {\n        return field.newDfp(sig, code);\n    }\n\n    /** Get the {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs.\n     * <p>\n     * The field is linked to the number of digits and acts as a factory\n     * for {@link Dfp} instances.\n     * </p>\n     * @return {@link org.apache.commons.math.Field Field} (really a {@link DfpField}) to which the instance belongs\n     */\n    public DfpField getField() {\n        return field;\n    }\n\n    /** Get the number of radix digits of the instance.\n     * @return number of radix digits\n     */\n    public int getRadixDigits() {\n        return field.getRadixDigits();\n    }\n\n    /** Get the constant 0.\n     * @return a Dfp with value zero\n     */\n    public Dfp getZero() {\n        return field.getZero();\n    }\n\n    /** Get the constant 1.\n     * @return a Dfp with value one\n     */\n    public Dfp getOne() {\n        return field.getOne();\n    }\n\n    /** Get the constant 2.\n     * @return a Dfp with value two\n     */\n    public Dfp getTwo() {\n        return field.getTwo();\n    }\n\n    /** Shift the mantissa left, and adjust the exponent to compensate.\n     */\n    protected void shiftLeft() {\n        for (int i = mant.length - 1; i > 0; i--) {\n            mant[i] = mant[i-1];\n        }\n        mant[0] = 0;\n        exp--;\n    }\n\n    /* Note that shiftRight() does not call round() as that round() itself\n     uses shiftRight() */\n    /** Shift the mantissa right, and adjust the exponent to compensate.\n     */\n    protected void shiftRight() {\n        for (int i = 0; i < mant.length - 1; i++) {\n            mant[i] = mant[i+1];\n        }\n        mant[mant.length - 1] = 0;\n        exp++;\n    }\n\n    /** Make our exp equal to the supplied one, this may cause rounding.\n     *  Also causes de-normalized numbers.  These numbers are generally\n     *  dangerous because most routines assume normalized numbers.\n     *  Align doesn't round, so it will return the last digit destroyed\n     *  by shifting right.\n     *  @param e desired exponent\n     *  @return last digit destroyed by shifting right\n     */\n    protected int align(int e) {\n        int lostdigit = 0;\n        boolean inexact = false;\n\n        int diff = exp - e;\n\n        int adiff = diff;\n        if (adiff < 0) {\n            adiff = -adiff;\n        }\n\n        if (diff == 0) {\n            return 0;\n        }\n\n        if (adiff > (mant.length + 1)) {\n            // Special case\n            Arrays.fill(mant, 0);\n            exp = e;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n\n            return 0;\n        }\n\n        for (int i = 0; i < adiff; i++) {\n            if (diff < 0) {\n                /* Keep track of loss -- only signal inexact after losing 2 digits.\n                 * the first lost digit is returned to add() and may be incorporated\n                 * into the result.\n                 */\n                if (lostdigit != 0) {\n                    inexact = true;\n                }\n\n                lostdigit = mant[0];\n\n                shiftRight();\n            } else {\n                shiftLeft();\n            }\n        }\n\n        if (inexact) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            dotrap(DfpField.FLAG_INEXACT, ALIGN_TRAP, this, this);\n        }\n\n        return lostdigit;\n\n    }\n\n    /** Check if instance is less than x.\n     * @param x number to check instance against\n     * @return true if instance is less than x and neither are NaN, false otherwise\n     */\n    public boolean lessThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) < 0;\n    }\n\n    /** Check if instance is greater than x.\n     * @param x number to check instance against\n     * @return true if instance is greater than x and neither are NaN, false otherwise\n     */\n    public boolean greaterThan(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, result);\n            return false;\n        }\n\n        /* if a nan is involved, signal invalid and return false */\n        if (isNaN() || x.isNaN()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            dotrap(DfpField.FLAG_INVALID, GREATER_THAN_TRAP, x, newInstance(getZero()));\n            return false;\n        }\n\n        return compare(this, x) > 0;\n    }\n\n    /** Check if instance is infinite.\n     * @return true if instance is infinite\n     */\n    public boolean isInfinite() {\n        return nans == INFINITE;\n    }\n\n    /** Check if instance is not a number.\n     * @return true if instance is not a number\n     */\n    public boolean isNaN() {\n        return (nans == QNAN) || (nans == SNAN);\n    }\n\n    /** Check if instance is equal to x.\n     * @param other object to check instance against\n     * @return true if instance is equal to x and neither are NaN, false otherwise\n     */\n    @Override\n    public boolean equals(final Object other) {\n\n        if (other instanceof Dfp) {\n            final Dfp x = (Dfp) other;\n            if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n                return false;\n            }\n\n            return compare(this, x) == 0;\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Gets a hashCode for the instance.\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode() {\n        return 17 + (sign << 8) + (nans << 16) + exp + Arrays.hashCode(mant);\n    }\n\n    /** Check if instance is not equal to x.\n     * @param x number to check instance against\n     * @return true if instance is not equal to x and neither are NaN, false otherwise\n     */\n    public boolean unequal(final Dfp x) {\n        if (isNaN() || x.isNaN() || field.getRadixDigits() != x.field.getRadixDigits()) {\n            return false;\n        }\n\n        return greaterThan(x) || lessThan(x);\n    }\n\n    /** Compare two instances.\n     * @param a first instance in comparison\n     * @param b second instance in comparison\n     * @return -1 if a<b, 1 if a>b and 0 if a==b\n     *  Note this method does not properly handle NaNs or numbers with different precision.\n     */\n    private static int compare(final Dfp a, final Dfp b) {\n        // Ignore the sign of zero\n        if (a.mant[a.mant.length - 1] == 0 && b.mant[b.mant.length - 1] == 0 &&\n            a.nans == FINITE && b.nans == FINITE) {\n            return 0;\n        }\n\n        if (a.sign != b.sign) {\n            if (a.sign == -1) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n\n        // deal with the infinities\n        if (a.nans == INFINITE && b.nans == FINITE) {\n            return a.sign;\n        }\n\n        if (a.nans == FINITE && b.nans == INFINITE) {\n            return -b.sign;\n        }\n\n        if (a.nans == INFINITE && b.nans == INFINITE) {\n            return 0;\n        }\n\n        // Handle special case when a or b is zero, by ignoring the exponents\n        if (b.mant[b.mant.length-1] != 0 && a.mant[b.mant.length-1] != 0) {\n            if (a.exp < b.exp) {\n                return -a.sign;\n            }\n\n            if (a.exp > b.exp) {\n                return a.sign;\n            }\n        }\n\n        // compare the mantissas\n        for (int i = a.mant.length - 1; i >= 0; i--) {\n            if (a.mant[i] > b.mant[i]) {\n                return a.sign;\n            }\n\n            if (a.mant[i] < b.mant[i]) {\n                return -a.sign;\n            }\n        }\n\n        return 0;\n\n    }\n\n    /** Round to nearest integer using the round-half-even method.\n     *  That is round to nearest integer unless both are equidistant.\n     *  In which case round to the even one.\n     *  @return rounded value\n     */\n    public Dfp rint() {\n        return trunc(DfpField.RoundingMode.ROUND_HALF_EVEN);\n    }\n\n    /** Round to an integer using the round floor mode.\n     * That is, round toward -Infinity\n     *  @return rounded value\n     */\n    public Dfp floor() {\n        return trunc(DfpField.RoundingMode.ROUND_FLOOR);\n    }\n\n    /** Round to an integer using the round ceil mode.\n     * That is, round toward +Infinity\n     *  @return rounded value\n     */\n    public Dfp ceil() {\n        return trunc(DfpField.RoundingMode.ROUND_CEIL);\n    }\n\n    /** Returns the IEEE remainder.\n     * @param d divisor\n     * @return this less n &times; d, where n is the integer closest to this/d\n     */\n    public Dfp remainder(final Dfp d) {\n\n        final Dfp result = this.subtract(this.divide(d).rint().multiply(d));\n\n        // IEEE 854-1987 says that if the result is zero, then it carries the sign of this\n        if (result.mant[mant.length-1] == 0) {\n            result.sign = sign;\n        }\n\n        return result;\n\n    }\n\n    /** Does the integer conversions with the specified rounding.\n     * @param rmode rounding mode to use\n     * @return truncated value\n     */\n    protected Dfp trunc(final DfpField.RoundingMode rmode) {\n        boolean changed = false;\n\n        if (isNaN()) {\n            return newInstance(this);\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n\n        if (mant[mant.length-1] == 0) {\n            // a is zero\n            return newInstance(this);\n        }\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (exp < 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            Dfp result = newInstance(getZero());\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (exp >= mant.length) {\n            return newInstance(this);\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(this);\n        for (int i = 0; i < mant.length-result.exp; i++) {\n            changed |= result.mant[i] != 0;\n            result.mant[i] = 0;\n        }\n\n        if (changed) {\n            switch (rmode) {\n                case ROUND_FLOOR:\n                    if (result.sign == -1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(newInstance(-1));\n                    }\n                    break;\n\n                case ROUND_CEIL:\n                    if (result.sign == 1) {\n                        // then we must increment the mantissa by one\n                        result = result.add(getOne());\n                    }\n                    break;\n\n                case ROUND_HALF_EVEN:\n                default:\n                    final Dfp half = newInstance(\"0.5\");\n                    Dfp a = subtract(result);  // difference between this and result\n                    a.sign = 1;            // force positive (take abs)\n                    if (a.greaterThan(half)) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n\n                    /** If exactly equal to 1/2 and odd then increment */\n                    if (a.equals(half) && result.exp > 0 && (result.mant[mant.length-result.exp]&1) != 0) {\n                        a = newInstance(getOne());\n                        a.sign = sign;\n                        result = result.add(a);\n                    }\n                    break;\n            }\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);  // signal inexact\n            result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, this, result);\n            return result;\n        }\n\n        return result;\n    }\n\n    /** Convert this to an integer.\n     * If greater than 2147483647, it returns 2147483647. If less than -2147483648 it returns -2147483648.\n     * @return converted number\n     */\n    public int intValue() {\n        Dfp rounded;\n        int result = 0;\n\n        rounded = rint();\n\n        if (rounded.greaterThan(newInstance(2147483647))) {\n            return 2147483647;\n        }\n\n        if (rounded.lessThan(newInstance(-2147483648))) {\n            return -2147483648;\n        }\n\n        for (int i = mant.length - 1; i >= mant.length - rounded.exp; i--) {\n            result = result * RADIX + rounded.mant[i];\n        }\n\n        if (rounded.sign == -1) {\n            result = -result;\n        }\n\n        return result;\n    }\n\n    /** Get the exponent of the greatest power of 10000 that is\n     *  less than or equal to the absolute value of this.  I.E.  if\n     *  this is 10<sup>6</sup> then log10K would return 1.\n     *  @return integer base 10000 logarithm\n     */\n    public int log10K() {\n        return exp - 1;\n    }\n\n    /** Get the specified  power of 10000.\n     * @param e desired power\n     * @return 10000<sup>e</sup>\n     */\n    public Dfp power10K(final int e) {\n        Dfp d = newInstance(getOne());\n        d.exp = e + 1;\n        return d;\n    }\n\n    /** Get the exponent of the greatest power of 10 that is less than or equal to abs(this).\n     *  @return integer base 10 logarithm\n     */\n    public int log10()  {\n        if (mant[mant.length-1] > 1000) {\n            return exp * 4 - 1;\n        }\n        if (mant[mant.length-1] > 100) {\n            return exp * 4 - 2;\n        }\n        if (mant[mant.length-1] > 10) {\n            return exp * 4 - 3;\n        }\n        return exp * 4 - 4;\n    }\n\n    /** Return the specified  power of 10.\n     * @param e desired power\n     * @return 10<sup>e</sup>\n     */\n    public Dfp power10(final int e) {\n        Dfp d = newInstance(getOne());\n\n        if (e >= 0) {\n            d.exp = e / 4 + 1;\n        } else {\n            d.exp = (e + 1) / 4;\n        }\n\n        switch ((e % 4 + 4) % 4) {\n            case 0:\n                break;\n            case 1:\n                d = d.multiply(10);\n                break;\n            case 2:\n                d = d.multiply(100);\n                break;\n            default:\n                d = d.multiply(1000);\n        }\n\n        return d;\n    }\n\n    /** Negate the mantissa of this by computing the complement.\n     *  Leaves the sign bit unchanged, used internally by add.\n     *  Denormalized numbers are handled properly here.\n     *  @param extra ???\n     *  @return ???\n     */\n    protected int complement(int extra) {\n\n        extra = RADIX-extra;\n        for (int i = 0; i < mant.length; i++) {\n            mant[i] = RADIX-mant[i]-1;\n        }\n\n        int rh = extra / RADIX;\n        extra = extra - rh * RADIX;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] + rh;\n            rh = r / RADIX;\n            mant[i] = r - rh * RADIX;\n        }\n\n        return extra;\n    }\n\n    /** Add x to this.\n     * @param x number to add\n     * @return sum of this and x\n     */\n    public Dfp add(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n        }\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE) {\n                return this;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign == x.sign) {\n                return x;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE && sign != x.sign) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                Dfp result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, ADD_TRAP, x, result);\n                return result;\n            }\n        }\n\n        /* copy this and the arg */\n        Dfp a = newInstance(this);\n        Dfp b = newInstance(x);\n\n        /* initialize the result object */\n        Dfp result = newInstance(getZero());\n\n        /* Make all numbers positive, but remember their sign */\n        final byte asign = a.sign;\n        final byte bsign = b.sign;\n\n        a.sign = 1;\n        b.sign = 1;\n\n        /* The result will be signed like the arg with greatest magnitude */\n        byte rsign = bsign;\n        if (compare(a, b) > 0) {\n            rsign = asign;\n        }\n\n        /* Handle special case when a or b is zero, by setting the exponent\n       of the zero number equal to the other one.  This avoids an alignment\n       which would cause catastropic loss of precision */\n        if (b.mant[mant.length-1] == 0) {\n            b.exp = a.exp;\n        }\n\n        if (a.mant[mant.length-1] == 0) {\n            a.exp = b.exp;\n        }\n\n        /* align number with the smaller exponent */\n        int aextradigit = 0;\n        int bextradigit = 0;\n        if (a.exp < b.exp) {\n            aextradigit = a.align(b.exp);\n        } else {\n            bextradigit = b.align(a.exp);\n        }\n\n        /* complement the smaller of the two if the signs are different */\n        if (asign != bsign) {\n            if (asign == rsign) {\n                bextradigit = b.complement(bextradigit);\n            } else {\n                aextradigit = a.complement(aextradigit);\n            }\n        }\n\n        /* add the mantissas */\n        int rh = 0; /* acts as a carry */\n        for (int i = 0; i < mant.length; i++) {\n            final int r = a.mant[i]+b.mant[i]+rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n        result.exp = a.exp;\n        result.sign = rsign;\n\n        /* handle overflow -- note, when asign!=bsign an overflow is\n         * normal and should be ignored.  */\n\n        if (rh != 0 && (asign == bsign)) {\n            final int lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n            final int excp = result.round(lostdigit);\n            if (excp != 0) {\n                result = dotrap(excp, ADD_TRAP, x, result);\n            }\n        }\n\n        /* normalize the result */\n        for (int i = 0; i < mant.length; i++) {\n            if (result.mant[mant.length-1] != 0) {\n                break;\n            }\n            result.shiftLeft();\n            if (i == 0) {\n                result.mant[0] = aextradigit+bextradigit;\n                aextradigit = 0;\n                bextradigit = 0;\n            }\n        }\n\n        /* result is zero if after normalization the most sig. digit is zero */\n        if (result.mant[mant.length-1] == 0) {\n            result.exp = 0;\n\n            if (asign != bsign) {\n                // Unless adding 2 negative zeros, sign is positive\n                result.sign = 1;  // Per IEEE 854-1987 Section 6.3\n            }\n        }\n\n        /* Call round to test for over/under flows */\n        final int excp = result.round(aextradigit + bextradigit);\n        if (excp != 0) {\n            result = dotrap(excp, ADD_TRAP, x, result);\n        }\n\n        return result;\n    }\n\n    /** Returns a number that is this number with the sign bit reversed.\n     * @return the opposite of this\n     */\n    public Dfp negate() {\n        Dfp result = newInstance(this);\n        result.sign = (byte) - result.sign;\n        return result;\n    }\n\n    /** Subtract x from this.\n     * @param x number to subtract\n     * @return difference of this and a\n     */\n    public Dfp subtract(final Dfp x) {\n        return add(x.negate());\n    }\n\n    /** Round this given the next digit n using the current rounding mode.\n     * @param n ???\n     * @return the IEEE flag if an exception occurred\n     */\n    protected int round(int n) {\n        boolean inc = false;\n        switch (field.getRoundingMode()) {\n            case ROUND_DOWN:\n                inc = false;\n                break;\n\n            case ROUND_UP:\n                inc = n != 0;       // round up if n!=0\n                break;\n\n            case ROUND_HALF_UP:\n                inc = n >= 5000;  // round half up\n                break;\n\n            case ROUND_HALF_DOWN:\n                inc = n > 5000;  // round half down\n                break;\n\n            case ROUND_HALF_EVEN:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\n                break;\n\n            case ROUND_HALF_ODD:\n                inc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\n                break;\n\n            case ROUND_CEIL:\n                inc = sign == 1 && n != 0;  // round ceil\n                break;\n\n            case ROUND_FLOOR:\n            default:\n                inc = sign == -1 && n != 0;  // round floor\n                break;\n        }\n\n        if (inc) {\n            // increment if necessary\n            int rh = 1;\n            for (int i = 0; i < mant.length; i++) {\n                final int r = mant[i] + rh;\n                rh = r / RADIX;\n                mant[i] = r - rh * RADIX;\n            }\n\n            if (rh != 0) {\n                shiftRight();\n                mant[mant.length-1] = rh;\n            }\n        }\n\n        // check for exceptional cases and raise signals if necessary\n        if (exp < MIN_EXP) {\n            // Gradual Underflow\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return DfpField.FLAG_UNDERFLOW;\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return 0;\n\n    }\n\n    /** Multiply this by x.\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if ( (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] == 0) ||\n                    (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] == 0) ) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n                return result;\n            }\n        }\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x.mant[j];    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + x.exp + md - 2 * mant.length + 1;\n        result.sign = (byte)((sign == x.sign)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Multiply this by a single digit 0&lt;=x&lt;radix.\n     * There are speed advantages in this special case\n     * @param x multiplicand\n     * @return product of this and x\n     */\n    public Dfp multiply(final int x) {\n        Dfp result = newInstance(this);\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE && x != 0) {\n                result = newInstance(this);\n                return result;\n            }\n\n            if (nans == INFINITE && x == 0) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(getZero()), result);\n                return result;\n            }\n        }\n\n        /* range check x */\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        int rh = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = mant[i] * x + rh;\n            rh = r / RADIX;\n            result.mant[i] = r - rh * RADIX;\n        }\n\n        int lostdigit = 0;\n        if (rh != 0) {\n            lostdigit = result.mant[0];\n            result.shiftRight();\n            result.mant[mant.length-1] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp = result.round(lostdigit);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n    }\n\n    /** Divide this by divisor.\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(Dfp divisor) {\n        int dividend[]; // current status of the dividend\n        int quotient[]; // quotient\n        int remainder[];// remainder\n        int qd;         // current quotient digit we're working with\n        int nsqd;       // number of significant quotient digits we have\n        int trial=0;    // trial quotient digit\n        int minadj;     // minimum adjustment\n        boolean trialgood; // Flag to indicate a good trail digit\n        int md=0;       // most sig digit in result\n        int excp;       // exceptions\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE) {\n                result = newInstance(getZero());\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(getZero());\n                result.nans = QNAN;\n                result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, divisor, result);\n                return result;\n            }\n        }\n\n        /* Test for divide by zero */\n        if (divisor.mant[mant.length-1] == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            result = newInstance(getZero());\n            result.sign = (byte) (sign * divisor.sign);\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, divisor, result);\n            return result;\n        }\n\n        dividend = new int[mant.length+1];  // one extra digit needed\n        quotient = new int[mant.length+2];  // two extra digits needed 1 for overflow, 1 for rounding\n        remainder = new int[mant.length+1]; // one extra digit needed\n\n        /* Initialize our most significant digits to zero */\n\n        dividend[mant.length] = 0;\n        quotient[mant.length] = 0;\n        quotient[mant.length+1] = 0;\n        remainder[mant.length] = 0;\n\n        /* copy our mantissa into the dividend, initialize the\n       quotient while we are at it */\n\n        for (int i = 0; i < mant.length; i++) {\n            dividend[i] = mant[i];\n            quotient[i] = 0;\n            remainder[i] = 0;\n        }\n\n        /* outer loop.  Once per quotient digit */\n        nsqd = 0;\n        for (qd = mant.length+1; qd >= 0; qd--) {\n            /* Determine outer limits of our quotient digit */\n\n            // r =  most sig 2 digits of dividend\n            final int divMsb = dividend[mant.length]*RADIX+dividend[mant.length-1];\n            int min = divMsb       / (divisor.mant[mant.length-1]+1);\n            int max = (divMsb + 1) / divisor.mant[mant.length-1];\n\n            trialgood = false;\n            while (!trialgood) {\n                // try the mean\n                trial = (min+max)/2;\n\n                /* Multiply by divisor and store as remainder */\n                int rh = 0;\n                for (int i = 0; i < mant.length + 1; i++) {\n                    int dm = (i<mant.length)?divisor.mant[i]:0;\n                    final int r = (dm * trial) + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* subtract the remainder from the dividend */\n                rh = 1;  // carry in to aid the subtraction\n                for (int i = 0; i < mant.length + 1; i++) {\n                    final int r = ((RADIX-1) - remainder[i]) + dividend[i] + rh;\n                    rh = r / RADIX;\n                    remainder[i] = r - rh * RADIX;\n                }\n\n                /* Lets analyze what we have here */\n                if (rh == 0) {\n                    // trial is too big -- negative remainder\n                    max = trial-1;\n                    continue;\n                }\n\n                /* find out how far off the remainder is telling us we are */\n                minadj = (remainder[mant.length] * RADIX)+remainder[mant.length-1];\n                minadj = minadj / (divisor.mant[mant.length-1]+1);\n\n                if (minadj >= 2) {\n                    min = trial+minadj;  // update the minimum\n                    continue;\n                }\n\n                /* May have a good one here, check more thoroughly.  Basically\n           its a good one if it is less than the divisor */\n                trialgood = false;  // assume false\n                for (int i = mant.length - 1; i >= 0; i--) {\n                    if (divisor.mant[i] > remainder[i]) {\n                        trialgood = true;\n                    }\n                    if (divisor.mant[i] < remainder[i]) {\n                        break;\n                    }\n                }\n\n                if (remainder[mant.length] != 0) {\n                    trialgood = false;\n                }\n\n                if (trialgood == false) {\n                    min = trial+1;\n                }\n            }\n\n            /* Great we have a digit! */\n            quotient[qd] = trial;\n            if (trial != 0 || nsqd != 0) {\n                nsqd++;\n            }\n\n            if (field.getRoundingMode() == DfpField.RoundingMode.ROUND_DOWN && nsqd == mant.length) {\n                // We have enough for this mode\n                break;\n            }\n\n            if (nsqd > mant.length) {\n                // We have enough digits\n                break;\n            }\n\n            /* move the remainder into the dividend while left shifting */\n            dividend[0] = 0;\n            for (int i = 0; i < mant.length; i++) {\n                dividend[i + 1] = remainder[i];\n            }\n        }\n\n        /* Find the most sig digit */\n        md = mant.length;  // default\n        for (int i = mant.length + 1; i >= 0; i--) {\n            if (quotient[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        /* Copy the digits into the result */\n        for (int i=0; i<mant.length; i++) {\n            result.mant[mant.length-i-1] = quotient[md-i];\n        }\n\n        /* Fixup the exponent. */\n        result.exp = exp - divisor.exp + md - mant.length;\n        result.sign = (byte) ((sign == divisor.sign) ? 1 : -1);\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        if (md > (mant.length-1)) {\n            excp = result.round(quotient[md-mant.length]);\n        } else {\n            excp = result.round(0);\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, divisor, result);\n        }\n\n        return result;\n    }\n\n    /** Divide by a single digit less than radix.\n     *  Special case, so there are speed advantages. 0 &lt;= divisor &lt; radix\n     * @param divisor divisor\n     * @return quotient of this by divisor\n     */\n    public Dfp divide(int divisor) {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (divisor == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (divisor < 0 || divisor >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[i] = rh;\n        }\n\n        if (result.mant[mant.length-1] == 0) {\n            // normalize\n            result.shiftLeft();\n            final int r = rl * RADIX;        // compute the next digit and put it in\n            final int rh = r / divisor;\n            rl = r - rh * divisor;\n            result.mant[0] = rh;\n        }\n\n        final int excp = result.round(rl * RADIX / divisor);  // do the rounding\n        if (excp != 0) {\n            result = dotrap(excp, DIVIDE_TRAP, result, result);\n        }\n\n        return result;\n\n    }\n\n    /** Compute the square root.\n     * @return square root of the instance\n     */\n    public Dfp sqrt() {\n\n        // check for unusual cases\n        if (nans == FINITE && mant[mant.length-1] == 0) {\n            // if zero\n            return newInstance(this);\n        }\n\n        if (nans != FINITE) {\n            if (nans == INFINITE && sign == 1) {\n                // if positive infinity\n                return newInstance(this);\n            }\n\n            if (nans == QNAN) {\n                return newInstance(this);\n            }\n\n            if (nans == SNAN) {\n                Dfp result;\n\n                field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n                result = newInstance(this);\n                result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n                return result;\n            }\n        }\n\n        if (sign == -1) {\n            // if negative\n            Dfp result;\n\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            result = newInstance(this);\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, SQRT_TRAP, null, result);\n            return result;\n        }\n\n        Dfp x = newInstance(this);\n\n        /* Lets make a reasonable guess as to the size of the square root */\n        if (x.exp < -1 || x.exp > 1) {\n            x.exp = this.exp / 2;\n        }\n\n        /* Coarsely estimate the mantissa */\n        switch (x.mant[mant.length-1] / 2000) {\n            case 0:\n                x.mant[mant.length-1] = x.mant[mant.length-1]/2+1;\n                break;\n            case 2:\n                x.mant[mant.length-1] = 1500;\n                break;\n            case 3:\n                x.mant[mant.length-1] = 2200;\n                break;\n            default:\n                x.mant[mant.length-1] = 3000;\n        }\n\n        Dfp dx = newInstance(x);\n\n        /* Now that we have the first pass estimate, compute the rest\n       by the formula dx = (y - x*x) / (2x); */\n\n        Dfp px  = getZero();\n        Dfp ppx = getZero();\n        while (x.unequal(px)) {\n            dx = newInstance(x);\n            dx.sign = -1;\n            dx = dx.add(this.divide(x));\n            dx = dx.divide(2);\n            ppx = px;\n            px = x;\n            x = x.add(dx);\n\n            if (x.equals(ppx)) {\n                // alternating between two values\n                break;\n            }\n\n            // if dx is zero, break.  Note testing the most sig digit\n            // is a sufficient test since dx is normalized\n            if (dx.mant[mant.length-1] == 0) {\n                break;\n            }\n        }\n\n        return x;\n\n    }\n\n    /** Get a string representation of the instance.\n     * @return string representation of the instance\n     */\n    @Override\n    public String toString() {\n        if (nans != FINITE) {\n            // if non-finite exceptional cases\n            if (nans == INFINITE) {\n                return (sign < 0) ? NEG_INFINITY_STRING : POS_INFINITY_STRING;\n            } else {\n                return NAN_STRING;\n            }\n        }\n\n        if (exp > mant.length || exp < -1) {\n            return dfp2sci();\n        }\n\n        return dfp2string();\n\n    }\n\n    /** Convert an instance to a string using scientific notation.\n     * @return string representation of the instance in scientific notation\n     */\n    protected String dfp2sci() {\n        char rawdigits[]    = new char[mant.length * 4];\n        char outputbuffer[] = new char[mant.length * 4 + 20];\n        int p;\n        int q;\n        int e;\n        int ae;\n        int shf;\n\n        // Get all the digits\n        p = 0;\n        for (int i = mant.length - 1; i >= 0; i--) {\n            rawdigits[p++] = (char) ((mant[i] / 1000) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 100) %10) + '0');\n            rawdigits[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            rawdigits[p++] = (char) (((mant[i]) % 10) + '0');\n        }\n\n        // Find the first non-zero one\n        for (p = 0; p < rawdigits.length; p++) {\n            if (rawdigits[p] != '0') {\n                break;\n            }\n        }\n        shf = p;\n\n        // Now do the conversion\n        q = 0;\n        if (sign == -1) {\n            outputbuffer[q++] = '-';\n        }\n\n        if (p != rawdigits.length) {\n            // there are non zero digits...\n            outputbuffer[q++] = rawdigits[p++];\n            outputbuffer[q++] = '.';\n\n            while (p<rawdigits.length) {\n                outputbuffer[q++] = rawdigits[p++];\n            }\n        } else {\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = '.';\n            outputbuffer[q++] = '0';\n            outputbuffer[q++] = 'e';\n            outputbuffer[q++] = '0';\n            return new String(outputbuffer, 0, 5);\n        }\n\n        outputbuffer[q++] = 'e';\n\n        // Find the msd of the exponent\n\n        e = exp * 4 - shf - 1;\n        ae = e;\n        if (e < 0) {\n            ae = -e;\n        }\n\n        // Find the largest p such that p < e\n        for (p = 1000000000; p > ae; p /= 10) {\n            // nothing to do\n        }\n\n        if (e < 0) {\n            outputbuffer[q++] = '-';\n        }\n\n        while (p > 0) {\n            outputbuffer[q++] = (char)(ae / p + '0');\n            ae = ae % p;\n            p = p / 10;\n        }\n\n        return new String(outputbuffer, 0, q);\n\n    }\n\n    /** Convert an instance to a string using normal notation.\n     * @return string representation of the instance in normal notation\n     */\n    protected String dfp2string() {\n        char buffer[] = new char[mant.length*4 + 20];\n        int p = 1;\n        int q;\n        int e = exp;\n        boolean pointInserted = false;\n\n        buffer[0] = ' ';\n\n        if (e <= 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '.';\n            pointInserted = true;\n        }\n\n        while (e < 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e++;\n        }\n\n        for (int i = mant.length - 1; i >= 0; i--) {\n            buffer[p++] = (char) ((mant[i] / 1000) + '0');\n            buffer[p++] = (char) (((mant[i] / 100) % 10) + '0');\n            buffer[p++] = (char) (((mant[i] / 10) % 10) + '0');\n            buffer[p++] = (char) (((mant[i]) % 10) + '0');\n            if (--e == 0) {\n                buffer[p++] = '.';\n                pointInserted = true;\n            }\n        }\n\n        while (e > 0) {\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            buffer[p++] = '0';\n            e--;\n        }\n\n        if (!pointInserted) {\n            // Ensure we have a radix point!\n            buffer[p++] = '.';\n        }\n\n        // Suppress leading zeros\n        q = 1;\n        while (buffer[q] == '0') {\n            q++;\n        }\n        if (buffer[q] == '.') {\n            q--;\n        }\n\n        // Suppress trailing zeros\n        while (buffer[p-1] == '0') {\n            p--;\n        }\n\n        // Insert sign\n        if (sign < 0) {\n            buffer[--q] = '-';\n        }\n\n        return new String(buffer, q, p - q);\n\n    }\n\n    /** Raises a trap.  This does not set the corresponding flag however.\n     *  @param type the trap type\n     *  @param what - name of routine trap occurred in\n     *  @param oper - input operator to function\n     *  @param result - the result computed prior to the trap\n     *  @return The suggested return value from the trap handler\n     */\n    public Dfp dotrap(int type, String what, Dfp oper, Dfp result) {\n        Dfp def = result;\n\n        switch (type) {\n            case DfpField.FLAG_INVALID:\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = QNAN;\n                break;\n\n            case DfpField.FLAG_DIV_ZERO:\n                if (nans == FINITE && mant[mant.length-1] != 0) {\n                    // normal case, we are finite, non-zero\n                    def = newInstance(getZero());\n                    def.sign = (byte)(sign*oper.sign);\n                    def.nans = INFINITE;\n                }\n\n                if (nans == FINITE && mant[mant.length-1] == 0) {\n                    //  0/0\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == QNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n\n                if (nans == INFINITE || nans == SNAN) {\n                    def = newInstance(getZero());\n                    def.nans = QNAN;\n                }\n                break;\n\n            case DfpField.FLAG_UNDERFLOW:\n                if ( (result.exp+mant.length) < MIN_EXP) {\n                    def = newInstance(getZero());\n                    def.sign = result.sign;\n                } else {\n                    def = newInstance(result);  // gradual underflow\n                }\n                result.exp = result.exp + ERR_SCALE;\n                break;\n\n            case DfpField.FLAG_OVERFLOW:\n                result.exp = result.exp - ERR_SCALE;\n                def = newInstance(getZero());\n                def.sign = result.sign;\n                def.nans = INFINITE;\n                break;\n\n            default: def = result; break;\n        }\n\n        return trap(type, what, oper, def, result);\n\n    }\n\n    /** Trap handler.  Subclasses may override this to provide trap\n     *  functionality per IEEE 854-1987.\n     *\n     *  @param type  The exception type - e.g. FLAG_OVERFLOW\n     *  @param what  The name of the routine we were in e.g. divide()\n     *  @param oper  An operand to this function if any\n     *  @param def   The default return value if trap not enabled\n     *  @param result    The result that is specified to be delivered per\n     *                   IEEE 854, if any\n     *  @return the value that should be return by the operation triggering the trap\n     */\n    protected Dfp trap(int type, String what, Dfp oper, Dfp def, Dfp result) {\n        return def;\n    }\n\n    /** Returns the type - one of FINITE, INFINITE, SNAN, QNAN.\n     * @return type of the number\n     */\n    public int classify() {\n        return nans;\n    }\n\n    /** Creates an instance that is the same as x except that it has the sign of y.\n     * abs(x) = dfp.copysign(x, dfp.one)\n     * @param x number to get the value from\n     * @param y number to get the sign from\n     * @return a number with the value of x and the sign of y\n     */\n    public static Dfp copysign(final Dfp x, final Dfp y) {\n        Dfp result = x.newInstance(x);\n        result.sign = y.sign;\n        return result;\n    }\n\n    /** Returns the next number greater than this one in the direction of x.\n     * If this==x then simply returns this.\n     * @param x direction where to look at\n     * @return closest number next to instance in the direction of x\n     */\n    public Dfp nextAfter(final Dfp x) {\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, NEXT_AFTER_TRAP, x, result);\n        }\n\n        // if this is greater than x\n        boolean up = false;\n        if (this.lessThan(x)) {\n            up = true;\n        }\n\n        if (compare(this, x) == 0) {\n            return newInstance(x);\n        }\n\n        if (lessThan(getZero())) {\n            up = !up;\n        }\n\n        final Dfp inc;\n        Dfp result;\n        if (up) {\n            inc = newInstance(getOne());\n            inc.exp = this.exp-mant.length+1;\n            inc.sign = this.sign;\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = add(inc);\n        } else {\n            inc = newInstance(getOne());\n            inc.exp = this.exp;\n            inc.sign = this.sign;\n\n            if (this.equals(inc)) {\n                inc.exp = this.exp-mant.length;\n            } else {\n                inc.exp = this.exp-mant.length+1;\n            }\n\n            if (this.equals(getZero())) {\n                inc.exp = MIN_EXP-mant.length;\n            }\n\n            result = this.subtract(inc);\n        }\n\n        if (result.classify() == INFINITE && this.classify() != INFINITE) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        if (result.equals(getZero()) && this.equals(getZero()) == false) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            result = dotrap(DfpField.FLAG_INEXACT, NEXT_AFTER_TRAP, x, result);\n        }\n\n        return result;\n\n    }\n\n    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        int cmp0 = compare(this, getZero());\n        if (cmp0 == 0) {\n            return sign < 0 ? -0.0 : +0.0;\n        } else if (cmp0 < 0) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }\n\n    /** Convert the instance into a split double.\n     * @return an array of two doubles which sum represent the instance\n     * @see #toDouble()\n     */\n    public double[] toSplitDouble() {\n        double split[] = new double[2];\n        long mask = 0xffffffffc0000000L;\n\n        split[0] = Double.longBitsToDouble(Double.doubleToLongBits(toDouble()) & mask);\n        split[1] = subtract(newInstance(split[0])).toDouble();\n\n        return split;\n    }\n\n}\n"}, "generated_test_class": "To write unit tests for the `toString()` method in the `Dfp` class, we need to cover different scenarios based on the logic in the method. Specifically, we need to cover the cases where:\n\n1. `nans` is `FINITE` and the exponent (`exp`) is within the range of the mantissa length.\n2. `nans` is `FINITE` and the exponent (`exp`) is outside the range of the mantissa length.\n3. `nans` is `INFINITE` and the sign is positive.\n4. `nans` is `INFINITE` and the sign is negative.\n5. `nans` is either `SNAN` or `QNAN`.\n\nGiven the fields and methods provided, we can create mock instances of `Dfp` to test these scenarios. Since the actual implementation of `dfp2sci()` and `dfp2string()` methods are not provided, we will assume they return valid string representations for the numbers.\n\nHere is the JUnit 4 test class for the `toString()` method:\n\n```java\nimport org.junit.Before;\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class DfpTest {\n\n    private Dfp dfpFiniteInRange;\n    private Dfp dfpFiniteOutRange;\n    private Dfp dfpPositiveInfinity;\n    private Dfp dfpNegativeInfinity;\n    private Dfp dfpNaN;\n\n    @Before\n    public void setUp() {\n        // Mocking the Dfp class for testing the toString method\n        dfpFiniteInRange = new DfpMock(new int[]{1000, 2000, 3000}, (byte) 1, 2, (byte) 0);\n        dfpFiniteOutRange = new DfpMock(new int[]{1000, 2000, 3000}, (byte) 1, 3, (byte) 0); // exp > mant.length\n        dfpPositiveInfinity = new DfpMock(new int[]{}, (byte) 1, 0, (byte) 1);\n        dfpNegativeInfinity = new DfpMock(new int[]{}, (byte) -1, 0, (byte) 1);\n        dfpNaN = new DfpMock(new int[]{}, (byte) 1, 0, (byte) 2); // SNAN\n    }\n\n    @Test\n    public void testToString_FiniteInRange() {\n        assertEquals(\"1.00020003000e2\", dfpFiniteInRange.toString());\n    }\n\n    @Test\n    public void testToString_FiniteOutOfRange() {\n        assertEquals(\"1.00020003000e3\", dfpFiniteOutRange.toString()); // Assuming dfp2sci() returns the same format as dfp2string()\n    }\n\n    @Test\n    public void testToString_PositiveInfinity() {\n        assertEquals(\"Infinity\", dfpPositiveInfinity.toString());\n    }\n\n    @Test\n    public void testToString_NegativeInfinity() {\n        assertEquals(\"-Infinity\", dfpNegativeInfinity.toString());\n    }\n\n    @Test\n    public void testToString_NaN() {\n        assertEquals(\"NaN\", dfpNaN.toString());\n    }\n\n    private static class DfpMock extends Dfp {\n        public DfpMock(int[] mant, byte sign, int exp, byte nans) {\n            super(null);\n            this.mant = mant;\n            this.sign = sign;\n            this.exp = exp;\n            this.nans = nans;\n        }\n\n        @Override\n        public String dfp2sci() {\n            // Simplified mock implementation for testing\n            return String.format(\"%.3fe%d\", mant[0], exp);\n        }\n\n        @Override\n        public String dfp2string() {\n            // Simplified mock implementation for testing\n            return String.format(\"%.3fe%d\", mant[0], exp);\n        }\n\n        @Override\n        protected Dfp newInstance() {\n            throw new UnsupportedOperationException();\n        }\n    }\n}\n```\n\n### Explanation:\n\n1. **DfpMock Class**: A mock implementation of the `Dfp` class is created to facilitate testing. It overrides the `dfp2sci()` and `dfp2string()` methods to return simplified string representations.\n\n2. **Test Cases**:\n   - `testToString_FiniteInRange`: Tests the scenario where `nans` is `FINITE` and the exponent is within the range of the mantissa length.\n   - `testToString_FiniteOutOfRange`: Tests the scenario where `nans` is `FINITE` and the exponent is outside the range of the mantissa length.\n   - `testToString_PositiveInfinity`: Tests the scenario where `nans` is `INFINITE` and the sign is positive.\n   - `testToString_NegativeInfinity`: Tests the scenario where `nans` is `INFINITE` and the sign is negative.\n   - `testToString_NaN`: Tests the scenario where `nans` is either `SNAN` or `QNAN`.\n\nThese tests should cover all branches and lines of the `toString()` method."}
