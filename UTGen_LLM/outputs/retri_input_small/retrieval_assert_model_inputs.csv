project,bug_num,test_name,test_prefix,source,target
Closure,Closure_62,com.google.javascript.jscomp.LightweightMessageFormatterTest::testFormatErrorSpaceEndOfLine1,,"public void testFormatErrorSpaceEndOfLine1() throws Exception { JSError error = JSError.make('javascript/complex.js', 1, 10, FOO_TYPE); LightweightMessageFormatter formatter = formatter('assert (1;'); assertEquals('javascript/complex.js:1: ERROR - error description here\n' + 'assert (1;\n' + ' ^\n', formatter.formatError(error)); } ""<FocalMethod>"" public String formatError(JSError error) { return format(error, false); }",
Closure,Closure_66,com.google.javascript.jscomp.TypeCheckTest::testGetTypedPercent5,,"public void testGetTypedPercent5() throws Exception { String js = '/** @enum {number} */ keys = {A: 1,B: 2,C: 3};'; assertEquals(100.0, getTypedPercent(js), 0.1); } ""<FocalMethod>"" double getTypedPercent() { int total = nullCount + unknownCount + typedCount; if (total == 0) { return 0.0; } else { return (100.0 * typedCount) / total; } }",
Closure,Closure_142,com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testParseLicenseWithAnnotation,,"public void testParseLicenseWithAnnotation() throws Exception { Node node = new Node(1); this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); String comment = '@license Foo \n * @author Charlie Brown */'; parse(comment); assertEquals(' Foo \n @author Charlie Brown ', node.getJSDocInfo().getLicense()); } ""<FocalMethod>"" boolean parse() { int lineno; int charno; // JSTypes are represented as Rhino AST nodes, and then resolved later. JSTypeExpression type; state = State.SEARCHING_ANNOTATION; JsDocToken token = next(); ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; // If we have a block level comment, record it. if (blockInfo.string.length() > 0) { jsdocBuilder.recordBlockDescription(blockInfo.string); } // Parse the actual JsDoc. retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addWarning('msg.bad.jsdoc.tag', annotationName, stream.getLineno(), stream.getCharno()); } else { // Mark the beginning of the annotation. jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case AUTHOR: ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addWarning('msg.jsdoc.authormissing', stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addWarning('msg.jsdoc.const', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addWarning('msg.jsdoc.interface.constructor', stream.getLineno(), stream.getCharno()); } else { parser.addWarning('msg.jsdoc.incompat.type', stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addWarning('msg.jsdoc.deprecated', stream.getLineno(), stream.getCharno()); } // Find the reason/description, if any. ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addWarning('msg.jsdoc.interface.constructor', stream.getLineno(), stream.getCharno()); } else { parser.addWarning('msg.jsdoc.incompat.type', stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addWarning('msg.jsdoc.desc.extra', stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW: ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); String fileOverview = fileOverviewInfo.string; if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addWarning('msg.jsdoc.fileoverview.extra', stream.getLineno(), stream.getCharno()); } token = fileOverviewInfo.token; continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode('number')); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addWarning('msg.jsdoc.incompat.type', lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addWarning('msg.jsdoc.export', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addWarning('msg.jsdoc.externs', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addWarning('msg.jsdoc.javadispatch', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { if (!jsdocBuilder.recordBaseType(type)) { parser.addWarning( 'msg.jsdoc.incompat.type', lineno, charno); } } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addWarning('msg.jsdoc.implements.duplicate', lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addWarning('msg.jsdoc.missing.rc', stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addWarning('msg.end.annotation.expected', stream.getLineno(), stream.getCharno()); } } else { parser.addWarning('msg.no.type.name', lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addWarning('msg.jsdoc.hidden', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addWarning('msg.jsdoc.noalias', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addWarning('msg.jsdoc.nocheck', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addWarning('msg.jsdoc.override', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { // parsing error reported during recursive descent // recovering parsing token = eatTokensUntilEOL(); continue retry; } } // *Update* the token to that after the type annotation. token = current(); // Save the throw type. jsdocBuilder.recordThrowType(type); // Find the throw's description (if applicable). ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; continue retry; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { // parsing error reported during recursive descent // recovering parsing token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addWarning('msg.missing.variable.name', lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); // Throw out JsDocToolkit's 'default' parameter annotation. // It makes no sense under our type system. if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning('msg.jsdoc.missing.rb'); } else if (type != null) { // Make the type expression optional, if it isn't // already. type = JSTypeExpression.makeOptionalArg(type); } } // If the param name has a DOT in it, just throw it out // quietly. We do not handle the JsDocToolkit method // for handling properties of params. if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addWarning('msg.dup.variable.name', name, lineno, charno); } else { parser.addWarning('msg.jsdoc.incompat.type', name, lineno, charno); } } } if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, lineno, charno); // Find the parameter's description (if applicable). ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addWarning('msg.jsdoc.preservertry', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addWarning('msg.jsdoc.visibility.private', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addWarning('msg.jsdoc.visibility.protected', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addWarning('msg.jsdoc.visibility.public', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addWarning('msg.jsdoc.noshadow', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addWarning('msg.jsdoc.nosideeffects', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addWarning('msg.jsdoc.implicitcast', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE: ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addWarning('msg.jsdoc.seemissing', stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addWarning('msg.jsdoc.templatemissing', stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addWarning('msg.jsdoc.template.at.most.once', stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addWarning('msg.jsdoc.versionmissing', stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addWarning('msg.jsdoc.extraversion', stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF: skipEOLs(); lineno = stream.getLineno(); charno = stream.getCharno(); token = next(); Node typeNode = parseAndRecordTypeNode(token, lineno, charno); if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { // error reported during recursive descent // recovering parsing } else { switch (annotation) { case DEFINE: if (!isValidDefineType(typeNode)) { parser.addWarning('msg.jsdoc.define.badtype', lineno, charno); } else if (!jsdocBuilder.recordDefineType(type)) { parser.addWarning('msg.jsdoc.define', lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addWarning( 'msg.jsdoc.incompat.type', lineno, charno); break; } // *Update* the token to that after the type annotation. token = current(); // Find the return's description (if applicable). ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription); } token = returnDescriptionInfo.token; continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addWarning( 'msg.jsdoc.incompat.type', lineno, charno); } break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addWarning( 'msg.jsdoc.incompat.type', lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addWarning( 'msg.jsdoc.incompat.type', lineno, charno); } break; } token = eatTokensUntilEOL(); } continue retry; } } } break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } return true; case EOF: // discard any accumulated information jsdocBuilder.build(null); parser.addWarning('msg.unexpected.eof', stream.getLineno(), stream.getCharno()); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } // next token token = next(); } }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('1'))); assertTrue(NodeUtil.isBooleanResult(getNode('true'))); assertFalse(NodeUtil.isBooleanResult(getNode('+true'))); assertFalse(NodeUtil.isBooleanResult(getNode('+1'))); assertFalse(NodeUtil.isBooleanResult(getNode('-1'))); assertFalse(NodeUtil.isBooleanResult(getNode('-Infinity'))); assertFalse(NodeUtil.isBooleanResult(getNode('Infinity'))); assertFalse(NodeUtil.isBooleanResult(getNode('NaN'))); assertFalse(NodeUtil.isBooleanResult(getNode('undefined'))); assertFalse(NodeUtil.isBooleanResult(getNode('void 0'))); assertFalse(NodeUtil.isBooleanResult(getNode('a << b'))); assertFalse(NodeUtil.isBooleanResult(getNode('a >> b'))); assertFalse(NodeUtil.isBooleanResult(getNode('a >>> b'))); assertTrue(NodeUtil.isBooleanResult(getNode('a == b'))); assertTrue(NodeUtil.isBooleanResult(getNode('a != b'))); assertTrue(NodeUtil.isBooleanResult(getNode('a === b'))); assertTrue(NodeUtil.isBooleanResult(getNode('a !== b'))); assertTrue(NodeUtil.isBooleanResult(getNode('a < b'))); assertTrue(NodeUtil.isBooleanResult(getNode('a > b'))); assertTrue(NodeUtil.isBooleanResult(getNode('a <= b'))); assertTrue(NodeUtil.isBooleanResult(getNode('a >= b'))); assertTrue(NodeUtil.isBooleanResult(getNode('a in b'))); assertTrue(NodeUtil.isBooleanResult(getNode('a instanceof b'))); assertFalse(NodeUtil.isBooleanResult(getNode(''a''))); assertFalse(NodeUtil.isBooleanResult(getNode(''a'+b'))); assertFalse(NodeUtil.isBooleanResult(getNode('a+'b''))); assertFalse(NodeUtil.isBooleanResult(getNode('a+b'))); assertFalse(NodeUtil.isBooleanResult(getNode('a()'))); assertFalse(NodeUtil.isBooleanResult(getNode('''.a'))); assertFalse(NodeUtil.isBooleanResult(getNode('a.b'))); assertFalse(NodeUtil.isBooleanResult(getNode('a.b()'))); assertFalse(NodeUtil.isBooleanResult(getNode('a().b()'))); assertFalse(NodeUtil.isBooleanResult(getNode('new a()'))); assertTrue(NodeUtil.isBooleanResult(getNode('delete a'))); // Definitely not boolean assertFalse(NodeUtil.isBooleanResult(getNode('([true,false])'))); assertFalse(NodeUtil.isBooleanResult(getNode('({a:true})'))); // These are boolean but aren't handled yet, 'false' here means 'unknown'. assertTrue(NodeUtil.isBooleanResult(getNode('true && false'))); assertTrue(NodeUtil.isBooleanResult(getNode('true || false'))); assertTrue(NodeUtil.isBooleanResult(getNode('a ? true : false'))); assertTrue(NodeUtil.isBooleanResult(getNode('a,true'))); assertTrue(NodeUtil.isBooleanResult(getNode('a=true'))); assertFalse(NodeUtil.isBooleanResult(getNode('a=1'))); } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('1'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('true'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('+true'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('+1'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('-1'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('-Infinity'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('Infinity'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('NaN'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('undefined'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('void 0'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('a << b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('a >> b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('a >>> b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('a == b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('a != b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('a === b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('a !== b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('a < b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('a > b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('a <= b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('a >= b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('a in b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('a instanceof b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode(''a''))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode(''a'+b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('a+'b''))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('a+b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('a()'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('''.a'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('a.b'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('a.b()'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('a().b()'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertFalse(NodeUtil.isBooleanResult(getNode('new a()'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { assertTrue(NodeUtil.isBooleanResult(getNode('delete a'))); // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { // Definitely not boolean assertFalse(NodeUtil.isBooleanResult(getNode('([true,false])'))); // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { // Definitely not boolean assertFalse(NodeUtil.isBooleanResult(getNode('({a:true})'))); // These are boolean but aren't handled yet, 'false' here means 'unknown'. } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. assertTrue(NodeUtil.isBooleanResult(getNode('true && false'))); } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. assertTrue(NodeUtil.isBooleanResult(getNode('true || false'))); } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. assertTrue(NodeUtil.isBooleanResult(getNode('a ? true : false'))); } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. assertTrue(NodeUtil.isBooleanResult(getNode('a,true'))); } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. assertTrue(NodeUtil.isBooleanResult(getNode('a=true'))); } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_80,com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult,,"public void testIsBooleanResult() { // Definitely not boolean // These are boolean but aren't handled yet, 'false' here means 'unknown'. assertFalse(NodeUtil.isBooleanResult(getNode('a=1'))); } ""<FocalMethod>"" static boolean isBooleanResult(Node n) { return valueCheck(n, BOOLEAN_RESULT_PREDICATE); }",
Closure,Closure_169,com.google.javascript.rhino.jstype.RecordTypeTest::testSubtypeWithUnknowns2,,"public void testSubtypeWithUnknowns2() throws Exception { JSType recordA = new RecordTypeBuilder(registry) .addProperty('a', new FunctionBuilder(registry) .withReturnType(NUMBER_TYPE) .build(), null) .build(); JSType recordB = new RecordTypeBuilder(registry) .addProperty('a', new FunctionBuilder(registry) .withReturnType(UNKNOWN_TYPE) .build(), null) .build(); assertTrue(recordA.isSubtype(recordB)); assertTrue(recordB.isSubtype(recordA)); } ""<FocalMethod>"" @Override public boolean isSubtype(JSType that) { if (JSType.isSubtypeHelper(this, that)) { return true; } // Top of the record types is the empty record, or OBJECT_TYPE. if (registry.getNativeObjectType( JSTypeNative.OBJECT_TYPE).isSubtype(that)) { return true; } // A type is a subtype of a record type if it itself is a record // type and it has at least the same members as the parent record type // with the same types. if (!that.isRecordType()) { return false; } return RecordType.isSubtype(this, that.toMaybeRecordType()); }",
Closure,Closure_169,com.google.javascript.rhino.jstype.RecordTypeTest::testSubtypeWithUnknowns2,,"public void testSubtypeWithUnknowns2() throws Exception { JSType recordA = new RecordTypeBuilder(registry) .addProperty('a', new FunctionBuilder(registry) .withReturnType(NUMBER_TYPE) .build(), null) .build(); JSType recordB = new RecordTypeBuilder(registry) .addProperty('a', new FunctionBuilder(registry) .withReturnType(UNKNOWN_TYPE) .build(), null) .build(); assertTrue(recordA.isSubtype(recordB)); } ""<FocalMethod>"" @Override public boolean isSubtype(JSType that) { if (JSType.isSubtypeHelper(this, that)) { return true; } // Top of the record types is the empty record, or OBJECT_TYPE. if (registry.getNativeObjectType( JSTypeNative.OBJECT_TYPE).isSubtype(that)) { return true; } // A type is a subtype of a record type if it itself is a record // type and it has at least the same members as the parent record type // with the same types. if (!that.isRecordType()) { return false; } return RecordType.isSubtype(this, that.toMaybeRecordType()); }",
Closure,Closure_169,com.google.javascript.rhino.jstype.RecordTypeTest::testSubtypeWithUnknowns2,,"public void testSubtypeWithUnknowns2() throws Exception { JSType recordA = new RecordTypeBuilder(registry) .addProperty('a', new FunctionBuilder(registry) .withReturnType(NUMBER_TYPE) .build(), null) .build(); JSType recordB = new RecordTypeBuilder(registry) .addProperty('a', new FunctionBuilder(registry) .withReturnType(UNKNOWN_TYPE) .build(), null) .build(); assertTrue(recordB.isSubtype(recordA)); } ""<FocalMethod>"" @Override public boolean isSubtype(JSType that) { if (JSType.isSubtypeHelper(this, that)) { return true; } // Top of the record types is the empty record, or OBJECT_TYPE. if (registry.getNativeObjectType( JSTypeNative.OBJECT_TYPE).isSubtype(that)) { return true; } // A type is a subtype of a record type if it itself is a record // type and it has at least the same members as the parent record type // with the same types. if (!that.isRecordType()) { return false; } return RecordType.isSubtype(this, that.toMaybeRecordType()); }",
Closure,Closure_144,com.google.javascript.jscomp.LooseTypeCheckTest::testDontAddMethodsIfNoConstructor,,"public void testDontAddMethodsIfNoConstructor() throws Exception { Node js1Node = parseAndTypeCheck( 'function A() {}' + 'A.prototype = {m1: 5, m2: true}'); JSType functionAType = js1Node.getFirstChild().getJSType(); assertEquals('function (): undefined', functionAType.toString()); assertEquals(UNKNOWN_TYPE, U2U_FUNCTION_TYPE.getPropertyType('m1')); assertEquals(UNKNOWN_TYPE, U2U_FUNCTION_TYPE.getPropertyType('m2')); } ""<FocalMethod>"" private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { // TODO(nicksantos): This branch indicates a compiler bug, not worthy of // halting the compilation but we should log this and analyze to track // down why it happens. This is not critical and will be resolved over // time as the type checker is extended. return getNativeType(UNKNOWN_TYPE); } else { return jsType; } }",
Closure,Closure_144,com.google.javascript.jscomp.LooseTypeCheckTest::testDontAddMethodsIfNoConstructor,,"public void testDontAddMethodsIfNoConstructor() throws Exception { Node js1Node = parseAndTypeCheck( 'function A() {}' + 'A.prototype = {m1: 5, m2: true}'); JSType functionAType = js1Node.getFirstChild().getJSType(); assertEquals('function (): undefined', functionAType.toString()); } ""<FocalMethod>"" private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { // TODO(nicksantos): This branch indicates a compiler bug, not worthy of // halting the compilation but we should log this and analyze to track // down why it happens. This is not critical and will be resolved over // time as the type checker is extended. return getNativeType(UNKNOWN_TYPE); } else { return jsType; } }",
Closure,Closure_144,com.google.javascript.jscomp.LooseTypeCheckTest::testDontAddMethodsIfNoConstructor,,"public void testDontAddMethodsIfNoConstructor() throws Exception { Node js1Node = parseAndTypeCheck( 'function A() {}' + 'A.prototype = {m1: 5, m2: true}'); JSType functionAType = js1Node.getFirstChild().getJSType(); assertEquals(UNKNOWN_TYPE, U2U_FUNCTION_TYPE.getPropertyType('m1')); } ""<FocalMethod>"" private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { // TODO(nicksantos): This branch indicates a compiler bug, not worthy of // halting the compilation but we should log this and analyze to track // down why it happens. This is not critical and will be resolved over // time as the type checker is extended. return getNativeType(UNKNOWN_TYPE); } else { return jsType; } }",
Closure,Closure_144,com.google.javascript.jscomp.LooseTypeCheckTest::testDontAddMethodsIfNoConstructor,,"public void testDontAddMethodsIfNoConstructor() throws Exception { Node js1Node = parseAndTypeCheck( 'function A() {}' + 'A.prototype = {m1: 5, m2: true}'); JSType functionAType = js1Node.getFirstChild().getJSType(); assertEquals(UNKNOWN_TYPE, U2U_FUNCTION_TYPE.getPropertyType('m2')); } ""<FocalMethod>"" private JSType getJSType(Node n) { JSType jsType = n.getJSType(); if (jsType == null) { // TODO(nicksantos): This branch indicates a compiler bug, not worthy of // halting the compilation but we should log this and analyze to track // down why it happens. This is not critical and will be resolved over // time as the type checker is extended. return getNativeType(UNKNOWN_TYPE); } else { return jsType; } }",
Closure,Closure_32,com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testParseLicense,,"public void testParseLicense() throws Exception { Node node = new Node(1); this.fileLevelJsDocBuilder = node.getJsDocBuilderForNode(); String comment = '@license Foo\nBar\n\nBaz*/'; parse(comment); assertEquals(' Foo\nBar\n\nBaz', node.getJSDocInfo().getLicense()); } ""<FocalMethod>"" boolean parse() { int lineno; int charno; // JSTypes are represented as Rhino AST nodes, and then resolved later. JSTypeExpression type; state = State.SEARCHING_ANNOTATION; skipEOLs(); JsDocToken token = next(); List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList(); // Always record that we have a comment. if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo blockInfo = extractBlockComment(token); token = blockInfo.token; if (!blockInfo.string.isEmpty()) { jsdocBuilder.recordBlockDescription(blockInfo.string); } } else { if (token != JsDocToken.ANNOTATION && token != JsDocToken.EOC) { // Mark that there was a description, but don't bother marking // what it was. jsdocBuilder.recordBlockDescription('); } } // Parse the actual JsDoc. retry: for (;;) { switch (token) { case ANNOTATION: if (state == State.SEARCHING_ANNOTATION) { state = State.SEARCHING_NEWLINE; lineno = stream.getLineno(); charno = stream.getCharno(); String annotationName = stream.getString(); Annotation annotation = annotationNames.get(annotationName); if (annotation == null) { parser.addParserWarning('msg.bad.jsdoc.tag', annotationName, stream.getLineno(), stream.getCharno()); } else { // Mark the beginning of the annotation. jsdocBuilder.markAnnotation(annotationName, lineno, charno); switch (annotation) { case AUTHOR: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo authorInfo = extractSingleLineBlock(); String author = authorInfo.string; if (author.length() == 0) { parser.addParserWarning('msg.jsdoc.authormissing', stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addAuthor(author); } token = authorInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case CONSISTENTIDGENERATOR: if (!jsdocBuilder.recordConsistentIdGenerator()) { parser.addParserWarning('msg.jsdoc.consistidgen', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTANT: if (!jsdocBuilder.recordConstancy()) { parser.addParserWarning('msg.jsdoc.const', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case CONSTRUCTOR: if (!jsdocBuilder.recordConstructor()) { if (jsdocBuilder.isInterfaceRecorded()) { parser.addTypeWarning('msg.jsdoc.interface.constructor', stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning('msg.jsdoc.incompat.type', stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DEPRECATED: if (!jsdocBuilder.recordDeprecated()) { parser.addParserWarning('msg.jsdoc.deprecated', stream.getLineno(), stream.getCharno()); } // Find the reason/description, if any. ExtractionInfo reasonInfo = extractMultilineTextualBlock(token); String reason = reasonInfo.string; if (reason.length() > 0) { jsdocBuilder.recordDeprecationReason(reason); } token = reasonInfo.token; continue retry; case INTERFACE: if (!jsdocBuilder.recordInterface()) { if (jsdocBuilder.isConstructorRecorded()) { parser.addTypeWarning('msg.jsdoc.interface.constructor', stream.getLineno(), stream.getCharno()); } else { parser.addTypeWarning('msg.jsdoc.incompat.type', stream.getLineno(), stream.getCharno()); } } token = eatTokensUntilEOL(); continue retry; case DESC: if (jsdocBuilder.isDescriptionRecorded()) { parser.addParserWarning('msg.jsdoc.desc.extra', stream.getLineno(), stream.getCharno()); token = eatTokensUntilEOL(); continue retry; } else { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; jsdocBuilder.recordDescription(description); token = descriptionInfo.token; continue retry; } case FILE_OVERVIEW: String fileOverview = '; if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo fileOverviewInfo = extractMultilineTextualBlock(token, WhitespaceOption.TRIM); fileOverview = fileOverviewInfo.string; token = fileOverviewInfo.token; } else { token = eatTokensUntilEOL(token); } if (!jsdocBuilder.recordFileOverview(fileOverview) || fileOverviewJSDocInfo != null) { parser.addParserWarning('msg.jsdoc.fileoverview.extra', stream.getLineno(), stream.getCharno()); } continue retry; case LICENSE: case PRESERVE: ExtractionInfo preserveInfo = extractMultilineTextualBlock(token, WhitespaceOption.PRESERVE); String preserve = preserveInfo.string; if (preserve.length() > 0) { if (fileLevelJsDocBuilder != null) { fileLevelJsDocBuilder.append(preserve); } } token = preserveInfo.token; continue retry; case ENUM: token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token != JsDocToken.EOL && token != JsDocToken.EOC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); } if (type == null) { type = createJSTypeExpression(newStringNode('number')); } if (!jsdocBuilder.recordEnumParameterType(type)) { parser.addTypeWarning( 'msg.jsdoc.incompat.type', lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case EXPORT: if (!jsdocBuilder.recordExport()) { parser.addParserWarning('msg.jsdoc.export', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXPOSE: if (!jsdocBuilder.recordExpose()) { parser.addParserWarning('msg.jsdoc.expose', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTERNS: if (!jsdocBuilder.recordExterns()) { parser.addParserWarning('msg.jsdoc.externs', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case JAVA_DISPATCH: if (!jsdocBuilder.recordJavaDispatch()) { parser.addParserWarning('msg.jsdoc.javadispatch', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case EXTENDS: case IMPLEMENTS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); boolean matchingRc = false; if (token == JsDocToken.LC) { token = next(); matchingRc = true; } if (token == JsDocToken.STRING) { Node typeNode = parseAndRecordTypeNameNode( token, lineno, charno, matchingRc); lineno = stream.getLineno(); charno = stream.getCharno(); typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && !matchingRc) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } type = createJSTypeExpression(typeNode); if (annotation == Annotation.EXTENDS) { // record the extended type, check later extendedTypes.add(new ExtendedTypeInfo( type, stream.getLineno(), stream.getCharno())); } else { Preconditions.checkState( annotation == Annotation.IMPLEMENTS); if (!jsdocBuilder.recordImplementedInterface(type)) { parser.addTypeWarning('msg.jsdoc.implements.duplicate', lineno, charno); } } token = next(); if (matchingRc) { if (token != JsDocToken.RC) { parser.addTypeWarning('msg.jsdoc.missing.rc', stream.getLineno(), stream.getCharno()); } } else if (token != JsDocToken.EOL && token != JsDocToken.EOF && token != JsDocToken.EOC) { parser.addTypeWarning('msg.end.annotation.expected', stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning('msg.no.type.name', lineno, charno); } token = eatTokensUntilEOL(token); continue retry; case HIDDEN: if (!jsdocBuilder.recordHiddenness()) { parser.addParserWarning('msg.jsdoc.hidden', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case LENDS: skipEOLs(); matchingRc = false; if (match(JsDocToken.LC)) { token = next(); matchingRc = true; } if (match(JsDocToken.STRING)) { token = next(); if (!jsdocBuilder.recordLends(stream.getString())) { parser.addTypeWarning('msg.jsdoc.lends.incompatible', stream.getLineno(), stream.getCharno()); } } else { parser.addTypeWarning('msg.jsdoc.lends.missing', stream.getLineno(), stream.getCharno()); } if (matchingRc && !match(JsDocToken.RC)) { parser.addTypeWarning('msg.jsdoc.missing.rc', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MEANING: ExtractionInfo meaningInfo = extractMultilineTextualBlock(token); String meaning = meaningInfo.string; token = meaningInfo.token; if (!jsdocBuilder.recordMeaning(meaning)) { parser.addParserWarning('msg.jsdoc.meaning.extra', stream.getLineno(), stream.getCharno()); } continue retry; case NO_ALIAS: if (!jsdocBuilder.recordNoAlias()) { parser.addParserWarning('msg.jsdoc.noalias', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_COMPILE: if (!jsdocBuilder.recordNoCompile()) { parser.addParserWarning('msg.jsdoc.nocompile', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_TYPE_CHECK: if (!jsdocBuilder.recordNoTypeCheck()) { parser.addParserWarning('msg.jsdoc.nocheck', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NOT_IMPLEMENTED: token = eatTokensUntilEOL(); continue retry; case INHERIT_DOC: case OVERRIDE: if (!jsdocBuilder.recordOverride()) { parser.addTypeWarning('msg.jsdoc.override', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case THROWS: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordTypeNode(token)); if (type == null) { // parsing error reported during recursive descent // recovering parsing token = eatTokensUntilEOL(); continue retry; } } // *Update* the token to that after the type annotation. token = current(); // Save the throw type. jsdocBuilder.recordThrowType(type); // Find the throw's description (if applicable). if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo descriptionInfo = extractMultilineTextualBlock(token); String description = descriptionInfo.string; if (description.length() > 0) { jsdocBuilder.recordThrowDescription(type, description); } token = descriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PARAM: skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); type = null; if (token == JsDocToken.LC) { type = createJSTypeExpression( parseAndRecordParamTypeNode(token)); if (type == null) { // parsing error reported during recursive descent // recovering parsing token = eatTokensUntilEOL(); continue retry; } skipEOLs(); token = next(); lineno = stream.getLineno(); charno = stream.getCharno(); } String name = null; boolean isBracketedParam = JsDocToken.LB == token; if (isBracketedParam) { token = next(); } if (JsDocToken.STRING != token) { parser.addTypeWarning('msg.missing.variable.name', lineno, charno); } else { name = stream.getString(); if (isBracketedParam) { token = next(); // Throw out JsDocToolkit's 'default' parameter // annotation. It makes no sense under our type // system. if (JsDocToken.EQUALS == token) { token = next(); if (JsDocToken.STRING == token) { token = next(); } } if (JsDocToken.RB != token) { reportTypeSyntaxWarning('msg.jsdoc.missing.rb'); } else if (type != null) { // Make the type expression optional, if it isn't // already. type = JSTypeExpression.makeOptionalArg(type); } } // If the param name has a DOT in it, just throw it out // quietly. We do not handle the JsDocToolkit method // for handling properties of params. if (name.indexOf('.') > -1) { name = null; } else if (!jsdocBuilder.recordParameter(name, type)) { if (jsdocBuilder.hasParameter(name)) { parser.addTypeWarning('msg.dup.variable.name', name, lineno, charno); } else { parser.addTypeWarning('msg.jsdoc.incompat.type', name, lineno, charno); } } } if (name == null) { token = eatTokensUntilEOL(token); continue retry; } jsdocBuilder.markName(name, sourceFile, lineno, charno); // Find the parameter's description (if applicable). if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo paramDescriptionInfo = extractMultilineTextualBlock(token); String paramDescription = paramDescriptionInfo.string; if (paramDescription.length() > 0) { jsdocBuilder.recordParameterDescription(name, paramDescription); } token = paramDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case PRESERVE_TRY: if (!jsdocBuilder.recordPreserveTry()) { parser.addParserWarning('msg.jsdoc.preservertry', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PRIVATE: if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) { parser.addParserWarning('msg.jsdoc.visibility.private', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PROTECTED: if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) { parser.addParserWarning('msg.jsdoc.visibility.protected', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case PUBLIC: if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) { parser.addParserWarning('msg.jsdoc.visibility.public', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SHADOW: if (!jsdocBuilder.recordNoShadow()) { parser.addParserWarning('msg.jsdoc.noshadow', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case NO_SIDE_EFFECTS: if (!jsdocBuilder.recordNoSideEffects()) { parser.addParserWarning('msg.jsdoc.nosideeffects', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case MODIFIES: token = parseModifiesTag(next()); continue retry; case IMPLICIT_CAST: if (!jsdocBuilder.recordImplicitCast()) { parser.addTypeWarning('msg.jsdoc.implicitcast', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case SEE: if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo referenceInfo = extractSingleLineBlock(); String reference = referenceInfo.string; if (reference.length() == 0) { parser.addParserWarning('msg.jsdoc.seemissing', stream.getLineno(), stream.getCharno()); } else { jsdocBuilder.addReference(reference); } token = referenceInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case SUPPRESS: token = parseSuppressTag(next()); continue retry; case TEMPLATE: ExtractionInfo templateInfo = extractSingleLineBlock(); String templateTypeName = templateInfo.string; if (templateTypeName.length() == 0) { parser.addTypeWarning('msg.jsdoc.templatemissing', stream.getLineno(), stream.getCharno()); } else if (!jsdocBuilder.recordTemplateTypeName( templateTypeName)) { parser.addTypeWarning('msg.jsdoc.template.at.most.once', stream.getLineno(), stream.getCharno()); } token = templateInfo.token; continue retry; case IDGENERATOR: if (!jsdocBuilder.recordIdGenerator()) { parser.addParserWarning('msg.jsdoc.idgen', stream.getLineno(), stream.getCharno()); } token = eatTokensUntilEOL(); continue retry; case VERSION: ExtractionInfo versionInfo = extractSingleLineBlock(); String version = versionInfo.string; if (version.length() == 0) { parser.addParserWarning('msg.jsdoc.versionmissing', stream.getLineno(), stream.getCharno()); } else { if (!jsdocBuilder.recordVersion(version)) { parser.addParserWarning('msg.jsdoc.extraversion', stream.getLineno(), stream.getCharno()); } } token = versionInfo.token; continue retry; case DEFINE: case RETURN: case THIS: case TYPE: case TYPEDEF: lineno = stream.getLineno(); charno = stream.getCharno(); Node typeNode = null; if (!lookAheadForTypeAnnotation() && annotation == Annotation.RETURN) { // If RETURN doesn't have a type annotation, record // it as the unknown type. typeNode = newNode(Token.QMARK); } else { skipEOLs(); token = next(); typeNode = parseAndRecordTypeNode(token); } if (annotation == Annotation.THIS) { typeNode = wrapNode(Token.BANG, typeNode); if (typeNode != null && token != JsDocToken.LC) { typeNode.putBooleanProp(Node.BRACELESS_TYPE, true); } } type = createJSTypeExpression(typeNode); if (type == null) { // error reported during recursive descent // recovering parsing } else { switch (annotation) { case DEFINE: if (!jsdocBuilder.recordDefineType(type)) { parser.addParserWarning('msg.jsdoc.define', lineno, charno); } break; case RETURN: if (!jsdocBuilder.recordReturnType(type)) { parser.addTypeWarning( 'msg.jsdoc.incompat.type', lineno, charno); break; } // Find the return's description (if applicable). if (jsdocBuilder.shouldParseDocumentation()) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock(token); String returnDescription = returnDescriptionInfo.string; if (returnDescription.length() > 0) { jsdocBuilder.recordReturnDescription( returnDescription); } token = returnDescriptionInfo.token; } else { token = eatTokensUntilEOL(token); } continue retry; case THIS: if (!jsdocBuilder.recordThisType(type)) { parser.addTypeWarning( 'msg.jsdoc.incompat.type', lineno, charno); } break; case TYPE: if (!jsdocBuilder.recordType(type)) { parser.addTypeWarning( 'msg.jsdoc.incompat.type', lineno, charno); } break; case TYPEDEF: if (!jsdocBuilder.recordTypedef(type)) { parser.addTypeWarning( 'msg.jsdoc.incompat.type', lineno, charno); } break; } } token = eatTokensUntilEOL(); continue retry; } } } break; case EOC: if (hasParsedFileOverviewDocInfo()) { fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo(); } checkExtendedTypes(extendedTypes); return true; case EOF: // discard any accumulated information jsdocBuilder.build(null); parser.addParserWarning('msg.unexpected.eof', stream.getLineno(), stream.getCharno()); checkExtendedTypes(extendedTypes); return false; case EOL: if (state == State.SEARCHING_NEWLINE) { state = State.SEARCHING_ANNOTATION; } token = next(); continue retry; default: if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) { token = next(); continue retry; } else { state = State.SEARCHING_NEWLINE; token = eatTokensUntilEOL(); continue retry; } } // next token token = next(); } }",
Compress,Compress_15,org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::testNullCommentEqualsEmptyComment,,"public void testNullCommentEqualsEmptyComment() { ZipArchiveEntry entry1 = new ZipArchiveEntry('foo'); ZipArchiveEntry entry2 = new ZipArchiveEntry('foo'); ZipArchiveEntry entry3 = new ZipArchiveEntry('foo'); entry1.setComment(null); entry2.setComment('); entry3.setComment('bar'); assertEquals(entry1, entry2); assertFalse(entry1.equals(entry3)); assertFalse(entry2.equals(entry3)); } ""<FocalMethod>"" @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { myComment = '; } if (otherComment == null) { otherComment = '; } return getTime() == other.getTime() && myComment.equals(otherComment) && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes() && getMethod() == other.getMethod() && getSize() == other.getSize() && getCrc() == other.getCrc() && getCompressedSize() == other.getCompressedSize() && Arrays.equals(getCentralDirectoryExtra(), other.getCentralDirectoryExtra()) && Arrays.equals(getLocalFileDataExtra(), other.getLocalFileDataExtra()) && gpb.equals(other.gpb); }",
Compress,Compress_15,org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::testNullCommentEqualsEmptyComment,,"public void testNullCommentEqualsEmptyComment() { ZipArchiveEntry entry1 = new ZipArchiveEntry('foo'); ZipArchiveEntry entry2 = new ZipArchiveEntry('foo'); ZipArchiveEntry entry3 = new ZipArchiveEntry('foo'); entry1.setComment(null); entry2.setComment('); entry3.setComment('bar'); assertEquals(entry1, entry2); } ""<FocalMethod>"" @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { myComment = '; } if (otherComment == null) { otherComment = '; } return getTime() == other.getTime() && myComment.equals(otherComment) && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes() && getMethod() == other.getMethod() && getSize() == other.getSize() && getCrc() == other.getCrc() && getCompressedSize() == other.getCompressedSize() && Arrays.equals(getCentralDirectoryExtra(), other.getCentralDirectoryExtra()) && Arrays.equals(getLocalFileDataExtra(), other.getLocalFileDataExtra()) && gpb.equals(other.gpb); }",
Compress,Compress_15,org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::testNullCommentEqualsEmptyComment,,"public void testNullCommentEqualsEmptyComment() { ZipArchiveEntry entry1 = new ZipArchiveEntry('foo'); ZipArchiveEntry entry2 = new ZipArchiveEntry('foo'); ZipArchiveEntry entry3 = new ZipArchiveEntry('foo'); entry1.setComment(null); entry2.setComment('); entry3.setComment('bar'); assertFalse(entry1.equals(entry3)); } ""<FocalMethod>"" @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { myComment = '; } if (otherComment == null) { otherComment = '; } return getTime() == other.getTime() && myComment.equals(otherComment) && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes() && getMethod() == other.getMethod() && getSize() == other.getSize() && getCrc() == other.getCrc() && getCompressedSize() == other.getCompressedSize() && Arrays.equals(getCentralDirectoryExtra(), other.getCentralDirectoryExtra()) && Arrays.equals(getLocalFileDataExtra(), other.getLocalFileDataExtra()) && gpb.equals(other.gpb); }",
Compress,Compress_15,org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::testNullCommentEqualsEmptyComment,,"public void testNullCommentEqualsEmptyComment() { ZipArchiveEntry entry1 = new ZipArchiveEntry('foo'); ZipArchiveEntry entry2 = new ZipArchiveEntry('foo'); ZipArchiveEntry entry3 = new ZipArchiveEntry('foo'); entry1.setComment(null); entry2.setComment('); entry3.setComment('bar'); assertFalse(entry2.equals(entry3)); } ""<FocalMethod>"" @Override public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } String myComment = getComment(); String otherComment = other.getComment(); if (myComment == null) { myComment = '; } if (otherComment == null) { otherComment = '; } return getTime() == other.getTime() && myComment.equals(otherComment) && getInternalAttributes() == other.getInternalAttributes() && getPlatform() == other.getPlatform() && getExternalAttributes() == other.getExternalAttributes() && getMethod() == other.getMethod() && getSize() == other.getSize() && getCrc() == other.getCrc() && getCompressedSize() == other.getCompressedSize() && Arrays.equals(getCentralDirectoryExtra(), other.getCentralDirectoryExtra()) && Arrays.equals(getLocalFileDataExtra(), other.getLocalFileDataExtra()) && gpb.equals(other.gpb); }",
Compress,Compress_16,org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::aiffFilesAreNoTARs,,"@Test public void aiffFilesAreNoTARs() throws Exception { InputStream is = null; try { is = new BufferedInputStream(new FileInputStream('src/test/resources/testAIFF.aif')); new ArchiveStreamFactory().createArchiveInputStream(is); fail('created an input stream for a non-archive'); } catch (ArchiveException ae) { assertTrue(ae.getMessage().startsWith('No Archiver found')); } finally { if (is != null) { is.close(); } } } ""<FocalMethod>"" public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException { if (archiverName == null) { throw new IllegalArgumentException('Archivername must not be null.'); } if (in == null) { throw new IllegalArgumentException('InputStream must not be null.'); } if (AR.equalsIgnoreCase(archiverName)) { return new ArArchiveInputStream(in); } if (ZIP.equalsIgnoreCase(archiverName)) { return new ZipArchiveInputStream(in); } if (TAR.equalsIgnoreCase(archiverName)) { return new TarArchiveInputStream(in); } if (JAR.equalsIgnoreCase(archiverName)) { return new JarArchiveInputStream(in); } if (CPIO.equalsIgnoreCase(archiverName)) { return new CpioArchiveInputStream(in); } if (DUMP.equalsIgnoreCase(archiverName)) { return new DumpArchiveInputStream(in); } throw new ArchiveException('Archiver: ' + archiverName + ' not found.'); }",
Compress,Compress_13,org.apache.commons.compress.archivers.zip.ZipFileTest::testWinzipBackSlashWorkaround,,"public void testWinzipBackSlashWorkaround() throws Exception { URL zip = getClass().getResource('/test-winzip.zip'); File archive = new File(new URI(zip.toString())); zf = new ZipFile(archive); assertNull(zf.getEntry('\u00e4\\\u00fc.txt')); assertNotNull(zf.getEntry('\u00e4/\u00fc.txt')); } ""<FocalMethod>"" public ZipArchiveEntry getEntry(String name) { return nameMap.get(name); }",
Compress,Compress_13,org.apache.commons.compress.archivers.zip.ZipFileTest::testWinzipBackSlashWorkaround,,"public void testWinzipBackSlashWorkaround() throws Exception { URL zip = getClass().getResource('/test-winzip.zip'); File archive = new File(new URI(zip.toString())); zf = new ZipFile(archive); assertNull(zf.getEntry('\u00e4\\\u00fc.txt')); } ""<FocalMethod>"" public ZipArchiveEntry getEntry(String name) { return nameMap.get(name); }",
Compress,Compress_13,org.apache.commons.compress.archivers.zip.ZipFileTest::testWinzipBackSlashWorkaround,,"public void testWinzipBackSlashWorkaround() throws Exception { URL zip = getClass().getResource('/test-winzip.zip'); File archive = new File(new URI(zip.toString())); zf = new ZipFile(archive); assertNotNull(zf.getEntry('\u00e4/\u00fc.txt')); } ""<FocalMethod>"" public ZipArchiveEntry getEntry(String name) { return nameMap.get(name); }",
Compress,Compress_11,org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::shortTextFilesAreNoTARs,,"@Test public void shortTextFilesAreNoTARs() throws Exception { try { new ArchiveStreamFactory() .createArchiveInputStream(new ByteArrayInputStream('This certainly is not a tar archive, really, no kidding'.getBytes())); fail('created an input stream for a non-archive'); } catch (ArchiveException ae) { assertTrue(ae.getMessage().startsWith('No Archiver found')); } } ""<FocalMethod>"" public ArchiveInputStream createArchiveInputStream( final String archiverName, final InputStream in) throws ArchiveException { if (archiverName == null) { throw new IllegalArgumentException('Archivername must not be null.'); } if (in == null) { throw new IllegalArgumentException('InputStream must not be null.'); } if (AR.equalsIgnoreCase(archiverName)) { return new ArArchiveInputStream(in); } if (ZIP.equalsIgnoreCase(archiverName)) { return new ZipArchiveInputStream(in); } if (TAR.equalsIgnoreCase(archiverName)) { return new TarArchiveInputStream(in); } if (JAR.equalsIgnoreCase(archiverName)) { return new JarArchiveInputStream(in); } if (CPIO.equalsIgnoreCase(archiverName)) { return new CpioArchiveInputStream(in); } if (DUMP.equalsIgnoreCase(archiverName)) { return new DumpArchiveInputStream(in); } throw new ArchiveException('Archiver: ' + archiverName + ' not found.'); }",
Compress,Compress_42,org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet,,"@Test public void isUnixSymlinkIsFalseIfMoreThanOneFlagIsSet() throws Exception { try (ZipFile zf = new ZipFile(getFile('COMPRESS-379.jar'))) { ZipArchiveEntry ze = zf.getEntry('META-INF/maven/'); assertFalse(ze.isUnixSymlink()); } } ""<FocalMethod>"" public boolean isUnixSymlink() { return (getUnixMode() & UnixStat.FILE_TYPE_FLAG) == UnixStat.LINK_FLAG; }",
Compress,Compress_4,org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest::testJarMarker,,"public void testJarMarker() throws IOException { File testArchive = File.createTempFile('jar-aostest', '.jar'); JarArchiveOutputStream out = null; ZipFile zf = null; try { out = new JarArchiveOutputStream(new FileOutputStream(testArchive)); out.putArchiveEntry(new ZipArchiveEntry('foo/')); out.closeArchiveEntry(); out.putArchiveEntry(new ZipArchiveEntry('bar/')); out.closeArchiveEntry(); out.finish(); out.close(); out = null; zf = new ZipFile(testArchive); ZipArchiveEntry ze = zf.getEntry('foo/'); assertNotNull(ze); ZipExtraField[] fes = ze.getExtraFields(); assertEquals(1, fes.length); assertTrue(fes[0] instanceof JarMarker); ze = zf.getEntry('bar/'); assertNotNull(ze); fes = ze.getExtraFields(); assertEquals(0, fes.length); } finally { if (out != null) { try { out.close(); } catch (IOException e) { /* swallow */ } } ZipFile.closeQuietly(zf); if (testArchive.exists()) { testArchive.delete(); } } } ""<FocalMethod>"" public void putArchiveEntry(ArchiveEntry ze) throws IOException { if (!jarMarkerAdded) { ((ZipArchiveEntry)ze).addAsFirstExtraField(JarMarker.getInstance()); jarMarkerAdded = true; } super.putArchiveEntry(ze); }",
Compress,Compress_40,org.apache.commons.compress.utils.BitInputStreamTest::littleEndianWithOverflow,,"@Test public void littleEndianWithOverflow() throws Exception { ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { 87, // 01010111 45, // 00101101 66, // 01000010 15, // 00001111 90, // 01011010 29, // 00011101 88, // 01011000 61, // 00111101 33, // 00100001 74 // 01001010 }); BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN); assertEquals(23, // 10111 bin.readBits(5)); assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010 bin.readBits(63)); assertEquals(1186, // 01001010-0010 bin.readBits(12)); assertEquals(-1 , bin.readBits(1)); } ""<FocalMethod>"" public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException('count must not be negative or greater than ' + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count && bitsCachedSize < 57) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } int overflowBits = 0; long overflow = 0l; if (bitsCachedSize < count) { // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow int bitsToAddCount = count - bitsCachedSize; overflowBits = 8 - bitsToAddCount; final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { long bitsToAdd = nextByte & MASKS[bitsToAddCount]; bitsCached |= (bitsToAdd << bitsCachedSize); overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits]; } else { bitsCached <<= bitsToAddCount; long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount]; bitsCached |= bitsToAdd; overflow = nextByte & MASKS[overflowBits]; } bitsCachedSize = count; } final long bitsOut; if (overflowBits == 0) { if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; } else { bitsOut = bitsCached & MASKS[count]; bitsCached = overflow; bitsCachedSize = overflowBits; } return bitsOut; }",
Compress,Compress_40,org.apache.commons.compress.utils.BitInputStreamTest::littleEndianWithOverflow,,"@Test public void littleEndianWithOverflow() throws Exception { ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { 87, // 01010111 45, // 00101101 66, // 01000010 15, // 00001111 90, // 01011010 29, // 00011101 88, // 01011000 61, // 00111101 33, // 00100001 74 // 01001010 }); BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN); assertEquals(23, // 10111 bin.readBits(5)); } ""<FocalMethod>"" public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException('count must not be negative or greater than ' + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count && bitsCachedSize < 57) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } int overflowBits = 0; long overflow = 0l; if (bitsCachedSize < count) { // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow int bitsToAddCount = count - bitsCachedSize; overflowBits = 8 - bitsToAddCount; final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { long bitsToAdd = nextByte & MASKS[bitsToAddCount]; bitsCached |= (bitsToAdd << bitsCachedSize); overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits]; } else { bitsCached <<= bitsToAddCount; long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount]; bitsCached |= bitsToAdd; overflow = nextByte & MASKS[overflowBits]; } bitsCachedSize = count; } final long bitsOut; if (overflowBits == 0) { if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; } else { bitsOut = bitsCached & MASKS[count]; bitsCached = overflow; bitsCachedSize = overflowBits; } return bitsOut; }",
Compress,Compress_40,org.apache.commons.compress.utils.BitInputStreamTest::littleEndianWithOverflow,,"@Test public void littleEndianWithOverflow() throws Exception { ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { 87, // 01010111 45, // 00101101 66, // 01000010 15, // 00001111 90, // 01011010 29, // 00011101 88, // 01011000 61, // 00111101 33, // 00100001 74 // 01001010 }); BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN); assertEquals(714595605644185962l, // 0001-00111101-01011000-00011101-01011010-00001111-01000010-00101101-010 bin.readBits(63)); } ""<FocalMethod>"" public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException('count must not be negative or greater than ' + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count && bitsCachedSize < 57) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } int overflowBits = 0; long overflow = 0l; if (bitsCachedSize < count) { // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow int bitsToAddCount = count - bitsCachedSize; overflowBits = 8 - bitsToAddCount; final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { long bitsToAdd = nextByte & MASKS[bitsToAddCount]; bitsCached |= (bitsToAdd << bitsCachedSize); overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits]; } else { bitsCached <<= bitsToAddCount; long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount]; bitsCached |= bitsToAdd; overflow = nextByte & MASKS[overflowBits]; } bitsCachedSize = count; } final long bitsOut; if (overflowBits == 0) { if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; } else { bitsOut = bitsCached & MASKS[count]; bitsCached = overflow; bitsCachedSize = overflowBits; } return bitsOut; }",
Compress,Compress_40,org.apache.commons.compress.utils.BitInputStreamTest::littleEndianWithOverflow,,"@Test public void littleEndianWithOverflow() throws Exception { ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { 87, // 01010111 45, // 00101101 66, // 01000010 15, // 00001111 90, // 01011010 29, // 00011101 88, // 01011000 61, // 00111101 33, // 00100001 74 // 01001010 }); BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN); assertEquals(1186, // 01001010-0010 bin.readBits(12)); } ""<FocalMethod>"" public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException('count must not be negative or greater than ' + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count && bitsCachedSize < 57) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } int overflowBits = 0; long overflow = 0l; if (bitsCachedSize < count) { // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow int bitsToAddCount = count - bitsCachedSize; overflowBits = 8 - bitsToAddCount; final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { long bitsToAdd = nextByte & MASKS[bitsToAddCount]; bitsCached |= (bitsToAdd << bitsCachedSize); overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits]; } else { bitsCached <<= bitsToAddCount; long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount]; bitsCached |= bitsToAdd; overflow = nextByte & MASKS[overflowBits]; } bitsCachedSize = count; } final long bitsOut; if (overflowBits == 0) { if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; } else { bitsOut = bitsCached & MASKS[count]; bitsCached = overflow; bitsCachedSize = overflowBits; } return bitsOut; }",
Compress,Compress_40,org.apache.commons.compress.utils.BitInputStreamTest::littleEndianWithOverflow,,"@Test public void littleEndianWithOverflow() throws Exception { ByteArrayInputStream in = new ByteArrayInputStream(new byte[] { 87, // 01010111 45, // 00101101 66, // 01000010 15, // 00001111 90, // 01011010 29, // 00011101 88, // 01011000 61, // 00111101 33, // 00100001 74 // 01001010 }); BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN); assertEquals(-1 , bin.readBits(1)); } ""<FocalMethod>"" public long readBits(final int count) throws IOException { if (count < 0 || count > MAXIMUM_CACHE_SIZE) { throw new IllegalArgumentException('count must not be negative or greater than ' + MAXIMUM_CACHE_SIZE); } while (bitsCachedSize < count && bitsCachedSize < 57) { final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsCached |= (nextByte << bitsCachedSize); } else { bitsCached <<= 8; bitsCached |= nextByte; } bitsCachedSize += 8; } int overflowBits = 0; long overflow = 0l; if (bitsCachedSize < count) { // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow int bitsToAddCount = count - bitsCachedSize; overflowBits = 8 - bitsToAddCount; final long nextByte = in.read(); if (nextByte < 0) { return nextByte; } if (byteOrder == ByteOrder.LITTLE_ENDIAN) { long bitsToAdd = nextByte & MASKS[bitsToAddCount]; bitsCached |= (bitsToAdd << bitsCachedSize); overflow = (nextByte >>> bitsToAddCount) & MASKS[overflowBits]; } else { bitsCached <<= bitsToAddCount; long bitsToAdd = (nextByte >>> (overflowBits)) & MASKS[bitsToAddCount]; bitsCached |= bitsToAdd; overflow = nextByte & MASKS[overflowBits]; } bitsCachedSize = count; } final long bitsOut; if (overflowBits == 0) { if (byteOrder == ByteOrder.LITTLE_ENDIAN) { bitsOut = (bitsCached & MASKS[count]); bitsCached >>>= count; } else { bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count]; } bitsCachedSize -= count; } else { bitsOut = bitsCached & MASKS[count]; bitsCached = overflow; bitsCachedSize = overflowBits; } return bitsOut; }",
Compress,Compress_6,org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::testNotEquals,,"public void testNotEquals() { ZipArchiveEntry entry1 = new ZipArchiveEntry('foo'); ZipArchiveEntry entry2 = new ZipArchiveEntry('bar'); assertFalse(entry1.equals(entry2)); } ""<FocalMethod>"" public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null || getClass() != obj.getClass()) { return false; } ZipArchiveEntry other = (ZipArchiveEntry) obj; String myName = getName(); String otherName = other.getName(); if (myName == null) { if (otherName != null) { return false; } } else if (!myName.equals(otherName)) { return false; } return true; }",
Compress,Compress_47,org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest::properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown,,"@Test public void properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown() throws Exception { // we never read any data try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new ByteArrayInputStream(new byte[0]))) { ZipArchiveEntry e = new ZipArchiveEntry('test'); e.setMethod(ZipMethod.DEFLATED.getCode()); assertTrue(zis.canReadEntryData(e)); e.setMethod(ZipMethod.ENHANCED_DEFLATED.getCode()); assertTrue(zis.canReadEntryData(e)); e.setMethod(ZipMethod.BZIP2.getCode()); assertFalse(zis.canReadEntryData(e)); } } ""<FocalMethod>"" @Override public boolean canReadEntryData(final ArchiveEntry ae) { if (ae instanceof ZipArchiveEntry) { final ZipArchiveEntry ze = (ZipArchiveEntry) ae; return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze) && supportsCompressedSizeFor(ze); } return false; }",
Compress,Compress_27,org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal,,"public void testParseOctal() throws Exception{ long value; byte [] buffer; final long MAX_OCTAL = 077777777777L; // Allowed 11 digits final long MAX_OCTAL_OVERFLOW = 0777777777777L; // in fact 12 for some implementations final String maxOctal = '777777777777'; // Maximum valid octal buffer = maxOctal.getBytes(CharsetNames.UTF_8); value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(MAX_OCTAL_OVERFLOW, value); buffer[buffer.length - 1] = ' '; value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(MAX_OCTAL, value); buffer[buffer.length-1]=0; value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(MAX_OCTAL, value); buffer=new byte[]{0,0}; value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(0, value); buffer=new byte[]{0,' '}; value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(0, value); buffer=new byte[]{' ',0}; value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(0, value); } ""<FocalMethod>"" public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException('Length '+length+' must be at least 2'); } if (buffer[start] == 0) { return 0L; } // Skip leading spaces while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } } // Trim all trailing NULs and spaces. // The ustar and POSIX tar specs require a trailing NUL or // space but some implementations use the extra digit for big // sizes/uids/gids ... byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; // CheckStyle:MagicNumber OFF if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII // CheckStyle:MagicNumber ON } return result; }",
Compress,Compress_27,org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal,,"public void testParseOctal() throws Exception{ long value; byte [] buffer; final long MAX_OCTAL = 077777777777L; // Allowed 11 digits final long MAX_OCTAL_OVERFLOW = 0777777777777L; // in fact 12 for some implementations final String maxOctal = '777777777777'; // Maximum valid octal buffer = maxOctal.getBytes(CharsetNames.UTF_8); value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(MAX_OCTAL_OVERFLOW, value); buffer[buffer.length - 1] = ' '; value = TarUtils.parseOctal(buffer,0, buffer.length); buffer[buffer.length-1]=0; value = TarUtils.parseOctal(buffer,0, buffer.length); buffer=new byte[]{0,0}; value = TarUtils.parseOctal(buffer,0, buffer.length); buffer=new byte[]{0,' '}; value = TarUtils.parseOctal(buffer,0, buffer.length); buffer=new byte[]{' ',0}; value = TarUtils.parseOctal(buffer,0, buffer.length); } ""<FocalMethod>"" public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException('Length '+length+' must be at least 2'); } if (buffer[start] == 0) { return 0L; } // Skip leading spaces while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } } // Trim all trailing NULs and spaces. // The ustar and POSIX tar specs require a trailing NUL or // space but some implementations use the extra digit for big // sizes/uids/gids ... byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; // CheckStyle:MagicNumber OFF if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII // CheckStyle:MagicNumber ON } return result; }",
Compress,Compress_19,org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField,,"public void testExcessDataInZip64ExtraField() throws Exception { File archive = getFile('COMPRESS-228.zip'); zf = new ZipFile(archive); // actually, if we get here, the test already has passed ZipArchiveEntry ze = zf.getEntry('src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java'); assertEquals(26101, ze.getSize()); } ""<FocalMethod>"" public ZipArchiveEntry getEntry(String name) { Deque<ZipArchiveEntry> entriesOfThatName = nameMap.get(name); return entriesOfThatName != null ? entriesOfThatName.getFirst() : null; }",
Compress,Compress_24,org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal,,"public void testParseOctal() throws Exception{ long value; byte [] buffer; final long MAX_OCTAL = 077777777777L; // Allowed 11 digits final long MAX_OCTAL_OVERFLOW = 0777777777777L; // in fact 12 for some implementations final String maxOctal = '777777777777'; // Maximum valid octal buffer = maxOctal.getBytes(CharsetNames.UTF_8); value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(MAX_OCTAL_OVERFLOW, value); buffer[buffer.length - 1] = ' '; value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(MAX_OCTAL, value); buffer[buffer.length-1]=0; value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(MAX_OCTAL, value); buffer=new byte[]{0,0}; value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(0, value); buffer=new byte[]{0,' '}; value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(0, value); } ""<FocalMethod>"" public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException('Length '+length+' must be at least 2'); } if (buffer[start] == 0) { return 0L; } // Skip leading spaces while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } } // Trim all trailing NULs and spaces. // The ustar and POSIX tar specs require a trailing NUL or // space but some implementations use the extra digit for big // sizes/uids/gids ... byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } for ( ;start < end; start++) { final byte currentByte = buffer[start]; // CheckStyle:MagicNumber OFF if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII // CheckStyle:MagicNumber ON } return result; }",
Compress,Compress_24,org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal,,"public void testParseOctal() throws Exception{ long value; byte [] buffer; final long MAX_OCTAL = 077777777777L; // Allowed 11 digits final long MAX_OCTAL_OVERFLOW = 0777777777777L; // in fact 12 for some implementations final String maxOctal = '777777777777'; // Maximum valid octal buffer = maxOctal.getBytes(CharsetNames.UTF_8); value = TarUtils.parseOctal(buffer,0, buffer.length); assertEquals(MAX_OCTAL_OVERFLOW, value); buffer[buffer.length - 1] = ' '; value = TarUtils.parseOctal(buffer,0, buffer.length); buffer[buffer.length-1]=0; value = TarUtils.parseOctal(buffer,0, buffer.length); buffer=new byte[]{0,0}; value = TarUtils.parseOctal(buffer,0, buffer.length); buffer=new byte[]{0,' '}; value = TarUtils.parseOctal(buffer,0, buffer.length); } ""<FocalMethod>"" public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException('Length '+length+' must be at least 2'); } if (buffer[start] == 0) { return 0L; } // Skip leading spaces while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } } // Trim all trailing NULs and spaces. // The ustar and POSIX tar specs require a trailing NUL or // space but some implementations use the extra digit for big // sizes/uids/gids ... byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } for ( ;start < end; start++) { final byte currentByte = buffer[start]; // CheckStyle:MagicNumber OFF if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); // convert from ASCII // CheckStyle:MagicNumber ON } return result; }",
Codec,Codec_15,org.apache.commons.codec.language.SoundexTest::testHWRuleEx1,,"@Test public void testHWRuleEx1() { // From // http://www.archives.gov/research_room/genealogy/census/soundex.html: // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 // for the F). It is not coded A-226. Assert.assertEquals('A261', this.getStringEncoder().encode('Ashcraft')); Assert.assertEquals('A261', this.getStringEncoder().encode('Ashcroft')); Assert.assertEquals('Y330', this.getStringEncoder().encode('yehudit')); Assert.assertEquals('Y330', this.getStringEncoder().encode('yhwdyt')); } ""<FocalMethod>"" @Override public Object encode(final Object obj) throws EncoderException { if (!(obj instanceof String)) { throw new EncoderException('Parameter supplied to Soundex encode is not of type java.lang.String'); } return soundex((String) obj); }",
Codec,Codec_15,org.apache.commons.codec.language.SoundexTest::testHWRuleEx1,,"@Test public void testHWRuleEx1() { // From // http://www.archives.gov/research_room/genealogy/census/soundex.html: // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 // for the F). It is not coded A-226. Assert.assertEquals('A261', this.getStringEncoder().encode('Ashcraft')); } ""<FocalMethod>"" @Override public Object encode(final Object obj) throws EncoderException { if (!(obj instanceof String)) { throw new EncoderException('Parameter supplied to Soundex encode is not of type java.lang.String'); } return soundex((String) obj); }",
Codec,Codec_15,org.apache.commons.codec.language.SoundexTest::testHWRuleEx1,,"@Test public void testHWRuleEx1() { // From // http://www.archives.gov/research_room/genealogy/census/soundex.html: // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 // for the F). It is not coded A-226. Assert.assertEquals('A261', this.getStringEncoder().encode('Ashcroft')); } ""<FocalMethod>"" @Override public Object encode(final Object obj) throws EncoderException { if (!(obj instanceof String)) { throw new EncoderException('Parameter supplied to Soundex encode is not of type java.lang.String'); } return soundex((String) obj); }",
Codec,Codec_15,org.apache.commons.codec.language.SoundexTest::testHWRuleEx1,,"@Test public void testHWRuleEx1() { // From // http://www.archives.gov/research_room/genealogy/census/soundex.html: // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 // for the F). It is not coded A-226. Assert.assertEquals('Y330', this.getStringEncoder().encode('yehudit')); } ""<FocalMethod>"" @Override public Object encode(final Object obj) throws EncoderException { if (!(obj instanceof String)) { throw new EncoderException('Parameter supplied to Soundex encode is not of type java.lang.String'); } return soundex((String) obj); }",
Codec,Codec_15,org.apache.commons.codec.language.SoundexTest::testHWRuleEx1,,"@Test public void testHWRuleEx1() { // From // http://www.archives.gov/research_room/genealogy/census/soundex.html: // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 // for the F). It is not coded A-226. Assert.assertEquals('Y330', this.getStringEncoder().encode('yhwdyt')); } ""<FocalMethod>"" @Override public Object encode(final Object obj) throws EncoderException { if (!(obj instanceof String)) { throw new EncoderException('Parameter supplied to Soundex encode is not of type java.lang.String'); } return soundex((String) obj); }",
Codec,Codec_14,org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest::testCompatibilityWithOriginalVersion,,"@Test public void testCompatibilityWithOriginalVersion() { // see CODEC-187 // comparison: http://stevemorse.org/census/soundex.html Map<String, String> args = new TreeMap<String, String>(); args.put('nameType', 'GENERIC'); args.put('ruleType', 'APPROX'); assertEquals(encode(args, true, 'abram'), 'Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom'); assertEquals(encode(args, true, 'Bendzin'), 'bndzn|bntsn|bnzn|vndzn|vntsn'); args.put('nameType', 'ASHKENAZI'); args.put('ruleType', 'APPROX'); assertEquals(encode(args, true, 'abram'), 'Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom'); assertEquals(encode(args, true, 'Halpern'), 'YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn'); } ""<FocalMethod>"" public String encode(final String input) { final Languages.LanguageSet languageSet = this.lang.guessLanguages(input); return encode(input, languageSet); }",
Codec,Codec_14,org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest::testCompatibilityWithOriginalVersion,,"@Test public void testCompatibilityWithOriginalVersion() { // see CODEC-187 // comparison: http://stevemorse.org/census/soundex.html Map<String, String> args = new TreeMap<String, String>(); args.put('nameType', 'GENERIC'); args.put('ruleType', 'APPROX'); assertEquals(encode(args, true, 'abram'), 'Ybram|Ybrom|abram|abran|abrom|abron|avram|avrom|obram|obran|obrom|obron|ovram|ovrom'); args.put('nameType', 'ASHKENAZI'); args.put('ruleType', 'APPROX'); } ""<FocalMethod>"" public String encode(final String input) { final Languages.LanguageSet languageSet = this.lang.guessLanguages(input); return encode(input, languageSet); }",
Codec,Codec_14,org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest::testCompatibilityWithOriginalVersion,,"@Test public void testCompatibilityWithOriginalVersion() { // see CODEC-187 // comparison: http://stevemorse.org/census/soundex.html Map<String, String> args = new TreeMap<String, String>(); args.put('nameType', 'GENERIC'); args.put('ruleType', 'APPROX'); assertEquals(encode(args, true, 'Bendzin'), 'bndzn|bntsn|bnzn|vndzn|vntsn'); args.put('nameType', 'ASHKENAZI'); args.put('ruleType', 'APPROX'); } ""<FocalMethod>"" public String encode(final String input) { final Languages.LanguageSet languageSet = this.lang.guessLanguages(input); return encode(input, languageSet); }",
Codec,Codec_14,org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest::testCompatibilityWithOriginalVersion,,"@Test public void testCompatibilityWithOriginalVersion() { // see CODEC-187 // comparison: http://stevemorse.org/census/soundex.html Map<String, String> args = new TreeMap<String, String>(); args.put('nameType', 'GENERIC'); args.put('ruleType', 'APPROX'); args.put('nameType', 'ASHKENAZI'); args.put('ruleType', 'APPROX'); assertEquals(encode(args, true, 'abram'), 'Ybram|Ybrom|abram|abrom|avram|avrom|imbram|imbrom|obram|obrom|ombram|ombrom|ovram|ovrom'); } ""<FocalMethod>"" public String encode(final String input) { final Languages.LanguageSet languageSet = this.lang.guessLanguages(input); return encode(input, languageSet); }",
Codec,Codec_14,org.apache.commons.codec.language.bm.PhoneticEngineRegressionTest::testCompatibilityWithOriginalVersion,,"@Test public void testCompatibilityWithOriginalVersion() { // see CODEC-187 // comparison: http://stevemorse.org/census/soundex.html Map<String, String> args = new TreeMap<String, String>(); args.put('nameType', 'GENERIC'); args.put('ruleType', 'APPROX'); args.put('nameType', 'ASHKENAZI'); args.put('ruleType', 'APPROX'); assertEquals(encode(args, true, 'Halpern'), 'YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn'); } ""<FocalMethod>"" public String encode(final String input) { final Languages.LanguageSet languageSet = this.lang.guessLanguages(input); return encode(input, languageSet); }",
Codec,Codec_11,org.apache.commons.codec.net.QuotedPrintableCodecTest::testUltimateSoftBreak,,"@Test public void testUltimateSoftBreak() throws Exception { final QuotedPrintableCodec qpcodec = new QuotedPrintableCodec(); String plain ='This is a example of a quoted-printable text file. There is no end to it\t'; String expected = 'This is a example of a quoted-printable text file. There is no end to i=\r\nt=09'; assertEquals(expected, qpcodec.encode(plain)); plain ='This is a example of a quoted-printable text file. There is no end to it '; expected = 'This is a example of a quoted-printable text file. There is no end to i=\r\nt=20'; assertEquals(expected, qpcodec.encode(plain)); // whitespace before soft break plain ='This is a example of a quoted-printable text file. There is no end to '; expected = 'This is a example of a quoted-printable text file. There is no end to=20=\r\n =20'; assertEquals(expected, qpcodec.encode(plain)); // non-printable character before soft break plain ='This is a example of a quoted-printable text file. There is no end to= '; expected = 'This is a example of a quoted-printable text file. There is no end to=3D=\r\n =20'; assertEquals(expected, qpcodec.encode(plain)); } ""<FocalMethod>"" public byte[] encode(byte[] bytes) { return encodeQuotedPrintable(PRINTABLE_CHARS, bytes); }",
Codec,Codec_4,org.apache.commons.codec.binary.Base64Codec13Test::testEncoder,,"public void testEncoder() throws EncoderException { Encoder enc = new Base64(); for (int i = 0; i < STRINGS.length; i++) { if (STRINGS[i] != null) { byte[] base64 = utf8(STRINGS[i]); byte[] binary = BYTES[i]; boolean b = Arrays.equals(base64, (byte[]) enc.encode(binary)); assertTrue('Encoder test-' + i, b); } } } ""<FocalMethod>"" void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } // inAvail < 0 is how we're informed of EOF in the underlying data we're // encoding. if (inAvail < 0) { eof = true; if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } switch (modulus) { case 1 : buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS]; // URL-SAFE skips the padding to further reduce size. if (encodeTable == STANDARD_ENCODE_TABLE) { buffer[pos++] = PAD; buffer[pos++] = PAD; } break; case 2 : buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS]; // URL-SAFE skips the padding to further reduce size. if (encodeTable == STANDARD_ENCODE_TABLE) { buffer[pos++] = PAD; } break; } if (lineLength > 0 && pos > 0) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buffer == null || buffer.length - pos < encodeSize) { resizeBuffer(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buffer[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } }",
Codec,Codec_6,org.apache.commons.codec.binary.Base64InputStreamTest::testCodec101,,"public void testCodec101() throws Exception { byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3); ByteArrayInputStream bais = new ByteArrayInputStream(codec101); Base64InputStream in = new Base64InputStream(bais); byte[] result = new byte[8192]; int c = in.read(result); assertTrue('Codec101: First read successful [c=' + c + ']', c > 0); c = in.read(result); assertTrue('Codec101: Second read should report end-of-stream [c=' + c + ']', c < 0); } ""<FocalMethod>"" public int read() throws IOException { int r = read(singleByte, 0, 1); while (r == 0) { r = read(singleByte, 0, 1); } if (r > 0) { return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0]; } return -1; }",
Codec,Codec_6,org.apache.commons.codec.binary.Base64InputStreamTest::testCodec101,,"public void testCodec101() throws Exception { byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3); ByteArrayInputStream bais = new ByteArrayInputStream(codec101); Base64InputStream in = new Base64InputStream(bais); byte[] result = new byte[8192]; int c = in.read(result); assertTrue('Codec101: First read successful [c=' + c + ']', c > 0); c = in.read(result); } ""<FocalMethod>"" public int read() throws IOException { int r = read(singleByte, 0, 1); while (r == 0) { r = read(singleByte, 0, 1); } if (r > 0) { return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0]; } return -1; }",
Codec,Codec_6,org.apache.commons.codec.binary.Base64InputStreamTest::testCodec101,,"public void testCodec101() throws Exception { byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3); ByteArrayInputStream bais = new ByteArrayInputStream(codec101); Base64InputStream in = new Base64InputStream(bais); byte[] result = new byte[8192]; int c = in.read(result); c = in.read(result); assertTrue('Codec101: Second read should report end-of-stream [c=' + c + ']', c < 0); } ""<FocalMethod>"" public int read() throws IOException { int r = read(singleByte, 0, 1); while (r == 0) { r = read(singleByte, 0, 1); } if (r > 0) { return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0]; } return -1; }",
Codec,Codec_18,org.apache.commons.codec.binary.StringUtilsTest::testEqualsCS1,,"@Test public void testEqualsCS1() { Assert.assertFalse(StringUtils.equals(new StringBuilder('abc'), null)); Assert.assertFalse(StringUtils.equals(null, new StringBuilder('abc'))); Assert.assertTrue(StringUtils.equals(new StringBuilder('abc'), new StringBuilder('abc'))); Assert.assertFalse(StringUtils.equals(new StringBuilder('abc'), new StringBuilder('abcd'))); Assert.assertFalse(StringUtils.equals(new StringBuilder('abcd'), new StringBuilder('abc'))); Assert.assertFalse(StringUtils.equals(new StringBuilder('abc'), new StringBuilder('ABC'))); } ""<FocalMethod>"" public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length()); }",
Codec,Codec_18,org.apache.commons.codec.binary.StringUtilsTest::testEqualsCS1,,"@Test public void testEqualsCS1() { Assert.assertFalse(StringUtils.equals(new StringBuilder('abc'), null)); } ""<FocalMethod>"" public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length()); }",
Codec,Codec_18,org.apache.commons.codec.binary.StringUtilsTest::testEqualsCS1,,"@Test public void testEqualsCS1() { Assert.assertFalse(StringUtils.equals(null, new StringBuilder('abc'))); } ""<FocalMethod>"" public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length()); }",
Codec,Codec_18,org.apache.commons.codec.binary.StringUtilsTest::testEqualsCS1,,"@Test public void testEqualsCS1() { Assert.assertTrue(StringUtils.equals(new StringBuilder('abc'), new StringBuilder('abc'))); } ""<FocalMethod>"" public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length()); }",
Codec,Codec_18,org.apache.commons.codec.binary.StringUtilsTest::testEqualsCS1,,"@Test public void testEqualsCS1() { Assert.assertFalse(StringUtils.equals(new StringBuilder('abc'), new StringBuilder('abcd'))); } ""<FocalMethod>"" public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length()); }",
Codec,Codec_18,org.apache.commons.codec.binary.StringUtilsTest::testEqualsCS1,,"@Test public void testEqualsCS1() { Assert.assertFalse(StringUtils.equals(new StringBuilder('abcd'), new StringBuilder('abc'))); } ""<FocalMethod>"" public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length()); }",
Codec,Codec_18,org.apache.commons.codec.binary.StringUtilsTest::testEqualsCS1,,"@Test public void testEqualsCS1() { Assert.assertFalse(StringUtils.equals(new StringBuilder('abc'), new StringBuilder('ABC'))); } ""<FocalMethod>"" public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length()); }",
Chart,Chart_15,org.jfree.chart.plot.PiePlot3DTests::testDrawWithNullDataset,,"public void testDrawWithNullDataset() { JFreeChart chart = ChartFactory.createPieChart3D('Test', null, true, false, false); boolean success = false; try { BufferedImage image = new BufferedImage(200 , 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null); g2.dispose(); success = true; } catch (Exception e) { success = false; } assertTrue(success); } ""<FocalMethod>"" public abstract void draw(Graphics2D g2, Rectangle2D area, Point2D anchor, PlotState parentState, PlotRenderingInfo info);",
