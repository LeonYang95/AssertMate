{"bug_id": "Chart_10", "version": "fixed", "focal_method_signature": "org.jfree.chart.imagemap#StandardToolTipTagFragmentGenerator#generateToolTipFragment(java.lang#String)", "focal_method_bytecode_signature": "org.jfree.chart.imagemap.StandardToolTipTagFragmentGenerator.generateToolTipFragment(Ljava/lang/String;)Ljava/lang/String;", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_10/evosuite-tests/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_10/fixed/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java", "focal_method": "public String generateToolTipFragment(String toolTipText) {\r\n    return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) + \"\\\" alt=\\\"\\\"\";\r\n}", "return_type": "String", "test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      StandardToolTipTagFragmentGenerator standardToolTipTagFragmentGenerator0 = new StandardToolTipTagFragmentGenerator();\n      String string0 = standardToolTipTagFragmentGenerator0.generateToolTipFragment(\"\");\n      assertEquals(\" title=\\\"\\\" alt=\\\"\\\"\", string0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      StandardToolTipTagFragmentGenerator standardToolTipTagFragmentGenerator0 = new StandardToolTipTagFragmentGenerator();\n      String string0 = standardToolTipTagFragmentGenerator0.generateToolTipFragment(\"\");\n      assertEquals(\" title=\\\"\\\" alt=\\\"\\\"\", string0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_10/evosuite-tests/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.imagemap.StandardToolTipTagFragmentGenerator;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.imagemap.StandardToolTipTagFragmentGenerator_ESTest#test0()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:46:12 GMT 2025\n */\n\npackage org.jfree.chart.imagemap;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.imagemap.StandardToolTipTagFragmentGenerator;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class StandardToolTipTagFragmentGenerator_ESTest extends StandardToolTipTagFragmentGenerator_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      StandardToolTipTagFragmentGenerator standardToolTipTagFragmentGenerator0 = new StandardToolTipTagFragmentGenerator();\n      String string0 = standardToolTipTagFragmentGenerator0.generateToolTipFragment(\"\");\n      assertEquals(\" title=\\\"\\\" alt=\\\"\\\"\", string0);\n  }\n}\n"}, "focal_class": {"name": "StandardToolTipTagFragmentGenerator", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_10/fixed/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java", "superclass": "", "interface": "implements ToolTipTagFragmentGenerator", "imports": [], "fields": [], "methods": ["String org.jfree.chart.imagemap.StandardToolTipTagFragmentGenerator#generateToolTipFragment(String#toolTipText)"], "other_methods": ["public String generateToolTipFragment(String toolTipText);"], "fields_dict": {}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * ----------------------------------------\n * StandardToolTipTagFragmentGenerator.java\n * ----------------------------------------\n * (C) Copyright 2003-2008, by Richard Atkinson and Contributors.\n *\n * Original Author:  Richard Atkinson;\n * Contributors:     David Gilbert (for Object Refinery Limited);\n *\n * Changes\n * -------\n * 12-Aug-2003 : Version 1 (RA);\n * 04-Dec-2007 : Escape tool tip text to fix bug 1400917 (DG);\n * \n */\n \npackage org.jfree.chart.imagemap;\n\n/**\n * Generates tooltips using the HTML title attribute for image map area tags.\n */\npublic class StandardToolTipTagFragmentGenerator \n        implements ToolTipTagFragmentGenerator {\n\n    /**\n     * Creates a new instance.\n     */\n    public StandardToolTipTagFragmentGenerator() {\n        super();\n    }\n\t\n    /**\n     * Generates a tooltip string to go in an HTML image map.\n     *\n     * @param toolTipText  the tooltip.\n     * \n     * @return The formatted HTML area tag attribute(s).\n     */\n    public String generateToolTipFragment(String toolTipText) {\n        return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \n            + \"\\\" alt=\\\"\\\"\";\n    }\n\n}\n"}, "retrieved_test_case": null}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Ellipse2D;Ljava/awt/geom/Ellipse2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Ellipse2D;Ljava/awt/geom/Ellipse2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Ellipse2D;Ljava/awt/geom/Ellipse2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Ellipse2D;Ljava/awt/geom/Ellipse2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Ellipse2D;Ljava/awt/geom/Ellipse2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Ellipse2D;Ljava/awt/geom/Ellipse2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Ellipse2D;Ljava/awt/geom/Ellipse2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Ellipse2D;Ljava/awt/geom/Ellipse2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Ellipse2D;Ljava/awt/geom/Ellipse2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Ellipse2D, java.awt.geom#Ellipse2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Ellipse2D;Ljava/awt/geom/Ellipse2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n    if (e1 == null) {\n        return (e2 == null);\n    }\n    if (e2 == null) {\n        return false;\n    }\n    if (!e1.getFrame().equals(e2.getFrame())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Polygon;Ljava/awt/Polygon;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Polygon;Ljava/awt/Polygon;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Polygon;Ljava/awt/Polygon;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Polygon;Ljava/awt/Polygon;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Polygon;Ljava/awt/Polygon;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Polygon;Ljava/awt/Polygon;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Polygon;Ljava/awt/Polygon;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Polygon;Ljava/awt/Polygon;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Polygon;Ljava/awt/Polygon;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Polygon, java.awt#Polygon)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Polygon;Ljava/awt/Polygon;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Polygon p1, Polygon p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.npoints != p2.npoints) {\n        return false;\n    }\n    if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n        return false;\n    }\n    if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Arc2D;Ljava/awt/geom/Arc2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Arc2D;Ljava/awt/geom/Arc2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Arc2D;Ljava/awt/geom/Arc2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Arc2D;Ljava/awt/geom/Arc2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Arc2D;Ljava/awt/geom/Arc2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Arc2D;Ljava/awt/geom/Arc2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Arc2D;Ljava/awt/geom/Arc2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Arc2D;Ljava/awt/geom/Arc2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Arc2D;Ljava/awt/geom/Arc2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Arc2D, java.awt.geom#Arc2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Arc2D;Ljava/awt/geom/Arc2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Arc2D a1, Arc2D a2) {\n    if (a1 == null) {\n        return (a2 == null);\n    }\n    if (a2 == null) {\n        return false;\n    }\n    if (!a1.getFrame().equals(a2.getFrame())) {\n        return false;\n    }\n    if (a1.getAngleStart() != a2.getAngleStart()) {\n        return false;\n    }\n    if (a1.getAngleExtent() != a2.getAngleExtent()) {\n        return false;\n    }\n    if (a1.getArcType() != a2.getArcType()) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Line2D;Ljava/awt/geom/Line2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Line2D;Ljava/awt/geom/Line2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Line2D;Ljava/awt/geom/Line2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Line2D;Ljava/awt/geom/Line2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Line2D;Ljava/awt/geom/Line2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Line2D;Ljava/awt/geom/Line2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Line2D;Ljava/awt/geom/Line2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Line2D;Ljava/awt/geom/Line2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Line2D;Ljava/awt/geom/Line2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#Line2D, java.awt.geom#Line2D)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/Line2D;Ljava/awt/geom/Line2D;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Line2D l1, Line2D l2) {\n    if (l1 == null) {\n        return (l2 == null);\n    }\n    if (l2 == null) {\n        return false;\n    }\n    if (!l1.getP1().equals(l2.getP1())) {\n        return false;\n    }\n    if (!l1.getP2().equals(l2.getP2())) {\n        return false;\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/GeneralPath;Ljava/awt/geom/GeneralPath;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/GeneralPath;Ljava/awt/geom/GeneralPath;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/GeneralPath;Ljava/awt/geom/GeneralPath;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/GeneralPath;Ljava/awt/geom/GeneralPath;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/GeneralPath;Ljava/awt/geom/GeneralPath;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/GeneralPath;Ljava/awt/geom/GeneralPath;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/GeneralPath;Ljava/awt/geom/GeneralPath;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/GeneralPath;Ljava/awt/geom/GeneralPath;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/GeneralPath;Ljava/awt/geom/GeneralPath;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt.geom#GeneralPath, java.awt.geom#GeneralPath)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/geom/GeneralPath;Ljava/awt/geom/GeneralPath;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    boolean done = iterator1.isDone() && iterator2.isDone();\n    while (!done) {\n        if (iterator1.isDone() != iterator2.isDone()) {\n            return false;\n        }\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (!Arrays.equals(d1, d2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n        done = iterator1.isDone() && iterator2.isDone();\n    }\n    return true;\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Shape, java.awt#Shape)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Shape;Ljava/awt/Shape;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Shape s1, Shape s2) {\n    if (s1 instanceof Line2D && s2 instanceof Line2D) {\n        return equal((Line2D) s1, (Line2D) s2);\n    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n        return equal((Ellipse2D) s1, (Ellipse2D) s2);\n    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n        return equal((Arc2D) s1, (Arc2D) s2);\n    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n        return equal((Polygon) s1, (Polygon) s2);\n    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n        return equal((GeneralPath) s1, (GeneralPath) s2);\n    } else {\n        // this will handle Rectangle2D...\n        return ObjectUtilities.equal(s1, s2);\n    }\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Shape, java.awt#Shape)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Shape;Ljava/awt/Shape;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Shape s1, Shape s2) {\n    if (s1 instanceof Line2D && s2 instanceof Line2D) {\n        return equal((Line2D) s1, (Line2D) s2);\n    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n        return equal((Ellipse2D) s1, (Ellipse2D) s2);\n    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n        return equal((Arc2D) s1, (Arc2D) s2);\n    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n        return equal((Polygon) s1, (Polygon) s2);\n    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n        return equal((GeneralPath) s1, (GeneralPath) s2);\n    } else {\n        // this will handle Rectangle2D...\n        return ObjectUtilities.equal(s1, s2);\n    }\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Shape, java.awt#Shape)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Shape;Ljava/awt/Shape;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Shape s1, Shape s2) {\n    if (s1 instanceof Line2D && s2 instanceof Line2D) {\n        return equal((Line2D) s1, (Line2D) s2);\n    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n        return equal((Ellipse2D) s1, (Ellipse2D) s2);\n    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n        return equal((Arc2D) s1, (Arc2D) s2);\n    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n        return equal((Polygon) s1, (Polygon) s2);\n    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n        return equal((GeneralPath) s1, (GeneralPath) s2);\n    } else {\n        // this will handle Rectangle2D...\n        return ObjectUtilities.equal(s1, s2);\n    }\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Shape, java.awt#Shape)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Shape;Ljava/awt/Shape;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Shape s1, Shape s2) {\n    if (s1 instanceof Line2D && s2 instanceof Line2D) {\n        return equal((Line2D) s1, (Line2D) s2);\n    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n        return equal((Ellipse2D) s1, (Ellipse2D) s2);\n    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n        return equal((Arc2D) s1, (Arc2D) s2);\n    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n        return equal((Polygon) s1, (Polygon) s2);\n    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n        return equal((GeneralPath) s1, (GeneralPath) s2);\n    } else {\n        // this will handle Rectangle2D...\n        return ObjectUtilities.equal(s1, s2);\n    }\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Shape, java.awt#Shape)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Shape;Ljava/awt/Shape;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Shape s1, Shape s2) {\n    if (s1 instanceof Line2D && s2 instanceof Line2D) {\n        return equal((Line2D) s1, (Line2D) s2);\n    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n        return equal((Ellipse2D) s1, (Ellipse2D) s2);\n    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n        return equal((Arc2D) s1, (Arc2D) s2);\n    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n        return equal((Polygon) s1, (Polygon) s2);\n    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n        return equal((GeneralPath) s1, (GeneralPath) s2);\n    } else {\n        // this will handle Rectangle2D...\n        return ObjectUtilities.equal(s1, s2);\n    }\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Shape, java.awt#Shape)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Shape;Ljava/awt/Shape;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Shape s1, Shape s2) {\n    if (s1 instanceof Line2D && s2 instanceof Line2D) {\n        return equal((Line2D) s1, (Line2D) s2);\n    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n        return equal((Ellipse2D) s1, (Ellipse2D) s2);\n    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n        return equal((Arc2D) s1, (Arc2D) s2);\n    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n        return equal((Polygon) s1, (Polygon) s2);\n    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n        return equal((GeneralPath) s1, (GeneralPath) s2);\n    } else {\n        // this will handle Rectangle2D...\n        return ObjectUtilities.equal(s1, s2);\n    }\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Shape, java.awt#Shape)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Shape;Ljava/awt/Shape;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Shape s1, Shape s2) {\n    if (s1 instanceof Line2D && s2 instanceof Line2D) {\n        return equal((Line2D) s1, (Line2D) s2);\n    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n        return equal((Ellipse2D) s1, (Ellipse2D) s2);\n    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n        return equal((Arc2D) s1, (Arc2D) s2);\n    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n        return equal((Polygon) s1, (Polygon) s2);\n    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n        return equal((GeneralPath) s1, (GeneralPath) s2);\n    } else {\n        // this will handle Rectangle2D...\n        return ObjectUtilities.equal(s1, s2);\n    }\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Shape, java.awt#Shape)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Shape;Ljava/awt/Shape;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Shape s1, Shape s2) {\n    if (s1 instanceof Line2D && s2 instanceof Line2D) {\n        return equal((Line2D) s1, (Line2D) s2);\n    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n        return equal((Ellipse2D) s1, (Ellipse2D) s2);\n    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n        return equal((Arc2D) s1, (Arc2D) s2);\n    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n        return equal((Polygon) s1, (Polygon) s2);\n    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n        return equal((GeneralPath) s1, (GeneralPath) s2);\n    } else {\n        // this will handle Rectangle2D...\n        return ObjectUtilities.equal(s1, s2);\n    }\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Shape, java.awt#Shape)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Shape;Ljava/awt/Shape;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Shape s1, Shape s2) {\n    if (s1 instanceof Line2D && s2 instanceof Line2D) {\n        return equal((Line2D) s1, (Line2D) s2);\n    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n        return equal((Ellipse2D) s1, (Ellipse2D) s2);\n    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n        return equal((Arc2D) s1, (Arc2D) s2);\n    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n        return equal((Polygon) s1, (Polygon) s2);\n    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n        return equal((GeneralPath) s1, (GeneralPath) s2);\n    } else {\n        // this will handle Rectangle2D...\n        return ObjectUtilities.equal(s1, s2);\n    }\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }"}
{"bug_id": "Chart_11", "version": "fixed", "focal_method_signature": "org.jfree.chart.util#ShapeUtilities#equal(java.awt#Shape, java.awt#Shape)", "focal_method_bytecode_signature": "org.jfree.chart.util.ShapeUtilities.equal(Ljava/awt/Shape;Ljava/awt/Shape;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "focal_method": "public static boolean equal(Shape s1, Shape s2) {\n    if (s1 instanceof Line2D && s2 instanceof Line2D) {\n        return equal((Line2D) s1, (Line2D) s2);\n    } else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n        return equal((Ellipse2D) s1, (Ellipse2D) s2);\n    } else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n        return equal((Arc2D) s1, (Arc2D) s2);\n    } else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n        return equal((Polygon) s1, (Polygon) s2);\n    } else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n        return equal((GeneralPath) s1, (GeneralPath) s2);\n    } else {\n        // this will handle Rectangle2D...\n        return ObjectUtilities.equal(s1, s2);\n    }\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_11/evosuite-tests/org/jfree/chart/util/ShapeUtilities_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import java.awt.Point;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.Rectangle2D;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.util.ShapeUtilities;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.util.ShapeUtilities_ESTest#test0()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test1()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test2()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test3()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test4()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test5()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test6()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test7()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test8()", "void org.jfree.chart.util.ShapeUtilities_ESTest#test9()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:37:57 GMT 2025\n */\n\npackage org.jfree.chart.util;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Rectangle2D;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.util.ShapeUtilities;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class ShapeUtilities_ESTest extends ShapeUtilities_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test1()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) polygon0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test2()  throws Throwable  {\n      Polygon polygon0 = new Polygon();\n      boolean boolean0 = ShapeUtilities.equal((Shape) polygon0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test3()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Rectangle2D.Float rectangle2D_Float0 = new Rectangle2D.Float(0.0F, (-1.0F), 0.0F, 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Float0, (Shape) rectangle2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test4()  throws Throwable  {\n      Arc2D.Double arc2D_Double0 = new Arc2D.Double(1744.03497, 0, 4328.309709853598, 1744.03497, 0.0, 0.0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) arc2D_Double0, (Shape) arc2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test5()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) ellipse2D_Float0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test6()  throws Throwable  {\n      Ellipse2D.Float ellipse2D_Float0 = new Ellipse2D.Float((-98.0839F), (-98.0839F), (-98.0839F), 0.0F);\n      boolean boolean0 = ShapeUtilities.equal((Shape) ellipse2D_Float0, (Shape) null);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test7()  throws Throwable  {\n      Point point0 = new Point(0, (-2715));\n      Line2D.Double line2D_Double0 = new Line2D.Double(point0, point0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) line2D_Double0);\n      assertTrue(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test8()  throws Throwable  {\n      Arc2D.Float arc2D_Float0 = new Arc2D.Float();\n      Line2D.Double line2D_Double0 = new Line2D.Double(0.0F, (-1.0F), 0.0, (-2816.873F));\n      boolean boolean0 = ShapeUtilities.equal((Shape) line2D_Double0, (Shape) arc2D_Float0);\n      assertFalse(boolean0);\n  }\n\n  @Test(timeout = 4000)\n  public void test9()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath(0, 0);\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) null);\n      assertFalse(boolean0);\n  }\n}\n"}, "focal_class": {"name": "ShapeUtilities", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_11/fixed/source/org/jfree/chart/util/ShapeUtilities.java", "superclass": "", "interface": "", "imports": ["import java.awt.Graphics2D;", "import java.awt.Polygon;", "import java.awt.Shape;", "import java.awt.geom.AffineTransform;", "import java.awt.geom.Arc2D;", "import java.awt.geom.Ellipse2D;", "import java.awt.geom.GeneralPath;", "import java.awt.geom.Line2D;", "import java.awt.geom.PathIterator;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.util.Arrays;"], "fields": ["private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"], "methods": ["Shape org.jfree.chart.util.ShapeUtilities#clone(Shape#shape)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Shape#s1,Shape#s2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Line2D#l1,Line2D#l2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Ellipse2D#e1,Ellipse2D#e2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Arc2D#a1,Arc2D#a2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(Polygon#p1,Polygon#p2)", "boolean org.jfree.chart.util.ShapeUtilities#equal(GeneralPath#p1,GeneralPath#p2)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,double#transX,double#transY)", "Shape org.jfree.chart.util.ShapeUtilities#createTranslatedShape(Shape#shape,RectangleAnchor#anchor,double#locationX,double#locationY)", "Shape org.jfree.chart.util.ShapeUtilities#rotateShape(Shape#base,double#angle,float#x,float#y)", "void org.jfree.chart.util.ShapeUtilities#drawRotatedShape(Graphics2D#g2,Shape#shape,double#angle,float#x,float#y)", "Shape org.jfree.chart.util.ShapeUtilities#createDiagonalCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createRegularCross(float#l,float#t)", "Shape org.jfree.chart.util.ShapeUtilities#createDiamond(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createUpTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createDownTriangle(float#s)", "Shape org.jfree.chart.util.ShapeUtilities#createLineRegion(Line2D#line,float#width)", "Point2D org.jfree.chart.util.ShapeUtilities#getPointInRectangle(double#x,double#y,Rectangle2D#area)", "boolean org.jfree.chart.util.ShapeUtilities#contains(Rectangle2D#rect1,Rectangle2D#rect2)", "boolean org.jfree.chart.util.ShapeUtilities#intersects(Rectangle2D#rect1,Rectangle2D#rect2)"], "other_methods": ["public static Shape clone(Shape shape);", "public static boolean equal(Shape s1,Shape s2);", "public static boolean equal(Line2D l1,Line2D l2);", "public static boolean equal(Ellipse2D e1,Ellipse2D e2);", "public static boolean equal(Arc2D a1,Arc2D a2);", "public static boolean equal(Polygon p1,Polygon p2);", "public static boolean equal(GeneralPath p1,GeneralPath p2);", "public static Shape createTranslatedShape(Shape shape,double transX,double transY);", "public static Shape createTranslatedShape(Shape shape,RectangleAnchor anchor,double locationX,double locationY);", "public static Shape rotateShape(Shape base,double angle,float x,float y);", "public static void drawRotatedShape(Graphics2D g2,Shape shape,double angle,float x,float y);", "public static Shape createDiagonalCross(float l,float t);", "public static Shape createRegularCross(float l,float t);", "public static Shape createDiamond(float s);", "public static Shape createUpTriangle(float s);", "public static Shape createDownTriangle(float s);", "public static Shape createLineRegion(Line2D line,float width);", "public static Point2D getPointInRectangle(double x,double y,Rectangle2D area);", "public static boolean contains(Rectangle2D rect1,Rectangle2D rect2);", "public static boolean intersects(Rectangle2D rect1,Rectangle2D rect2);"], "fields_dict": {"float#SQRT2": "private static final float SQRT2 = (float) Math.pow(2.0, 0.5)"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -------------------\n * ShapeUtilities.java\n * -------------------\n * (C)opyright 2003-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   -;\n *\n * Changes\n * -------\n * 13-Aug-2003 : Version 1 (DG);\n * 16-Mar-2004 : Moved rotateShape() from RefineryUtilities.java to here (DG);\n * 13-May-2004 : Added new shape creation methods (DG);\n * 30-Sep-2004 : Added createLineRegion() method (DG);\n *               Moved drawRotatedShape() method from RefineryUtilities class\n *               to this class (DG);\n * 04-Oct-2004 : Renamed ShapeUtils --> ShapeUtilities (DG);\n * 26-Oct-2004 : Added a method to test the equality of two Line2D\n *               instances (DG);\n * 10-Nov-2004 : Added new translateShape() and equal(Ellipse2D, Ellipse2D)\n *               methods (DG);\n * 11-Nov-2004 : Renamed translateShape() --> createTranslatedShape() (DG);\n * 07-Jan-2005 : Minor Javadoc fix (DG);\n * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG);\n * 21-Jan-2005 : Modified return type of RectangleAnchor.coordinates()\n *               method (DG);\n * 22-Feb-2005 : Added equality tests for Arc2D and GeneralPath (DG);\n * 16-Mar-2005 : Fixed bug where equal(Shape, Shape) fails for two Polygon\n *               instances (DG);\n * 20-Jun-2007 : Copied from JCommon (DG);\n * 02-Jun-2008 : Fixed bug in equal(GeneralPath, GeneralPath) (DG);\n *\n */\n\npackage org.jfree.chart.util;\n\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Arc2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.GeneralPath;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Arrays;\n\n/**\n * Utility methods for {@link Shape} objects.\n */\npublic class ShapeUtilities {\n\n    /**\n     * Prevents instantiation.\n     */\n    private ShapeUtilities() {\n    }\n\n    /**\n     * Returns a clone of the specified shape, or <code>null</code>.  At the\n     * current time, this method supports cloning for instances of\n     * <code>Line2D</code>, <code>RectangularShape</code>, <code>Area</code>\n     * and <code>GeneralPath</code>.\n     * <p>\n     * <code>RectangularShape</code> includes <code>Arc2D</code>,\n     * <code>Ellipse2D</code>, <code>Rectangle2D</code>,\n     * <code>RoundRectangle2D</code>.\n     *\n     * @param shape  the shape to clone (<code>null</code> permitted,\n     *               returns <code>null</code>).\n     *\n     * @return A clone or <code>null</code>.\n     */\n    public static Shape clone(Shape shape) {\n        if (shape instanceof Cloneable) {\n            try {\n                return (Shape) ObjectUtilities.clone(shape);\n            }\n            catch (CloneNotSupportedException cnse) {\n            }\n        }\n        Shape result = null;\n        return result;\n    }\n\n    /**\n     * Tests two shapes for equality.  If both shapes are <code>null</code>,\n     * this method will return <code>true</code>.\n     * <p>\n     * In the current implementation, the following shapes are supported:\n     * <code>Ellipse2D</code>, <code>Line2D</code> and <code>Rectangle2D</code>\n     * (implicit).\n     *\n     * @param s1  the first shape (<code>null</code> permitted).\n     * @param s2  the second shape (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Shape s1, Shape s2) {\n        if (s1 instanceof Line2D && s2 instanceof Line2D) {\n            return equal((Line2D) s1, (Line2D) s2);\n        }\n        else if (s1 instanceof Ellipse2D && s2 instanceof Ellipse2D) {\n            return equal((Ellipse2D) s1, (Ellipse2D) s2);\n        }\n        else if (s1 instanceof Arc2D && s2 instanceof Arc2D) {\n            return equal((Arc2D) s1, (Arc2D) s2);\n        }\n        else if (s1 instanceof Polygon && s2 instanceof Polygon) {\n            return equal((Polygon) s1, (Polygon) s2);\n        }\n        else if (s1 instanceof GeneralPath && s2 instanceof GeneralPath) {\n            return equal((GeneralPath) s1, (GeneralPath) s2);\n        }\n        else {\n            // this will handle Rectangle2D...\n            return ObjectUtilities.equal(s1, s2);\n        }\n    }\n\n    /**\n     * Compares two lines are returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param l1  the first line (<code>null</code> permitted).\n     * @param l2  the second line (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Line2D l1, Line2D l2) {\n        if (l1 == null) {\n            return (l2 == null);\n        }\n        if (l2 == null) {\n            return false;\n        }\n        if (!l1.getP1().equals(l2.getP1())) {\n            return false;\n        }\n        if (!l1.getP2().equals(l2.getP2())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two ellipses and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param e1  the first ellipse (<code>null</code> permitted).\n     * @param e2  the second ellipse (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Ellipse2D e1, Ellipse2D e2) {\n        if (e1 == null) {\n            return (e2 == null);\n        }\n        if (e2 == null) {\n            return false;\n        }\n        if (!e1.getFrame().equals(e2.getFrame())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Compares two arcs and returns <code>true</code> if they are equal or\n     * both <code>null</code>.\n     *\n     * @param a1  the first arc (<code>null</code> permitted).\n     * @param a2  the second arc (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Arc2D a1, Arc2D a2) {\n        if (a1 == null) {\n            return (a2 == null);\n        }\n        if (a2 == null) {\n            return false;\n        }\n        if (!a1.getFrame().equals(a2.getFrame())) {\n            return false;\n        }\n        if (a1.getAngleStart() != a2.getAngleStart()) {\n            return false;\n        }\n        if (a1.getAngleExtent() != a2.getAngleExtent()) {\n            return false;\n        }\n        if (a1.getArcType() != a2.getArcType()) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  polygon 1 (<code>null</code> permitted).\n     * @param p2  polygon 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(Polygon p1, Polygon p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.npoints != p2.npoints) {\n            return false;\n        }\n        if (!Arrays.equals(p1.xpoints, p2.xpoints)) {\n            return false;\n        }\n        if (!Arrays.equals(p1.ypoints, p2.ypoints)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Tests two polygons for equality.  If both are <code>null</code> this\n     * method returns <code>true</code>.\n     *\n     * @param p1  path 1 (<code>null</code> permitted).\n     * @param p2  path 2 (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }\n\n    /**\n     * Creates and returns a translated shape.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param transX  the x translation (in Java2D space).\n     * @param transY  the y translation (in Java2D space).\n     *\n     * @return The translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              double transX,\n                                              double transY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                transX, transY);\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Translates a shape to a new location such that the anchor point\n     * (relative to the rectangular bounds of the shape) aligns with the\n     * specified (x, y) coordinate in Java2D space.\n     *\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param anchor  the anchor (<code>null</code> not permitted).\n     * @param locationX  the x-coordinate (in Java2D space).\n     * @param locationY  the y-coordinate (in Java2D space).\n     *\n     * @return A new and translated shape.\n     */\n    public static Shape createTranslatedShape(Shape shape,\n                                              RectangleAnchor anchor,\n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(),\n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);\n    }\n\n    /**\n     * Rotates a shape about the specified coordinates.\n     *\n     * @param base  the shape (<code>null</code> permitted, returns\n     *              <code>null</code>).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point (in Java2D space).\n     * @param y  the y coordinate for the rotation point (in Java2D space).\n     *\n     * @return the rotated shape.\n     */\n    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }\n\n    /**\n     * Draws a shape with the specified rotation about <code>(x, y)</code>.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param shape  the shape (<code>null</code> not permitted).\n     * @param angle  the angle (in radians).\n     * @param x  the x coordinate for the rotation point.\n     * @param y  the y coordinate for the rotation point.\n     */\n    public static void drawRotatedShape(Graphics2D g2, Shape shape,\n                                        double angle, float x, float y) {\n\n        AffineTransform saved = g2.getTransform();\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        g2.transform(rotate);\n        g2.draw(shape);\n        g2.setTransform(saved);\n\n    }\n\n    /** A useful constant used internally. */\n    private static final float SQRT2 = (float) Math.pow(2.0, 0.5);\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createDiagonalCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l - t, -l + t);\n        p0.lineTo(-l + t, -l - t);\n        p0.lineTo(0.0f, -t * SQRT2);\n        p0.lineTo(l - t, -l - t);\n        p0.lineTo(l + t, -l + t);\n        p0.lineTo(t * SQRT2, 0.0f);\n        p0.lineTo(l + t, l - t);\n        p0.lineTo(l - t, l + t);\n        p0.lineTo(0.0f, t * SQRT2);\n        p0.lineTo(-l + t, l + t);\n        p0.lineTo(-l - t, l - t);\n        p0.lineTo(-t * SQRT2, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diagonal cross shape.\n     *\n     * @param l  the length of each 'arm'.\n     * @param t  the thickness.\n     *\n     * @return A diagonal cross shape.\n     */\n    public static Shape createRegularCross(float l, float t) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(-l, t);\n        p0.lineTo(-t, t);\n        p0.lineTo(-t, l);\n        p0.lineTo(t, l);\n        p0.lineTo(t, t);\n        p0.lineTo(l, t);\n        p0.lineTo(l, -t);\n        p0.lineTo(t, -t);\n        p0.lineTo(t, -l);\n        p0.lineTo(-t, -l);\n        p0.lineTo(-t, -t);\n        p0.lineTo(-l, -t);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a diamond shape.\n     *\n     * @param s  the size factor (equal to half the height of the diamond).\n     *\n     * @return A diamond shape.\n     */\n    public static Shape createDiamond(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, 0.0f);\n        p0.lineTo(0.0f, s);\n        p0.lineTo(-s, 0.0f);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points upwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createUpTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, -s);\n        p0.lineTo(s, s);\n        p0.lineTo(-s, s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a triangle shape that points downwards.\n     *\n     * @param s  the size factor (equal to half the height of the triangle).\n     *\n     * @return A triangle shape.\n     */\n    public static Shape createDownTriangle(float s) {\n        GeneralPath p0 = new GeneralPath();\n        p0.moveTo(0.0f, s);\n        p0.lineTo(s, -s);\n        p0.lineTo(-s, -s);\n        p0.closePath();\n        return p0;\n    }\n\n    /**\n     * Creates a region surrounding a line segment by 'widening' the line\n     * segment.  A typical use for this method is the creation of a\n     * 'clickable' region for a line that is displayed on-screen.\n     *\n     * @param line  the line (<code>null</code> not permitted).\n     * @param width  the width of the region.\n     *\n     * @return A region that surrounds the line.\n     */\n    public static Shape createLineRegion(Line2D line, float width) {\n        GeneralPath result = new GeneralPath();\n        float x1 = (float) line.getX1();\n        float x2 = (float) line.getX2();\n        float y1 = (float) line.getY1();\n        float y2 = (float) line.getY2();\n        if ((x2 - x1) != 0.0) {\n            double theta = Math.atan((y2 - y1) / (x2 - x1));\n            float dx = (float) Math.sin(theta) * width;\n            float dy = (float) Math.cos(theta) * width;\n            result.moveTo(x1 - dx, y1 + dy);\n            result.lineTo(x1 + dx, y1 - dy);\n            result.lineTo(x2 + dx, y2 - dy);\n            result.lineTo(x2 - dx, y2 + dy);\n            result.closePath();\n        }\n        else {\n            // special case, vertical line\n            result.moveTo(x1 - width / 2.0f, y1);\n            result.lineTo(x1 + width / 2.0f, y1);\n            result.lineTo(x2 + width / 2.0f, y2);\n            result.lineTo(x2 - width / 2.0f, y2);\n            result.closePath();\n        }\n        return result;\n    }\n\n    /**\n     * Returns a point based on (x, y) but constrained to be within the bounds\n     * of a given rectangle.\n     *\n     * @param x  the x-coordinate.\n     * @param y  the y-coordinate.\n     * @param area  the constraining rectangle (<code>null</code> not\n     *              permitted).\n     *\n     * @return A point within the rectangle.\n     *\n     * @throws NullPointerException if <code>area</code> is <code>null</code>.\n     */\n    public static Point2D getPointInRectangle(double x, double y,\n                                              Rectangle2D area) {\n\n        x = Math.max(area.getMinX(), Math.min(x, area.getMaxX()));\n        y = Math.max(area.getMinY(), Math.min(y, area.getMaxY()));\n        return new Point2D.Double(x, y);\n\n    }\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean contains(Rectangle2D rect1, Rectangle2D rect2) {\n\n        double x0 = rect1.getX();\n        double y0 = rect1.getY();\n        double x = rect2.getX();\n        double y = rect2.getY();\n        double w = rect2.getWidth();\n        double h = rect2.getHeight();\n\n        return ((x >= x0) && (y >= y0)\n                && ((x + w) <= (x0 + rect1.getWidth()))\n                && ((y + h) <= (y0 + rect1.getHeight())));\n\n    }\n\n\n    /**\n     * Checks, whether the given rectangle1 fully contains rectangle 2\n     * (even if rectangle 2 has a height or width of zero!).\n     *\n     * @param rect1  the first rectangle.\n     * @param rect2  the second rectangle.\n     *\n     * @return A boolean.\n     */\n    public static boolean intersects(Rectangle2D rect1, Rectangle2D rect2) {\n\n      double x0 = rect1.getX();\n      double y0 = rect1.getY();\n\n      double x = rect2.getX();\n      double width = rect2.getWidth();\n      double y = rect2.getY();\n      double height = rect2.getHeight();\n      return (x + width >= x0 && y + height >= y0 && x <= x0 + rect1.getWidth()\n              && y <= y0 + rect1.getHeight());\n    }\n}\n"}, "retrieved_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      GeneralPath generalPath0 = new GeneralPath();\n      boolean boolean0 = ShapeUtilities.equal((Shape) generalPath0, (Shape) generalPath0);\n      assertTrue(boolean0);\n  }"}
{"bug_id": "Chart_14", "version": "fixed", "focal_method_signature": "org.jfree.chart.plot#XYPlot#removeRangeMarker(org.jfree.chart.plot#Marker)", "focal_method_bytecode_signature": "org.jfree.chart.plot.XYPlot.removeRangeMarker(Lorg/jfree/chart/plot/Marker;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_14/evosuite-tests/org/jfree/chart/plot/CategoryPlot_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_14/fixed/source/org/jfree/chart/plot/XYPlot.java", "focal_method": "public boolean removeRangeMarker(Marker marker) {\r\n    return removeRangeMarker(marker, Layer.FOREGROUND);\r\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      CategoryPlot categoryPlot0 = new CategoryPlot();\n      ValueMarker valueMarker0 = new ValueMarker((-1360.5635568969062), categoryPlot0.DEFAULT_BACKGROUND_PAINT, categoryPlot0.DEFAULT_OUTLINE_STROKE);\n      categoryPlot0.removeRangeMarker((Marker) valueMarker0);\n      assertEquals(1, categoryPlot0.getDatasetCount());\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      CategoryPlot categoryPlot0 = new CategoryPlot();\n      ValueMarker valueMarker0 = new ValueMarker((-1360.5635568969062), categoryPlot0.DEFAULT_BACKGROUND_PAINT, categoryPlot0.DEFAULT_OUTLINE_STROKE);\n      categoryPlot0.removeRangeMarker((Marker) valueMarker0);\n      assertEquals(1, categoryPlot0.getDatasetCount());\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_14/evosuite-tests/org/jfree/chart/plot/CategoryPlot_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.plot.CategoryPlot;", "import org.jfree.chart.plot.Marker;", "import org.jfree.chart.plot.ValueMarker;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.plot.CategoryPlot_ESTest#test0()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:04:58 GMT 2025\n */\n\npackage org.jfree.chart.plot;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.plot.CategoryPlot;\nimport org.jfree.chart.plot.Marker;\nimport org.jfree.chart.plot.ValueMarker;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class CategoryPlot_ESTest extends CategoryPlot_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      CategoryPlot categoryPlot0 = new CategoryPlot();\n      ValueMarker valueMarker0 = new ValueMarker((-1360.5635568969062), categoryPlot0.DEFAULT_BACKGROUND_PAINT, categoryPlot0.DEFAULT_OUTLINE_STROKE);\n      categoryPlot0.removeRangeMarker((Marker) valueMarker0);\n      assertEquals(1, categoryPlot0.getDatasetCount());\n  }\n}\n"}, "focal_class": {"name": "XYPlot", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_14/fixed/source/org/jfree/chart/plot/XYPlot.java", "superclass": "extends Plot", "interface": "implements ValueAxisPlot, Zoomable,\n        RendererChangeListener, Cloneable, PublicCloneable, Serializable", "imports": ["import java.awt.AlphaComposite;", "import java.awt.BasicStroke;", "import java.awt.Color;", "import java.awt.Composite;", "import java.awt.Graphics2D;", "import java.awt.Paint;", "import java.awt.Shape;", "import java.awt.Stroke;", "import java.awt.geom.Line2D;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.io.IOException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.io.Serializable;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.HashMap;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.ResourceBundle;", "import java.util.Set;", "import java.util.TreeMap;", "import org.jfree.chart.LegendItem;", "import org.jfree.chart.LegendItemCollection;", "import org.jfree.chart.annotations.XYAnnotation;", "import org.jfree.chart.axis.Axis;", "import org.jfree.chart.axis.AxisCollection;", "import org.jfree.chart.axis.AxisLocation;", "import org.jfree.chart.axis.AxisSpace;", "import org.jfree.chart.axis.AxisState;", "import org.jfree.chart.axis.ValueAxis;", "import org.jfree.chart.axis.ValueTick;", "import org.jfree.chart.event.ChartChangeEventType;", "import org.jfree.chart.event.PlotChangeEvent;", "import org.jfree.chart.event.RendererChangeEvent;", "import org.jfree.chart.event.RendererChangeListener;", "import org.jfree.chart.renderer.RendererUtilities;", "import org.jfree.chart.renderer.xy.XYItemRenderer;", "import org.jfree.chart.renderer.xy.XYItemRendererState;", "import org.jfree.chart.util.Layer;", "import org.jfree.chart.util.ObjectList;", "import org.jfree.chart.util.ObjectUtilities;", "import org.jfree.chart.util.PaintUtilities;", "import org.jfree.chart.util.PublicCloneable;", "import org.jfree.chart.util.RectangleEdge;", "import org.jfree.chart.util.RectangleInsets;", "import org.jfree.chart.util.SerialUtilities;", "import org.jfree.data.Range;", "import org.jfree.data.general.Dataset;", "import org.jfree.data.general.DatasetChangeEvent;", "import org.jfree.data.general.DatasetUtilities;", "import org.jfree.data.xy.XYDataset;"], "fields": ["private static final long serialVersionUID = 7044148245716569264L", "public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, \n            new float[] {2.0f, 2.0f}, 0.0f)", "public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE", "public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false", "public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE", "public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue", "protected static ResourceBundle localizationResources = ResourceBundle.getBundle(\n                    \"org.jfree.chart.plot.LocalizationBundle\")", "private PlotOrientation orientation", "private RectangleInsets axisOffset", "private ObjectList domainAxes", "private ObjectList domainAxisLocations", "private ObjectList rangeAxes", "private ObjectList rangeAxisLocations", "private ObjectList datasets", "private ObjectList renderers", "private Map datasetToDomainAxisMap", "private Map datasetToRangeAxisMap", "private transient Point2D quadrantOrigin = new Point2D.Double(0.0, 0.0)", "private transient Paint[] quadrantPaint = new Paint[] {null, null, null, null}", "private boolean domainGridlinesVisible", "private transient Stroke domainGridlineStroke", "private transient Paint domainGridlinePaint", "private boolean rangeGridlinesVisible", "private transient Stroke rangeGridlineStroke", "private transient Paint rangeGridlinePaint", "private boolean domainZeroBaselineVisible", "private transient Stroke domainZeroBaselineStroke", "private transient Paint domainZeroBaselinePaint", "private boolean rangeZeroBaselineVisible", "private transient Stroke rangeZeroBaselineStroke", "private transient Paint rangeZeroBaselinePaint", "private boolean domainCrosshairVisible", "private double domainCrosshairValue", "private transient Stroke domainCrosshairStroke", "private transient Paint domainCrosshairPaint", "private boolean domainCrosshairLockedOnData = true", "private boolean rangeCrosshairVisible", "private double rangeCrosshairValue", "private transient Stroke rangeCrosshairStroke", "private transient Paint rangeCrosshairPaint", "private boolean rangeCrosshairLockedOnData = true", "private Map foregroundDomainMarkers", "private Map backgroundDomainMarkers", "private Map foregroundRangeMarkers", "private Map backgroundRangeMarkers", "private List annotations", "private transient Paint domainTickBandPaint", "private transient Paint rangeTickBandPaint", "private AxisSpace fixedDomainAxisSpace", "private AxisSpace fixedRangeAxisSpace", "private DatasetRenderingOrder datasetRenderingOrder = DatasetRenderingOrder.REVERSE", "private SeriesRenderingOrder seriesRenderingOrder = SeriesRenderingOrder.REVERSE", "private int weight", "private LegendItemCollection fixedLegendItems"], "methods": ["String org.jfree.chart.plot.XYPlot#getPlotType()", "PlotOrientation org.jfree.chart.plot.XYPlot#getOrientation()", "void org.jfree.chart.plot.XYPlot#setOrientation(PlotOrientation#orientation)", "RectangleInsets org.jfree.chart.plot.XYPlot#getAxisOffset()", "void org.jfree.chart.plot.XYPlot#setAxisOffset(RectangleInsets#offset)", "ValueAxis org.jfree.chart.plot.XYPlot#getDomainAxis()", "ValueAxis org.jfree.chart.plot.XYPlot#getDomainAxis(int#index)", "void org.jfree.chart.plot.XYPlot#setDomainAxis(ValueAxis#axis)", "void org.jfree.chart.plot.XYPlot#setDomainAxis(int#index,ValueAxis#axis)", "void org.jfree.chart.plot.XYPlot#setDomainAxis(int#index,ValueAxis#axis,boolean#notify)", "void org.jfree.chart.plot.XYPlot#setDomainAxes(ValueAxis[]#axes)", "AxisLocation org.jfree.chart.plot.XYPlot#getDomainAxisLocation()", "void org.jfree.chart.plot.XYPlot#setDomainAxisLocation(AxisLocation#location)", "void org.jfree.chart.plot.XYPlot#setDomainAxisLocation(AxisLocation#location,boolean#notify)", "RectangleEdge org.jfree.chart.plot.XYPlot#getDomainAxisEdge()", "int org.jfree.chart.plot.XYPlot#getDomainAxisCount()", "void org.jfree.chart.plot.XYPlot#clearDomainAxes()", "void org.jfree.chart.plot.XYPlot#configureDomainAxes()", "AxisLocation org.jfree.chart.plot.XYPlot#getDomainAxisLocation(int#index)", "void org.jfree.chart.plot.XYPlot#setDomainAxisLocation(int#index,AxisLocation#location)", "void org.jfree.chart.plot.XYPlot#setDomainAxisLocation(int#index,AxisLocation#location,boolean#notify)", "RectangleEdge org.jfree.chart.plot.XYPlot#getDomainAxisEdge(int#index)", "ValueAxis org.jfree.chart.plot.XYPlot#getRangeAxis()", "void org.jfree.chart.plot.XYPlot#setRangeAxis(ValueAxis#axis)", "AxisLocation org.jfree.chart.plot.XYPlot#getRangeAxisLocation()", "void org.jfree.chart.plot.XYPlot#setRangeAxisLocation(AxisLocation#location)", "void org.jfree.chart.plot.XYPlot#setRangeAxisLocation(AxisLocation#location,boolean#notify)", "RectangleEdge org.jfree.chart.plot.XYPlot#getRangeAxisEdge()", "ValueAxis org.jfree.chart.plot.XYPlot#getRangeAxis(int#index)", "void org.jfree.chart.plot.XYPlot#setRangeAxis(int#index,ValueAxis#axis)", "void org.jfree.chart.plot.XYPlot#setRangeAxis(int#index,ValueAxis#axis,boolean#notify)", "void org.jfree.chart.plot.XYPlot#setRangeAxes(ValueAxis[]#axes)", "int org.jfree.chart.plot.XYPlot#getRangeAxisCount()", "void org.jfree.chart.plot.XYPlot#clearRangeAxes()", "void org.jfree.chart.plot.XYPlot#configureRangeAxes()", "AxisLocation org.jfree.chart.plot.XYPlot#getRangeAxisLocation(int#index)", "void org.jfree.chart.plot.XYPlot#setRangeAxisLocation(int#index,AxisLocation#location)", "void org.jfree.chart.plot.XYPlot#setRangeAxisLocation(int#index,AxisLocation#location,boolean#notify)", "RectangleEdge org.jfree.chart.plot.XYPlot#getRangeAxisEdge(int#index)", "XYDataset org.jfree.chart.plot.XYPlot#getDataset()", "XYDataset org.jfree.chart.plot.XYPlot#getDataset(int#index)", "void org.jfree.chart.plot.XYPlot#setDataset(XYDataset#dataset)", "void org.jfree.chart.plot.XYPlot#setDataset(int#index,XYDataset#dataset)", "int org.jfree.chart.plot.XYPlot#getDatasetCount()", "int org.jfree.chart.plot.XYPlot#indexOf(XYDataset#dataset)", "void org.jfree.chart.plot.XYPlot#mapDatasetToDomainAxis(int#index,int#axisIndex)", "void org.jfree.chart.plot.XYPlot#mapDatasetToRangeAxis(int#index,int#axisIndex)", "XYItemRenderer org.jfree.chart.plot.XYPlot#getRenderer()", "XYItemRenderer org.jfree.chart.plot.XYPlot#getRenderer(int#index)", "void org.jfree.chart.plot.XYPlot#setRenderer(XYItemRenderer#renderer)", "void org.jfree.chart.plot.XYPlot#setRenderer(int#index,XYItemRenderer#renderer)", "void org.jfree.chart.plot.XYPlot#setRenderer(int#index,XYItemRenderer#renderer,boolean#notify)", "void org.jfree.chart.plot.XYPlot#setRenderers(XYItemRenderer[]#renderers)", "DatasetRenderingOrder org.jfree.chart.plot.XYPlot#getDatasetRenderingOrder()", "void org.jfree.chart.plot.XYPlot#setDatasetRenderingOrder(DatasetRenderingOrder#order)", "SeriesRenderingOrder org.jfree.chart.plot.XYPlot#getSeriesRenderingOrder()", "void org.jfree.chart.plot.XYPlot#setSeriesRenderingOrder(SeriesRenderingOrder#order)", "int org.jfree.chart.plot.XYPlot#getIndexOf(XYItemRenderer#renderer)", "XYItemRenderer org.jfree.chart.plot.XYPlot#getRendererForDataset(XYDataset#dataset)", "int org.jfree.chart.plot.XYPlot#getWeight()", "void org.jfree.chart.plot.XYPlot#setWeight(int#weight)", "boolean org.jfree.chart.plot.XYPlot#isDomainGridlinesVisible()", "void org.jfree.chart.plot.XYPlot#setDomainGridlinesVisible(boolean#visible)", "Stroke org.jfree.chart.plot.XYPlot#getDomainGridlineStroke()", "void org.jfree.chart.plot.XYPlot#setDomainGridlineStroke(Stroke#stroke)", "Paint org.jfree.chart.plot.XYPlot#getDomainGridlinePaint()", "void org.jfree.chart.plot.XYPlot#setDomainGridlinePaint(Paint#paint)", "boolean org.jfree.chart.plot.XYPlot#isRangeGridlinesVisible()", "void org.jfree.chart.plot.XYPlot#setRangeGridlinesVisible(boolean#visible)", "Stroke org.jfree.chart.plot.XYPlot#getRangeGridlineStroke()", "void org.jfree.chart.plot.XYPlot#setRangeGridlineStroke(Stroke#stroke)", "Paint org.jfree.chart.plot.XYPlot#getRangeGridlinePaint()", "void org.jfree.chart.plot.XYPlot#setRangeGridlinePaint(Paint#paint)", "boolean org.jfree.chart.plot.XYPlot#isDomainZeroBaselineVisible()", "void org.jfree.chart.plot.XYPlot#setDomainZeroBaselineVisible(boolean#visible)", "Stroke org.jfree.chart.plot.XYPlot#getDomainZeroBaselineStroke()", "void org.jfree.chart.plot.XYPlot#setDomainZeroBaselineStroke(Stroke#stroke)", "Paint org.jfree.chart.plot.XYPlot#getDomainZeroBaselinePaint()", "void org.jfree.chart.plot.XYPlot#setDomainZeroBaselinePaint(Paint#paint)", "boolean org.jfree.chart.plot.XYPlot#isRangeZeroBaselineVisible()", "void org.jfree.chart.plot.XYPlot#setRangeZeroBaselineVisible(boolean#visible)", "Stroke org.jfree.chart.plot.XYPlot#getRangeZeroBaselineStroke()", "void org.jfree.chart.plot.XYPlot#setRangeZeroBaselineStroke(Stroke#stroke)", "Paint org.jfree.chart.plot.XYPlot#getRangeZeroBaselinePaint()", "void org.jfree.chart.plot.XYPlot#setRangeZeroBaselinePaint(Paint#paint)", "Paint org.jfree.chart.plot.XYPlot#getDomainTickBandPaint()", "void org.jfree.chart.plot.XYPlot#setDomainTickBandPaint(Paint#paint)", "Paint org.jfree.chart.plot.XYPlot#getRangeTickBandPaint()", "void org.jfree.chart.plot.XYPlot#setRangeTickBandPaint(Paint#paint)", "Point2D org.jfree.chart.plot.XYPlot#getQuadrantOrigin()", "void org.jfree.chart.plot.XYPlot#setQuadrantOrigin(Point2D#origin)", "Paint org.jfree.chart.plot.XYPlot#getQuadrantPaint(int#index)", "void org.jfree.chart.plot.XYPlot#setQuadrantPaint(int#index,Paint#paint)", "void org.jfree.chart.plot.XYPlot#addDomainMarker(Marker#marker)", "void org.jfree.chart.plot.XYPlot#addDomainMarker(Marker#marker,Layer#layer)", "void org.jfree.chart.plot.XYPlot#clearDomainMarkers()", "void org.jfree.chart.plot.XYPlot#clearDomainMarkers(int#index)", "void org.jfree.chart.plot.XYPlot#addDomainMarker(int#index,Marker#marker,Layer#layer)", "void org.jfree.chart.plot.XYPlot#addDomainMarker(int#index,Marker#marker,Layer#layer,boolean#notify)", "boolean org.jfree.chart.plot.XYPlot#removeDomainMarker(Marker#marker)", "boolean org.jfree.chart.plot.XYPlot#removeDomainMarker(Marker#marker,Layer#layer)", "boolean org.jfree.chart.plot.XYPlot#removeDomainMarker(int#index,Marker#marker,Layer#layer)", "boolean org.jfree.chart.plot.XYPlot#removeDomainMarker(int#index,Marker#marker,Layer#layer,boolean#notify)", "void org.jfree.chart.plot.XYPlot#addRangeMarker(Marker#marker)", "void org.jfree.chart.plot.XYPlot#addRangeMarker(Marker#marker,Layer#layer)", "void org.jfree.chart.plot.XYPlot#clearRangeMarkers()", "void org.jfree.chart.plot.XYPlot#addRangeMarker(int#index,Marker#marker,Layer#layer)", "void org.jfree.chart.plot.XYPlot#addRangeMarker(int#index,Marker#marker,Layer#layer,boolean#notify)", "void org.jfree.chart.plot.XYPlot#clearRangeMarkers(int#index)", "boolean org.jfree.chart.plot.XYPlot#removeRangeMarker(Marker#marker)", "boolean org.jfree.chart.plot.XYPlot#removeRangeMarker(Marker#marker,Layer#layer)", "boolean org.jfree.chart.plot.XYPlot#removeRangeMarker(int#index,Marker#marker,Layer#layer)", "boolean org.jfree.chart.plot.XYPlot#removeRangeMarker(int#index,Marker#marker,Layer#layer,boolean#notify)", "void org.jfree.chart.plot.XYPlot#addAnnotation(XYAnnotation#annotation)", "void org.jfree.chart.plot.XYPlot#addAnnotation(XYAnnotation#annotation,boolean#notify)", "boolean org.jfree.chart.plot.XYPlot#removeAnnotation(XYAnnotation#annotation)", "boolean org.jfree.chart.plot.XYPlot#removeAnnotation(XYAnnotation#annotation,boolean#notify)", "List org.jfree.chart.plot.XYPlot#getAnnotations()", "void org.jfree.chart.plot.XYPlot#clearAnnotations()", "AxisSpace org.jfree.chart.plot.XYPlot#calculateAxisSpace(Graphics2D#g2,Rectangle2D#plotArea)", "AxisSpace org.jfree.chart.plot.XYPlot#calculateDomainAxisSpace(Graphics2D#g2,Rectangle2D#plotArea,AxisSpace#space)", "AxisSpace org.jfree.chart.plot.XYPlot#calculateRangeAxisSpace(Graphics2D#g2,Rectangle2D#plotArea,AxisSpace#space)", "void org.jfree.chart.plot.XYPlot#draw(Graphics2D#g2,Rectangle2D#area,Point2D#anchor,PlotState#parentState,PlotRenderingInfo#info)", "void org.jfree.chart.plot.XYPlot#drawBackground(Graphics2D#g2,Rectangle2D#area)", "void org.jfree.chart.plot.XYPlot#drawQuadrants(Graphics2D#g2,Rectangle2D#area)", "void org.jfree.chart.plot.XYPlot#drawDomainTickBands(Graphics2D#g2,Rectangle2D#dataArea,List#ticks)", "void org.jfree.chart.plot.XYPlot#drawRangeTickBands(Graphics2D#g2,Rectangle2D#dataArea,List#ticks)", "Map org.jfree.chart.plot.XYPlot#drawAxes(Graphics2D#g2,Rectangle2D#plotArea,Rectangle2D#dataArea,PlotRenderingInfo#plotState)", "boolean org.jfree.chart.plot.XYPlot#render(Graphics2D#g2,Rectangle2D#dataArea,int#index,PlotRenderingInfo#info,CrosshairState#crosshairState)", "ValueAxis org.jfree.chart.plot.XYPlot#getDomainAxisForDataset(int#index)", "ValueAxis org.jfree.chart.plot.XYPlot#getRangeAxisForDataset(int#index)", "void org.jfree.chart.plot.XYPlot#drawDomainGridlines(Graphics2D#g2,Rectangle2D#dataArea,List#ticks)", "void org.jfree.chart.plot.XYPlot#drawRangeGridlines(Graphics2D#g2,Rectangle2D#area,List#ticks)", "void org.jfree.chart.plot.XYPlot#drawZeroDomainBaseline(Graphics2D#g2,Rectangle2D#area)", "void org.jfree.chart.plot.XYPlot#drawZeroRangeBaseline(Graphics2D#g2,Rectangle2D#area)", "void org.jfree.chart.plot.XYPlot#drawAnnotations(Graphics2D#g2,Rectangle2D#dataArea,PlotRenderingInfo#info)", "void org.jfree.chart.plot.XYPlot#drawDomainMarkers(Graphics2D#g2,Rectangle2D#dataArea,int#index,Layer#layer)", "void org.jfree.chart.plot.XYPlot#drawRangeMarkers(Graphics2D#g2,Rectangle2D#dataArea,int#index,Layer#layer)", "Collection org.jfree.chart.plot.XYPlot#getDomainMarkers(Layer#layer)", "Collection org.jfree.chart.plot.XYPlot#getRangeMarkers(Layer#layer)", "Collection org.jfree.chart.plot.XYPlot#getDomainMarkers(int#index,Layer#layer)", "Collection org.jfree.chart.plot.XYPlot#getRangeMarkers(int#index,Layer#layer)", "void org.jfree.chart.plot.XYPlot#drawHorizontalLine(Graphics2D#g2,Rectangle2D#dataArea,double#value,Stroke#stroke,Paint#paint)", "void org.jfree.chart.plot.XYPlot#drawDomainCrosshair(Graphics2D#g2,Rectangle2D#dataArea,PlotOrientation#orientation,double#value,ValueAxis#axis,Stroke#stroke,Paint#paint)", "void org.jfree.chart.plot.XYPlot#drawVerticalLine(Graphics2D#g2,Rectangle2D#dataArea,double#value,Stroke#stroke,Paint#paint)", "void org.jfree.chart.plot.XYPlot#drawRangeCrosshair(Graphics2D#g2,Rectangle2D#dataArea,PlotOrientation#orientation,double#value,ValueAxis#axis,Stroke#stroke,Paint#paint)", "void org.jfree.chart.plot.XYPlot#handleClick(int#x,int#y,PlotRenderingInfo#info)", "List org.jfree.chart.plot.XYPlot#getDatasetsMappedToDomainAxis(Integer#axisIndex)", "List org.jfree.chart.plot.XYPlot#getDatasetsMappedToRangeAxis(Integer#axisIndex)", "int org.jfree.chart.plot.XYPlot#getDomainAxisIndex(ValueAxis#axis)", "int org.jfree.chart.plot.XYPlot#getRangeAxisIndex(ValueAxis#axis)", "Range org.jfree.chart.plot.XYPlot#getDataRange(ValueAxis#axis)", "void org.jfree.chart.plot.XYPlot#datasetChanged(DatasetChangeEvent#event)", "void org.jfree.chart.plot.XYPlot#rendererChanged(RendererChangeEvent#event)", "boolean org.jfree.chart.plot.XYPlot#isDomainCrosshairVisible()", "void org.jfree.chart.plot.XYPlot#setDomainCrosshairVisible(boolean#flag)", "boolean org.jfree.chart.plot.XYPlot#isDomainCrosshairLockedOnData()", "void org.jfree.chart.plot.XYPlot#setDomainCrosshairLockedOnData(boolean#flag)", "double org.jfree.chart.plot.XYPlot#getDomainCrosshairValue()", "void org.jfree.chart.plot.XYPlot#setDomainCrosshairValue(double#value)", "void org.jfree.chart.plot.XYPlot#setDomainCrosshairValue(double#value,boolean#notify)", "Stroke org.jfree.chart.plot.XYPlot#getDomainCrosshairStroke()", "void org.jfree.chart.plot.XYPlot#setDomainCrosshairStroke(Stroke#stroke)", "Paint org.jfree.chart.plot.XYPlot#getDomainCrosshairPaint()", "void org.jfree.chart.plot.XYPlot#setDomainCrosshairPaint(Paint#paint)", "boolean org.jfree.chart.plot.XYPlot#isRangeCrosshairVisible()", "void org.jfree.chart.plot.XYPlot#setRangeCrosshairVisible(boolean#flag)", "boolean org.jfree.chart.plot.XYPlot#isRangeCrosshairLockedOnData()", "void org.jfree.chart.plot.XYPlot#setRangeCrosshairLockedOnData(boolean#flag)", "double org.jfree.chart.plot.XYPlot#getRangeCrosshairValue()", "void org.jfree.chart.plot.XYPlot#setRangeCrosshairValue(double#value)", "void org.jfree.chart.plot.XYPlot#setRangeCrosshairValue(double#value,boolean#notify)", "Stroke org.jfree.chart.plot.XYPlot#getRangeCrosshairStroke()", "void org.jfree.chart.plot.XYPlot#setRangeCrosshairStroke(Stroke#stroke)", "Paint org.jfree.chart.plot.XYPlot#getRangeCrosshairPaint()", "void org.jfree.chart.plot.XYPlot#setRangeCrosshairPaint(Paint#paint)", "AxisSpace org.jfree.chart.plot.XYPlot#getFixedDomainAxisSpace()", "void org.jfree.chart.plot.XYPlot#setFixedDomainAxisSpace(AxisSpace#space)", "void org.jfree.chart.plot.XYPlot#setFixedDomainAxisSpace(AxisSpace#space,boolean#notify)", "AxisSpace org.jfree.chart.plot.XYPlot#getFixedRangeAxisSpace()", "void org.jfree.chart.plot.XYPlot#setFixedRangeAxisSpace(AxisSpace#space)", "void org.jfree.chart.plot.XYPlot#setFixedRangeAxisSpace(AxisSpace#space,boolean#notify)", "void org.jfree.chart.plot.XYPlot#zoomDomainAxes(double#factor,PlotRenderingInfo#info,Point2D#source)", "void org.jfree.chart.plot.XYPlot#zoomDomainAxes(double#factor,PlotRenderingInfo#info,Point2D#source,boolean#useAnchor)", "void org.jfree.chart.plot.XYPlot#zoomDomainAxes(double#lowerPercent,double#upperPercent,PlotRenderingInfo#info,Point2D#source)", "void org.jfree.chart.plot.XYPlot#zoomRangeAxes(double#factor,PlotRenderingInfo#info,Point2D#source)", "void org.jfree.chart.plot.XYPlot#zoomRangeAxes(double#factor,PlotRenderingInfo#info,Point2D#source,boolean#useAnchor)", "void org.jfree.chart.plot.XYPlot#zoomRangeAxes(double#lowerPercent,double#upperPercent,PlotRenderingInfo#info,Point2D#source)", "boolean org.jfree.chart.plot.XYPlot#isDomainZoomable()", "boolean org.jfree.chart.plot.XYPlot#isRangeZoomable()", "int org.jfree.chart.plot.XYPlot#getSeriesCount()", "LegendItemCollection org.jfree.chart.plot.XYPlot#getFixedLegendItems()", "void org.jfree.chart.plot.XYPlot#setFixedLegendItems(LegendItemCollection#items)", "LegendItemCollection org.jfree.chart.plot.XYPlot#getLegendItems()", "boolean org.jfree.chart.plot.XYPlot#equals(Object#obj)", "Object org.jfree.chart.plot.XYPlot#clone()", "void org.jfree.chart.plot.XYPlot#writeObject(ObjectOutputStream#stream)", "void org.jfree.chart.plot.XYPlot#readObject(ObjectInputStream#stream)"], "other_methods": ["public String getPlotType();", "public PlotOrientation getOrientation();", "public void setOrientation(PlotOrientation orientation);", "public RectangleInsets getAxisOffset();", "public void setAxisOffset(RectangleInsets offset);", "public ValueAxis getDomainAxis();", "public ValueAxis getDomainAxis(int index);", "public void setDomainAxis(ValueAxis axis);", "public void setDomainAxis(int index,ValueAxis axis);", "public void setDomainAxis(int index,ValueAxis axis,boolean notify);", "public void setDomainAxes(ValueAxis[] axes);", "public AxisLocation getDomainAxisLocation();", "public void setDomainAxisLocation(AxisLocation location);", "public void setDomainAxisLocation(AxisLocation location,boolean notify);", "public RectangleEdge getDomainAxisEdge();", "public int getDomainAxisCount();", "public void clearDomainAxes();", "public void configureDomainAxes();", "public AxisLocation getDomainAxisLocation(int index);", "public void setDomainAxisLocation(int index,AxisLocation location);", "public void setDomainAxisLocation(int index,AxisLocation location,boolean notify);", "public RectangleEdge getDomainAxisEdge(int index);", "public ValueAxis getRangeAxis();", "public void setRangeAxis(ValueAxis axis);", "public AxisLocation getRangeAxisLocation();", "public void setRangeAxisLocation(AxisLocation location);", "public void setRangeAxisLocation(AxisLocation location,boolean notify);", "public RectangleEdge getRangeAxisEdge();", "public ValueAxis getRangeAxis(int index);", "public void setRangeAxis(int index,ValueAxis axis);", "public void setRangeAxis(int index,ValueAxis axis,boolean notify);", "public void setRangeAxes(ValueAxis[] axes);", "public int getRangeAxisCount();", "public void clearRangeAxes();", "public void configureRangeAxes();", "public AxisLocation getRangeAxisLocation(int index);", "public void setRangeAxisLocation(int index,AxisLocation location);", "public void setRangeAxisLocation(int index,AxisLocation location,boolean notify);", "public RectangleEdge getRangeAxisEdge(int index);", "public XYDataset getDataset();", "public XYDataset getDataset(int index);", "public void setDataset(XYDataset dataset);", "public void setDataset(int index,XYDataset dataset);", "public int getDatasetCount();", "public int indexOf(XYDataset dataset);", "public void mapDatasetToDomainAxis(int index,int axisIndex);", "public void mapDatasetToRangeAxis(int index,int axisIndex);", "public XYItemRenderer getRenderer();", "public XYItemRenderer getRenderer(int index);", "public void setRenderer(XYItemRenderer renderer);", "public void setRenderer(int index,XYItemRenderer renderer);", "public void setRenderer(int index,XYItemRenderer renderer,boolean notify);", "public void setRenderers(XYItemRenderer[] renderers);", "public DatasetRenderingOrder getDatasetRenderingOrder();", "public void setDatasetRenderingOrder(DatasetRenderingOrder order);", "public SeriesRenderingOrder getSeriesRenderingOrder();", "public void setSeriesRenderingOrder(SeriesRenderingOrder order);", "public int getIndexOf(XYItemRenderer renderer);", "public XYItemRenderer getRendererForDataset(XYDataset dataset);", "public int getWeight();", "public void setWeight(int weight);", "public boolean isDomainGridlinesVisible();", "public void setDomainGridlinesVisible(boolean visible);", "public Stroke getDomainGridlineStroke();", "public void setDomainGridlineStroke(Stroke stroke);", "public Paint getDomainGridlinePaint();", "public void setDomainGridlinePaint(Paint paint);", "public boolean isRangeGridlinesVisible();", "public void setRangeGridlinesVisible(boolean visible);", "public Stroke getRangeGridlineStroke();", "public void setRangeGridlineStroke(Stroke stroke);", "public Paint getRangeGridlinePaint();", "public void setRangeGridlinePaint(Paint paint);", "public boolean isDomainZeroBaselineVisible();", "public void setDomainZeroBaselineVisible(boolean visible);", "public Stroke getDomainZeroBaselineStroke();", "public void setDomainZeroBaselineStroke(Stroke stroke);", "public Paint getDomainZeroBaselinePaint();", "public void setDomainZeroBaselinePaint(Paint paint);", "public boolean isRangeZeroBaselineVisible();", "public void setRangeZeroBaselineVisible(boolean visible);", "public Stroke getRangeZeroBaselineStroke();", "public void setRangeZeroBaselineStroke(Stroke stroke);", "public Paint getRangeZeroBaselinePaint();", "public void setRangeZeroBaselinePaint(Paint paint);", "public Paint getDomainTickBandPaint();", "public void setDomainTickBandPaint(Paint paint);", "public Paint getRangeTickBandPaint();", "public void setRangeTickBandPaint(Paint paint);", "public Point2D getQuadrantOrigin();", "public void setQuadrantOrigin(Point2D origin);", "public Paint getQuadrantPaint(int index);", "public void setQuadrantPaint(int index,Paint paint);", "public void addDomainMarker(Marker marker);", "public void addDomainMarker(Marker marker,Layer layer);", "public void clearDomainMarkers();", "public void clearDomainMarkers(int index);", "public void addDomainMarker(int index,Marker marker,Layer layer);", "public void addDomainMarker(int index,Marker marker,Layer layer,boolean notify);", "public boolean removeDomainMarker(Marker marker);", "public boolean removeDomainMarker(Marker marker,Layer layer);", "public boolean removeDomainMarker(int index,Marker marker,Layer layer);", "public boolean removeDomainMarker(int index,Marker marker,Layer layer,boolean notify);", "public void addRangeMarker(Marker marker);", "public void addRangeMarker(Marker marker,Layer layer);", "public void clearRangeMarkers();", "public void addRangeMarker(int index,Marker marker,Layer layer);", "public void addRangeMarker(int index,Marker marker,Layer layer,boolean notify);", "public void clearRangeMarkers(int index);", "public boolean removeRangeMarker(Marker marker);", "public boolean removeRangeMarker(Marker marker,Layer layer);", "public boolean removeRangeMarker(int index,Marker marker,Layer layer);", "public boolean removeRangeMarker(int index,Marker marker,Layer layer,boolean notify);", "public void addAnnotation(XYAnnotation annotation);", "public void addAnnotation(XYAnnotation annotation,boolean notify);", "public boolean removeAnnotation(XYAnnotation annotation);", "public boolean removeAnnotation(XYAnnotation annotation,boolean notify);", "public List getAnnotations();", "public void clearAnnotations();", "public void draw(Graphics2D g2,Rectangle2D area,Point2D anchor,PlotState parentState,PlotRenderingInfo info);", "public void drawBackground(Graphics2D g2,Rectangle2D area);", "public void drawDomainTickBands(Graphics2D g2,Rectangle2D dataArea,List ticks);", "public void drawRangeTickBands(Graphics2D g2,Rectangle2D dataArea,List ticks);", "public boolean render(Graphics2D g2,Rectangle2D dataArea,int index,PlotRenderingInfo info,CrosshairState crosshairState);", "public ValueAxis getDomainAxisForDataset(int index);", "public ValueAxis getRangeAxisForDataset(int index);", "public void drawAnnotations(Graphics2D g2,Rectangle2D dataArea,PlotRenderingInfo info);", "public Collection getDomainMarkers(Layer layer);", "public Collection getRangeMarkers(Layer layer);", "public Collection getDomainMarkers(int index,Layer layer);", "public Collection getRangeMarkers(int index,Layer layer);", "public void handleClick(int x,int y,PlotRenderingInfo info);", "public int getDomainAxisIndex(ValueAxis axis);", "public int getRangeAxisIndex(ValueAxis axis);", "public Range getDataRange(ValueAxis axis);", "public void datasetChanged(DatasetChangeEvent event);", "public void rendererChanged(RendererChangeEvent event);", "public boolean isDomainCrosshairVisible();", "public void setDomainCrosshairVisible(boolean flag);", "public boolean isDomainCrosshairLockedOnData();", "public void setDomainCrosshairLockedOnData(boolean flag);", "public double getDomainCrosshairValue();", "public void setDomainCrosshairValue(double value);", "public void setDomainCrosshairValue(double value,boolean notify);", "public Stroke getDomainCrosshairStroke();", "public void setDomainCrosshairStroke(Stroke stroke);", "public Paint getDomainCrosshairPaint();", "public void setDomainCrosshairPaint(Paint paint);", "public boolean isRangeCrosshairVisible();", "public void setRangeCrosshairVisible(boolean flag);", "public boolean isRangeCrosshairLockedOnData();", "public void setRangeCrosshairLockedOnData(boolean flag);", "public double getRangeCrosshairValue();", "public void setRangeCrosshairValue(double value);", "public void setRangeCrosshairValue(double value,boolean notify);", "public Stroke getRangeCrosshairStroke();", "public void setRangeCrosshairStroke(Stroke stroke);", "public Paint getRangeCrosshairPaint();", "public void setRangeCrosshairPaint(Paint paint);", "public AxisSpace getFixedDomainAxisSpace();", "public void setFixedDomainAxisSpace(AxisSpace space);", "public void setFixedDomainAxisSpace(AxisSpace space,boolean notify);", "public AxisSpace getFixedRangeAxisSpace();", "public void setFixedRangeAxisSpace(AxisSpace space);", "public void setFixedRangeAxisSpace(AxisSpace space,boolean notify);", "public void zoomDomainAxes(double factor,PlotRenderingInfo info,Point2D source);", "public void zoomDomainAxes(double factor,PlotRenderingInfo info,Point2D source,boolean useAnchor);", "public void zoomDomainAxes(double lowerPercent,double upperPercent,PlotRenderingInfo info,Point2D source);", "public void zoomRangeAxes(double factor,PlotRenderingInfo info,Point2D source);", "public void zoomRangeAxes(double factor,PlotRenderingInfo info,Point2D source,boolean useAnchor);", "public void zoomRangeAxes(double lowerPercent,double upperPercent,PlotRenderingInfo info,Point2D source);", "public boolean isDomainZoomable();", "public boolean isRangeZoomable();", "public int getSeriesCount();", "public LegendItemCollection getFixedLegendItems();", "public void setFixedLegendItems(LegendItemCollection items);", "public LegendItemCollection getLegendItems();", "public boolean equals(Object obj);", "public Object clone();"], "fields_dict": {"long#serialVersionUID": "private static final long serialVersionUID = 7044148245716569264L", "Stroke#DEFAULT_GRIDLINE_STROKE": "public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, \n            new float[] {2.0f, 2.0f}, 0.0f)", "Paint#DEFAULT_GRIDLINE_PAINT": "public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE", "boolean#DEFAULT_CROSSHAIR_VISIBLE": "public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false", "Stroke#DEFAULT_CROSSHAIR_STROKE": "public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE", "Paint#DEFAULT_CROSSHAIR_PAINT": "public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue", "ResourceBundle#localizationResources": "protected static ResourceBundle localizationResources = ResourceBundle.getBundle(\n                    \"org.jfree.chart.plot.LocalizationBundle\")", "PlotOrientation#orientation": "private PlotOrientation orientation", "RectangleInsets#axisOffset": "private RectangleInsets axisOffset", "ObjectList#domainAxes": "private ObjectList domainAxes", "ObjectList#domainAxisLocations": "private ObjectList domainAxisLocations", "ObjectList#rangeAxes": "private ObjectList rangeAxes", "ObjectList#rangeAxisLocations": "private ObjectList rangeAxisLocations", "ObjectList#datasets": "private ObjectList datasets", "ObjectList#renderers": "private ObjectList renderers", "Map#datasetToDomainAxisMap": "private Map datasetToDomainAxisMap", "Map#datasetToRangeAxisMap": "private Map datasetToRangeAxisMap", "Point2D#quadrantOrigin": "private transient Point2D quadrantOrigin = new Point2D.Double(0.0, 0.0)", "Paint[]#quadrantPaint": "private transient Paint[] quadrantPaint = new Paint[] {null, null, null, null}", "boolean#domainGridlinesVisible": "private boolean domainGridlinesVisible", "Stroke#domainGridlineStroke": "private transient Stroke domainGridlineStroke", "Paint#domainGridlinePaint": "private transient Paint domainGridlinePaint", "boolean#rangeGridlinesVisible": "private boolean rangeGridlinesVisible", "Stroke#rangeGridlineStroke": "private transient Stroke rangeGridlineStroke", "Paint#rangeGridlinePaint": "private transient Paint rangeGridlinePaint", "boolean#domainZeroBaselineVisible": "private boolean domainZeroBaselineVisible", "Stroke#domainZeroBaselineStroke": "private transient Stroke domainZeroBaselineStroke", "Paint#domainZeroBaselinePaint": "private transient Paint domainZeroBaselinePaint", "boolean#rangeZeroBaselineVisible": "private boolean rangeZeroBaselineVisible", "Stroke#rangeZeroBaselineStroke": "private transient Stroke rangeZeroBaselineStroke", "Paint#rangeZeroBaselinePaint": "private transient Paint rangeZeroBaselinePaint", "boolean#domainCrosshairVisible": "private boolean domainCrosshairVisible", "double#domainCrosshairValue": "private double domainCrosshairValue", "Stroke#domainCrosshairStroke": "private transient Stroke domainCrosshairStroke", "Paint#domainCrosshairPaint": "private transient Paint domainCrosshairPaint", "boolean#domainCrosshairLockedOnData": "private boolean domainCrosshairLockedOnData = true", "boolean#rangeCrosshairVisible": "private boolean rangeCrosshairVisible", "double#rangeCrosshairValue": "private double rangeCrosshairValue", "Stroke#rangeCrosshairStroke": "private transient Stroke rangeCrosshairStroke", "Paint#rangeCrosshairPaint": "private transient Paint rangeCrosshairPaint", "boolean#rangeCrosshairLockedOnData": "private boolean rangeCrosshairLockedOnData = true", "Map#foregroundDomainMarkers": "private Map foregroundDomainMarkers", "Map#backgroundDomainMarkers": "private Map backgroundDomainMarkers", "Map#foregroundRangeMarkers": "private Map foregroundRangeMarkers", "Map#backgroundRangeMarkers": "private Map backgroundRangeMarkers", "List#annotations": "private List annotations", "Paint#domainTickBandPaint": "private transient Paint domainTickBandPaint", "Paint#rangeTickBandPaint": "private transient Paint rangeTickBandPaint", "AxisSpace#fixedDomainAxisSpace": "private AxisSpace fixedDomainAxisSpace", "AxisSpace#fixedRangeAxisSpace": "private AxisSpace fixedRangeAxisSpace", "DatasetRenderingOrder#datasetRenderingOrder": "private DatasetRenderingOrder datasetRenderingOrder = DatasetRenderingOrder.REVERSE", "SeriesRenderingOrder#seriesRenderingOrder": "private SeriesRenderingOrder seriesRenderingOrder = SeriesRenderingOrder.REVERSE", "int#weight": "private int weight", "LegendItemCollection#fixedLegendItems": "private LegendItemCollection fixedLegendItems"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; either version 2.1 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc.\n * in the United States and other countries.]\n *\n * -----------\n * XYPlot.java\n * -----------\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Craig MacFarlane;\n *                   Mark Watson (www.markwatson.com);\n *                   Jonathan Nash;\n *                   Gideon Krause;\n *                   Klaus Rheinwald;\n *                   Xavier Poinsard;\n *                   Richard Atkinson;\n *                   Arnaud Lelievre;\n *                   Nicolas Brodu;\n *                   Eduardo Ramalho;\n *                   Sergei Ivanov;\n *                   Richard West, Advanced Micro Devices, Inc.;\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 18-Sep-2001 : Updated header and fixed DOS encoding problem (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 19-Oct-2001 : Removed the code for drawing the visual representation of each\n *               data point into a separate class StandardXYItemRenderer.\n *               This will make it easier to add variations to the way the\n *               charts are drawn.  Based on code contributed by Mark\n *               Watson (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 20-Nov-2001 : Fixed clipping bug that shows up when chart is displayed\n *               inside JScrollPane (DG);\n * 12-Dec-2001 : Removed unnecessary 'throws' clauses from constructor (DG);\n * 13-Dec-2001 : Added skeleton code for tooltips.  Added new constructor. (DG);\n * 16-Jan-2002 : Renamed the tooltips class (DG);\n * 22-Jan-2002 : Added DrawInfo class, incorporating tooltips and crosshairs.\n *               Crosshairs based on code by Jonathan Nash (DG);\n * 05-Feb-2002 : Added alpha-transparency setting based on code by Sylvain\n *               Vieujot (DG);\n * 26-Feb-2002 : Updated getMinimumXXX() and getMaximumXXX() methods to handle\n *               special case when chart is null (DG);\n * 28-Feb-2002 : Renamed Datasets.java --> DatasetUtilities.java (DG);\n * 28-Mar-2002 : The plot now registers with the renderer as a property change\n *               listener.  Also added a new constructor (DG);\n * 09-Apr-2002 : Removed the transRangeZero from the renderer.drawItem()\n *               method.  Moved the tooltip generator into the renderer (DG);\n * 23-Apr-2002 : Fixed bug in methods for drawing horizontal and vertical\n *               lines (DG);\n * 13-May-2002 : Small change to the draw() method so that it works for\n *               OverlaidXYPlot also (DG);\n * 25-Jun-2002 : Removed redundant import (DG);\n * 20-Aug-2002 : Renamed getItemRenderer() --> getRenderer(), and\n *               setXYItemRenderer() --> setRenderer() (DG);\n * 28-Aug-2002 : Added mechanism for (optional) plot annotations (DG);\n * 02-Oct-2002 : Fixed errors reported by Checkstyle (DG);\n * 18-Nov-2002 : Added grid settings for both domain and range axis (previously\n *               these were set in the axes) (DG);\n * 09-Jan-2003 : Further additions to the grid settings, plus integrated plot\n *               border bug fix contributed by Gideon Krause (DG);\n * 22-Jan-2003 : Removed monolithic constructor (DG);\n * 04-Mar-2003 : Added 'no data' message, see bug report 691634.  Added\n *               secondary range markers using code contributed by Klaus\n *               Rheinwald (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 03-Apr-2003 : Added setDomainAxisLocation() method (DG);\n * 30-Apr-2003 : Moved annotation drawing into a separate method (DG);\n * 01-May-2003 : Added multi-pass mechanism for renderers (DG);\n * 02-May-2003 : Changed axis locations from int to AxisLocation (DG);\n * 15-May-2003 : Added an orientation attribute (DG);\n * 02-Jun-2003 : Removed range axis compatibility test (DG);\n * 05-Jun-2003 : Added domain and range grid bands (sponsored by Focus Computer\n *               Services Ltd) (DG);\n * 26-Jun-2003 : Fixed bug (757303) in getDataRange() method (DG);\n * 02-Jul-2003 : Added patch from bug report 698646 (secondary axes for\n *               overlaid plots) (DG);\n * 23-Jul-2003 : Added support for multiple secondary datasets, axes and\n *               renderers (DG);\n * 27-Jul-2003 : Added support for stacked XY area charts (RA);\n * 19-Aug-2003 : Implemented Cloneable (DG);\n * 01-Sep-2003 : Fixed bug where change to secondary datasets didn't generate\n *               change event (797466) (DG)\n * 08-Sep-2003 : Added internationalization via use of properties\n *               resourceBundle (RFE 690236) (AL);\n * 08-Sep-2003 : Changed ValueAxis API (DG);\n * 08-Sep-2003 : Fixes for serialization (NB);\n * 16-Sep-2003 : Changed ChartRenderingInfo --> PlotRenderingInfo (DG);\n * 17-Sep-2003 : Fixed zooming to include secondary domain axes (DG);\n * 18-Sep-2003 : Added getSecondaryDomainAxisCount() and\n *               getSecondaryRangeAxisCount() methods suggested by Eduardo\n *               Ramalho (RFE 808548) (DG);\n * 23-Sep-2003 : Split domain and range markers into foreground and\n *               background (DG);\n * 06-Oct-2003 : Fixed bug in clearDomainMarkers() and clearRangeMarkers()\n *               methods.  Fixed bug (815876) in addSecondaryRangeMarker()\n *               method.  Added new addSecondaryDomainMarker methods (see bug\n *               id 815869) (DG);\n * 10-Nov-2003 : Added getSecondaryDomain/RangeAxisMappedToDataset() methods\n *               requested by Eduardo Ramalho (DG);\n * 24-Nov-2003 : Removed unnecessary notification when updating axis anchor\n *               values (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 25-Feb-2004 : Replaced CrosshairInfo with CrosshairState (DG);\n * 12-Mar-2004 : Fixed bug where primary renderer is always used to determine\n *               range type (DG);\n * 22-Mar-2004 : Fixed cloning bug (DG);\n * 23-Mar-2004 : Fixed more cloning bugs (DG);\n * 07-Apr-2004 : Fixed problem with axis range when the secondary renderer is\n *               stacked, see this post in the forum:\n *               http://www.jfree.org/phpBB2/viewtopic.php?t=8204 (DG);\n * 07-Apr-2004 : Added get/setDatasetRenderingOrder() methods (DG);\n * 26-Apr-2004 : Added option to fill quadrant areas in the background of the\n *               plot (DG);\n * 27-Apr-2004 : Removed major distinction between primary and secondary\n *               datasets, renderers and axes (DG);\n * 30-Apr-2004 : Modified to make use of the new getRangeExtent() method in the\n *               renderer interface (DG);\n * 13-May-2004 : Added optional fixedLegendItems attribute (DG);\n * 19-May-2004 : Added indexOf() method (DG);\n * 03-Jun-2004 : Fixed zooming bug (DG);\n * 18-Aug-2004 : Added removedAnnotation() method (by tkram01) (DG);\n * 05-Oct-2004 : Modified storage type for dataset-to-axis maps (DG);\n * 06-Oct-2004 : Modified getDataRange() method to use renderer to determine\n *               the x-value range (now matches behaviour for y-values).  Added\n *               getDomainAxisIndex() method (DG);\n * 12-Nov-2004 : Implemented new Zoomable interface (DG);\n * 25-Nov-2004 : Small update to clone() implementation (DG);\n * 22-Feb-2005 : Changed axis offsets from Spacer --> RectangleInsets (DG);\n * 24-Feb-2005 : Added indexOf(XYItemRenderer) method (DG);\n * 21-Mar-2005 : Register plot as change listener in setRenderer() method (DG);\n * 21-Apr-2005 : Added get/setSeriesRenderingOrder() methods (ET);\n * 26-Apr-2005 : Removed LOGGER (DG);\n * 04-May-2005 : Fixed serialization of domain and range markers (DG);\n * 05-May-2005 : Removed unused draw() method (DG);\n * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per\n *               RFE 1183100 (DG);\n * 01-Jun-2005 : Upon deserialization, register plot as a listener with its\n *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG);\n * 01-Jun-2005 : Added clearDomainMarkers(int) method to match \n *               clearRangeMarkers(int) (DG);\n * 06-Jun-2005 : Fixed equals() method to handle GradientPaint (DG);\n * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG);\n * 06-Jul-2005 : Fixed crosshair bug (id = 1233336) (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 26-Jan-2006 : Added getAnnotations() method (DG);\n * 05-Sep-2006 : Added MarkerChangeEvent support (DG);\n * 13-Oct-2006 : Fixed initialisation of CrosshairState - see bug report \n *               1565168 (DG);\n * 22-Nov-2006 : Fixed equals() and cloning() for quadrant attributes, plus \n *               API doc updates (DG);\n * 29-Nov-2006 : Added argument checks (DG);\n * 15-Jan-2007 : Fixed bug in drawRangeMarkers() (DG);\n * 07-Feb-2007 : Fixed bug 1654215, renderer with no dataset (DG);\n * 26-Feb-2007 : Added missing setDomainAxisLocation() and \n *               setRangeAxisLocation() methods (DG);\n * 02-Mar-2007 : Fix for crosshair positioning with horizontal orientation\n *               (see patch 1671648 by Sergei Ivanov) (DG);\n * 13-Mar-2007 : Added null argument checks for crosshair attributes (DG);\n * 23-Mar-2007 : Added domain zero base line facility (DG);\n * 04-May-2007 : Render only visible data items if possible (DG);\n * 24-May-2007 : Fixed bug in render method for an empty series (DG);\n * 07-Jun-2007 : Modified drawBackground() to pass orientation to \n *               fillBackground() for handling GradientPaint (DG);\n * 20-Jun-2007 : Removed JCommon dependencies (DG);\n * 27-Jun-2007 : Updated drawDomainGridlines() method for renamed method in\n *               XYItemRenderer interface.\n * 24-Sep-2007 : Added new zoom methods (DG);\n * 26-Sep-2007 : Include index value in IllegalArgumentExceptions (DG);\n * 05-Nov-2007 : Applied patch 1823697, by Richard West, for removal of domain\n *               and range markers (DG);\n * 12-Nov-2007 : Fixed bug in equals() method for domain and range tick\n *               band paint attributes (DG);\n * 27-Nov-2007 : Added new setFixedDomain/RangeAxisSpace() methods (DG);\n * 04-Jan-2008 : Fix for quadrant painting error - see patch 1849564 (DG);\n * 25-Mar-2008 : Added new methods with optional notification - see patch\n *               1913751 (DG);\n * 07-Apr-2008 : Fixed NPE in removeDomainMarker() and \n *               removeRangeMarker() (DG);\n * \n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.XYAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.RendererUtilities;\nimport org.jfree.chart.renderer.xy.XYItemRenderer;\nimport org.jfree.chart.renderer.xy.XYItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.data.Range;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\nimport org.jfree.data.xy.XYDataset;\n\n/**\n * A general class for plotting data in the form of (x, y) pairs.  This plot can\n * use data from any class that implements the {@link XYDataset} interface.\n * <P>\n * <code>XYPlot</code> makes use of an {@link XYItemRenderer} to draw each point\n * on the plot.  By using different renderers, various chart types can be\n * produced.\n * <p>\n * The {@link org.jfree.chart.ChartFactory} class contains static methods for\n * creating pre-configured charts.\n */\npublic class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n        RendererChangeListener, Cloneable, PublicCloneable, Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = 7044148245716569264L;\n    \n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, \n            new float[] {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\n\n    /** The default crosshair visibility. */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\n\n    /** The default crosshair stroke. */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            = DEFAULT_GRIDLINE_STROKE;\n\n    /** The default crosshair paint. */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources \n            = ResourceBundle.getBundle(\n                    \"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** The domain axis / axes (used for the x-values). */\n    private ObjectList domainAxes;\n\n    /** The domain axis locations. */\n    private ObjectList domainAxisLocations;\n\n    /** The range axis (used for the y-values). */\n    private ObjectList rangeAxes;\n\n    /** The range axis location. */\n    private ObjectList rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private ObjectList datasets;\n\n    /** Storage for the renderers. */\n    private ObjectList renderers;\n\n    /**\n     * Storage for keys that map datasets/renderers to domain axes.  If the\n     * map contains no entry for a dataset, it is assumed to map to the\n     * primary domain axis (index = 0).\n     */\n    private Map datasetToDomainAxisMap;\n\n    /**\n     * Storage for keys that map datasets/renderers to range axes. If the\n     * map contains no entry for a dataset, it is assumed to map to the\n     * primary domain axis (index = 0).\n     */\n    private Map datasetToRangeAxisMap;\n\n    /** The origin point for the quadrants (if drawn). */\n    private transient Point2D quadrantOrigin = new Point2D.Double(0.0, 0.0);\n\n    /** The paint used for each quadrant. */\n    private transient Paint[] quadrantPaint\n            = new Paint[] {null, null, null, null};\n\n    /** A flag that controls whether the domain grid-lines are visible. */\n    private boolean domainGridlinesVisible;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** A flag that controls whether the range grid-lines are visible. */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /** \n     * A flag that controls whether or not the zero baseline against the domain\n     * axis is visible.\n     * \n     * @since 1.0.5\n     */\n    private boolean domainZeroBaselineVisible;\n\n    /** \n     * The stroke used for the zero baseline against the domain axis. \n     * \n     * @since 1.0.5\n     */\n    private transient Stroke domainZeroBaselineStroke;\n\n    /** \n     * The paint used for the zero baseline against the domain axis. \n     * \n     * @since 1.0.5\n     */\n    private transient Paint domainZeroBaselinePaint;\n\n    /** \n     * A flag that controls whether or not the zero baseline against the range\n     * axis is visible.\n     */\n    private boolean rangeZeroBaselineVisible;\n\n    /** The stroke used for the zero baseline against the range axis. */\n    private transient Stroke rangeZeroBaselineStroke;\n\n    /** The paint used for the zero baseline against the range axis. */\n    private transient Paint rangeZeroBaselinePaint;\n\n    /** A flag that controls whether or not a domain crosshair is drawn..*/\n    private boolean domainCrosshairVisible;\n\n    /** The domain crosshair value. */\n    private double domainCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke domainCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint domainCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean domainCrosshairLockedOnData = true;\n\n    /** A flag that controls whether or not a range crosshair is drawn..*/\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /**\n     * A flag that controls whether or not the crosshair locks onto actual\n     * data points.\n     */\n    private boolean rangeCrosshairLockedOnData = true;\n\n    /** A map of lists of foreground markers (optional) for the domain axes. */\n    private Map foregroundDomainMarkers;\n\n    /** A map of lists of background markers (optional) for the domain axes. */\n    private Map backgroundDomainMarkers;\n\n    /** A map of lists of foreground markers (optional) for the range axes. */\n    private Map foregroundRangeMarkers;\n\n    /** A map of lists of background markers (optional) for the range axes. */\n    private Map backgroundRangeMarkers;\n\n    /** \n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be \n     * <code>null</code>.\n     */\n    private List annotations;\n\n    /** The paint used for the domain tick bands (if any). */\n    private transient Paint domainTickBandPaint;\n\n    /** The paint used for the range tick bands (if any). */\n    private transient Paint rangeTickBandPaint;\n\n    /** The fixed domain axis space. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed range axis space. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /**\n     * The order of the dataset rendering (REVERSE draws the primary dataset\n     * last so that it appears to be on top).\n     */\n    private DatasetRenderingOrder datasetRenderingOrder\n            = DatasetRenderingOrder.REVERSE;\n\n    /**\n     * The order of the series rendering (REVERSE draws the primary series\n     * last so that it appears to be on top).\n     */\n    private SeriesRenderingOrder seriesRenderingOrder\n            = SeriesRenderingOrder.REVERSE;\n\n    /**\n     * The weight for this plot (only relevant if this is a subplot in a\n     * combined plot).\n     */\n    private int weight;\n\n    /**\n     * An optional collection of legend items that can be returned by the\n     * getLegendItems() method.\n     */\n    private LegendItemCollection fixedLegendItems;\n\n    /**\n     * Creates a new <code>XYPlot</code> instance with no dataset, no axes and\n     * no renderer.  You should specify these items before using the plot.\n     */\n    public XYPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot with the specified dataset, axes and renderer.  Any\n     * of the arguments can be <code>null</code>, but in that case you should\n     * take care to specify the value before using the plot (otherwise a\n     * <code>NullPointerException</code> may be thrown).\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\n     * @param renderer  the renderer (<code>null</code> permitted).\n     */\n    public XYPlot(XYDataset dataset,\n                  ValueAxis domainAxis,\n                  ValueAxis rangeAxis,\n                  XYItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n        this.weight = 1;  // only relevant when this is a subplot\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        // allocate storage for datasets, axes and renderers (all optional)\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        this.datasets = new ObjectList();\n        this.renderers = new ObjectList();\n\n        this.datasetToDomainAxisMap = new TreeMap();\n        this.datasetToRangeAxisMap = new TreeMap();\n\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.domainAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        this.rangeAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\n\n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = true;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.domainZeroBaselineVisible = false;\n        this.domainZeroBaselinePaint = Color.black;\n        this.domainZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.rangeGridlinesVisible = true;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeZeroBaselineVisible = false;\n        this.rangeZeroBaselinePaint = Color.black;\n        this.rangeZeroBaselineStroke = new BasicStroke(0.5f);\n\n        this.domainCrosshairVisible = false;\n        this.domainCrosshairValue = 0.0;\n        this.domainCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.domainCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.rangeCrosshairVisible = false;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n\n        this.annotations = new java.util.ArrayList();\n\n    }\n\n    /**\n     * Returns the plot type as a string.\n     *\n     * @return A short string describing the type of plot.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"XY_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation (never <code>null</code>).\n     * \n     * @see #setOrientation(PlotOrientation)\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation (<code>null</code> not allowed).\n     * \n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        if (orientation != this.orientation) {\n            this.orientation = orientation;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never <code>null</code>).\n     * \n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and sends\n     * a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");\n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain axis with index 0.  If the domain axis for this plot\n     * is <code>null</code>, then the method will return the parent plot's \n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (possibly <code>null</code>).\n     * \n     * @see #getDomainAxis(int)\n     * @see #setDomainAxis(ValueAxis)\n     */\n    public ValueAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns the domain axis with the specified index, or <code>null</code>.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public ValueAxis getDomainAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (ValueAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param axis  the new axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis()\n     * @see #setDomainAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(ValueAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis(int)\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setDomainAxis(int index, ValueAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n    \n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     * \n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getDomainAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the location of the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return (AxisLocation) this.domainAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary domain axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getDomainAxisLocation()\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary domain axis (taking into account the\n     * plot's orientation).\n     *\n     * @return The edge.\n     * \n     * @see #getDomainAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return Plot.resolveDomainAxisLocation(getDomainAxisLocation(), \n                this.orientation);\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     * \n     * @see #getRangeAxisCount()\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @see #clearRangeAxes()\n     */\n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the domain axes. \n     */\n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a domain axis.  If this hasn't been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary domain axis location.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for index\n     *     0).\n     * \n     * @see #getDomainAxisLocation(int)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for \n     *     index 0).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        \n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }        \n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     * \n     * @see #getRangeAxisEdge(int)\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * <code>null</code>, then the method will return the parent plot's range \n     * axis (if there is a parent plot).\n     *\n     * @return The range axis.\n     * \n     * @see #getRangeAxis(int)\n     * @see #setRangeAxis(ValueAxis)\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     *\n     * @see #getRangeAxis()\n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public void setRangeAxis(ValueAxis axis)  {\n\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n\n        // plot is likely registered as a listener with the existing axis...\n        ValueAxis existing = getRangeAxis();\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n\n        this.rangeAxes.set(0, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        fireChangeEvent();\n\n    }\n\n    /**\n     * Returns the location of the primary range axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setRangeAxisLocation(AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return (AxisLocation) this.rangeAxisLocations.get(0);\n    }\n\n    /**\n     * Sets the location of the primary range axis and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the primary range axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Returns the edge for the primary range axis.\n     *\n     * @return The range axis edge.\n     * \n     * @see #getRangeAxisLocation()\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return Plot.resolveRangeAxisLocation(getRangeAxisLocation(), \n                this.orientation);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setRangeAxis(int, ValueAxis)\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot xy = (XYPlot) parent;\n                result = xy.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    } \n    \n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxis(int)\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = getRangeAxis(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setDomainAxes(ValueAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     * \n     * @see #getDomainAxisCount()\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @see #clearDomainAxes()\n     */\n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the range axes.\n     * \n     * @see #configureDomainAxes()\n     */\n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the location for a range axis.  If this hasn't been set\n     * explicitly, the method returns the location that is opposite to the\n     * primary range axis location.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation());\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> permitted).\n     * \n     * @see #getRangeAxisLocation(int)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setRangeAxisLocation(index, location, true);\n    }\n    \n    /**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for \n     *     index 0).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        \n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }   \n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #getOrientation()\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge());\n        }\n        return result;\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly <code>null</code>).\n     * \n     * @see #getDataset(int)\n     * @see #setDataset(XYDataset)\n     */\n    public XYDataset getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(int, XYDataset)\n     */\n    public XYDataset getDataset(int index) {\n        XYDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (XYDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the primary dataset for the plot, replacing the existing dataset if\n     * there is one.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     * @see #setDataset(int, XYDataset)\n     */\n    public void setDataset(XYDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot.\n     *\n     * @param index  the dataset index.\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, XYDataset dataset) {\n        XYDataset existing = getDataset(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Returns the index of the specified dataset, or <code>-1</code> if the\n     * dataset does not belong to the plot.\n     *\n     * @param dataset  the dataset (<code>null</code> not permitted).\n     *\n     * @return The index.\n     */\n    public int indexOf(XYDataset dataset) {\n        int result = -1;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (dataset == this.datasets.get(i)) {\n                result = i;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     * \n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.put(new Integer(index), \n                new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * Maps a dataset to a particular range axis.  All data will be plotted\n     * against axis zero by default, no mapping is required for this case.\n     *\n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index.\n     * \n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.put(new Integer(index), \n                new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));\n    }\n\n    /**\n     * Returns the renderer for the primary dataset.\n     *\n     * @return The item renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer for a dataset, or <code>null</code>.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(int, XYItemRenderer)\n     */\n    public XYItemRenderer getRenderer(int index) {\n        XYItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (XYItemRenderer) this.renderers.get(index);\n        }\n        return result;\n\n    }\n\n    /**\n     * Sets the renderer for the primary dataset and sends a\n     * {@link PlotChangeEvent} to all registered listeners.  If the renderer\n     * is set to <code>null</code>, no data will be displayed.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(XYItemRenderer renderer) {\n        setRenderer(0, renderer);\n    }\n\n    /**\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer.\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer) {\n        setRenderer(index, renderer, true);\n    }\n\n    /**\n     * Sets a renderer and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer.\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, XYItemRenderer renderer, \n                            boolean notify) {\n        XYItemRenderer existing = getRenderer(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        configureDomainAxes();\n        configureRangeAxes();\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param renderers  the renderers (<code>null</code> not permitted).\n     */\n    public void setRenderers(XYItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never <code>null</code>).\n     * \n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.datasetRenderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary dataset\n     * last (so that the primary dataset overlays the secondary datasets).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.datasetRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the series rendering order.\n     *\n     * @return the order (never <code>null</code>).\n     * \n     * @see #setSeriesRenderingOrder(SeriesRenderingOrder)\n     */\n    public SeriesRenderingOrder getSeriesRenderingOrder() {\n        return this.seriesRenderingOrder;\n    }\n\n    /**\n     * Sets the series order and sends a {@link PlotChangeEvent} to all\n     * registered listeners.  By default, the plot renders the primary series\n     * last (so that the primary series appears to be on top).\n     * You can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getSeriesRenderingOrder()\n     */\n    public void setSeriesRenderingOrder(SeriesRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.seriesRenderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified renderer, or <code>-1</code> if the\n     * renderer is not assigned to this plot.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     *\n     * @return The renderer index.\n     */\n    public int getIndexOf(XYItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    /**\n     * Returns the renderer for the specified dataset.  The code first\n     * determines the index of the dataset, then checks if there is a\n     * renderer with the same index (if not, the method returns renderer(0).\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     *\n     * @return The renderer (possibly <code>null</code>).\n     */\n    public XYItemRenderer getRendererForDataset(XYDataset dataset) {\n        XYItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (XYItemRenderer) this.renderers.get(i);\n                if (result == null) {\n                    result = getRenderer();\n                }\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a\n     * combined plot.\n     *\n     * @return The weight.\n     * \n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param weight  the weight.\n     * \n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the domain gridlines are visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return <code>true</code> or <code>false</code>.\n     * \n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the domain grid-lines are\n     * visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid-lines (if any) plotted against the\n     * domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     * <p>\n     * If you set this to <code>null</code>, no grid lines will be drawn.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @throws IllegalArgumentException if <code>stroke</code> is \n     *     <code>null</code>.\n     *\n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the domain\n     * axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the domain axis, and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @throws IllegalArgumentException if <code>paint</code> is \n     *     <code>null</code>.\n     * \n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>true</code> if the range axis grid is visible, and\n     * <code>false<code> otherwise.\n     *\n     * @return A boolean.\n     * \n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the range axis grid lines\n     * are visible.\n     * <p>\n     * If the flag value is changed, a {@link PlotChangeEvent} is sent to all\n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke for the grid lines (if any) plotted against the\n     * range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke for the grid lines plotted against the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the grid lines (if any) plotted against the range\n     * axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint for the grid lines plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the domain axis.\n     *\n     * @return A boolean.\n     * \n     * @since 1.0.5\n     * \n     * @see #setDomainZeroBaselineVisible(boolean)\n     */\n    public boolean isDomainZeroBaselineVisible() {\n        return this.domainZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the domain axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     * \n     * @since 1.0.5\n     * \n     * @see #isDomainZeroBaselineVisible()\n     */\n    public void setDomainZeroBaselineVisible(boolean visible) {\n        this.domainZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @since 1.0.5\n     * \n     * @see #setDomainZeroBaselineStroke(Stroke)\n     */\n    public Stroke getDomainZeroBaselineStroke() {\n        return this.domainZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the domain axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @since 1.0.5\n     * \n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setDomainZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * domain axis.\n     * \n     * @since 1.0.5\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainZeroBaselinePaint(Paint)\n     */\n    public Paint getDomainZeroBaselinePaint() {\n        return this.domainZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainZeroBaselinePaint()\n     */\n    public void setDomainZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns a flag that controls whether or not a zero baseline is\n     * displayed for the range axis.\n     *\n     * @return A boolean.\n     * \n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    public boolean isRangeZeroBaselineVisible() {\n        return this.rangeZeroBaselineVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not the zero baseline is\n     * displayed for the range axis, and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param visible  the flag.\n     * \n     * @see #isRangeZeroBaselineVisible()\n     */\n    public void setRangeZeroBaselineVisible(boolean visible) {\n        this.rangeZeroBaselineVisible = visible;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used for the zero baseline against the range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeZeroBaselineStroke(Stroke)\n     */\n    public Stroke getRangeZeroBaselineStroke() {\n        return this.rangeZeroBaselineStroke;\n    }\n\n    /**\n     * Sets the stroke for the zero baseline for the range axis,\n     * and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeZeroBaselineStroke()\n     */\n    public void setRangeZeroBaselineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeZeroBaselineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint for the zero baseline (if any) plotted against the\n     * range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeZeroBaselinePaint(Paint)\n     */\n    public Paint getRangeZeroBaselinePaint() {\n        return this.rangeZeroBaselinePaint;\n    }\n\n    /**\n     * Sets the paint for the zero baseline plotted against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeZeroBaselinePaint()\n     */\n    public void setRangeZeroBaselinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeZeroBaselinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the domain tick bands.  If this is\n     * <code>null</code>, no tick bands will be drawn.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public Paint getDomainTickBandPaint() {\n        return this.domainTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the domain tick bands.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getDomainTickBandPaint()\n     */\n    public void setDomainTickBandPaint(Paint paint) {\n        this.domainTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the range tick bands.  If this is\n     * <code>null</code>, no tick bands will be drawn.\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public Paint getRangeTickBandPaint() {\n        return this.rangeTickBandPaint;\n    }\n\n    /**\n     * Sets the paint for the range tick bands.\n     *\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getRangeTickBandPaint()\n     */\n    public void setRangeTickBandPaint(Paint paint) {\n        this.rangeTickBandPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the origin for the quadrants that can be displayed on the plot.\n     * This defaults to (0, 0).\n     *\n     * @return The origin point (never <code>null</code>).\n     * \n     * @see #setQuadrantOrigin(Point2D)\n     */\n    public Point2D getQuadrantOrigin() {\n        return this.quadrantOrigin;\n    }\n\n    /**\n     * Sets the quadrant origin and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param origin  the origin (<code>null</code> not permitted).\n     * \n     * @see #getQuadrantOrigin()\n     */\n    public void setQuadrantOrigin(Point2D origin) {\n        if (origin == null) {\n            throw new IllegalArgumentException(\"Null 'origin' argument.\");\n        }\n        this.quadrantOrigin = origin;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used for the specified quadrant.\n     *\n     * @param index  the quadrant index (0-3).\n     *\n     * @return The paint (possibly <code>null</code>).\n     * \n     * @see #setQuadrantPaint(int, Paint)\n     */\n    public Paint getQuadrantPaint(int index) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index \n                    + \") should be in the range 0 to 3.\");\n        }\n        return this.quadrantPaint[index];\n    }\n\n    /**\n     * Sets the paint used for the specified quadrant and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the quadrant index (0-3).\n     * @param paint  the paint (<code>null</code> permitted).\n     * \n     * @see #getQuadrantPaint(int)\n     */\n    public void setQuadrantPaint(int index, Paint paint) {\n        if (index < 0 || index > 3) {\n            throw new IllegalArgumentException(\"The index value (\" + index \n                    + \") should be in the range 0 to 3.\");\n        }\n        this.quadrantPaint[index] = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #addDomainMarker(Marker, Layer)\n     * @see #clearDomainMarkers()\n     */\n    public void addDomainMarker(Marker marker) {\n        // defer argument checking...\n        addDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(Marker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the (foreground and background) domain markers and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Clears the (foreground and background) domain markers for a particular\n     * renderer.\n     *\n     * @param index  the renderer index.\n     * \n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #clearDomainMarkers(int)\n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer) {\n    \taddDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the domain axis (that the renderer is mapped to), however this is\n     * entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addDomainMarker(int index, Marker marker, Layer layer, \n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker  the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n    \treturn removeDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and, if requested, \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n    \n    /**\n     * Adds a marker for the range axis and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #addRangeMarker(Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Adds a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Clears all the range markers and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @see #clearRangeMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Adds a marker for a specific dataset/renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #clearRangeMarkers(int)\n     * @see #addDomainMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n    \taddRangeMarker(index, marker, layer, true);\n    }\n    \n    /**\n     * Adds a marker for a specific dataset/renderer and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to the range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer, \n    \t\tboolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears the (foreground and background) range markers for a particular\n     * renderer.\n     *\n     * @param index  the renderer index.\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers\n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    \treturn removeRangeMarker(index, marker, layer, true);\n    }\n    \n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * \n     * @see #getAnnotations()\n     * @see #removeAnnotation(XYAnnotation)\n     */\n    public void addAnnotation(XYAnnotation annotation) {\n        addAnnotation(annotation, true);\t\n    }\n    \n    /**\n     * Adds an annotation to the plot and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @see #addAnnotation(XYAnnotation)\n     * @see #getAnnotations()\n     */\n    public boolean removeAnnotation(XYAnnotation annotation) {\n    \treturn removeAnnotation(annotation, true);\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @since 1.0.10\n     */\n    public boolean removeAnnotation(XYAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations.\n     * \n     * @since 1.0.1\n     * \n     * @see #addAnnotation(XYAnnotation)\n     */\n    public List getAnnotations() {\n        return new ArrayList(this.annotations);\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     * \n     * @see #addAnnotation(XYAnnotation)\n     */\n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n    \n    /**\n     * Calculates the space required for all the axes in the plot.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2,\n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        return space;\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2,\n                                                 Rectangle2D plotArea,\n                                                 AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis axis = (Axis) this.domainAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n\n    }\n\n    /**\n     * Calculates the space required for the range axis/axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     *\n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2,\n                                                Rectangle2D plotArea,\n                                                AxisSpace space) {\n\n        if (space == null) {\n            space = new AxisSpace();\n        }\n\n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis axis = (Axis) this.rangeAxes.get(i);\n                if (axis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = axis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n\n    }\n\n    /**\n     * Draws the plot within the specified area on a graphics device.\n     *\n     * @param g2  the graphics device.\n     * @param area  the plot area (in Java2D space).\n     * @param anchor  an anchor point in Java2D space (<code>null</code>\n     *                permitted).\n     * @param parentState  the state from the parent plot, if there is one\n     *                     (<code>null</code> permitted).\n     * @param info  collects chart drawing information (<code>null</code>\n     *              permitted).\n     */\n    public void draw(Graphics2D g2,\n                     Rectangle2D area,\n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo info) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (info != null) {\n            info.setPlotArea(area);\n        }\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        if (info != null) {\n            info.setDataArea(dataArea);\n        }\n\n        // draw the plot background and axes...\n        drawBackground(g2, dataArea);\n        Map axisStateMap = drawAxes(g2, area, dataArea, info);\n\n        PlotOrientation orient = getOrientation();\n\n        // the anchor point is typically the point where the mouse last\n        // clicked - the crosshairs will be driven off this point...\n        if (anchor != null && !dataArea.contains(anchor)) {\n            anchor = null;\n        }\n        CrosshairState crosshairState = new CrosshairState();\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\n        crosshairState.setAnchor(anchor);\n        \n        crosshairState.setAnchorX(Double.NaN);\n        crosshairState.setAnchorY(Double.NaN);            \n        if (anchor != null) {\n            ValueAxis domainAxis = getDomainAxis();\n            if (domainAxis != null) {\n                double x;\n                if (orient == PlotOrientation.VERTICAL) {\n                    x = domainAxis.java2DToValue(anchor.getX(), dataArea, \n                            getDomainAxisEdge());\n                } \n                else {\n                    x = domainAxis.java2DToValue(anchor.getY(), dataArea, \n                            getDomainAxisEdge());\n                }\n                crosshairState.setAnchorX(x);\n            }\n            ValueAxis rangeAxis = getRangeAxis();\n            if (rangeAxis != null) {\n                double y;\n                if (orient == PlotOrientation.VERTICAL) {\n                    y = rangeAxis.java2DToValue(anchor.getY(), dataArea, \n                            getRangeAxisEdge());\n                } \n                else {\n                    y = rangeAxis.java2DToValue(anchor.getX(), dataArea, \n                            getRangeAxisEdge());\n                }\n                crosshairState.setAnchorY(y);                \n            }\n        }\n        crosshairState.setCrosshairX(getDomainCrosshairValue());\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\n        Shape originalClip = g2.getClip();\n        Composite originalComposite = g2.getComposite();\n\n        g2.clip(dataArea);\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                getForegroundAlpha()));\n\n        AxisState domainAxisState = (AxisState) axisStateMap.get(\n                getDomainAxis());\n        if (domainAxisState == null) {\n            if (parentState != null) {\n                domainAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getDomainAxis());\n            }\n        }\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (domainAxisState != null) {\n            drawDomainTickBands(g2, dataArea, domainAxisState.getTicks());\n        }\n        if (rangeAxisState != null) {\n            drawRangeTickBands(g2, dataArea, rangeAxisState.getTicks());\n        }\n        if (domainAxisState != null) {\n            drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());\n            drawZeroDomainBaseline(g2, dataArea);\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n            drawZeroRangeBaseline(g2, dataArea);\n        }\n\n        // draw the markers that are associated with a specific renderer...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now draw annotations and render data items...\n        boolean foundData = false;\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            // render data items...\n            for (int i = 0; i < getDatasetCount(); i++) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < rendererCount; i++) {\n                XYItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n        else if (order == DatasetRenderingOrder.REVERSE) {\n\n            // draw background annotations\n            int rendererCount = this.renderers.size();\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, info);\n                }\n            }\n\n            for (int i = getDatasetCount() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, info, crosshairState)\n                    || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = rendererCount - 1; i >= 0; i--) {\n                XYItemRenderer r = getRenderer(i);\n                if (i >= getDatasetCount()) { // we need the dataset to make\n                    continue;                 // a link to the axes\n                }\n                if (r != null) {\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, info);\n                }\n            }\n\n        }\n\n        // draw domain crosshair if required...\n        int xAxisIndex = crosshairState.getDomainAxisIndex();\n        ValueAxis xAxis = getDomainAxis(xAxisIndex);\n        RectangleEdge xAxisEdge = getDomainAxisEdge(xAxisIndex);\n        if (!this.domainCrosshairLockedOnData && anchor != null) {\n            double xx;\n            if (orient == PlotOrientation.VERTICAL) {\n                xx = xAxis.java2DToValue(anchor.getX(), dataArea, xAxisEdge);\n            } \n            else {\n                xx = xAxis.java2DToValue(anchor.getY(), dataArea, xAxisEdge);\n            }\n            crosshairState.setCrosshairX(xx);\n        }\n        setDomainCrosshairValue(crosshairState.getCrosshairX(), false);\n        if (isDomainCrosshairVisible()) {\n            double x = getDomainCrosshairValue();\n            Paint paint = getDomainCrosshairPaint();\n            Stroke stroke = getDomainCrosshairStroke();\n            drawDomainCrosshair(g2, dataArea, orient, x, xAxis, stroke, paint);\n        }\n\n        // draw range crosshair if required...\n        int yAxisIndex = crosshairState.getRangeAxisIndex();\n        ValueAxis yAxis = getRangeAxis(yAxisIndex);\n        RectangleEdge yAxisEdge = getRangeAxisEdge(yAxisIndex);\n        if (!this.rangeCrosshairLockedOnData && anchor != null) {\n            double yy;\n            if (orient == PlotOrientation.VERTICAL) {\n                yy = yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\n            } else {\n                yy = yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\n            }\n            crosshairState.setCrosshairY(yy);\n        }\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\n        if (isRangeCrosshairVisible()) {\n            double y = getRangeCrosshairValue();\n            Paint paint = getRangeCrosshairPaint();\n            Stroke stroke = getRangeCrosshairStroke();\n            drawRangeCrosshair(g2, dataArea, orient, y, yAxis, stroke, paint);\n        }\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        drawAnnotations(g2, dataArea, info);\n        g2.setClip(originalClip);\n        g2.setComposite(originalComposite);\n\n        drawOutline(g2, dataArea);\n\n    }\n\n    /**\n     * Draws the background for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawQuadrants(g2, area);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * Draws the quadrants.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area.\n     * \n     * @see #setQuadrantOrigin(Point2D)\n     * @see #setQuadrantPaint(int, Paint)\n     */\n    protected void drawQuadrants(Graphics2D g2, Rectangle2D area) {\n        //  0 | 1\n        //  --+--\n        //  2 | 3\n        boolean somethingToDraw = false;\n\n        ValueAxis xAxis = getDomainAxis();\n        double x = xAxis.getRange().constrain(this.quadrantOrigin.getX());\n        double xx = xAxis.valueToJava2D(x, area, getDomainAxisEdge());\n\n        ValueAxis yAxis = getRangeAxis();\n        double y = yAxis.getRange().constrain(this.quadrantOrigin.getY());\n        double yy = yAxis.valueToJava2D(y, area, getRangeAxisEdge());\n\n        double xmin = xAxis.getLowerBound();\n        double xxmin = xAxis.valueToJava2D(xmin, area, getDomainAxisEdge());\n\n        double xmax = xAxis.getUpperBound();\n        double xxmax = xAxis.valueToJava2D(xmax, area, getDomainAxisEdge());\n\n        double ymin = yAxis.getLowerBound();\n        double yymin = yAxis.valueToJava2D(ymin, area, getRangeAxisEdge());\n\n        double ymax = yAxis.getUpperBound();\n        double yymax = yAxis.valueToJava2D(ymax, area, getRangeAxisEdge());\n\n        Rectangle2D[] r = new Rectangle2D[] {null, null, null, null};\n        if (this.quadrantPaint[0] != null) {\n            if (x > xmin && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[0] = new Rectangle2D.Double(Math.min(yymax, yy), \n                            Math.min(xxmin, xx), Math.abs(yy - yymax), \n                            Math.abs(xx - xxmin)\n                    );\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[0] = new Rectangle2D.Double(Math.min(xxmin, xx), \n                            Math.min(yymax, yy), Math.abs(xx - xxmin), \n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[1] != null) {\n            if (x < xmax && y < ymax) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[1] = new Rectangle2D.Double(Math.min(yymax, yy), \n                            Math.min(xxmax, xx), Math.abs(yy - yymax), \n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[1] = new Rectangle2D.Double(Math.min(xx, xxmax), \n                            Math.min(yymax, yy), Math.abs(xx - xxmax), \n                            Math.abs(yy - yymax));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[2] != null) {\n            if (x > xmin && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[2] = new Rectangle2D.Double(Math.min(yymin, yy), \n                            Math.min(xxmin, xx), Math.abs(yy - yymin), \n                            Math.abs(xx - xxmin));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[2] = new Rectangle2D.Double(Math.min(xxmin, xx), \n                            Math.min(yymin, yy), Math.abs(xx - xxmin), \n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (this.quadrantPaint[3] != null) {\n            if (x < xmax && y > ymin) {\n                if (this.orientation == PlotOrientation.HORIZONTAL) {\n                    r[3] = new Rectangle2D.Double(Math.min(yymin, yy), \n                            Math.min(xxmax, xx), Math.abs(yy - yymin), \n                            Math.abs(xx - xxmax));\n                }\n                else {  // PlotOrientation.VERTICAL\n                    r[3] = new Rectangle2D.Double(Math.min(xx, xxmax), \n                            Math.min(yymin, yy), Math.abs(xx - xxmax), \n                            Math.abs(yy - yymin));\n                }\n                somethingToDraw = true;\n            }\n        }\n        if (somethingToDraw) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                    getBackgroundAlpha()));\n            for (int i = 0; i < 4; i++) {\n                if (this.quadrantPaint[i] != null && r[i] != null) {\n                    g2.setPaint(this.quadrantPaint[i]);\n                    g2.fill(r[i]);\n                }\n            }\n            g2.setComposite(originalComposite);\n        }\n    }\n\n    /**\n     * Draws the domain tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #setDomainTickBandPaint(Paint)\n     */\n    public void drawDomainTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                    List ticks) {\n        Paint bandPaint = getDomainTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis xAxis = getDomainAxis();\n            double previous = xAxis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea,\n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = xAxis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillDomainGridBand(g2, this, xAxis, dataArea, \n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * Draws the range tick bands, if any.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #setRangeTickBandPaint(Paint)\n     */\n    public void drawRangeTickBands(Graphics2D g2, Rectangle2D dataArea,\n                                   List ticks) {\n        Paint bandPaint = getRangeTickBandPaint();\n        if (bandPaint != null) {\n            boolean fillBand = false;\n            ValueAxis axis = getRangeAxis();\n            double previous = axis.getLowerBound();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                double current = tick.getValue();\n                if (fillBand) {\n                    getRenderer().fillRangeGridBand(g2, this, axis, dataArea, \n                            previous, current);\n                }\n                previous = current;\n                fillBand = !fillBand;\n            }\n            double end = axis.getUpperBound();\n            if (fillBand) {\n                getRenderer().fillRangeGridBand(g2, this, axis, dataArea, \n                        previous, end);\n            }\n        }\n    }\n\n    /**\n     * A utility method for drawing the axes.\n     *\n     * @param g2  the graphics device (<code>null</code> not permitted).\n     * @param plotArea  the plot area (<code>null</code> not permitted).\n     * @param dataArea  the data area (<code>null</code> not permitted).\n     * @param plotState  collects information about the plot (<code>null</code>\n     *                   permitted).\n     *\n     * @return A map containing the state for each axis drawn.\n     */\n    protected Map drawAxes(Graphics2D g2,\n                           Rectangle2D plotArea,\n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(index);\n            if (axis != null) {\n                axisCollection.add(axis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n\n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.TOP, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY()\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.BOTTOM, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX()\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.LEFT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX()\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            ValueAxis axis = (ValueAxis) iterator.next();\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \n                    RectangleEdge.RIGHT, plotState);\n            cursor = info.getCursor();\n            axisStateMap.put(axis, info);\n        }\n\n        return axisStateMap;\n    }\n\n    /**\n     * Draws a representation of the data within the dataArea region, using the\n     * current renderer.\n     * <P>\n     * The <code>info</code> and <code>crosshairState</code> arguments may be\n     * <code>null</code>.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset index.\n     * @param info  an optional object for collection dimension information.\n     * @param crosshairState  collects crosshair information\n     *                        (<code>null</code> permitted).\n     *\n     * @return A flag that indicates whether any data was actually rendered.\n     */\n    public boolean render(Graphics2D g2,\n                          Rectangle2D dataArea,\n                          int index,\n                          PlotRenderingInfo info,\n                          CrosshairState crosshairState) {\n\n        boolean foundData = false;\n        XYDataset dataset = getDataset(index);\n        if (!DatasetUtilities.isEmptyOrNull(dataset)) {\n            foundData = true;\n            ValueAxis xAxis = getDomainAxisForDataset(index);\n            ValueAxis yAxis = getRangeAxisForDataset(index);\n            XYItemRenderer renderer = getRenderer(index);\n            if (renderer == null) {\n                renderer = getRenderer();\n                if (renderer == null) { // no default renderer available\n                    return foundData;\n                }\n            }\n\n            XYItemRendererState state = renderer.initialise(g2, dataArea, this,\n                    dataset, info);\n            int passCount = renderer.getPassCount();\n\n            SeriesRenderingOrder seriesOrder = getSeriesRenderingOrder();\n            if (seriesOrder == SeriesRenderingOrder.REVERSE) {\n                //render series in reverse order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = seriesCount - 1; series >= 0; series--) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (lastItem == -1) {\n                            continue;\n                        }\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(), \n                                    xAxis.getUpperBound());\n                            firstItem = itemBounds[0];\n                            lastItem = itemBounds[1];\n                        }\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                    }\n                }\n            }\n            else {\n                //render series in forward order\n                for (int pass = 0; pass < passCount; pass++) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int series = 0; series < seriesCount; series++) {\n                        int firstItem = 0;\n                        int lastItem = dataset.getItemCount(series) - 1;\n                        if (state.getProcessVisibleItemsOnly()) {\n                            int[] itemBounds = RendererUtilities.findLiveItems(\n                                    dataset, series, xAxis.getLowerBound(), \n                                    xAxis.getUpperBound());\n                            firstItem = itemBounds[0];\n                            lastItem = itemBounds[1];\n                        }\n                        for (int item = firstItem; item <= lastItem; item++) {\n                            renderer.drawItem(g2, state, dataArea, info,\n                                    this, xAxis, yAxis, dataset, series, item,\n                                    crosshairState, pass);\n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n    }\n\n    /**\n     * Returns the domain axis for a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The axis.\n     */\n    public ValueAxis getDomainAxisForDataset(int index) {\n\n        if (index < 0 || index >= getDatasetCount()) {\n            throw new IllegalArgumentException(\"Index \" + index \n                    + \" out of bounds.\");\n        }\n\n        ValueAxis valueAxis = null;\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(\n                new Integer(index));\n        if (axisIndex != null) {\n            valueAxis = getDomainAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getDomainAxis(0);\n        }\n        return valueAxis;\n\n    }\n\n    /**\n     * Returns the range axis for a dataset.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The axis.\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n\n        if (index < 0 || index >= getDatasetCount()) {\n            throw new IllegalArgumentException(\"Index \" + index \n                    + \" out of bounds.\");\n        }\n\n        ValueAxis valueAxis = null;\n        Integer axisIndex\n            = (Integer) this.datasetToRangeAxisMap.get(new Integer(index));\n        if (axisIndex != null) {\n            valueAxis = getRangeAxis(axisIndex.intValue());\n        }\n        else {\n            valueAxis = getRangeAxis(0);\n        }\n        return valueAxis;\n\n    }\n\n    /**\n     * Draws the gridlines for the plot, if they are visible.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea,\n                                       List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible()) {\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                ValueTick tick = (ValueTick) iterator.next();\n                getRenderer().drawDomainLine(g2, this, getDomainAxis(),\n                        dataArea, tick.getValue(), gridPaint, gridStroke);\n            }\n        }\n    }\n\n    /**\n     * Draws the gridlines for the plot's primary range axis, if they are\n     * visible.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * @param ticks  the ticks.\n     * \n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area,\n                                      List ticks) {\n\n        // no renderer, no gridlines...\n        if (getRenderer() == null) {\n            return;\n        }\n\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            ValueAxis axis = getRangeAxis();\n            if (axis != null) {\n                Iterator iterator = ticks.iterator();\n                while (iterator.hasNext()) {\n                    ValueTick tick = (ValueTick) iterator.next();\n                    if (tick.getValue() != 0.0\n                            || !isRangeZeroBaselineVisible()) {\n                        getRenderer().drawRangeLine(g2, this, getRangeAxis(), \n                                area, tick.getValue(), gridPaint, gridStroke);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the domain axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * \n     * @see #setDomainZeroBaselineVisible(boolean)\n     * \n     * @since 1.0.5\n     */\n    protected void drawZeroDomainBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isDomainZeroBaselineVisible()) {\n            XYItemRenderer r = getRenderer();\n            r.drawDomainLine(g2, this, getDomainAxis(), area, 0.0, \n                    this.domainZeroBaselinePaint, \n                    this.domainZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws a base line across the chart at value zero on the range axis.\n     *\n     * @param g2  the graphics device.\n     * @param area  the data area.\n     * \n     * @see #setRangeZeroBaselineVisible(boolean)\n     */\n    protected void drawZeroRangeBaseline(Graphics2D g2, Rectangle2D area) {\n        if (isRangeZeroBaselineVisible()) {\n            getRenderer().drawRangeLine(g2, this, getRangeAxis(), area, 0.0, \n                    this.rangeZeroBaselinePaint, this.rangeZeroBaselineStroke);\n        }\n    }\n\n    /**\n     * Draws the annotations for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the chart rendering info.\n     */\n    public void drawAnnotations(Graphics2D g2,\n                                Rectangle2D dataArea,\n                                PlotRenderingInfo info) {\n\n        Iterator iterator = this.annotations.iterator();\n        while (iterator.hasNext()) {\n            XYAnnotation annotation = (XYAnnotation) iterator.next();\n            ValueAxis xAxis = getDomainAxis();\n            ValueAxis yAxis = getRangeAxis();\n            annotation.draw(g2, this, dataArea, xAxis, yAxis, 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is\n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                     int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }    \n        Collection markers = getDomainMarkers(index, layer);\n        ValueAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n\n    }\n\n    /**\n     * Draws the range markers (if any) for a renderer and layer.  This method\n     * is typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea,\n                                    int index, Layer layer) {\n\n        XYItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        // check that the renderer has a corresponding dataset (it doesn't\n        // matter if the dataset is null)\n        if (index >= getDatasetCount()) {\n            return;\n        }\n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of domain markers.\n     * \n     * @see #getRangeMarkers(Layer)\n     */\n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     *\n     * @return The list of range markers.\n     * \n     * @see #getDomainMarkers(Layer)\n     */\n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly <code>null</code>).\n     * \n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and\n     * layer.\n     *\n     * @param index  the renderer index.\n     * @param layer  the layer.\n     *\n     * @return A collection of markers (possibly <code>null</code>).\n     * \n     * @see #getDomainMarkers(int, Layer)\n     */\n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n\n    /**\n     * Utility method for drawing a horizontal line across the data area of the\n     * plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawHorizontalLine(Graphics2D g2, Rectangle2D dataArea,\n                                      double value, Stroke stroke,\n                                      Paint paint) {\n\n        ValueAxis axis = getRangeAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getDomainAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double yy = axis.valueToJava2D(value, dataArea, RectangleEdge.LEFT);\n            Line2D line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n    \n    /**\n     * Draws a domain crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.4\n     */\n    protected void drawDomainCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.VERTICAL) {\n                double xx = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy, \n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n        \n    }\n\n    /**\n     * Utility method for drawing a vertical line on the data area of the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param value  the coordinate, where to draw the line.\n     * @param stroke  the stroke to use.\n     * @param paint  the paint to use.\n     */\n    protected void drawVerticalLine(Graphics2D g2, Rectangle2D dataArea,\n                                    double value, Stroke stroke, Paint paint) {\n\n        ValueAxis axis = getDomainAxis();\n        if (getOrientation() == PlotOrientation.HORIZONTAL) {\n            axis = getRangeAxis();\n        }\n        if (axis.getRange().contains(value)) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            Line2D line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.4\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (axis.getRange().contains(value)) {\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                double xx = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.BOTTOM);\n                line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                        dataArea.getMaxY());\n            }\n            else {\n                double yy = axis.valueToJava2D(value, dataArea, \n                        RectangleEdge.LEFT);\n                line = new Line2D.Double(dataArea.getMinX(), yy, \n                        dataArea.getMaxX(), yy);\n            }\n            g2.setStroke(stroke);\n            g2.setPaint(paint);\n            g2.draw(line);\n        }\n        \n    }\n\n    /**\n     * Handles a 'click' on the plot by updating the anchor values.\n     *\n     * @param x  the x-coordinate, where the click occurred, in Java2D space.\n     * @param y  the y-coordinate, where the click occurred, in Java2D space.\n     * @param info  object containing information about the plot dimensions.\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the horizontal axis...\n            ValueAxis da = getDomainAxis();\n            if (da != null) {\n                double hvalue = da.java2DToValue(x, info.getDataArea(), \n                        getDomainAxisEdge());\n                setDomainCrosshairValue(hvalue);\n            }\n\n            // set the anchor value for the vertical axis...\n            ValueAxis ra = getRangeAxis();\n            if (ra != null) {\n                double vvalue = ra.java2DToValue(y, info.getDataArea(), \n                        getRangeAxisEdge());\n                setRangeCrosshairValue(vvalue);\n            }\n        }\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List getDatasetsMappedToDomainAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Integer mappedAxis = (Integer) this.datasetToDomainAxisMap.get(\n                    new Integer(i));\n            if (mappedAxis == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxis.equals(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * A utility method that returns a list of datasets that are mapped to a\n     * particular axis.\n     *\n     * @param axisIndex  the axis index (<code>null</code> not permitted).\n     *\n     * @return A list of datasets.\n     */\n    private List getDatasetsMappedToRangeAxis(Integer axisIndex) {\n        if (axisIndex == null) {\n            throw new IllegalArgumentException(\"Null 'axisIndex' argument.\");\n        }\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Integer mappedAxis = (Integer) this.datasetToRangeAxisMap.get(\n                    new Integer(i));\n            if (mappedAxis == null) {\n                if (axisIndex.equals(ZERO)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n            else {\n                if (mappedAxis.equals(axisIndex)) {\n                    result.add(this.datasets.get(i));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given domain axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     * \n     * @see #getRangeAxisIndex(ValueAxis)\n     */\n    public int getDomainAxisIndex(ValueAxis axis) {\n        int result = this.domainAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getDomainAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given range axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The axis index.\n     * \n     * @see #getDomainAxisIndex(ValueAxis)\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) {\n            // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof XYPlot) {\n                XYPlot p = (XYPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range for the specified axis.\n     *\n     * @param axis  the axis.\n     *\n     * @return The range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result, \n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result, \n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The axis ranges are updated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n        configureDomainAxes();\n        configureRangeAxes();\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    public void rendererChanged(RendererChangeEvent event) {\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the domain crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setDomainCrosshairVisible(boolean)\n     */\n    public boolean isDomainCrosshairVisible() {\n        return this.domainCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair is visible \n     * and, if the flag changes, sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isDomainCrosshairVisible()\n     */\n    public void setDomainCrosshairVisible(boolean flag) {\n        if (this.domainCrosshairVisible != flag) {\n            this.domainCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setDomainCrosshairLockedOnData(boolean)\n     */\n    public boolean isDomainCrosshairLockedOnData() {\n        return this.domainCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the domain crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this\n     * method sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isDomainCrosshairLockedOnData()\n     */\n    public void setDomainCrosshairLockedOnData(boolean flag) {\n        if (this.domainCrosshairLockedOnData != flag) {\n            this.domainCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setDomainCrosshairValue(double)\n     */\n    public double getDomainCrosshairValue() {\n        return this.domainCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners (provided that the domain crosshair is visible).\n     *\n     * @param value  the value.\n     * \n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value) {\n        setDomainCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the domain crosshair value and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners (provided that the\n     * domain crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  notify listeners?\n     * \n     * @see #getDomainCrosshairValue()\n     */\n    public void setDomainCrosshairValue(double value, boolean notify) {\n        this.domainCrosshairValue = value;\n        if (isDomainCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the {@link Stroke} used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setDomainCrosshairStroke(Stroke)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairPaint()\n     */\n    public Stroke getDomainCrosshairStroke() {\n        return this.domainCrosshairStroke;\n    }\n\n    /**\n     * Sets the Stroke used to draw the crosshairs (if visible) and notifies\n     * registered listeners that the axis has been modified.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *     permitted).\n     *     \n     * @see #getDomainCrosshairStroke()\n     */\n    public void setDomainCrosshairStroke(Stroke stroke) {\n        if (stroke == null) { \n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.domainCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain crosshair paint.\n     *\n     * @return The crosshair paint (never <code>null</code>).\n     * \n     * @see #setDomainCrosshairPaint(Paint)\n     * @see #isDomainCrosshairVisible()\n     * @see #getDomainCrosshairStroke()\n     */\n    public Paint getDomainCrosshairPaint() {\n        return this.domainCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the crosshairs (if visible) and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\n     * \n     * @see #getDomainCrosshairPaint()\n     */\n    public void setDomainCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.domainCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairVisible(boolean)\n     * @see #isDomainCrosshairVisible()\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     * If the flag value changes, this method sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should\n     * \"lock-on\" to actual data values.  If the flag value changes, this method\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the range crosshair value.\n     * <P>\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and sends a {@link PlotChangeEvent} to\n     * all registered listeners, but only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are\n     *                notified.\n     *                \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the crosshair (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the crosshairs (if visible) and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *         permitted).\n     * \n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the range crosshair paint.\n     *\n     * @return The crosshair paint (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to color the crosshairs (if visible) and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint the new crosshair paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed domain axis space and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedDomainAxisSpace()\n     * \n     * @since 1.0.9\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed range axis space and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedRangeAxisSpace()\n     * \n     * @since 1.0.9\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source) {\n        // delegate to other method\n        zoomDomainAxes(factor, info, source, false);\n    }\n\n    /**\n     * Multiplies the range on the domain axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each domain axis\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceX = source.getX();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceX = source.getY();\n                    }\n                    double anchorX = domainAxis.java2DToValue(sourceX, \n                            info.getDataArea(), getDomainAxisEdge());\n                    domainAxis.resizeRange(factor, anchorX);\n                }\n                else {\n                    domainAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the domain axis/axes.  The new lower and upper bounds are\n     * specified as percentages of the current axis range, where 0 percent is\n     * the current lower bound and 100 percent is the current upper bound.\n     *\n     * @param lowerPercent  a percentage that determines the new lower bound\n     *                      for the axis (e.g. 0.20 is twenty percent).\n     * @param upperPercent  a percentage that determines the new upper bound\n     *                      for the axis (e.g. 0.80 is eighty percent).\n     * @param info  the plot rendering info.\n     * @param source  the source point (ignored).\n     * \n     * @see #zoomRangeAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomDomainAxes(double lowerPercent, double upperPercent,\n                               PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis domainAxis = (ValueAxis) this.domainAxes.get(i);\n            if (domainAxis != null) {\n                domainAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, info, source, false);    \n    }\n    \n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each range axis\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     *\n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * \n     * @see #zoomDomainAxes(double, double, PlotRenderingInfo, Point2D)\n     */\n    public void zoomRangeAxes(double lowerPercent, double upperPercent,\n                              PlotRenderingInfo info, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n\n    /**\n     * Returns <code>true</code>, indicating that the domain axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     * \n     * @see #isRangeZoomable()\n     */\n    public boolean isDomainZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns <code>true</code>, indicating that the range axis/axes for this\n     * plot are zoomable.\n     *\n     * @return A boolean.\n     * \n     * @see #isDomainZoomable()\n     */\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * Returns the number of series in the primary dataset for this plot.  If\n     * the dataset is <code>null</code>, the method returns 0.\n     *\n     * @return The series count.\n     */\n    public int getSeriesCount() {\n        int result = 0;\n        XYDataset dataset = getDataset();\n        if (dataset != null) {\n            result = dataset.getSeriesCount();\n        }\n        return result;\n    }\n\n    /**\n     * Returns the fixed legend items, if any.\n     *\n     * @return The legend items (possibly <code>null</code>).\n     * \n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;\n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to\n     * <code>null</code> if you prefer the legend items to be created\n     * automatically.\n     *\n     * @param items  the legend items (<code>null</code> permitted).\n     * \n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the legend items for the plot.  Each legend item is generated by\n     * the plot's renderer, since the renderer is responsible for the visual\n     * representation of the data.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n        if (this.fixedLegendItems != null) {\n            return this.fixedLegendItems;\n        }\n        LegendItemCollection result = new LegendItemCollection();\n        int count = this.datasets.size();\n        for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n            XYDataset dataset = getDataset(datasetIndex);\n            if (dataset != null) {\n                XYItemRenderer renderer = getRenderer(datasetIndex);\n                if (renderer == null) {\n                    renderer = getRenderer(0);\n                }\n                if (renderer != null) {\n                    int seriesCount = dataset.getSeriesCount();\n                    for (int i = 0; i < seriesCount; i++) {\n                        if (renderer.isSeriesVisible(i)\n                                && renderer.isSeriesVisibleInLegend(i)) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Tests this plot for equality with another object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return <code>true</code> or <code>false</code>.\n     */\n    public boolean equals(Object obj) {\n\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof XYPlot)) {\n            return false;\n        }\n\n        XYPlot that = (XYPlot) obj;\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData\n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (this.domainZeroBaselineVisible != that.domainZeroBaselineVisible) {\n            return false;\n        }\n        if (this.rangeZeroBaselineVisible != that.rangeZeroBaselineVisible) {\n            return false;\n        }\n        if (this.domainCrosshairVisible != that.domainCrosshairVisible) {\n            return false;\n        }\n        if (this.domainCrosshairValue != that.domainCrosshairValue) {\n            return false;\n        }\n        if (this.domainCrosshairLockedOnData\n                != that.domainCrosshairLockedOnData) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeAxes, that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainZeroBaselinePaint, \n                that.domainZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainZeroBaselineStroke, \n                that.domainZeroBaselineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeZeroBaselinePaint, \n                that.rangeZeroBaselinePaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeZeroBaselineStroke, \n                that.rangeZeroBaselineStroke)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainCrosshairStroke, \n                that.domainCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainCrosshairPaint, \n                that.domainCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, \n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, \n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundDomainMarkers, \n                that.foregroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundDomainMarkers, \n                that.backgroundDomainMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainTickBandPaint, \n                that.domainTickBandPaint)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeTickBandPaint, \n                that.rangeTickBandPaint)) {\n            return false;\n        }\n        if (!this.quadrantOrigin.equals(that.quadrantOrigin)) {\n            return false;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (!PaintUtilities.equal(this.quadrantPaint[i], \n                    that.quadrantPaint[i])) {\n                return false;\n            }\n        }\n        return super.equals(obj);\n    }\n\n    /**\n     * Returns a clone of the plot.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this can occur if some component of\n     *         the plot cannot be cloned.\n     */\n    public Object clone() throws CloneNotSupportedException {\n\n        XYPlot clone = (XYPlot) super.clone();\n        clone.domainAxes = (ObjectList) ObjectUtilities.clone(this.domainAxes);\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.domainAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.domainAxisLocations = (ObjectList) \n                this.domainAxisLocations.clone();\n\n        clone.rangeAxes = (ObjectList) ObjectUtilities.clone(this.rangeAxes);\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                ValueAxis clonedAxis = (ValueAxis) axis.clone();\n                clone.rangeAxes.set(i, clonedAxis);\n                clonedAxis.setPlot(clone);\n                clonedAxis.addChangeListener(clone);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) ObjectUtilities.clone(\n                this.rangeAxisLocations);\n\n        // the datasets are not cloned, but listeners need to be added...\n        clone.datasets = (ObjectList) ObjectUtilities.clone(this.datasets);\n        for (int i = 0; i < clone.datasets.size(); ++i) {\n            XYDataset d = getDataset(i);\n            if (d != null) {\n                d.addChangeListener(clone);\n            }\n        }\n\n        clone.datasetToDomainAxisMap = new TreeMap();\n        clone.datasetToDomainAxisMap.putAll(this.datasetToDomainAxisMap);\n        clone.datasetToRangeAxisMap = new TreeMap();\n        clone.datasetToRangeAxisMap.putAll(this.datasetToRangeAxisMap);\n\n        clone.renderers = (ObjectList) ObjectUtilities.clone(this.renderers);\n        for (int i = 0; i < this.renderers.size(); i++) {\n            XYItemRenderer renderer2 = (XYItemRenderer) this.renderers.get(i);\n            if (renderer2 instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) renderer2;\n                clone.renderers.set(i, pc.clone());\n            }\n        }\n        clone.foregroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundDomainMarkers);\n        clone.backgroundDomainMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundDomainMarkers);\n        clone.foregroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.foregroundRangeMarkers);\n        clone.backgroundRangeMarkers = (Map) ObjectUtilities.clone(\n                this.backgroundRangeMarkers);\n        clone.annotations = (List) ObjectUtilities.deepClone(this.annotations);\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n\n        clone.quadrantOrigin = (Point2D) ObjectUtilities.clone(\n                this.quadrantOrigin);\n        clone.quadrantPaint = (Paint[]) this.quadrantPaint.clone();\n        return clone;\n\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.rangeZeroBaselinePaint, stream);\n        SerialUtilities.writeStroke(this.domainCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.domainCrosshairPaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n        SerialUtilities.writePaint(this.domainTickBandPaint, stream);\n        SerialUtilities.writePaint(this.rangeTickBandPaint, stream);\n        SerialUtilities.writePoint2D(this.quadrantOrigin, stream);\n        for (int i = 0; i < 4; i++) {\n            SerialUtilities.writePaint(this.quadrantPaint[i], stream);\n        }\n        SerialUtilities.writeStroke(this.domainZeroBaselineStroke, stream);\n        SerialUtilities.writePaint(this.domainZeroBaselinePaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream);\n        this.domainCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.domainCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n        this.domainTickBandPaint = SerialUtilities.readPaint(stream);\n        this.rangeTickBandPaint = SerialUtilities.readPaint(stream);\n        this.quadrantOrigin = SerialUtilities.readPoint2D(stream);\n        this.quadrantPaint = new Paint[4];\n        for (int i = 0; i < 4; i++) {\n            this.quadrantPaint[i] = SerialUtilities.readPaint(stream);\n        }\n\n        this.domainZeroBaselineStroke = SerialUtilities.readStroke(stream);\n        this.domainZeroBaselinePaint = SerialUtilities.readPaint(stream);\n\n        // register the plot as a listener with its axes, datasets, and \n        // renderers...\n        int domainAxisCount = this.domainAxes.size();\n        for (int i = 0; i < domainAxisCount; i++) {\n            Axis axis = (Axis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int rangeAxisCount = this.rangeAxes.size();\n        for (int i = 0; i < rangeAxisCount; i++) {\n            Axis axis = (Axis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.setPlot(this);\n                axis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            XYItemRenderer renderer = (XYItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n    \n    }\n\n}\n"}, "retrieved_test_case": null}
{"bug_id": "Chart_14", "version": "fixed", "focal_method_signature": "org.jfree.chart.plot#CategoryPlot#removeDomainMarker(org.jfree.chart.plot#Marker, org.jfree.chart.util#Layer)", "focal_method_bytecode_signature": "org.jfree.chart.plot.CategoryPlot.removeDomainMarker(Lorg/jfree/chart/plot/Marker;Lorg/jfree/chart/util/Layer;)Z", "test_file": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_14/evosuite-tests/org/jfree/chart/plot/CategoryPlot_ESTest.java", "source_file": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_14/fixed/source/org/jfree/chart/plot/CategoryPlot.java", "focal_method": "public boolean removeDomainMarker(Marker marker, Layer layer) {\r\n    return removeDomainMarker(0, marker, layer);\r\n}", "return_type": "boolean", "test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      CategoryPlot categoryPlot0 = new CategoryPlot();\n      ValueMarker valueMarker0 = new ValueMarker((-1360.5635568969062), categoryPlot0.DEFAULT_BACKGROUND_PAINT, categoryPlot0.DEFAULT_OUTLINE_STROKE);\n      categoryPlot0.removeRangeMarker((Marker) valueMarker0);\n      assertEquals(1, categoryPlot0.getDatasetCount());\n}", "parent_test_case": "@Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      CategoryPlot categoryPlot0 = new CategoryPlot();\n      ValueMarker valueMarker0 = new ValueMarker((-1360.5635568969062), categoryPlot0.DEFAULT_BACKGROUND_PAINT, categoryPlot0.DEFAULT_OUTLINE_STROKE);\n      categoryPlot0.removeRangeMarker((Marker) valueMarker0);\n      assertEquals(1, categoryPlot0.getDatasetCount());\n  }", "test_class": {"path": "/Users/yanglin/Documents/Projects/as-gen-integration/outputs/evosuite_outputs/Chart_14/evosuite-tests/org/jfree/chart/plot/CategoryPlot_ESTest.java", "imports": ["import org.junit.Test;", "import static org.junit.Assert.*;", "import org.evosuite.runtime.EvoRunner;", "import org.evosuite.runtime.EvoRunnerParameters;", "import org.jfree.chart.plot.CategoryPlot;", "import org.jfree.chart.plot.Marker;", "import org.jfree.chart.plot.ValueMarker;", "import org.junit.runner.RunWith;"], "fields": [], "methods": ["void org.jfree.chart.plot.CategoryPlot_ESTest#test0()"], "text": "/*\n * This file was automatically generated by EvoSuite\n * Tue Mar 11 11:04:58 GMT 2025\n */\n\npackage org.jfree.chart.plot;\n\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport org.evosuite.runtime.EvoRunner;\nimport org.evosuite.runtime.EvoRunnerParameters;\nimport org.jfree.chart.plot.CategoryPlot;\nimport org.jfree.chart.plot.Marker;\nimport org.jfree.chart.plot.ValueMarker;\nimport org.junit.runner.RunWith;\n\n@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = true) \npublic class CategoryPlot_ESTest extends CategoryPlot_ESTest_scaffolding {\n\n  @Test(timeout = 4000)\n  public void test0()  throws Throwable  {\n      CategoryPlot categoryPlot0 = new CategoryPlot();\n      ValueMarker valueMarker0 = new ValueMarker((-1360.5635568969062), categoryPlot0.DEFAULT_BACKGROUND_PAINT, categoryPlot0.DEFAULT_OUTLINE_STROKE);\n      categoryPlot0.removeRangeMarker((Marker) valueMarker0);\n      assertEquals(1, categoryPlot0.getDatasetCount());\n  }\n}\n"}, "focal_class": {"name": "CategoryPlot", "path": "/Users/yanglin/Documents/Projects/data/defects4j/d4j_projects/Chart_14/fixed/source/org/jfree/chart/plot/CategoryPlot.java", "superclass": "extends Plot", "interface": "implements ValueAxisPlot, \n        Zoomable, RendererChangeListener, Cloneable, PublicCloneable, \n        Serializable", "imports": ["import java.awt.AlphaComposite;", "import java.awt.BasicStroke;", "import java.awt.Color;", "import java.awt.Composite;", "import java.awt.Font;", "import java.awt.Graphics2D;", "import java.awt.Paint;", "import java.awt.Shape;", "import java.awt.Stroke;", "import java.awt.geom.Line2D;", "import java.awt.geom.Point2D;", "import java.awt.geom.Rectangle2D;", "import java.io.IOException;", "import java.io.ObjectInputStream;", "import java.io.ObjectOutputStream;", "import java.io.Serializable;", "import java.util.ArrayList;", "import java.util.Collection;", "import java.util.Collections;", "import java.util.HashMap;", "import java.util.Iterator;", "import java.util.List;", "import java.util.Map;", "import java.util.ResourceBundle;", "import java.util.Set;", "import org.jfree.chart.LegendItem;", "import org.jfree.chart.LegendItemCollection;", "import org.jfree.chart.annotations.CategoryAnnotation;", "import org.jfree.chart.axis.Axis;", "import org.jfree.chart.axis.AxisCollection;", "import org.jfree.chart.axis.AxisLocation;", "import org.jfree.chart.axis.AxisSpace;", "import org.jfree.chart.axis.AxisState;", "import org.jfree.chart.axis.CategoryAnchor;", "import org.jfree.chart.axis.CategoryAxis;", "import org.jfree.chart.axis.ValueAxis;", "import org.jfree.chart.axis.ValueTick;", "import org.jfree.chart.event.ChartChangeEventType;", "import org.jfree.chart.event.PlotChangeEvent;", "import org.jfree.chart.event.RendererChangeEvent;", "import org.jfree.chart.event.RendererChangeListener;", "import org.jfree.chart.renderer.category.CategoryItemRenderer;", "import org.jfree.chart.renderer.category.CategoryItemRendererState;", "import org.jfree.chart.util.Layer;", "import org.jfree.chart.util.ObjectList;", "import org.jfree.chart.util.ObjectUtilities;", "import org.jfree.chart.util.PaintUtilities;", "import org.jfree.chart.util.PublicCloneable;", "import org.jfree.chart.util.RectangleEdge;", "import org.jfree.chart.util.RectangleInsets;", "import org.jfree.chart.util.SerialUtilities;", "import org.jfree.chart.util.SortOrder;", "import org.jfree.data.Range;", "import org.jfree.data.category.CategoryDataset;", "import org.jfree.data.general.Dataset;", "import org.jfree.data.general.DatasetChangeEvent;", "import org.jfree.data.general.DatasetUtilities;"], "fields": ["private static final long serialVersionUID = -3537691700434728188L", "public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false", "public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true", "public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] \n            {2.0f, 2.0f}, 0.0f)", "public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE", "public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10)", "public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false", "public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE", "public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue", "protected static ResourceBundle localizationResources = ResourceBundle.getBundle(\n            \"org.jfree.chart.plot.LocalizationBundle\")", "private PlotOrientation orientation", "private RectangleInsets axisOffset", "private ObjectList domainAxes", "private ObjectList domainAxisLocations", "private boolean drawSharedDomainAxis", "private ObjectList rangeAxes", "private ObjectList rangeAxisLocations", "private ObjectList datasets", "private ObjectList datasetToDomainAxisMap", "private ObjectList datasetToRangeAxisMap", "private ObjectList renderers", "private DatasetRenderingOrder renderingOrder = DatasetRenderingOrder.REVERSE", "private SortOrder columnRenderingOrder = SortOrder.ASCENDING", "private SortOrder rowRenderingOrder = SortOrder.ASCENDING", "private boolean domainGridlinesVisible", "private CategoryAnchor domainGridlinePosition", "private transient Stroke domainGridlineStroke", "private transient Paint domainGridlinePaint", "private boolean rangeGridlinesVisible", "private transient Stroke rangeGridlineStroke", "private transient Paint rangeGridlinePaint", "private double anchorValue", "private boolean rangeCrosshairVisible", "private double rangeCrosshairValue", "private transient Stroke rangeCrosshairStroke", "private transient Paint rangeCrosshairPaint", "private boolean rangeCrosshairLockedOnData = true", "private Map foregroundDomainMarkers", "private Map backgroundDomainMarkers", "private Map foregroundRangeMarkers", "private Map backgroundRangeMarkers", "private List annotations", "private int weight", "private AxisSpace fixedDomainAxisSpace", "private AxisSpace fixedRangeAxisSpace", "private LegendItemCollection fixedLegendItems"], "methods": ["String org.jfree.chart.plot.CategoryPlot#getPlotType()", "PlotOrientation org.jfree.chart.plot.CategoryPlot#getOrientation()", "void org.jfree.chart.plot.CategoryPlot#setOrientation(PlotOrientation#orientation)", "RectangleInsets org.jfree.chart.plot.CategoryPlot#getAxisOffset()", "void org.jfree.chart.plot.CategoryPlot#setAxisOffset(RectangleInsets#offset)", "CategoryAxis org.jfree.chart.plot.CategoryPlot#getDomainAxis()", "CategoryAxis org.jfree.chart.plot.CategoryPlot#getDomainAxis(int#index)", "void org.jfree.chart.plot.CategoryPlot#setDomainAxis(CategoryAxis#axis)", "void org.jfree.chart.plot.CategoryPlot#setDomainAxis(int#index,CategoryAxis#axis)", "void org.jfree.chart.plot.CategoryPlot#setDomainAxis(int#index,CategoryAxis#axis,boolean#notify)", "void org.jfree.chart.plot.CategoryPlot#setDomainAxes(CategoryAxis[]#axes)", "int org.jfree.chart.plot.CategoryPlot#getDomainAxisIndex(CategoryAxis#axis)", "AxisLocation org.jfree.chart.plot.CategoryPlot#getDomainAxisLocation()", "AxisLocation org.jfree.chart.plot.CategoryPlot#getDomainAxisLocation(int#index)", "void org.jfree.chart.plot.CategoryPlot#setDomainAxisLocation(AxisLocation#location)", "void org.jfree.chart.plot.CategoryPlot#setDomainAxisLocation(AxisLocation#location,boolean#notify)", "void org.jfree.chart.plot.CategoryPlot#setDomainAxisLocation(int#index,AxisLocation#location)", "void org.jfree.chart.plot.CategoryPlot#setDomainAxisLocation(int#index,AxisLocation#location,boolean#notify)", "RectangleEdge org.jfree.chart.plot.CategoryPlot#getDomainAxisEdge()", "RectangleEdge org.jfree.chart.plot.CategoryPlot#getDomainAxisEdge(int#index)", "int org.jfree.chart.plot.CategoryPlot#getDomainAxisCount()", "void org.jfree.chart.plot.CategoryPlot#clearDomainAxes()", "void org.jfree.chart.plot.CategoryPlot#configureDomainAxes()", "ValueAxis org.jfree.chart.plot.CategoryPlot#getRangeAxis()", "ValueAxis org.jfree.chart.plot.CategoryPlot#getRangeAxis(int#index)", "void org.jfree.chart.plot.CategoryPlot#setRangeAxis(ValueAxis#axis)", "void org.jfree.chart.plot.CategoryPlot#setRangeAxis(int#index,ValueAxis#axis)", "void org.jfree.chart.plot.CategoryPlot#setRangeAxis(int#index,ValueAxis#axis,boolean#notify)", "void org.jfree.chart.plot.CategoryPlot#setRangeAxes(ValueAxis[]#axes)", "int org.jfree.chart.plot.CategoryPlot#getRangeAxisIndex(ValueAxis#axis)", "AxisLocation org.jfree.chart.plot.CategoryPlot#getRangeAxisLocation()", "AxisLocation org.jfree.chart.plot.CategoryPlot#getRangeAxisLocation(int#index)", "void org.jfree.chart.plot.CategoryPlot#setRangeAxisLocation(AxisLocation#location)", "void org.jfree.chart.plot.CategoryPlot#setRangeAxisLocation(AxisLocation#location,boolean#notify)", "void org.jfree.chart.plot.CategoryPlot#setRangeAxisLocation(int#index,AxisLocation#location)", "void org.jfree.chart.plot.CategoryPlot#setRangeAxisLocation(int#index,AxisLocation#location,boolean#notify)", "RectangleEdge org.jfree.chart.plot.CategoryPlot#getRangeAxisEdge()", "RectangleEdge org.jfree.chart.plot.CategoryPlot#getRangeAxisEdge(int#index)", "int org.jfree.chart.plot.CategoryPlot#getRangeAxisCount()", "void org.jfree.chart.plot.CategoryPlot#clearRangeAxes()", "void org.jfree.chart.plot.CategoryPlot#configureRangeAxes()", "CategoryDataset org.jfree.chart.plot.CategoryPlot#getDataset()", "CategoryDataset org.jfree.chart.plot.CategoryPlot#getDataset(int#index)", "void org.jfree.chart.plot.CategoryPlot#setDataset(CategoryDataset#dataset)", "void org.jfree.chart.plot.CategoryPlot#setDataset(int#index,CategoryDataset#dataset)", "int org.jfree.chart.plot.CategoryPlot#getDatasetCount()", "void org.jfree.chart.plot.CategoryPlot#mapDatasetToDomainAxis(int#index,int#axisIndex)", "CategoryAxis org.jfree.chart.plot.CategoryPlot#getDomainAxisForDataset(int#index)", "void org.jfree.chart.plot.CategoryPlot#mapDatasetToRangeAxis(int#index,int#axisIndex)", "ValueAxis org.jfree.chart.plot.CategoryPlot#getRangeAxisForDataset(int#index)", "CategoryItemRenderer org.jfree.chart.plot.CategoryPlot#getRenderer()", "CategoryItemRenderer org.jfree.chart.plot.CategoryPlot#getRenderer(int#index)", "void org.jfree.chart.plot.CategoryPlot#setRenderer(CategoryItemRenderer#renderer)", "void org.jfree.chart.plot.CategoryPlot#setRenderer(CategoryItemRenderer#renderer,boolean#notify)", "void org.jfree.chart.plot.CategoryPlot#setRenderer(int#index,CategoryItemRenderer#renderer)", "void org.jfree.chart.plot.CategoryPlot#setRenderer(int#index,CategoryItemRenderer#renderer,boolean#notify)", "void org.jfree.chart.plot.CategoryPlot#setRenderers(CategoryItemRenderer[]#renderers)", "CategoryItemRenderer org.jfree.chart.plot.CategoryPlot#getRendererForDataset(CategoryDataset#dataset)", "int org.jfree.chart.plot.CategoryPlot#getIndexOf(CategoryItemRenderer#renderer)", "DatasetRenderingOrder org.jfree.chart.plot.CategoryPlot#getDatasetRenderingOrder()", "void org.jfree.chart.plot.CategoryPlot#setDatasetRenderingOrder(DatasetRenderingOrder#order)", "SortOrder org.jfree.chart.plot.CategoryPlot#getColumnRenderingOrder()", "void org.jfree.chart.plot.CategoryPlot#setColumnRenderingOrder(SortOrder#order)", "SortOrder org.jfree.chart.plot.CategoryPlot#getRowRenderingOrder()", "void org.jfree.chart.plot.CategoryPlot#setRowRenderingOrder(SortOrder#order)", "boolean org.jfree.chart.plot.CategoryPlot#isDomainGridlinesVisible()", "void org.jfree.chart.plot.CategoryPlot#setDomainGridlinesVisible(boolean#visible)", "CategoryAnchor org.jfree.chart.plot.CategoryPlot#getDomainGridlinePosition()", "void org.jfree.chart.plot.CategoryPlot#setDomainGridlinePosition(CategoryAnchor#position)", "Stroke org.jfree.chart.plot.CategoryPlot#getDomainGridlineStroke()", "void org.jfree.chart.plot.CategoryPlot#setDomainGridlineStroke(Stroke#stroke)", "Paint org.jfree.chart.plot.CategoryPlot#getDomainGridlinePaint()", "void org.jfree.chart.plot.CategoryPlot#setDomainGridlinePaint(Paint#paint)", "boolean org.jfree.chart.plot.CategoryPlot#isRangeGridlinesVisible()", "void org.jfree.chart.plot.CategoryPlot#setRangeGridlinesVisible(boolean#visible)", "Stroke org.jfree.chart.plot.CategoryPlot#getRangeGridlineStroke()", "void org.jfree.chart.plot.CategoryPlot#setRangeGridlineStroke(Stroke#stroke)", "Paint org.jfree.chart.plot.CategoryPlot#getRangeGridlinePaint()", "void org.jfree.chart.plot.CategoryPlot#setRangeGridlinePaint(Paint#paint)", "LegendItemCollection org.jfree.chart.plot.CategoryPlot#getFixedLegendItems()", "void org.jfree.chart.plot.CategoryPlot#setFixedLegendItems(LegendItemCollection#items)", "LegendItemCollection org.jfree.chart.plot.CategoryPlot#getLegendItems()", "void org.jfree.chart.plot.CategoryPlot#handleClick(int#x,int#y,PlotRenderingInfo#info)", "void org.jfree.chart.plot.CategoryPlot#zoom(double#percent)", "void org.jfree.chart.plot.CategoryPlot#datasetChanged(DatasetChangeEvent#event)", "void org.jfree.chart.plot.CategoryPlot#rendererChanged(RendererChangeEvent#event)", "void org.jfree.chart.plot.CategoryPlot#addDomainMarker(CategoryMarker#marker)", "void org.jfree.chart.plot.CategoryPlot#addDomainMarker(CategoryMarker#marker,Layer#layer)", "void org.jfree.chart.plot.CategoryPlot#addDomainMarker(int#index,CategoryMarker#marker,Layer#layer)", "void org.jfree.chart.plot.CategoryPlot#addDomainMarker(int#index,CategoryMarker#marker,Layer#layer,boolean#notify)", "void org.jfree.chart.plot.CategoryPlot#clearDomainMarkers()", "Collection org.jfree.chart.plot.CategoryPlot#getDomainMarkers(Layer#layer)", "Collection org.jfree.chart.plot.CategoryPlot#getDomainMarkers(int#index,Layer#layer)", "void org.jfree.chart.plot.CategoryPlot#clearDomainMarkers(int#index)", "boolean org.jfree.chart.plot.CategoryPlot#removeDomainMarker(Marker#marker)", "boolean org.jfree.chart.plot.CategoryPlot#removeDomainMarker(Marker#marker,Layer#layer)", "boolean org.jfree.chart.plot.CategoryPlot#removeDomainMarker(int#index,Marker#marker,Layer#layer)", "boolean org.jfree.chart.plot.CategoryPlot#removeDomainMarker(int#index,Marker#marker,Layer#layer,boolean#notify)", "void org.jfree.chart.plot.CategoryPlot#addRangeMarker(Marker#marker)", "void org.jfree.chart.plot.CategoryPlot#addRangeMarker(Marker#marker,Layer#layer)", "void org.jfree.chart.plot.CategoryPlot#addRangeMarker(int#index,Marker#marker,Layer#layer)", "void org.jfree.chart.plot.CategoryPlot#addRangeMarker(int#index,Marker#marker,Layer#layer,boolean#notify)", "void org.jfree.chart.plot.CategoryPlot#clearRangeMarkers()", "Collection org.jfree.chart.plot.CategoryPlot#getRangeMarkers(Layer#layer)", "Collection org.jfree.chart.plot.CategoryPlot#getRangeMarkers(int#index,Layer#layer)", "void org.jfree.chart.plot.CategoryPlot#clearRangeMarkers(int#index)", "boolean org.jfree.chart.plot.CategoryPlot#removeRangeMarker(Marker#marker)", "boolean org.jfree.chart.plot.CategoryPlot#removeRangeMarker(Marker#marker,Layer#layer)", "boolean org.jfree.chart.plot.CategoryPlot#removeRangeMarker(int#index,Marker#marker,Layer#layer)", "boolean org.jfree.chart.plot.CategoryPlot#removeRangeMarker(int#index,Marker#marker,Layer#layer,boolean#notify)", "boolean org.jfree.chart.plot.CategoryPlot#isRangeCrosshairVisible()", "void org.jfree.chart.plot.CategoryPlot#setRangeCrosshairVisible(boolean#flag)", "boolean org.jfree.chart.plot.CategoryPlot#isRangeCrosshairLockedOnData()", "void org.jfree.chart.plot.CategoryPlot#setRangeCrosshairLockedOnData(boolean#flag)", "double org.jfree.chart.plot.CategoryPlot#getRangeCrosshairValue()", "void org.jfree.chart.plot.CategoryPlot#setRangeCrosshairValue(double#value)", "void org.jfree.chart.plot.CategoryPlot#setRangeCrosshairValue(double#value,boolean#notify)", "Stroke org.jfree.chart.plot.CategoryPlot#getRangeCrosshairStroke()", "void org.jfree.chart.plot.CategoryPlot#setRangeCrosshairStroke(Stroke#stroke)", "Paint org.jfree.chart.plot.CategoryPlot#getRangeCrosshairPaint()", "void org.jfree.chart.plot.CategoryPlot#setRangeCrosshairPaint(Paint#paint)", "List org.jfree.chart.plot.CategoryPlot#getAnnotations()", "void org.jfree.chart.plot.CategoryPlot#addAnnotation(CategoryAnnotation#annotation)", "void org.jfree.chart.plot.CategoryPlot#addAnnotation(CategoryAnnotation#annotation,boolean#notify)", "boolean org.jfree.chart.plot.CategoryPlot#removeAnnotation(CategoryAnnotation#annotation)", "boolean org.jfree.chart.plot.CategoryPlot#removeAnnotation(CategoryAnnotation#annotation,boolean#notify)", "void org.jfree.chart.plot.CategoryPlot#clearAnnotations()", "AxisSpace org.jfree.chart.plot.CategoryPlot#calculateDomainAxisSpace(Graphics2D#g2,Rectangle2D#plotArea,AxisSpace#space)", "AxisSpace org.jfree.chart.plot.CategoryPlot#calculateRangeAxisSpace(Graphics2D#g2,Rectangle2D#plotArea,AxisSpace#space)", "AxisSpace org.jfree.chart.plot.CategoryPlot#calculateAxisSpace(Graphics2D#g2,Rectangle2D#plotArea)", "void org.jfree.chart.plot.CategoryPlot#draw(Graphics2D#g2,Rectangle2D#area,Point2D#anchor,PlotState#parentState,PlotRenderingInfo#state)", "void org.jfree.chart.plot.CategoryPlot#drawBackground(Graphics2D#g2,Rectangle2D#area)", "Map org.jfree.chart.plot.CategoryPlot#drawAxes(Graphics2D#g2,Rectangle2D#plotArea,Rectangle2D#dataArea,PlotRenderingInfo#plotState)", "boolean org.jfree.chart.plot.CategoryPlot#render(Graphics2D#g2,Rectangle2D#dataArea,int#index,PlotRenderingInfo#info)", "void org.jfree.chart.plot.CategoryPlot#drawDomainGridlines(Graphics2D#g2,Rectangle2D#dataArea)", "void org.jfree.chart.plot.CategoryPlot#drawRangeGridlines(Graphics2D#g2,Rectangle2D#dataArea,List#ticks)", "void org.jfree.chart.plot.CategoryPlot#drawAnnotations(Graphics2D#g2,Rectangle2D#dataArea,PlotRenderingInfo#info)", "void org.jfree.chart.plot.CategoryPlot#drawDomainMarkers(Graphics2D#g2,Rectangle2D#dataArea,int#index,Layer#layer)", "void org.jfree.chart.plot.CategoryPlot#drawRangeMarkers(Graphics2D#g2,Rectangle2D#dataArea,int#index,Layer#layer)", "void org.jfree.chart.plot.CategoryPlot#drawRangeLine(Graphics2D#g2,Rectangle2D#dataArea,double#value,Stroke#stroke,Paint#paint)", "void org.jfree.chart.plot.CategoryPlot#drawRangeCrosshair(Graphics2D#g2,Rectangle2D#dataArea,PlotOrientation#orientation,double#value,ValueAxis#axis,Stroke#stroke,Paint#paint)", "Range org.jfree.chart.plot.CategoryPlot#getDataRange(ValueAxis#axis)", "List org.jfree.chart.plot.CategoryPlot#datasetsMappedToDomainAxis(int#axisIndex)", "List org.jfree.chart.plot.CategoryPlot#datasetsMappedToRangeAxis(int#index)", "int org.jfree.chart.plot.CategoryPlot#getWeight()", "void org.jfree.chart.plot.CategoryPlot#setWeight(int#weight)", "AxisSpace org.jfree.chart.plot.CategoryPlot#getFixedDomainAxisSpace()", "void org.jfree.chart.plot.CategoryPlot#setFixedDomainAxisSpace(AxisSpace#space)", "void org.jfree.chart.plot.CategoryPlot#setFixedDomainAxisSpace(AxisSpace#space,boolean#notify)", "AxisSpace org.jfree.chart.plot.CategoryPlot#getFixedRangeAxisSpace()", "void org.jfree.chart.plot.CategoryPlot#setFixedRangeAxisSpace(AxisSpace#space)", "void org.jfree.chart.plot.CategoryPlot#setFixedRangeAxisSpace(AxisSpace#space,boolean#notify)", "List org.jfree.chart.plot.CategoryPlot#getCategories()", "List org.jfree.chart.plot.CategoryPlot#getCategoriesForAxis(CategoryAxis#axis)", "boolean org.jfree.chart.plot.CategoryPlot#getDrawSharedDomainAxis()", "void org.jfree.chart.plot.CategoryPlot#setDrawSharedDomainAxis(boolean#draw)", "boolean org.jfree.chart.plot.CategoryPlot#isDomainZoomable()", "boolean org.jfree.chart.plot.CategoryPlot#isRangeZoomable()", "void org.jfree.chart.plot.CategoryPlot#zoomDomainAxes(double#factor,PlotRenderingInfo#state,Point2D#source)", "void org.jfree.chart.plot.CategoryPlot#zoomDomainAxes(double#lowerPercent,double#upperPercent,PlotRenderingInfo#state,Point2D#source)", "void org.jfree.chart.plot.CategoryPlot#zoomDomainAxes(double#factor,PlotRenderingInfo#info,Point2D#source,boolean#useAnchor)", "void org.jfree.chart.plot.CategoryPlot#zoomRangeAxes(double#factor,PlotRenderingInfo#state,Point2D#source)", "void org.jfree.chart.plot.CategoryPlot#zoomRangeAxes(double#factor,PlotRenderingInfo#info,Point2D#source,boolean#useAnchor)", "void org.jfree.chart.plot.CategoryPlot#zoomRangeAxes(double#lowerPercent,double#upperPercent,PlotRenderingInfo#state,Point2D#source)", "double org.jfree.chart.plot.CategoryPlot#getAnchorValue()", "void org.jfree.chart.plot.CategoryPlot#setAnchorValue(double#value)", "void org.jfree.chart.plot.CategoryPlot#setAnchorValue(double#value,boolean#notify)", "boolean org.jfree.chart.plot.CategoryPlot#equals(Object#obj)", "Object org.jfree.chart.plot.CategoryPlot#clone()", "void org.jfree.chart.plot.CategoryPlot#writeObject(ObjectOutputStream#stream)", "void org.jfree.chart.plot.CategoryPlot#readObject(ObjectInputStream#stream)"], "other_methods": ["public String getPlotType();", "public PlotOrientation getOrientation();", "public void setOrientation(PlotOrientation orientation);", "public RectangleInsets getAxisOffset();", "public void setAxisOffset(RectangleInsets offset);", "public CategoryAxis getDomainAxis();", "public CategoryAxis getDomainAxis(int index);", "public void setDomainAxis(CategoryAxis axis);", "public void setDomainAxis(int index,CategoryAxis axis);", "public void setDomainAxis(int index,CategoryAxis axis,boolean notify);", "public void setDomainAxes(CategoryAxis[] axes);", "public int getDomainAxisIndex(CategoryAxis axis);", "public AxisLocation getDomainAxisLocation();", "public AxisLocation getDomainAxisLocation(int index);", "public void setDomainAxisLocation(AxisLocation location);", "public void setDomainAxisLocation(AxisLocation location,boolean notify);", "public void setDomainAxisLocation(int index,AxisLocation location);", "public void setDomainAxisLocation(int index,AxisLocation location,boolean notify);", "public RectangleEdge getDomainAxisEdge();", "public RectangleEdge getDomainAxisEdge(int index);", "public int getDomainAxisCount();", "public void clearDomainAxes();", "public void configureDomainAxes();", "public ValueAxis getRangeAxis();", "public ValueAxis getRangeAxis(int index);", "public void setRangeAxis(ValueAxis axis);", "public void setRangeAxis(int index,ValueAxis axis);", "public void setRangeAxis(int index,ValueAxis axis,boolean notify);", "public void setRangeAxes(ValueAxis[] axes);", "public int getRangeAxisIndex(ValueAxis axis);", "public AxisLocation getRangeAxisLocation();", "public AxisLocation getRangeAxisLocation(int index);", "public void setRangeAxisLocation(AxisLocation location);", "public void setRangeAxisLocation(AxisLocation location,boolean notify);", "public void setRangeAxisLocation(int index,AxisLocation location);", "public void setRangeAxisLocation(int index,AxisLocation location,boolean notify);", "public RectangleEdge getRangeAxisEdge();", "public RectangleEdge getRangeAxisEdge(int index);", "public int getRangeAxisCount();", "public void clearRangeAxes();", "public void configureRangeAxes();", "public CategoryDataset getDataset();", "public CategoryDataset getDataset(int index);", "public void setDataset(CategoryDataset dataset);", "public void setDataset(int index,CategoryDataset dataset);", "public int getDatasetCount();", "public void mapDatasetToDomainAxis(int index,int axisIndex);", "public CategoryAxis getDomainAxisForDataset(int index);", "public void mapDatasetToRangeAxis(int index,int axisIndex);", "public ValueAxis getRangeAxisForDataset(int index);", "public CategoryItemRenderer getRenderer();", "public CategoryItemRenderer getRenderer(int index);", "public void setRenderer(CategoryItemRenderer renderer);", "public void setRenderer(CategoryItemRenderer renderer,boolean notify);", "public void setRenderer(int index,CategoryItemRenderer renderer);", "public void setRenderer(int index,CategoryItemRenderer renderer,boolean notify);", "public void setRenderers(CategoryItemRenderer[] renderers);", "public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset);", "public int getIndexOf(CategoryItemRenderer renderer);", "public DatasetRenderingOrder getDatasetRenderingOrder();", "public void setDatasetRenderingOrder(DatasetRenderingOrder order);", "public SortOrder getColumnRenderingOrder();", "public void setColumnRenderingOrder(SortOrder order);", "public SortOrder getRowRenderingOrder();", "public void setRowRenderingOrder(SortOrder order);", "public boolean isDomainGridlinesVisible();", "public void setDomainGridlinesVisible(boolean visible);", "public CategoryAnchor getDomainGridlinePosition();", "public void setDomainGridlinePosition(CategoryAnchor position);", "public Stroke getDomainGridlineStroke();", "public void setDomainGridlineStroke(Stroke stroke);", "public Paint getDomainGridlinePaint();", "public void setDomainGridlinePaint(Paint paint);", "public boolean isRangeGridlinesVisible();", "public void setRangeGridlinesVisible(boolean visible);", "public Stroke getRangeGridlineStroke();", "public void setRangeGridlineStroke(Stroke stroke);", "public Paint getRangeGridlinePaint();", "public void setRangeGridlinePaint(Paint paint);", "public LegendItemCollection getFixedLegendItems();", "public void setFixedLegendItems(LegendItemCollection items);", "public LegendItemCollection getLegendItems();", "public void handleClick(int x,int y,PlotRenderingInfo info);", "public void zoom(double percent);", "public void datasetChanged(DatasetChangeEvent event);", "public void rendererChanged(RendererChangeEvent event);", "public void addDomainMarker(CategoryMarker marker);", "public void addDomainMarker(CategoryMarker marker,Layer layer);", "public void addDomainMarker(int index,CategoryMarker marker,Layer layer);", "public void addDomainMarker(int index,CategoryMarker marker,Layer layer,boolean notify);", "public void clearDomainMarkers();", "public Collection getDomainMarkers(Layer layer);", "public Collection getDomainMarkers(int index,Layer layer);", "public void clearDomainMarkers(int index);", "public boolean removeDomainMarker(Marker marker);", "public boolean removeDomainMarker(Marker marker,Layer layer);", "public boolean removeDomainMarker(int index,Marker marker,Layer layer);", "public boolean removeDomainMarker(int index,Marker marker,Layer layer,boolean notify);", "public void addRangeMarker(Marker marker);", "public void addRangeMarker(Marker marker,Layer layer);", "public void addRangeMarker(int index,Marker marker,Layer layer);", "public void addRangeMarker(int index,Marker marker,Layer layer,boolean notify);", "public void clearRangeMarkers();", "public Collection getRangeMarkers(Layer layer);", "public Collection getRangeMarkers(int index,Layer layer);", "public void clearRangeMarkers(int index);", "public boolean removeRangeMarker(Marker marker);", "public boolean removeRangeMarker(Marker marker,Layer layer);", "public boolean removeRangeMarker(int index,Marker marker,Layer layer);", "public boolean removeRangeMarker(int index,Marker marker,Layer layer,boolean notify);", "public boolean isRangeCrosshairVisible();", "public void setRangeCrosshairVisible(boolean flag);", "public boolean isRangeCrosshairLockedOnData();", "public void setRangeCrosshairLockedOnData(boolean flag);", "public double getRangeCrosshairValue();", "public void setRangeCrosshairValue(double value);", "public void setRangeCrosshairValue(double value,boolean notify);", "public Stroke getRangeCrosshairStroke();", "public void setRangeCrosshairStroke(Stroke stroke);", "public Paint getRangeCrosshairPaint();", "public void setRangeCrosshairPaint(Paint paint);", "public List getAnnotations();", "public void addAnnotation(CategoryAnnotation annotation);", "public void addAnnotation(CategoryAnnotation annotation,boolean notify);", "public boolean removeAnnotation(CategoryAnnotation annotation);", "public boolean removeAnnotation(CategoryAnnotation annotation,boolean notify);", "public void clearAnnotations();", "public void draw(Graphics2D g2,Rectangle2D area,Point2D anchor,PlotState parentState,PlotRenderingInfo state);", "public void drawBackground(Graphics2D g2,Rectangle2D area);", "public boolean render(Graphics2D g2,Rectangle2D dataArea,int index,PlotRenderingInfo info);", "public Range getDataRange(ValueAxis axis);", "public int getWeight();", "public void setWeight(int weight);", "public AxisSpace getFixedDomainAxisSpace();", "public void setFixedDomainAxisSpace(AxisSpace space);", "public void setFixedDomainAxisSpace(AxisSpace space,boolean notify);", "public AxisSpace getFixedRangeAxisSpace();", "public void setFixedRangeAxisSpace(AxisSpace space);", "public void setFixedRangeAxisSpace(AxisSpace space,boolean notify);", "public List getCategories();", "public List getCategoriesForAxis(CategoryAxis axis);", "public boolean getDrawSharedDomainAxis();", "public void setDrawSharedDomainAxis(boolean draw);", "public boolean isDomainZoomable();", "public boolean isRangeZoomable();", "public void zoomDomainAxes(double factor,PlotRenderingInfo state,Point2D source);", "public void zoomDomainAxes(double lowerPercent,double upperPercent,PlotRenderingInfo state,Point2D source);", "public void zoomDomainAxes(double factor,PlotRenderingInfo info,Point2D source,boolean useAnchor);", "public void zoomRangeAxes(double factor,PlotRenderingInfo state,Point2D source);", "public void zoomRangeAxes(double factor,PlotRenderingInfo info,Point2D source,boolean useAnchor);", "public void zoomRangeAxes(double lowerPercent,double upperPercent,PlotRenderingInfo state,Point2D source);", "public double getAnchorValue();", "public void setAnchorValue(double value);", "public void setAnchorValue(double value,boolean notify);", "public boolean equals(Object obj);", "public Object clone();"], "fields_dict": {"long#serialVersionUID": "private static final long serialVersionUID = -3537691700434728188L", "boolean#DEFAULT_DOMAIN_GRIDLINES_VISIBLE": "public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false", "boolean#DEFAULT_RANGE_GRIDLINES_VISIBLE": "public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true", "Stroke#DEFAULT_GRIDLINE_STROKE": "public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] \n            {2.0f, 2.0f}, 0.0f)", "Paint#DEFAULT_GRIDLINE_PAINT": "public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE", "Font#DEFAULT_VALUE_LABEL_FONT": "public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10)", "boolean#DEFAULT_CROSSHAIR_VISIBLE": "public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false", "Stroke#DEFAULT_CROSSHAIR_STROKE": "public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE", "Paint#DEFAULT_CROSSHAIR_PAINT": "public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue", "ResourceBundle#localizationResources": "protected static ResourceBundle localizationResources = ResourceBundle.getBundle(\n            \"org.jfree.chart.plot.LocalizationBundle\")", "PlotOrientation#orientation": "private PlotOrientation orientation", "RectangleInsets#axisOffset": "private RectangleInsets axisOffset", "ObjectList#domainAxes": "private ObjectList domainAxes", "ObjectList#domainAxisLocations": "private ObjectList domainAxisLocations", "boolean#drawSharedDomainAxis": "private boolean drawSharedDomainAxis", "ObjectList#rangeAxes": "private ObjectList rangeAxes", "ObjectList#rangeAxisLocations": "private ObjectList rangeAxisLocations", "ObjectList#datasets": "private ObjectList datasets", "ObjectList#datasetToDomainAxisMap": "private ObjectList datasetToDomainAxisMap", "ObjectList#datasetToRangeAxisMap": "private ObjectList datasetToRangeAxisMap", "ObjectList#renderers": "private ObjectList renderers", "DatasetRenderingOrder#renderingOrder": "private DatasetRenderingOrder renderingOrder = DatasetRenderingOrder.REVERSE", "SortOrder#columnRenderingOrder": "private SortOrder columnRenderingOrder = SortOrder.ASCENDING", "SortOrder#rowRenderingOrder": "private SortOrder rowRenderingOrder = SortOrder.ASCENDING", "boolean#domainGridlinesVisible": "private boolean domainGridlinesVisible", "CategoryAnchor#domainGridlinePosition": "private CategoryAnchor domainGridlinePosition", "Stroke#domainGridlineStroke": "private transient Stroke domainGridlineStroke", "Paint#domainGridlinePaint": "private transient Paint domainGridlinePaint", "boolean#rangeGridlinesVisible": "private boolean rangeGridlinesVisible", "Stroke#rangeGridlineStroke": "private transient Stroke rangeGridlineStroke", "Paint#rangeGridlinePaint": "private transient Paint rangeGridlinePaint", "double#anchorValue": "private double anchorValue", "boolean#rangeCrosshairVisible": "private boolean rangeCrosshairVisible", "double#rangeCrosshairValue": "private double rangeCrosshairValue", "Stroke#rangeCrosshairStroke": "private transient Stroke rangeCrosshairStroke", "Paint#rangeCrosshairPaint": "private transient Paint rangeCrosshairPaint", "boolean#rangeCrosshairLockedOnData": "private boolean rangeCrosshairLockedOnData = true", "Map#foregroundDomainMarkers": "private Map foregroundDomainMarkers", "Map#backgroundDomainMarkers": "private Map backgroundDomainMarkers", "Map#foregroundRangeMarkers": "private Map foregroundRangeMarkers", "Map#backgroundRangeMarkers": "private Map backgroundRangeMarkers", "List#annotations": "private List annotations", "int#weight": "private int weight", "AxisSpace#fixedDomainAxisSpace": "private AxisSpace fixedDomainAxisSpace", "AxisSpace#fixedRangeAxisSpace": "private AxisSpace fixedRangeAxisSpace", "LegendItemCollection#fixedLegendItems": "private LegendItemCollection fixedLegendItems"}, "text": "/* ===========================================================\n * JFreeChart : a free chart library for the Java(tm) platform\n * ===========================================================\n *\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Project Info:  http://www.jfree.org/jfreechart/index.html\n *\n * This library is free software; you can redistribute it and/or modify it \n * under the terms of the GNU Lesser General Public License as published by \n * the Free Software Foundation; either version 2.1 of the License, or \n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but \n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY \n * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public \n * License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, \n * USA.  \n *\n * [Java is a trademark or registered trademark of Sun Microsystems, Inc. \n * in the United States and other countries.]\n *\n * -----------------\n * CategoryPlot.java\n * -----------------\n * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.\n *\n * Original Author:  David Gilbert (for Object Refinery Limited);\n * Contributor(s):   Jeremy Bowman;\n *                   Arnaud Lelievre;\n *                   Richard West, Advanced Micro Devices, Inc.;\n *\n * Changes (from 21-Jun-2001)\n * --------------------------\n * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG);\n * 21-Aug-2001 : Added standard header. Fixed DOS encoding problem (DG);\n * 18-Sep-2001 : Updated header (DG);\n * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG);\n * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG);\n * 23-Oct-2001 : Changed intro and trail gaps on bar plots to use percentage of \n *               available space rather than a fixed number of units (DG);\n * 12-Dec-2001 : Changed constructors to protected (DG);\n * 13-Dec-2001 : Added tooltips (DG);\n * 16-Jan-2002 : Increased maximum intro and trail gap percents, plus added \n *               some argument checking code.  Thanks to Taoufik Romdhane for \n *               suggesting this (DG);\n * 05-Feb-2002 : Added accessor methods for the tooltip generator, incorporated\n *               alpha-transparency for Plot and subclasses (DG);\n * 06-Mar-2002 : Updated import statements (DG);\n * 14-Mar-2002 : Renamed BarPlot.java --> CategoryPlot.java, and changed code \n *               to use the CategoryItemRenderer interface (DG);\n * 22-Mar-2002 : Dropped the getCategories() method (DG);\n * 23-Apr-2002 : Moved the dataset from the JFreeChart class to the Plot \n *               class (DG);\n * 29-Apr-2002 : New methods to support printing values at the end of bars, \n *               contributed by Jeremy Bowman (DG);\n * 11-May-2002 : New methods for label visibility and overlaid plot support, \n *               contributed by Jeremy Bowman (DG);\n * 06-Jun-2002 : Removed the tooltip generator, this is now stored with the \n *               renderer.  Moved constants into the CategoryPlotConstants \n *               interface.  Updated Javadoc comments (DG);\n * 10-Jun-2002 : Overridden datasetChanged() method to update the upper and \n *               lower bound on the range axis (if necessary), updated \n *               Javadocs (DG);\n * 25-Jun-2002 : Removed redundant imports (DG);\n * 20-Aug-2002 : Changed the constructor for Marker (DG);\n * 28-Aug-2002 : Added listener notification to setDomainAxis() and \n *               setRangeAxis() (DG);\n * 23-Sep-2002 : Added getLegendItems() method and fixed errors reported by \n *               Checkstyle (DG);\n * 28-Oct-2002 : Changes to the CategoryDataset interface (DG);\n * 05-Nov-2002 : Base dataset is now TableDataset not CategoryDataset (DG);\n * 07-Nov-2002 : Renamed labelXXX as valueLabelXXX (DG);\n * 18-Nov-2002 : Added grid settings for both domain and range axis (previously\n *               these were set in the axes) (DG);\n * 19-Nov-2002 : Added axis location parameters to constructor (DG);\n * 17-Jan-2003 : Moved to com.jrefinery.chart.plot package (DG);\n * 14-Feb-2003 : Fixed bug in auto-range calculation for secondary axis (DG);\n * 26-Mar-2003 : Implemented Serializable (DG);\n * 02-May-2003 : Moved render() method up from subclasses. Added secondary \n *               range markers. Added an attribute to control the dataset \n *               rendering order.  Added a drawAnnotations() method.  Changed \n *               the axis location from an int to an AxisLocation (DG);\n * 07-May-2003 : Merged HorizontalCategoryPlot and VerticalCategoryPlot into \n *               this class (DG);\n * 02-Jun-2003 : Removed check for range axis compatibility (DG);\n * 04-Jul-2003 : Added a domain gridline position attribute (DG);\n * 21-Jul-2003 : Moved DrawingSupplier to Plot superclass (DG);\n * 19-Aug-2003 : Added equals() method and implemented Cloneable (DG);\n * 01-Sep-2003 : Fixed bug 797466 (no change event when secondary dataset \n *               changes) (DG);\n * 02-Sep-2003 : Fixed bug 795209 (wrong dataset checked in render2 method) and\n *               790407 (initialise method) (DG);\n * 08-Sep-2003 : Added internationalization via use of properties \n *               resourceBundle (RFE 690236) (AL); \n * 08-Sep-2003 : Fixed bug (wrong secondary range axis being used).  Changed \n *               ValueAxis API (DG);\n * 10-Sep-2003 : Fixed bug in setRangeAxis() method (DG);\n * 15-Sep-2003 : Fixed two bugs in serialization, implemented \n *               PublicCloneable (DG);\n * 23-Oct-2003 : Added event notification for changes to renderer (DG);\n * 26-Nov-2003 : Fixed bug (849645) in clearRangeMarkers() method (DG);\n * 03-Dec-2003 : Modified draw method to accept anchor (DG);\n * 21-Jan-2004 : Update for renamed method in ValueAxis (DG);\n * 10-Mar-2004 : Fixed bug in axis range calculation when secondary renderer is\n *               stacked (DG);\n * 12-May-2004 : Added fixed legend items (DG);\n * 19-May-2004 : Added check for null legend item from renderer (DG);\n * 02-Jun-2004 : Updated the DatasetRenderingOrder class (DG);\n * 05-Nov-2004 : Renamed getDatasetsMappedToRangeAxis() \n *               --> datasetsMappedToRangeAxis(), and ensured that returned \n *               list doesn't contain null datasets (DG);\n * 12-Nov-2004 : Implemented new Zoomable interface (DG);\n * 07-Jan-2005 : Renamed getRangeExtent() --> findRangeBounds() in \n *               CategoryItemRenderer (DG);\n * 04-May-2005 : Fixed serialization of range markers (DG);\n * 05-May-2005 : Updated draw() method parameters (DG);\n * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per\n *               RFE 1183100 (DG);\n * 01-Jun-2005 : Upon deserialization, register plot as a listener with its\n *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG);\n * 02-Jun-2005 : Added support for domain markers (DG);\n * 06-Jun-2005 : Fixed equals() method for use with GradientPaint (DG);\n * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG);\n * 16-Jun-2005 : Added getDomainAxisCount() and getRangeAxisCount() methods, to\n *               match XYPlot (see RFE 1220495) (DG);\n * ------------- JFREECHART 1.0.x ---------------------------------------------\n * 11-Jan-2006 : Added configureRangeAxes() to rendererChanged(), since the\n *               renderer might influence the axis range (DG);\n * 27-Jan-2006 : Added various null argument checks (DG);\n * 18-Aug-2006 : Added getDatasetCount() method, plus a fix for bug drawing \n *               category labels, thanks to Adriaan Joubert (1277726) (DG);\n * 05-Sep-2006 : Added MarkerChangeEvent support (DG);\n * 30-Oct-2006 : Added getDomainAxisIndex(), datasetsMappedToDomainAxis() and \n *               getCategoriesForAxis() methods (DG);\n * 22-Nov-2006 : Fire PlotChangeEvent from setColumnRenderingOrder() and\n *               setRowRenderingOrder() (DG);\n * 29-Nov-2006 : Fix for bug 1605207 (IntervalMarker exceeds bounds of data \n *               area) (DG);\n * 26-Feb-2007 : Fix for bug 1669218 (setDomainAxisLocation() notify argument\n *               ignored) (DG);\n * 13-Mar-2007 : Added null argument checks for setRangeCrosshairPaint() and\n *               setRangeCrosshairStroke(), fixed clipping for \n *               annotations (DG);\n * 07-Jun-2007 : Override drawBackground() for new GradientPaint handling (DG);\n * 21-Jun-2007 : Removed JCommon dependencies (DG);\n * 06-Jul-2007 : Updated annotation handling (DG);\n * 10-Jul-2007 : Added getRangeAxisIndex(ValueAxis) method (DG);\n * 24-Sep-2007 : Implemented new zoom methods (DG);\n * 25-Oct-2007 : Added some argument checks (DG);\n * 05-Nov-2007 : Applied patch 1823697, by Richard West, for removal of domain\n *               and range markers (DG);\n * 14-Nov-2007 : Added missing event notifications (DG);\n * 25-Mar-2008 : Added new methods with optional notification - see patch\n *               1913751 (DG);\n * 07-Apr-2008 : Fixed NPE in removeDomainMarker() and \n *               removeRangeMarker() (DG);\n * \n *\n */\n\npackage org.jfree.chart.plot;\n\nimport java.awt.AlphaComposite;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Composite;\nimport java.awt.Font;\nimport java.awt.Graphics2D;\nimport java.awt.Paint;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\n\nimport org.jfree.chart.LegendItem;\nimport org.jfree.chart.LegendItemCollection;\nimport org.jfree.chart.annotations.CategoryAnnotation;\nimport org.jfree.chart.axis.Axis;\nimport org.jfree.chart.axis.AxisCollection;\nimport org.jfree.chart.axis.AxisLocation;\nimport org.jfree.chart.axis.AxisSpace;\nimport org.jfree.chart.axis.AxisState;\nimport org.jfree.chart.axis.CategoryAnchor;\nimport org.jfree.chart.axis.CategoryAxis;\nimport org.jfree.chart.axis.ValueAxis;\nimport org.jfree.chart.axis.ValueTick;\nimport org.jfree.chart.event.ChartChangeEventType;\nimport org.jfree.chart.event.PlotChangeEvent;\nimport org.jfree.chart.event.RendererChangeEvent;\nimport org.jfree.chart.event.RendererChangeListener;\nimport org.jfree.chart.renderer.category.CategoryItemRenderer;\nimport org.jfree.chart.renderer.category.CategoryItemRendererState;\nimport org.jfree.chart.util.Layer;\nimport org.jfree.chart.util.ObjectList;\nimport org.jfree.chart.util.ObjectUtilities;\nimport org.jfree.chart.util.PaintUtilities;\nimport org.jfree.chart.util.PublicCloneable;\nimport org.jfree.chart.util.RectangleEdge;\nimport org.jfree.chart.util.RectangleInsets;\nimport org.jfree.chart.util.SerialUtilities;\nimport org.jfree.chart.util.SortOrder;\nimport org.jfree.data.Range;\nimport org.jfree.data.category.CategoryDataset;\nimport org.jfree.data.general.Dataset;\nimport org.jfree.data.general.DatasetChangeEvent;\nimport org.jfree.data.general.DatasetUtilities;\n\n/**\n * A general plotting class that uses data from a {@link CategoryDataset} and \n * renders each data item using a {@link CategoryItemRenderer}.\n */\npublic class CategoryPlot extends Plot implements ValueAxisPlot, \n        Zoomable, RendererChangeListener, Cloneable, PublicCloneable, \n        Serializable {\n\n    /** For serialization. */\n    private static final long serialVersionUID = -3537691700434728188L;\n    \n    /** \n     * The default visibility of the grid lines plotted against the domain \n     * axis. \n     */\n    public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false;\n\n    /** \n     * The default visibility of the grid lines plotted against the range \n     * axis. \n     */\n    public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true;\n\n    /** The default grid line stroke. */\n    public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke(0.5f,\n            BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0.0f, new float[] \n            {2.0f, 2.0f}, 0.0f);\n\n    /** The default grid line paint. */\n    public static final Paint DEFAULT_GRIDLINE_PAINT = Color.WHITE;\n\n    /** The default value label font. */\n    public static final Font DEFAULT_VALUE_LABEL_FONT = new Font(\"SansSerif\", \n            Font.PLAIN, 10);\n\n    /** \n     * The default crosshair visibility. \n     * \n     * @since 1.0.5\n     */\n    public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false;\n\n    /** \n     * The default crosshair stroke. \n     * \n     * @since 1.0.5\n     */\n    public static final Stroke DEFAULT_CROSSHAIR_STROKE\n            = DEFAULT_GRIDLINE_STROKE;\n\n    /** \n     * The default crosshair paint. \n     * \n     * @since 1.0.5\n     */\n    public static final Paint DEFAULT_CROSSHAIR_PAINT = Color.blue;\n\n    /** The resourceBundle for the localization. */\n    protected static ResourceBundle localizationResources \n            = ResourceBundle.getBundle(\n            \"org.jfree.chart.plot.LocalizationBundle\");\n\n    /** The plot orientation. */\n    private PlotOrientation orientation;\n\n    /** The offset between the data area and the axes. */\n    private RectangleInsets axisOffset;\n\n    /** Storage for the domain axes. */\n    private ObjectList domainAxes;\n\n    /** Storage for the domain axis locations. */\n    private ObjectList domainAxisLocations;\n\n    /**\n     * A flag that controls whether or not the shared domain axis is drawn \n     * (only relevant when the plot is being used as a subplot).\n     */\n    private boolean drawSharedDomainAxis;\n\n    /** Storage for the range axes. */\n    private ObjectList rangeAxes;\n\n    /** Storage for the range axis locations. */\n    private ObjectList rangeAxisLocations;\n\n    /** Storage for the datasets. */\n    private ObjectList datasets;\n\n    /** Storage for keys that map datasets to domain axes. */\n    private ObjectList datasetToDomainAxisMap;\n    \n    /** Storage for keys that map datasets to range axes. */\n    private ObjectList datasetToRangeAxisMap;\n\n    /** Storage for the renderers. */\n    private ObjectList renderers;\n\n    /** The dataset rendering order. */\n    private DatasetRenderingOrder renderingOrder \n            = DatasetRenderingOrder.REVERSE;\n\n    /** \n     * Controls the order in which the columns are traversed when rendering the \n     * data items. \n     */\n    private SortOrder columnRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * Controls the order in which the rows are traversed when rendering the \n     * data items. \n     */\n    private SortOrder rowRenderingOrder = SortOrder.ASCENDING;\n    \n    /** \n     * A flag that controls whether the grid-lines for the domain axis are \n     * visible. \n     */\n    private boolean domainGridlinesVisible;\n\n    /** The position of the domain gridlines relative to the category. */\n    private CategoryAnchor domainGridlinePosition;\n\n    /** The stroke used to draw the domain grid-lines. */\n    private transient Stroke domainGridlineStroke;\n\n    /** The paint used to draw the domain  grid-lines. */\n    private transient Paint domainGridlinePaint;\n\n    /** \n     * A flag that controls whether the grid-lines for the range axis are \n     * visible. \n     */\n    private boolean rangeGridlinesVisible;\n\n    /** The stroke used to draw the range axis grid-lines. */\n    private transient Stroke rangeGridlineStroke;\n\n    /** The paint used to draw the range axis grid-lines. */\n    private transient Paint rangeGridlinePaint;\n\n    /** The anchor value. */\n    private double anchorValue;\n\n    /** A flag that controls whether or not a range crosshair is drawn. */\n    private boolean rangeCrosshairVisible;\n\n    /** The range crosshair value. */\n    private double rangeCrosshairValue;\n\n    /** The pen/brush used to draw the crosshair (if any). */\n    private transient Stroke rangeCrosshairStroke;\n\n    /** The color used to draw the crosshair (if any). */\n    private transient Paint rangeCrosshairPaint;\n\n    /** \n     * A flag that controls whether or not the crosshair locks onto actual \n     * data points. \n     */\n    private boolean rangeCrosshairLockedOnData = true;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map foregroundDomainMarkers;\n\n    /** A map containing lists of markers for the domain axes. */\n    private Map backgroundDomainMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map foregroundRangeMarkers;\n\n    /** A map containing lists of markers for the range axes. */\n    private Map backgroundRangeMarkers;\n\n    /** \n     * A (possibly empty) list of annotations for the plot.  The list should\n     * be initialised in the constructor and never allowed to be \n     * <code>null</code>.\n     */\n    private List annotations;\n\n    /**\n     * The weight for the plot (only relevant when the plot is used as a subplot\n     * within a combined plot).\n     */\n    private int weight;\n\n    /** The fixed space for the domain axis. */\n    private AxisSpace fixedDomainAxisSpace;\n\n    /** The fixed space for the range axis. */\n    private AxisSpace fixedRangeAxisSpace;\n\n    /** \n     * An optional collection of legend items that can be returned by the \n     * getLegendItems() method. \n     */\n    private LegendItemCollection fixedLegendItems;\n    \n    /**\n     * Default constructor.\n     */\n    public CategoryPlot() {\n        this(null, null, null, null);\n    }\n\n    /**\n     * Creates a new plot.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * @param domainAxis  the domain axis (<code>null</code> permitted).\n     * @param rangeAxis  the range axis (<code>null</code> permitted).\n     * @param renderer  the item renderer (<code>null</code> permitted).\n     *\n     */\n    public CategoryPlot(CategoryDataset dataset,\n                        CategoryAxis domainAxis,\n                        ValueAxis rangeAxis,\n                        CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n\n        // allocate storage for dataset, axes and renderers\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        \n        this.datasetToDomainAxisMap = new ObjectList();\n        this.datasetToRangeAxisMap = new ObjectList();\n\n        this.renderers = new ObjectList();\n\n        this.datasets = new ObjectList();\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis = false;\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, \n                0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, \n                0.5f), new BasicStroke(1.0f), 0.6f);\n        addRangeMarker(baseline, Layer.BACKGROUND);\n\n        this.anchorValue = 0.0;\n\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n        \n        this.annotations = new java.util.ArrayList();\n\n    }\n    \n    /**\n     * Returns a string describing the type of plot.\n     *\n     * @return The type.\n     */\n    public String getPlotType() {\n        return localizationResources.getString(\"Category_Plot\");\n    }\n\n    /**\n     * Returns the orientation of the plot.\n     *\n     * @return The orientation of the plot (never <code>null</code>).\n     * \n     * @see #setOrientation(PlotOrientation)\n     */\n    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }\n\n    /**\n     * Sets the orientation for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param orientation  the orientation (<code>null</code> not permitted).\n     * \n     * @see #getOrientation()\n     */\n    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        this.orientation = orientation;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the axis offset.\n     *\n     * @return The axis offset (never <code>null</code>).\n     * \n     * @see #setAxisOffset(RectangleInsets)\n     */\n    public RectangleInsets getAxisOffset() {\n        return this.axisOffset;\n    }\n\n    /**\n     * Sets the axis offsets (gap between the data area and the axes) and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param offset  the offset (<code>null</code> not permitted).\n     * \n     * @see #getAxisOffset()\n     */\n    public void setAxisOffset(RectangleInsets offset) {\n        if (offset == null) {\n            throw new IllegalArgumentException(\"Null 'offset' argument.\");   \n        }\n        this.axisOffset = offset;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the domain axis for the plot.  If the domain axis for this plot\n     * is <code>null</code>, then the method will return the parent plot's \n     * domain axis (if there is a parent plot).\n     *\n     * @return The domain axis (<code>null</code> permitted).\n     * \n     * @see #setDomainAxis(CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }\n\n    /**\n     * Returns a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     * \n     * @see #setDomainAxis(int, CategoryAxis)\n     */\n    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (CategoryAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the domain axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis()\n     */\n    public void setDomainAxis(CategoryAxis axis) {\n        setDomainAxis(0, axis);\n    }\n\n    /**\n     * Sets a domain axis and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * \n     * @see #getDomainAxis(int)\n     */\n    public void setDomainAxis(int index, CategoryAxis axis) {\n        setDomainAxis(index, axis, true);\n    }\n \n    /**\n     * Sets a domain axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     */\n    public void setDomainAxis(int index, CategoryAxis axis, boolean notify) {\n        CategoryAxis existing = (CategoryAxis) this.domainAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.domainAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the domain axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxes(ValueAxis[])\n     */\n    public void setDomainAxes(CategoryAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setDomainAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     * \n     * @param axis  the axis (<code>null</code> not permitted).\n     * \n     * @return The axis index.\n     * \n     * @see #getDomainAxis(int)\n     * @see #getRangeAxisIndex(ValueAxis)\n     * \n     * @since 1.0.3\n     */\n    public int getDomainAxisIndex(CategoryAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        return this.domainAxes.indexOf(axis);\n    }\n    \n    /**\n     * Returns the domain axis location for the primary domain axis.\n     *\n     * @return The location (never <code>null</code>).\n     * \n     * @see #getRangeAxisLocation()\n     */\n    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * \n     * @see #getDomainAxisLocation()\n     * @see #setDomainAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(0, location, true);\n    }\n\n    /**\n     * Sets the location of the domain axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the axis location (<code>null</code> not permitted).\n     * @param notify  a flag that controls whether listeners are notified.\n     */\n    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location) {\n        // delegate...\n        setDomainAxisLocation(index, location, true);\n    }\n    \n    /**\n     * Sets the location for a domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     * \n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.5\n     * \n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setDomainAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the domain axis edge.  This is derived from the axis location\n     * and the plot orientation.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a domain axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of domain axes.\n     *\n     * @return The axis count.\n     */\n    public int getDomainAxisCount() {\n        return this.domainAxes.size();\n    }\n\n    /**\n     * Clears the domain axes from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     */\n    public void clearDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.domainAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the domain axes.\n     */\n    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the range axis for the plot.  If the range axis for this plot is\n     * null, then the method will return the parent plot's range axis (if there\n     * is a parent plot).\n     *\n     * @return The range axis (possibly <code>null</code>).\n     */\n    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }\n\n    /**\n     * Returns a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The axis (<code>null</code> possible).\n     */\n    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Sets the range axis for the plot and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param axis  the axis (<code>null</code> permitted).\n     */\n    public void setRangeAxis(ValueAxis axis) {\n        setRangeAxis(0, axis);\n    }\n\n    /**\n     * Sets a range axis and sends a {@link PlotChangeEvent} to all registered\n     * listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     */\n    public void setRangeAxis(int index, ValueAxis axis) {\n        setRangeAxis(index, axis, true);\n    }\n        \n    /**\n     * Sets a range axis and, if requested, sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param axis  the axis.\n     * @param notify  notify listeners?\n     */\n    public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n        ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        if (axis != null) {\n            axis.setPlot(this);\n        }\n        this.rangeAxes.set(index, axis);\n        if (axis != null) {\n            axis.configure();\n            axis.addChangeListener(this);\n        }\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the range axes for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param axes  the axes (<code>null</code> not permitted).\n     * \n     * @see #setDomainAxes(CategoryAxis[])\n     */\n    public void setRangeAxes(ValueAxis[] axes) {\n        for (int i = 0; i < axes.length; i++) {\n            setRangeAxis(i, axes[i], false);   \n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the index of the specified axis, or <code>-1</code> if the axis\n     * is not assigned to the plot.\n     *\n     * @param axis  the axis (<code>null</code> not permitted).\n     *\n     * @return The axis index.\n     * \n     * @see #getRangeAxis(int)\n     * @see #getDomainAxisIndex(CategoryAxis)\n     * \n     * @since 1.0.7\n     */\n    public int getRangeAxisIndex(ValueAxis axis) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n        }\n        int result = this.rangeAxes.indexOf(axis);\n        if (result < 0) { // try the parent plot\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot p = (CategoryPlot) parent;\n                result = p.getRangeAxisIndex(axis);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the range axis location.\n     *\n     * @return The location (never <code>null</code>).\n     */\n    public AxisLocation getRangeAxisLocation() {\n        return getRangeAxisLocation(0);\n    }\n\n    /**\n     * Returns the location for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The location.\n     * \n     * @see #setRangeAxisLocation(int, AxisLocation)\n     */\n    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }\n\n    /**\n     * Sets the location of the range axis and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * \n     * @see #setRangeAxisLocation(AxisLocation, boolean)\n     * @see #setDomainAxisLocation(AxisLocation)\n     */\n    public void setRangeAxisLocation(AxisLocation location) {\n        // defer argument checking...\n        setRangeAxisLocation(location, true);\n    }\n\n    /**\n     * Sets the location of the range axis and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param location  the location (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #setDomainAxisLocation(AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location) {\n        setRangeAxisLocation(index, location, true);\n    }\n\n    /**\n     * Sets the location for a range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location.\n     * @param notify  notify listeners?\n     * \n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)\n     */\n    public void setRangeAxisLocation(int index, AxisLocation location, \n                                     boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the edge where the primary range axis is located.\n     *\n     * @return The edge (never <code>null</code>).\n     */\n    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }\n\n    /**\n     * Returns the edge for a range axis.\n     *\n     * @param index  the axis index.\n     *\n     * @return The edge.\n     */\n    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\n        }\n        return result;\n    }\n\n    /**\n     * Returns the number of range axes.\n     *\n     * @return The axis count.\n     */\n    public int getRangeAxisCount() {\n        return this.rangeAxes.size();\n    }\n\n    /**\n     * Clears the range axes from the plot and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     */\n    public void clearRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.removeChangeListener(this);\n            }\n        }\n        this.rangeAxes.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Configures the range axes.\n     */\n    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }\n\n    /**\n     * Returns the primary dataset for the plot.\n     *\n     * @return The primary dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(CategoryDataset)\n     */\n    public CategoryDataset getDataset() {\n        return getDataset(0);\n    }\n\n    /**\n     * Returns the dataset at the given index.\n     *\n     * @param index  the dataset index.\n     *\n     * @return The dataset (possibly <code>null</code>).\n     * \n     * @see #setDataset(int, CategoryDataset)\n     */\n    public CategoryDataset getDataset(int index) {\n        CategoryDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (CategoryDataset) this.datasets.get(index);\n        }\n        return result;\n    }\n\n    /**\n     * Sets the dataset for the plot, replacing the existing dataset, if there \n     * is one.  This method also calls the \n     * {@link #datasetChanged(DatasetChangeEvent)} method, which adjusts the \n     * axis ranges if necessary and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset()\n     */\n    public void setDataset(CategoryDataset dataset) {\n        setDataset(0, dataset);\n    }\n\n    /**\n     * Sets a dataset for the plot.\n     *\n     * @param index  the dataset index.\n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @see #getDataset(int)\n     */\n    public void setDataset(int index, CategoryDataset dataset) {\n        \n        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        this.datasets.set(index, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n        \n        // send a dataset change event to self...\n        DatasetChangeEvent event = new DatasetChangeEvent(this, dataset);\n        datasetChanged(event);\n        \n    }\n\n    /**\n     * Returns the number of datasets.\n     *\n     * @return The number of datasets.\n     * \n     * @since 1.0.2\n     */\n    public int getDatasetCount() {\n        return this.datasets.size();\n    }\n\n    /**\n     * Maps a dataset to a particular domain axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getDomainAxisForDataset(int)\n     */\n    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));  \n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the domain axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToDomainAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The domain axis.\n     * \n     * @see #mapDatasetToDomainAxis(int, int)\n     */\n    public CategoryAxis getDomainAxisForDataset(int index) {\n        CategoryAxis result = getDomainAxis();\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getDomainAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Maps a dataset to a particular range axis.\n     * \n     * @param index  the dataset index (zero-based).\n     * @param axisIndex  the axis index (zero-based).\n     * \n     * @see #getRangeAxisForDataset(int)\n     */\n    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }\n\n    /**\n     * Returns the range axis for a dataset.  You can change the axis for a \n     * dataset using the {@link #mapDatasetToRangeAxis(int, int)} method.\n     * \n     * @param index  the dataset index.\n     * \n     * @return The range axis.\n     * \n     * @see #mapDatasetToRangeAxis(int, int)\n     */\n    public ValueAxis getRangeAxisForDataset(int index) {\n        ValueAxis result = getRangeAxis();\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getRangeAxis(axisIndex.intValue());\n        }\n        return result;    \n    }\n    \n    /**\n     * Returns a reference to the renderer for the plot.\n     *\n     * @return The renderer.\n     * \n     * @see #setRenderer(CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }\n\n    /**\n     * Returns the renderer at the given index.\n     *\n     * @param index  the renderer index.\n     *\n     * @return The renderer (possibly <code>null</code>).\n     * \n     * @see #setRenderer(int, CategoryItemRenderer)\n     */\n    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (CategoryItemRenderer) this.renderers.get(index);\n        }\n        return result;\n    }\n    \n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and sends a {@link PlotChangeEvent} to all registered \n     * listeners.\n     *\n     * @param renderer  the renderer (<code>null</code> permitted.\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer) {\n        setRenderer(0, renderer, true);\n    }\n\n    /**\n     * Sets the renderer at index 0 (sometimes referred to as the \"primary\" \n     * renderer) and, if requested, sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * <p>\n     * You can set the renderer to <code>null</code>, but this is not \n     * recommended because:\n     * <ul>\n     *   <li>no data will be displayed;</li>\n     *   <li>the plot background will not be painted;</li>\n     * </ul>\n     *\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer()\n     */\n    public void setRenderer(CategoryItemRenderer renderer, boolean notify) {\n        setRenderer(0, renderer, notify);\n    }\n\n    /**\n     * Sets the renderer at the specified index and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @see #getRenderer(int)\n     * @see #setRenderer(int, CategoryItemRenderer, boolean)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer) {\n        setRenderer(index, renderer, true);   \n    }\n\n    /**\n     * Sets a renderer.  A {@link PlotChangeEvent} is sent to all registered \n     * listeners.\n     *\n     * @param index  the index.\n     * @param renderer  the renderer (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getRenderer(int)\n     */\n    public void setRenderer(int index, CategoryItemRenderer renderer, \n                            boolean notify) {\n        \n        // stop listening to the existing renderer...\n        CategoryItemRenderer existing \n            = (CategoryItemRenderer) this.renderers.get(index);\n        if (existing != null) {\n            existing.removeChangeListener(this);\n        }\n        \n        // register the new renderer...\n        this.renderers.set(index, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n        \n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Sets the renderers for this plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param renderers  the renderers.\n     */\n    public void setRenderers(CategoryItemRenderer[] renderers) {\n        for (int i = 0; i < renderers.length; i++) {\n            setRenderer(i, renderers[i], false);   \n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the renderer for the specified dataset.  If the dataset doesn't\n     * belong to the plot, this method will return <code>null</code>.\n     * \n     * @param dataset  the dataset (<code>null</code> permitted).\n     * \n     * @return The renderer (possibly <code>null</code>).\n     */\n    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\n        CategoryItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (CategoryItemRenderer) this.renderers.get(i);   \n                break;\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * Returns the index of the specified renderer, or <code>-1</code> if the\n     * renderer is not assigned to this plot.\n     * \n     * @param renderer  the renderer (<code>null</code> permitted).\n     * \n     * @return The renderer index.\n     */\n    public int getIndexOf(CategoryItemRenderer renderer) {\n        return this.renderers.indexOf(renderer);\n    }\n\n    /**\n     * Returns the dataset rendering order.\n     *\n     * @return The order (never <code>null</code>).\n     * \n     * @see #setDatasetRenderingOrder(DatasetRenderingOrder)\n     */\n    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }\n\n    /**\n     * Sets the rendering order and sends a {@link PlotChangeEvent} to all \n     * registered listeners.  By default, the plot renders the primary dataset \n     * last (so that the primary dataset overlays the secondary datasets).  You \n     * can reverse this if you want to.\n     *\n     * @param order  the rendering order (<code>null</code> not permitted).\n     * \n     * @see #getDatasetRenderingOrder()\n     */\n    public void setDatasetRenderingOrder(DatasetRenderingOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");   \n        }\n        this.renderingOrder = order;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the order in which the columns are rendered.  The default value\n     * is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The column rendering order (never <code>null</code).\n     * \n     * @see #setColumnRenderingOrder(SortOrder)\n     */    \n    public SortOrder getColumnRenderingOrder() {\n        return this.columnRenderingOrder;\n    }\n    \n    /**\n     * Sets the column order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getColumnRenderingOrder()\n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public void setColumnRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.columnRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the order in which the rows should be rendered.  The default \n     * value is <code>SortOrder.ASCENDING</code>.\n     * \n     * @return The order (never <code>null</code>).\n     * \n     * @see #setRowRenderingOrder(SortOrder)\n     */\n    public SortOrder getRowRenderingOrder() {\n        return this.rowRenderingOrder;\n    }\n\n    /**\n     * Sets the row order in which the items in each dataset should be \n     * rendered and sends a {@link PlotChangeEvent} to all registered \n     * listeners.  Note that this affects the order in which items are drawn, \n     * NOT their position in the chart.\n     * \n     * @param order  the order (<code>null</code> not permitted).\n     * \n     * @see #getRowRenderingOrder()\n     * @see #setColumnRenderingOrder(SortOrder)\n     */\n    public void setRowRenderingOrder(SortOrder order) {\n        if (order == null) {\n            throw new IllegalArgumentException(\"Null 'order' argument.\");\n        }\n        this.rowRenderingOrder = order;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the flag that controls whether the domain grid-lines are visible.\n     *\n     * @return The <code>true</code> or <code>false</code>.\n     * \n     * @see #setDomainGridlinesVisible(boolean)\n     */\n    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the domain axis.\n     * <p>\n     * If the flag value changes, a {@link PlotChangeEvent} is sent to all \n     * registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isDomainGridlinesVisible()\n     */\n    public void setDomainGridlinesVisible(boolean visible) {\n        if (this.domainGridlinesVisible != visible) {\n            this.domainGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the position used for the domain gridlines.\n     * \n     * @return The gridline position (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePosition(CategoryAnchor)\n     */\n    public CategoryAnchor getDomainGridlinePosition() {\n        return this.domainGridlinePosition;\n    }\n\n    /**\n     * Sets the position used for the domain gridlines and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @param position  the position (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePosition()\n     */\n    public void setDomainGridlinePosition(CategoryAnchor position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");   \n        }\n        this.domainGridlinePosition = position;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the stroke used to draw grid-lines against the domain axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setDomainGridlineStroke(Stroke)\n     */\n    public Stroke getDomainGridlineStroke() {\n        return this.domainGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw grid-lines against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlineStroke()\n     */\n    public void setDomainGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' not permitted.\");\n        }\n        this.domainGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw grid-lines against the domain axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setDomainGridlinePaint(Paint)\n     */\n    public Paint getDomainGridlinePaint() {\n        return this.domainGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid-lines (if any) against the domain \n     * axis and sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getDomainGridlinePaint()\n     */\n    public void setDomainGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.domainGridlinePaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the flag that controls whether the range grid-lines are visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeGridlinesVisible(boolean)\n     */\n    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }\n\n    /**\n     * Sets the flag that controls whether or not grid-lines are drawn against \n     * the range axis.  If the flag changes value, a {@link PlotChangeEvent} is \n     * sent to all registered listeners.\n     *\n     * @param visible  the new value of the flag.\n     * \n     * @see #isRangeGridlinesVisible()\n     */\n    public void setRangeGridlinesVisible(boolean visible) {\n        if (this.rangeGridlinesVisible != visible) {\n            this.rangeGridlinesVisible = visible;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the stroke used to draw the grid-lines against the range axis.\n     *\n     * @return The stroke (never <code>null</code>).\n     * \n     * @see #setRangeGridlineStroke(Stroke)\n     */\n    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }\n\n    /**\n     * Sets the stroke used to draw the grid-lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlineStroke()\n     */\n    public void setRangeGridlineStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");   \n        }\n        this.rangeGridlineStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the grid-lines against the range axis.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeGridlinePaint(Paint)\n     */\n    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }\n\n    /**\n     * Sets the paint used to draw the grid lines against the range axis and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeGridlinePaint()\n     */\n    public void setRangeGridlinePaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.rangeGridlinePaint = paint;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the fixed legend items, if any.\n     * \n     * @return The legend items (possibly <code>null</code>).\n     * \n     * @see #setFixedLegendItems(LegendItemCollection)\n     */\n    public LegendItemCollection getFixedLegendItems() {\n        return this.fixedLegendItems;   \n    }\n\n    /**\n     * Sets the fixed legend items for the plot.  Leave this set to \n     * <code>null</code> if you prefer the legend items to be created \n     * automatically.\n     * \n     * @param items  the legend items (<code>null</code> permitted).\n     * \n     * @see #getFixedLegendItems()\n     */\n    public void setFixedLegendItems(LegendItemCollection items) {\n        this.fixedLegendItems = items;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the legend items for the plot.  By default, this method creates \n     * a legend item for each series in each of the datasets.  You can change \n     * this behaviour by overriding this method.\n     *\n     * @return The legend items.\n     */\n    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = this.fixedLegendItems;\n        if (result == null) {\n            result = new LegendItemCollection();\n            // get the legend items for the datasets...\n            int count = this.datasets.size();\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n                CategoryDataset dataset = getDataset(datasetIndex);\n                if (dataset != null) {\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\n                    if (renderer != null) {\n                        int seriesCount = dataset.getRowCount();\n                        for (int i = 0; i < seriesCount; i++) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Handles a 'click' on the plot by updating the anchor value.\n     *\n     * @param x  x-coordinate of the click (in Java2D space).\n     * @param y  y-coordinate of the click (in Java2D space).\n     * @param info  information about the plot's dimensions.\n     *\n     */\n    public void handleClick(int x, int y, PlotRenderingInfo info) {\n\n        Rectangle2D dataArea = info.getDataArea();\n        if (dataArea.contains(x, y)) {\n            // set the anchor value for the range axis...\n            double java2D = 0.0;\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                java2D = x;\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                java2D = y;\n            }\n            RectangleEdge edge = Plot.resolveRangeAxisLocation(\n                    getRangeAxisLocation(), this.orientation);\n            double value = getRangeAxis().java2DToValue(\n                    java2D, info.getDataArea(), edge);\n            setAnchorValue(value);\n            setRangeCrosshairValue(value);\n        }\n\n    }\n\n    /**\n     * Zooms (in or out) on the plot's value axis.\n     * <p>\n     * If the value 0.0 is passed in as the zoom percent, the auto-range\n     * calculation for the axis is restored (which sets the range to include\n     * the minimum and maximum data values, thus displaying all the data).\n     *\n     * @param percent  the zoom amount.\n     */\n    public void zoom(double percent) {\n\n        if (percent > 0.0) {\n            double range = getRangeAxis().getRange().getLength();\n            double scaledRange = range * percent;\n            getRangeAxis().setRange(this.anchorValue - scaledRange / 2.0,\n                    this.anchorValue + scaledRange / 2.0);\n        }\n        else {\n            getRangeAxis().setAutoRange(true);\n        }\n\n    }\n\n    /**\n     * Receives notification of a change to the plot's dataset.\n     * <P>\n     * The range axis bounds will be recalculated if necessary.\n     *\n     * @param event  information about the event (not used here).\n     */\n    public void datasetChanged(DatasetChangeEvent event) {\n\n        int count = this.rangeAxes.size();\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\n            ValueAxis yAxis = getRangeAxis(axisIndex);\n            if (yAxis != null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }\n\n    /**\n     * Receives notification of a renderer change event.\n     *\n     * @param event  the event.\n     */\n    public void rendererChanged(RendererChangeEvent event) {\n        Plot parent = getParent();\n        if (parent != null) {\n            if (parent instanceof RendererChangeListener) {\n                RendererChangeListener rcl = (RendererChangeListener) parent;\n                rcl.rendererChanged(event);\n            }\n            else {\n                // this should never happen with the existing code, but throw \n                // an exception in case future changes make it possible...\n                throw new RuntimeException(\n                    \"The renderer has changed and I don't know what to do!\");\n            }\n        }\n        else {\n            configureRangeAxes();\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            notifyListeners(e);\n        }\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the domain axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * domain axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #removeDomainMarker(Marker)\n     */\n    public void addDomainMarker(CategoryMarker marker) {\n        addDomainMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the domain axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the domain \n     * axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     *               \n     * @see #removeDomainMarker(Marker, Layer)\n     */\n    public void addDomainMarker(CategoryMarker marker, Layer layer) {\n        addDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     * \n     * @see #removeDomainMarker(int, Marker, Layer)\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer) {\n        addDomainMarker(index, marker, layer, true);\n    }\n    \t\n    /**\n     * Adds a marker for display by a particular renderer and, if requested,\n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a domain axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     * \n     * @see #removeDomainMarker(int, Marker, Layer, boolean)\n     */\n    public void addDomainMarker(int index, CategoryMarker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' not permitted.\");\n        }\n        if (layer == null) {\n            throw new IllegalArgumentException(\"Null 'layer' not permitted.\");\n        }\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundDomainMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundDomainMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears all the domain markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearRangeMarkers()\n     */\n    public void clearDomainMarkers() {\n        if (this.backgroundDomainMarkers != null) {\n            Set keys = this.backgroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.backgroundDomainMarkers.clear();\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Set keys = this.foregroundDomainMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearDomainMarkers(key.intValue());\n            }\n            this.foregroundDomainMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of domain markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of domain markers.\n     */\n    public Collection getDomainMarkers(Layer layer) {\n        return getDomainMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of domain markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the domain markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearRangeMarkers(int)\n     */\n    public void clearDomainMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundDomainMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundDomainMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n    \n    /**\n     * Removes a marker for the domain axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker  the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker) {\n        return removeDomainMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the domain axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(Marker marker, Layer layer) {\n        return removeDomainMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n    \treturn removeDomainMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and, if requested, \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     */\n    public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n    \n    /**\n     * Adds a marker for display (in the foreground) against the range axis and\n     * sends a {@link PlotChangeEvent} to all registered listeners. Typically a \n     * marker will be drawn by the renderer as a line perpendicular to the \n     * range axis, however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * \n     * @see #removeRangeMarker(Marker)\n     */\n    public void addRangeMarker(Marker marker) {\n        addRangeMarker(marker, Layer.FOREGROUND); \n    }\n        \n    /**\n     * Adds a marker for display against the range axis and sends a \n     * {@link PlotChangeEvent} to all registered listeners.  Typically a marker \n     * will be drawn by the renderer as a line perpendicular to the range axis, \n     * however this is entirely up to the renderer.\n     *\n     * @param marker  the marker (<code>null</code> not permitted).\n     * @param layer  the layer (foreground or background) (<code>null</code> \n     *               not permitted).\n     *               \n     * @see #removeRangeMarker(Marker, Layer)\n     */\n    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     * \n     * @see #removeRangeMarker(int, Marker, Layer)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer) {\n    \taddRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Adds a marker for display by a particular renderer and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * <P>\n     * Typically a marker will be drawn by the renderer as a line perpendicular\n     * to a range axis, however this is entirely up to the renderer.\n     *\n     * @param index  the renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer.\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     * \n     * @see #removeRangeMarker(int, Marker, Layer, boolean)\n     */\n    public void addRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Clears all the range markers for the plot and sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     * \n     * @see #clearDomainMarkers()\n     */\n    public void clearRangeMarkers() {\n        if (this.backgroundRangeMarkers != null) {\n            Set keys = this.backgroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.backgroundRangeMarkers.clear();\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Set keys = this.foregroundRangeMarkers.keySet();\n            Iterator iterator = keys.iterator();\n            while (iterator.hasNext()) {\n                Integer key = (Integer) iterator.next();\n                clearRangeMarkers(key.intValue());\n            }\n            this.foregroundRangeMarkers.clear();\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of range markers (read only) for the specified layer.\n     *\n     * @param layer  the layer (foreground or background).\n     * \n     * @return The list of range markers.\n     * \n     * @see #getRangeMarkers(int, Layer)\n     */\n    public Collection getRangeMarkers(Layer layer) {\n        return getRangeMarkers(0, layer);\n    }\n\n    /**\n     * Returns a collection of range markers for a particular renderer and \n     * layer.\n     * \n     * @param index  the renderer index.\n     * @param layer  the layer.\n     * \n     * @return A collection of markers (possibly <code>null</code>).\n     */\n    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }\n    \n    /**\n     * Clears all the range markers for the specified renderer.\n     * \n     * @param index  the renderer index.\n     * \n     * @see #clearDomainMarkers(int)\n     */\n    public void clearRangeMarkers(int index) {\n        Integer key = new Integer(index);\n        if (this.backgroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.backgroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        if (this.foregroundRangeMarkers != null) {\n            Collection markers \n                = (Collection) this.foregroundRangeMarkers.get(key);\n            if (markers != null) {\n                Iterator iterator = markers.iterator();\n                while (iterator.hasNext()) {\n                    Marker m = (Marker) iterator.next();\n                    m.removeChangeListener(this);\n                }\n                markers.clear();\n            }\n        }\n        fireChangeEvent();\n    }\n\n    /**\n     * Removes a marker for the range axis and sends a {@link PlotChangeEvent} \n     * to all registered listeners.\n     *\n     * @param marker the marker.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(Marker)\n     */\n    public boolean removeRangeMarker(Marker marker) {\n        return removeRangeMarker(marker, Layer.FOREGROUND);\n    }\n\n    /**\n     * Removes a marker for the range axis in the specified layer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param marker the marker (<code>null</code> not permitted).\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(Marker, Layer)\n     */\n    public boolean removeRangeMarker(Marker marker, Layer layer) {\n        return removeRangeMarker(0, marker, layer);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index the dataset/renderer index.\n     * @param marker the marker.\n     * @param layer the layer (foreground or background).\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.7\n     * \n     * @see #addRangeMarker(int, Marker, Layer)\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer) {\n    \treturn removeRangeMarker(index, marker, layer, true);\n    }\n\n    /**\n     * Removes a marker for a specific dataset/renderer and sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the dataset/renderer index.\n     * @param marker  the marker.\n     * @param layer  the layer (foreground or background).\n     * @param notify  notify listeners.\n     *\n     * @return A boolean indicating whether or not the marker was actually \n     *         removed.\n     *\n     * @since 1.0.10\n     * \n     * @see #addRangeMarker(int, Marker, Layer, boolean)\n     */\n    public boolean removeRangeMarker(int index, Marker marker, Layer layer,\n    \t\tboolean notify) {\n        if (marker == null) {\n            throw new IllegalArgumentException(\"Null 'marker' argument.\");\n        }\n        ArrayList markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        else {\n            markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                    index));\n        }\n        if (markers == null) {\n            return false;\n        }\n        boolean removed = markers.remove(marker);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Returns a flag indicating whether or not the range crosshair is visible.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairVisible(boolean)\n     */\n    public boolean isRangeCrosshairVisible() {\n        return this.rangeCrosshairVisible;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair is visible.\n     *\n     * @param flag  the new value of the flag.\n     * \n     * @see #isRangeCrosshairVisible()\n     */\n    public void setRangeCrosshairVisible(boolean flag) {\n        if (this.rangeCrosshairVisible != flag) {\n            this.rangeCrosshairVisible = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a flag indicating whether or not the crosshair should \"lock-on\"\n     * to actual data values.\n     *\n     * @return The flag.\n     * \n     * @see #setRangeCrosshairLockedOnData(boolean)\n     */\n    public boolean isRangeCrosshairLockedOnData() {\n        return this.rangeCrosshairLockedOnData;\n    }\n\n    /**\n     * Sets the flag indicating whether or not the range crosshair should \n     * \"lock-on\" to actual data values.\n     *\n     * @param flag  the flag.\n     * \n     * @see #isRangeCrosshairLockedOnData()\n     */\n    public void setRangeCrosshairLockedOnData(boolean flag) {\n        if (this.rangeCrosshairLockedOnData != flag) {\n            this.rangeCrosshairLockedOnData = flag;\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the range crosshair value.\n     *\n     * @return The value.\n     * \n     * @see #setRangeCrosshairValue(double)\n     */\n    public double getRangeCrosshairValue() {\n        return this.rangeCrosshairValue;\n    }\n\n    /**\n     * Sets the domain crosshair value.\n     * <P>\n     * Registered listeners are notified that the plot has been modified, but\n     * only if the crosshair is visible.\n     *\n     * @param value  the new value.\n     * \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value) {\n        setRangeCrosshairValue(value, true);\n    }\n\n    /**\n     * Sets the range crosshair value and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners (but only if the \n     * crosshair is visible).\n     *\n     * @param value  the new value.\n     * @param notify  a flag that controls whether or not listeners are \n     *                notified.\n     *                \n     * @see #getRangeCrosshairValue()\n     */\n    public void setRangeCrosshairValue(double value, boolean notify) {\n        this.rangeCrosshairValue = value;\n        if (isRangeCrosshairVisible() && notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the pen-style (<code>Stroke</code>) used to draw the crosshair \n     * (if visible).\n     *\n     * @return The crosshair stroke (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairStroke(Stroke)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairPaint()\n     */\n    public Stroke getRangeCrosshairStroke() {\n        return this.rangeCrosshairStroke;\n    }\n\n    /**\n     * Sets the pen-style (<code>Stroke</code>) used to draw the range \n     * crosshair (if visible), and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     *\n     * @param stroke  the new crosshair stroke (<code>null</code> not \n     *         permitted).\n     * \n     * @see #getRangeCrosshairStroke()\n     */\n    public void setRangeCrosshairStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        this.rangeCrosshairStroke = stroke;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the paint used to draw the range crosshair.\n     *\n     * @return The paint (never <code>null</code>).\n     * \n     * @see #setRangeCrosshairPaint(Paint)\n     * @see #isRangeCrosshairVisible()\n     * @see #getRangeCrosshairStroke()\n     */\n    public Paint getRangeCrosshairPaint() {\n        return this.rangeCrosshairPaint;\n    }\n\n    /**\n     * Sets the paint used to draw the range crosshair (if visible) and \n     * sends a {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     * \n     * @see #getRangeCrosshairPaint()\n     */\n    public void setRangeCrosshairPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.rangeCrosshairPaint = paint;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns the list of annotations.\n     *\n     * @return The list of annotations (never <code>null</code>).\n     */\n    public List getAnnotations() {\n        return this.annotations;\n    }\n\n    /**\n     * Adds an annotation to the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * \n     * @see #removeAnnotation(CategoryAnnotation)\n     */\n    public void addAnnotation(CategoryAnnotation annotation) {\n    \taddAnnotation(annotation, true);\n    }\n    \n    /**\n     * Adds an annotation to the plot and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     * \n     * @since 1.0.10\n     */\n    public void addAnnotation(CategoryAnnotation annotation, boolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        this.annotations.add(annotation);\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Removes an annotation from the plot and sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @see #addAnnotation(CategoryAnnotation)\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation) {\n    \treturn removeAnnotation(annotation, true);\n    }\n\n    /**\n     * Removes an annotation from the plot and, if requested, sends a \n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param annotation  the annotation (<code>null</code> not permitted).\n     * @param notify  notify listeners?\n     *\n     * @return A boolean (indicates whether or not the annotation was removed).\n     * \n     * @since 1.0.10\n     */\n    public boolean removeAnnotation(CategoryAnnotation annotation, \n    \t\tboolean notify) {\n        if (annotation == null) {\n            throw new IllegalArgumentException(\"Null 'annotation' argument.\");\n        }\n        boolean removed = this.annotations.remove(annotation);\n        if (removed && notify) {\n            fireChangeEvent();\n        }\n        return removed;\n    }\n\n    /**\n     * Clears all the annotations and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     */\n    public void clearAnnotations() {\n        this.annotations.clear();\n        fireChangeEvent();\n    }\n\n    /**\n     * Calculates the space required for the domain axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, \n                                                 Rectangle2D plotArea, \n                                                 AxisSpace space) {\n                                                     \n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the primary domain axis...\n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, \n                        domainEdge, space);\n            }\n            \n            // reserve space for any domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis xAxis = (Axis) this.domainAxes.get(i);\n                if (xAxis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n                                                     \n    }\n    \n    /**\n     * Calculates the space required for the range axis/axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param space  a carrier for the result (<code>null</code> permitted).\n     * \n     * @return The required space.\n     */\n    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, \n                                                Rectangle2D plotArea, \n                                                AxisSpace space) {\n                                                  \n        if (space == null) {\n            space = new AxisSpace(); \n        }\n        \n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes (if any)...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\n                if (yAxis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n                                                    \n    }\n\n    /**\n     * Calculates the space required for the axes.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     *\n     * @return The space required for the axes.\n     */\n    protected AxisSpace calculateAxisSpace(Graphics2D g2, \n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }\n    \n    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \n     * printer).\n     * <P>\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\n     * If you do, it will be populated with information about the drawing,\n     * including various plot dimensions and tooltip info.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot (including axes) should \n     *              be drawn.\n     * @param anchor  the anchor point (<code>null</code> permitted).\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param state  collects info as the chart is drawn (possibly \n     *               <code>null</code>).\n     */\n    public void draw(Graphics2D g2, Rectangle2D area, \n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo state) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (state == null) {\n            // if the incoming state is null, no information will be passed\n            // back to the caller - but we create a temporary state to record\n            // the plot area, since that is used later by the axes\n            state = new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        // calculate the data area...\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        state.setDataArea(dataArea);\n\n        // if there is a renderer, it draws the background, otherwise use the \n        // default background...\n        if (getRenderer() != null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        }\n        else {\n            drawBackground(g2, dataArea);\n        }\n       \n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\n\n        // don't let anyone draw outside the data area\n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n        }\n        \n        // draw the markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now render data items...\n        boolean foundData = false;\n\n        // set up the alpha-transparency...\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n\n            for (int i = 0; i < datasetCount; i++) {\n                foundData = render(g2, dataArea, i, state) || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        else {  // DatasetRenderingOrder.REVERSE\n            \n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n            \n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, state) || foundData;   \n            }\n\n            // draw foreground annotations\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        \n        // draw the foreground markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        // draw the plot's annotations (if any)...\n        drawAnnotations(g2, dataArea, state);\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        // draw range crosshair if required...\n        if (isRangeCrosshairVisible()) {\n            // FIXME: this doesn't handle multiple range axes\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \n                    getRangeCrosshairValue(), getRangeAxis(),\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\n        }\n\n        // draw an outline around the plot area...\n        if (getRenderer() != null) {\n            getRenderer().drawOutline(g2, this, dataArea);\n        }\n        else {\n            drawOutline(g2, dataArea);\n        }\n\n    }\n\n    /**\n     * Draws the plot background (the background color and/or image).\n     * <P>\n     * This method will be called during the chart drawing process and is \n     * declared public so that it can be accessed by the renderers used by \n     * certain subclasses.  You shouldn't need to call this method directly.\n     *\n     * @param g2  the graphics device.\n     * @param area  the area within which the plot should be drawn.\n     */\n    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }\n\n    /**\n     * A utility method for drawing the plot's axes.\n     * \n     * @param g2  the graphics device.\n     * @param plotArea  the plot area.\n     * @param dataArea  the data area.\n     * @param plotState  collects information about the plot (<code>null</code>\n     *                   permitted).\n     * \n     * @return A map containing the axis states.\n     */\n    protected Map drawAxes(Graphics2D g2, \n                           Rectangle2D plotArea, \n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n            if (xAxis != null) {\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n        \n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY() \n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX() \n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX() \n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        \n        return axisStateMap;\n        \n    }\n\n    /**\n     * Draws a representation of a dataset within the dataArea region using the\n     * appropriate renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the region in which the data is to be drawn.\n     * @param index  the dataset and renderer index.\n     * @param info  an optional object for collection dimension information.\n     * \n     * @return A boolean that indicates whether or not real data was found.\n     */\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, \n                          PlotRenderingInfo info) {\n\n        boolean foundData = false;\n        CategoryDataset currentDataset = getDataset(index);\n        CategoryItemRenderer renderer = getRenderer(index);\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\n        if (hasData && renderer != null) {\n            \n            foundData = true;\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\n                    this, index, info);\n            int columnCount = currentDataset.getColumnCount();\n            int rowCount = currentDataset.getRowCount();\n            int passCount = renderer.getPassCount();\n            for (int pass = 0; pass < passCount; pass++) {            \n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\n                    for (int column = 0; column < columnCount; column++) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n                else {\n                    for (int column = columnCount - 1; column >= 0; column--) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n        \n    }\n\n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * \n     * @see #drawRangeGridlines(Graphics2D, Rectangle2D, List)\n     */\n    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible()) {\n            CategoryAnchor anchor = getDomainGridlinePosition();\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                // iterate over the categories\n                CategoryDataset data = getDataset();\n                if (data != null) {\n                    CategoryAxis axis = getDomainAxis();\n                    if (axis != null) {\n                        int columnCount = data.getColumnCount();\n                        for (int c = 0; c < columnCount; c++) {\n                            double xx = axis.getCategoryJava2DCoordinate(\n                                    anchor, c, columnCount, dataArea, \n                                    domainAxisEdge);\n                            CategoryItemRenderer renderer1 = getRenderer();\n                            if (renderer1 != null) {\n                                renderer1.drawDomainGridline(g2, this, \n                                        dataArea, xx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n \n    /**\n     * Draws the gridlines for the plot.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area inside the axes.\n     * @param ticks  the ticks.\n     * \n     * @see #drawDomainGridlines(Graphics2D, Rectangle2D)\n     */\n    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, \n                                      List ticks) {\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                ValueAxis axis = getRangeAxis();\n                if (axis != null) {\n                    Iterator iterator = ticks.iterator();\n                    while (iterator.hasNext()) {\n                        ValueTick tick = (ValueTick) iterator.next();\n                        CategoryItemRenderer renderer1 = getRenderer();\n                        if (renderer1 != null) {\n                            renderer1.drawRangeGridline(g2, this, \n                                    getRangeAxis(), dataArea, tick.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the annotations.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param info  the plot rendering info (<code>null</code> permitted).\n     */\n    protected void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n            PlotRenderingInfo info) {\n\n        Iterator iterator = getAnnotations().iterator();\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation \n                    = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this, dataArea, getDomainAxis(), \n                    getRangeAxis(), 0, info);\n        }\n\n    }\n\n    /**\n     * Draws the domain markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawRangeMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                     int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getDomainMarkers(index, layer);\n        CategoryAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                CategoryMarker marker = (CategoryMarker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Draws the range markers (if any) for an axis and layer.  This method is \n     * typically called from within the draw() method.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the data area.\n     * @param index  the renderer index.\n     * @param layer  the layer (foreground or background).\n     * \n     * @see #drawDomainMarkers(Graphics2D, Rectangle2D, int, Layer)\n     */\n    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                    int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }\n\n    /**\n     * Utility method for drawing a line perpendicular to the range axis (used\n     * for crosshairs).\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area defined by the axes.\n     * @param value  the data value.\n     * @param stroke  the line stroke (<code>null</code> not permitted).\n     * @param paint  the line paint (<code>null</code> not permitted).\n     */\n    protected void drawRangeLine(Graphics2D g2, Rectangle2D dataArea,\n            double value, Stroke stroke, Paint paint) {\n\n        double java2D = getRangeAxis().valueToJava2D(value, dataArea, \n                getRangeAxisEdge());\n        Line2D line = null;\n        if (this.orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(java2D, dataArea.getMinY(), java2D, \n                    dataArea.getMaxY());\n        }\n        else if (this.orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), java2D, \n                    dataArea.getMaxX(), java2D);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n\n    }\n\n    /**\n     * Draws a range crosshair.\n     * \n     * @param g2  the graphics target.\n     * @param dataArea  the data area.\n     * @param orientation  the plot orientation.\n     * @param value  the crosshair value.\n     * @param axis  the axis against which the value is measured.\n     * @param stroke  the stroke used to draw the crosshair line.\n     * @param paint  the paint used to draw the crosshair line.\n     * \n     * @since 1.0.5\n     */\n    protected void drawRangeCrosshair(Graphics2D g2, Rectangle2D dataArea, \n            PlotOrientation orientation, double value, ValueAxis axis, \n            Stroke stroke, Paint paint) {\n        \n        if (!axis.getRange().contains(value)) {\n            return;\n        }\n        Line2D line = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            double xx = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.BOTTOM);\n            line = new Line2D.Double(xx, dataArea.getMinY(), xx, \n                    dataArea.getMaxY());\n        }\n        else {\n            double yy = axis.valueToJava2D(value, dataArea, \n                    RectangleEdge.LEFT);\n            line = new Line2D.Double(dataArea.getMinX(), yy, \n                    dataArea.getMaxX(), yy);\n        }\n        g2.setStroke(stroke);\n        g2.setPaint(paint);\n        g2.draw(line);\n       \n    }\n    \n    /**\n     * Returns the range of data values that will be plotted against the range \n     * axis.  If the dataset is <code>null</code>, this method returns \n     * <code>null</code>.\n     *\n     * @param axis  the axis.\n     *\n     * @return The data range.\n     */\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        \n        int rangeIndex = this.rangeAxes.indexOf(axis);\n        if (rangeIndex >= 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis == getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        // iterate through the datasets that map to the axis and get the union \n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset d = (CategoryDataset) iterator.next();\n            CategoryItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n\n    }\n\n    /**\n     * Returns a list of the datasets that are mapped to the axis with the\n     * specified index.\n     * \n     * @param axisIndex  the axis index.\n     * \n     * @return The list (possibly empty, but never <code>null</code>).\n     * \n     * @since 1.0.3\n     */\n    private List datasetsMappedToDomainAxis(int axisIndex) {\n        List result = new ArrayList();\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); \n                datasetIndex++) {\n            Object dataset = this.datasets.get(datasetIndex);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(\n                        datasetIndex);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (axisIndex == 0) {\n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == axisIndex) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    \n    /**\n     * A utility method that returns a list of datasets that are mapped to a \n     * given range axis.\n     * \n     * @param index  the axis index.\n     * \n     * @return A list of datasets.\n     */\n    private List datasetsMappedToRangeAxis(int index) {\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Object dataset = this.datasets.get(i);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (index == 0) { \n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == index) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;    \n    }\n\n    /**\n     * Returns the weight for this plot when it is used as a subplot within a \n     * combined plot.\n     *\n     * @return The weight.\n     * \n     * @see #setWeight(int)\n     */\n    public int getWeight() {\n        return this.weight;\n    }\n\n    /**\n     * Sets the weight for the plot and sends a {@link PlotChangeEvent} to all\n     * registered listeners.\n     *\n     * @param weight  the weight.\n     * \n     * @see #getWeight()\n     */\n    public void setWeight(int weight) {\n        this.weight = weight;\n        fireChangeEvent();\n    }\n    \n    /**\n     * Returns the fixed domain axis space.\n     *\n     * @return The fixed domain axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedDomainAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedDomainAxisSpace() {\n        return this.fixedDomainAxisSpace;\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedDomainAxisSpace()\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space) {\n        setFixedDomainAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed domain axis space and sends a {@link PlotChangeEvent} to\n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedDomainAxisSpace()\n     * \n     * @since 1.0.7\n     */\n    public void setFixedDomainAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedDomainAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns the fixed range axis space.\n     *\n     * @return The fixed range axis space (possibly <code>null</code>).\n     * \n     * @see #setFixedRangeAxisSpace(AxisSpace)\n     */\n    public AxisSpace getFixedRangeAxisSpace() {\n        return this.fixedRangeAxisSpace;\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * \n     * @see #getFixedRangeAxisSpace()\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space) {\n        setFixedRangeAxisSpace(space, true);\n    }\n\n    /**\n     * Sets the fixed range axis space and sends a {@link PlotChangeEvent} to \n     * all registered listeners.\n     *\n     * @param space  the space (<code>null</code> permitted).\n     * @param notify  notify listeners?\n     * \n     * @see #getFixedRangeAxisSpace()\n     *\n     * @since 1.0.7\n     */\n    public void setFixedRangeAxisSpace(AxisSpace space, boolean notify) {\n        this.fixedRangeAxisSpace = space;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n\n    /**\n     * Returns a list of the categories in the plot's primary dataset.\n     * \n     * @return A list of the categories in the plot's primary dataset.\n     * \n     * @see #getCategoriesForAxis(CategoryAxis)\n     */\n    public List getCategories() {\n        List result = null;\n        if (getDataset() != null) {\n            result = Collections.unmodifiableList(getDataset().getColumnKeys());\n        }\n        return result;\n    }\n    \n    /**\n     * Returns a list of the categories that should be displayed for the\n     * specified axis.\n     * \n     * @param axis  the axis (<code>null</code> not permitted)\n     * \n     * @return The categories.\n     * \n     * @since 1.0.3\n     */\n    public List getCategoriesForAxis(CategoryAxis axis) {\n        List result = new ArrayList();\n        int axisIndex = this.domainAxes.indexOf(axis);\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\n        Iterator iterator = datasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\n            // add the unique categories from this dataset\n            for (int i = 0; i < dataset.getColumnCount(); i++) {\n                Comparable category = dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the flag that controls whether or not the shared domain axis is \n     * drawn for each subplot.\n     * \n     * @return A boolean.\n     * \n     * @see #setDrawSharedDomainAxis(boolean)\n     */\n    public boolean getDrawSharedDomainAxis() {\n        return this.drawSharedDomainAxis;\n    }\n    \n    /**\n     * Sets the flag that controls whether the shared domain axis is drawn when\n     * this plot is being used as a subplot.\n     * \n     * @param draw  a boolean.\n     * \n     * @see #getDrawSharedDomainAxis()\n     */\n    public void setDrawSharedDomainAxis(boolean draw) {\n        this.drawSharedDomainAxis = draw;\n        fireChangeEvent();\n    }\n\n    /**\n     * Returns <code>false</code> to indicate that the domain axes are not\n     * zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isRangeZoomable()\n     */\n    public boolean isDomainZoomable() {\n        return false;\n    }\n    \n    /**\n     * Returns <code>true</code> to indicate that the range axes are zoomable.\n     * \n     * @return A boolean.\n     * \n     * @see #isDomainZoomable()\n     */\n    public boolean isRangeZoomable() {\n        return true;\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo state, \n                               Point2D source) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomDomainAxes(double lowerPercent, double upperPercent, \n                               PlotRenderingInfo state, Point2D source) {\n        // can't zoom domain axis\n    }\n    \n    /**\n     * This method does nothing, because <code>CategoryPlot</code> doesn't \n     * support zooming on the domain.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point (in Java2D space).\n     * @param useAnchor  use source point as zoom anchor?\n     * \n     * @see #zoomRangeAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomDomainAxes(double factor, PlotRenderingInfo info,\n                               Point2D source, boolean useAnchor) {\n        // can't zoom domain axis\n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo state, \n                              Point2D source) {\n        // delegate to other method\n        zoomRangeAxes(factor, state, source, false);    \n    }\n\n    /**\n     * Multiplies the range on the range axis/axes by the specified factor.\n     *\n     * @param factor  the zoom factor.\n     * @param info  the plot rendering info.\n     * @param source  the source point.\n     * @param useAnchor  a flag that controls whether or not the source point\n     *         is used for the zoom anchor.\n     * \n     * @see #zoomDomainAxes(double, PlotRenderingInfo, Point2D, boolean)\n     * \n     * @since 1.0.7\n     */\n    public void zoomRangeAxes(double factor, PlotRenderingInfo info,\n                              Point2D source, boolean useAnchor) {\n                \n        // perform the zoom on each range axis\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                if (useAnchor) {\n                    // get the relevant source coordinate given the plot \n                    // orientation\n                    double sourceY = source.getY();\n                    if (this.orientation == PlotOrientation.HORIZONTAL) {\n                        sourceY = source.getX();\n                    }\n                    double anchorY = rangeAxis.java2DToValue(sourceY, \n                            info.getDataArea(), getRangeAxisEdge());\n                    rangeAxis.resizeRange(factor, anchorY);\n                }\n                else {\n                    rangeAxis.resizeRange(factor);\n                }\n            }\n        }\n    }\n\n    /**\n     * Zooms in on the range axes.\n     * \n     * @param lowerPercent  the lower bound.\n     * @param upperPercent  the upper bound.\n     * @param state  the plot state.\n     * @param source  the source point (in Java2D space) for the zoom.\n     */\n    public void zoomRangeAxes(double lowerPercent, double upperPercent, \n                              PlotRenderingInfo state, Point2D source) {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis rangeAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (rangeAxis != null) {\n                rangeAxis.zoomRange(lowerPercent, upperPercent);\n            }\n        }\n    }\n    \n    /**\n     * Returns the anchor value.\n     * \n     * @return The anchor value.\n     * \n     * @see #setAnchorValue(double)\n     */\n    public double getAnchorValue() {\n        return this.anchorValue;\n    }\n\n    /**\n     * Sets the anchor value and sends a {@link PlotChangeEvent} to all \n     * registered listeners.\n     * \n     * @param value  the anchor value.\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value) {\n        setAnchorValue(value, true);\n    }\n\n    /**\n     * Sets the anchor value and, if requested, sends a {@link PlotChangeEvent}\n     * to all registered listeners.\n     * \n     * @param value  the value.\n     * @param notify  notify listeners?\n     * \n     * @see #getAnchorValue()\n     */\n    public void setAnchorValue(double value, boolean notify) {\n        this.anchorValue = value;\n        if (notify) {\n            fireChangeEvent();\n        }\n    }\n    \n    /** \n     * Tests the plot for equality with an arbitrary object.\n     * \n     * @param obj  the object to test against (<code>null</code> permitted).\n     * \n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n    \n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryPlot)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n\n        CategoryPlot that = (CategoryPlot) obj;\n            \n        if (this.orientation != that.orientation) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.axisOffset, that.axisOffset)) {\n            return false;\n        }\n        if (!this.domainAxes.equals(that.domainAxes)) {\n            return false;\n        }\n        if (!this.domainAxisLocations.equals(that.domainAxisLocations)) {\n            return false;\n        }\n        if (this.drawSharedDomainAxis != that.drawSharedDomainAxis) {\n            return false;\n        }\n        if (!this.rangeAxes.equals(that.rangeAxes)) {\n            return false;\n        }\n        if (!this.rangeAxisLocations.equals(that.rangeAxisLocations)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToDomainAxisMap, \n                that.datasetToDomainAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.datasetToRangeAxisMap, \n                that.datasetToRangeAxisMap)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.renderers, that.renderers)) {\n            return false;\n        }\n        if (this.renderingOrder != that.renderingOrder) {\n            return false;\n        }\n        if (this.columnRenderingOrder != that.columnRenderingOrder) {\n            return false;\n        }\n        if (this.rowRenderingOrder != that.rowRenderingOrder) {\n            return false;\n        }\n        if (this.domainGridlinesVisible != that.domainGridlinesVisible) {\n            return false;\n        }\n        if (this.domainGridlinePosition != that.domainGridlinePosition) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.domainGridlineStroke, \n                that.domainGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.domainGridlinePaint, \n                that.domainGridlinePaint)) {\n            return false;\n        }\n        if (this.rangeGridlinesVisible != that.rangeGridlinesVisible) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeGridlineStroke, \n                that.rangeGridlineStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeGridlinePaint, \n                that.rangeGridlinePaint)) {\n            return false;\n        }\n        if (this.anchorValue != that.anchorValue) {\n            return false;\n        }\n        if (this.rangeCrosshairVisible != that.rangeCrosshairVisible) {\n            return false;\n        }\n        if (this.rangeCrosshairValue != that.rangeCrosshairValue) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.rangeCrosshairStroke, \n                that.rangeCrosshairStroke)) {\n            return false;\n        }\n        if (!PaintUtilities.equal(this.rangeCrosshairPaint, \n                that.rangeCrosshairPaint)) {\n            return false;\n        }\n        if (this.rangeCrosshairLockedOnData \n                != that.rangeCrosshairLockedOnData) {\n            return false;\n        }      \n        if (!ObjectUtilities.equal(this.foregroundRangeMarkers, \n                that.foregroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.backgroundRangeMarkers, \n                that.backgroundRangeMarkers)) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.annotations, that.annotations)) {\n            return false;\n        }\n        if (this.weight != that.weight) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.fixedDomainAxisSpace, \n                that.fixedDomainAxisSpace)) {\n            return false;\n        }    \n        if (!ObjectUtilities.equal(this.fixedRangeAxisSpace, \n                that.fixedRangeAxisSpace)) {\n            return false;\n        }    \n        \n        return true;\n        \n    }\n    \n    /**\n     * Returns a clone of the plot.\n     * \n     * @return A clone.\n     * \n     * @throws CloneNotSupportedException  if the cloning is not supported.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        \n        CategoryPlot clone = (CategoryPlot) super.clone();\n        \n        clone.domainAxes = new ObjectList();\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                CategoryAxis clonedAxis = (CategoryAxis) xAxis.clone();\n                clone.setDomainAxis(i, clonedAxis);\n            }\n        }\n        clone.domainAxisLocations \n            = (ObjectList) this.domainAxisLocations.clone();\n\n        clone.rangeAxes = new ObjectList();\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                ValueAxis clonedAxis = (ValueAxis) yAxis.clone();\n                clone.setRangeAxis(i, clonedAxis);\n            }\n        }\n        clone.rangeAxisLocations = (ObjectList) this.rangeAxisLocations.clone();\n\n        clone.datasets = (ObjectList) this.datasets.clone();\n        for (int i = 0; i < clone.datasets.size(); i++) {\n            CategoryDataset dataset = clone.getDataset(i);\n            if (dataset != null) {\n                dataset.addChangeListener(clone);\n            }\n        }\n        clone.datasetToDomainAxisMap \n            = (ObjectList) this.datasetToDomainAxisMap.clone();\n        clone.datasetToRangeAxisMap \n            = (ObjectList) this.datasetToRangeAxisMap.clone();\n        clone.renderers = (ObjectList) this.renderers.clone();\n        if (this.fixedDomainAxisSpace != null) {\n            clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedDomainAxisSpace);\n        }\n        if (this.fixedRangeAxisSpace != null) {\n            clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone(\n                    this.fixedRangeAxisSpace);\n        }\n        \n        return clone;\n            \n    }\n    \n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the output stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     */\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n        SerialUtilities.writeStroke(this.domainGridlineStroke, stream);\n        SerialUtilities.writePaint(this.domainGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeGridlineStroke, stream);\n        SerialUtilities.writePaint(this.rangeGridlinePaint, stream);\n        SerialUtilities.writeStroke(this.rangeCrosshairStroke, stream);\n        SerialUtilities.writePaint(this.rangeCrosshairPaint, stream);\n    }\n\n    /**\n     * Provides serialization support.\n     *\n     * @param stream  the input stream.\n     *\n     * @throws IOException  if there is an I/O error.\n     * @throws ClassNotFoundException  if there is a classpath problem.\n     */\n    private void readObject(ObjectInputStream stream) \n        throws IOException, ClassNotFoundException {\n\n        stream.defaultReadObject();\n        this.domainGridlineStroke = SerialUtilities.readStroke(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlineStroke = SerialUtilities.readStroke(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeCrosshairStroke = SerialUtilities.readStroke(stream);\n        this.rangeCrosshairPaint = SerialUtilities.readPaint(stream);\n\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(i);\n            if (xAxis != null) {\n                xAxis.setPlot(this);\n                xAxis.addChangeListener(this);\n            }\n        } \n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(i);\n            if (yAxis != null) {\n                yAxis.setPlot(this);   \n                yAxis.addChangeListener(this);\n            }\n        }\n        int datasetCount = this.datasets.size();\n        for (int i = 0; i < datasetCount; i++) {\n            Dataset dataset = (Dataset) this.datasets.get(i);\n            if (dataset != null) {\n                dataset.addChangeListener(this);\n            }\n        }\n        int rendererCount = this.renderers.size();\n        for (int i = 0; i < rendererCount; i++) {\n            CategoryItemRenderer renderer \n                = (CategoryItemRenderer) this.renderers.get(i);\n            if (renderer != null) {\n                renderer.addChangeListener(this);\n            }\n        }\n\n    }\n\n}\n"}, "retrieved_test_case": null}
